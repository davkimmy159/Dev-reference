타입 추론
========

##### 타입 추론 적용 코드
- 명시적 타입 주석 X
```ts
// let x: number (타입 추론)
let x = 3;
```

##### 적용 경우
- 변수 · 멤버 초기화
- 매개변수 기본값 설정
- 함수 반환 타입 결정

## 최선의 공통 타입
```ts
// let x: (number | null)[]
let x = [0, 1, null];
```

##### `x` <sub>(변수)</sub> 타입 추론
- 배열 내 각 요소 타입 고려
  - `number` · `null`
- 각 타입 후보 고려
  - 모든 후보 호환 가능 타입 선정

##### 제공된 후보 타입 내 선정
```ts
class Animal {}
class Rhino extends Animal {}
class Elephant extends Animal {}
class Snake extends Animal {}
```
- 종종 공통 구조 공유
  - 평등한 각 타입 <sub>(상위 · 하위 X)</sub>
```ts
// let zoo1: (Rhino | Elephant | Snake)[]
// - 배열 내 명시적인 Animal (객체) X
let zoo1 = [new Rhino(), new Elephant(), new Snake()];

// let zoo2: Animal[]
let zoo2 = [new Rhino(), new Elephant(), new Snake(), new Animal()];
```
- 명시적인 공통 타입 지정 <sub>(상위 타입 부재 시)</sub>
```ts
// let zoo: Animal[]
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

##### 최선의 공통 타입 부재
- `union` <sub>(각 타입 구성)</sub>
  - `(Rhino | Elephant | Snake)[]`

## 문맥적 타입 결정
- 위치 따라 표현식 타입 암시

##### `window.onmousedown` <sub>(함수)</sub> 타입 사용해 타입 추론
1. 함수 표현식 <sub>(할당문 우측)</sub>
2. `mouseEvent` <sub>(매개변수)</sub>
```ts
window.onmousedown = function (mouseEvent) {
  console.log(mouseEvent.button);

  // 에러 발생
  // - Property 'kangaroo' does not exist on type 'MouseEvent'.
  console.log(mouseEvent.kangaroo);
};
```


This works because window already has `onmousedown` declared in its type:
```ts
// Declares there is a global variable called 'window'
declare var window: Window & typeof globalThis;

// Which is declared as (simplified):
interface Window extends GlobalEventHandlers {
  // ...
}

// Which defines a lot of known handler events
interface GlobalEventHandlers {
  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;
  // ...
}
```

TypeScript is smart enough to infer types in other contexts as well:
```ts
window.onscroll = function (uiEvent) {

  // Property 'button' does not exist on type 'Event'.
  console.log(uiEvent.button);
};
```

Based on the fact that the above function is being assigned to `Window.onscroll`, TypeScript knows that `uiEvent` is a `UIEvent`, and not a `MouseEvent` like the previous example. `UIEvent` objects contain no `button` property, and so TypeScript will throw an error.

If this function were not in a contextually typed position, the function’s argument would implicitly have type `any`, and no error would be issued (unless you are using the `noImplicitAny` option):
```ts
const handler = function (uiEvent) {
  console.log(uiEvent.button); // <- OK
};
```

We can also explicitly give type information to the function’s argument to override any contextual type:
```ts
window.onscroll = function (uiEvent: any) {
  console.log(uiEvent.button); // <- Now, no error is given
};
```

However, this code will log `undefined`, since `uiEvent` has no property called `button`.

Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:
```ts
function createZoo(): Animal[] {
  return [new Rhino(), new Elephant(), new Snake()];
}
```

In this example, best common type has a set of four candidates: `Animal`, `Rhino`, `Elephant`, and `Snake`. Of these, `Animal` can be chosen by the best common type algorithm.
