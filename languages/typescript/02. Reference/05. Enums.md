`enum`
=====

##### 기명 상수 그룹 정의
- 용도
  - 명확한 의도 표현
  - 구별된 그룹 생성
- 숫자 · 문자 기반

## 숫자형 `enum`
- 자동 값 증가 기능

##### 1번째 멤버 초기화
```ts
enum Direction {

  // 초기화
  Up = 1,

  // 이하 멤버
  // - 값 자동 증가
  Down,  // 2
  Left,  // 3
  Right, // 4
}
```

##### 초기화 생략
- `0` 부터 시작
```ts
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right, // 3
}
```

##### 사용하기
- 타입 지정 <sub>(`enum` 이름)</sub>
- 프로퍼티 접근
```ts
enum UserResponse {
  No = 0,
  Yes = 1,
}

function respond(recipient: string, message: UserResponse): void {
  // …
}

respond("Princess Caroline", UserResponse.Yes);
```

##### 미초기화 멤버 위치 <sub>(계산 · 상숫값 조합 가능)</sub>
- 1번째
- 초기화 멤버 다음
  - 상수
  - 타 `enum` 상수 멤버
```ts
enum E {
  A = getSomeValue(),

  // 에러 발생
  // - Enum member must have initializer.
  B,
}
```

## 문자형 `enum`

##### 숫자형 `enum` 유사 · 미묘한 런타임 차이점
- 모든 멤버 초기화 필수
  - 문자열 상수
  - 타 문자형 `enum` 멤버
```ts
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",

  // 에러 발생
  // - Enum member must have initializer.
  Right,
}
```

##### 자동 값 증가 기능 X · 직렬화 용이
- 의미있는 값 보유
  - 값 자체 특정 의미 표현
  - 디버깅 시 유용
```ts
// 의미 없는 숫자 값
enum DirectionNumber {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right, // 3
}

// 의미있는 문자열 값
enum DirectionString {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
```

## 조합 `enum`

##### 숫자형 · 문자형 <sub>(조합)</sub> `enum`
- 기술적으로 가능
- 사용 권장 X
```ts
enum BooleanLikeHeterogeneousEnum {
  No = 0,
  Yes = "YES",
}
```

## 계산 · 상숫값 멤버

##### 각 `enum` 멤버 값
- 계산값
- 상숫값

#### `enum` 멤버 상숫값 조건

##### 1. 미초기화 1번째 멤버 <sub>(`0`)</sub>
```ts
enum E {
  X, // 0
}
```

##### 2. 미초기화 · 숫자 상수 멤버 다음 위치
- 자동 증가 값 적용
```ts
// 상수 멤버
enum E1 {
  X, // 0
  Y, // 1
  Z, // 2
}

// 상수 멤버
enum E2 {
  A = 1, // 1
  B,     // 2
  C,     // 3
}
```

##### 3. 상수 `enum` 표현식 초기화
- 컴파일 시 완전 평가 가능 표현식
1. 리터럴 `enum` 표현식
    - 문자열 상수
    - 숫자 상수
2. 기존 정의된 `enum` 상수 멤버 참조
    - 타 `enum` 유래 가능
3. 괄호 내 상수 `enum` 표현식
4. `+` · `-` · `~` <sub>(단항 연산자)</sub> 적용 상수 `enume` 표현식
5. `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands

  It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.

In all other cases enum member is considered computed.
```rs
enum FileAccess {
  // constant members
  None,
  Read = 1 << 1,
  Write = 1 << 2,
  ReadWrite = Read | Write,
  // computed member
  G = "123".length,
}
```

## Union enums and enum member types
There is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to
- any string literal (e.g. `"foo"`, `"bar"`, `"baz"`)
- any numeric literal (e.g. `1`, `100`)
- a unary minus applied to any numeric literal (e.g. `-1`, `-100`)

When all members in an enum have literal enum values, some special semantics come into play.

The first is that enum members also become types as well! For example, we can say that certain members can only have the value of an enum member:
```ts
enum ShapeKind {
  Circle,
  Square,
}

interface Circle {
  kind: ShapeKind.Circle;
  radius: number;
}

interface Square {
  kind: ShapeKind.Square;
  sideLength: number;
}

let c: Circle = {

  // 에러 발생
  // - Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
  kind: ShapeKind.Square,

  radius: 100,
};
```

The other change is that enum types themselves effectively become a union of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:
```ts
enum E {
  Foo,
  Bar,
}

function f(x: E) {
  // 에러 발생
  // - This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.
  if (x !== E.Foo || x !== E.Bar) {
    // …
  }
}
```

In that example, we first checked whether `x` was not `E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can only be `E.Foo`, so it doesn’t make sense to see whether it’s not equal to `E.Bar`.

## Enums at runtime
Enums are real objects that exist at runtime. For example, the following enum
```ts
enum E {
  X,
  Y,
  Z,
}
```

can actually be passed around to functions
```ts
enum E {
  X,
  Y,
  Z,
}

function f(obj: { X: number }) {
  return obj.X;
}

// Works, since 'E' has a property named 'X' which is a number.
f(E);
```

## Enums at compile time
Even though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.
```ts
enum LogLevel {
  ERROR,
  WARN,
  INFO,
  DEBUG,
}

/**
 * This is equivalent to:
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
  const num = LogLevel[key];
  if (num <= LogLevel.WARN) {
    console.log("Log level key is:", key);
    console.log("Log level value is:", num);
    console.log("Log level message is:", message);
  }
}
printImportant("ERROR", "This is a message");
```

### Reverse mappings
In addition to creating an object with property names for members, numeric enums members also get a reverse mapping from enum values to enum names. For example, in this example:
```ts
enum Enum {
  A,
}

let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

TypeScript compiles this down to the following JavaScript:
```ts
"use strict";
var Enum;
(function (Enum) {
  Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

In this generated code, an enum is compiled into an object that stores both forward (`name` → `value`) and reverse (`value` → `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.

Keep in mind that string enum members do not get a reverse mapping generated at all.

### `const` enums
In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. `const` enums are defined using the `const` modifier on our enums:
```ts
const enum Enum {
  A = 1,
  B = A * 2,
}
```

`const` enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.
```ts
const enum Direction {
  Up,
  Down,
  Left,
  Right,
}

let directions = [
  Direction.Up,
  Direction.Down,
  Direction.Left,
  Direction.Right,
];
```

in generated code will become
```ts
"use strict";
let directions = [
    0 /* Direction.Up */,
    1 /* Direction.Down */,
    2 /* Direction.Left */,
    3 /* Direction.Right */,
];
```

### `const` enum pitfalls
Inlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to ambient const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.

1. For the reasons laid out in the `isolatedModules` documentation, that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use `isolatedModules` and those enum values at the same time.
2. You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.
3. `importsNotUsedAsValues: "preserve"` will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, type-only imports, does not allow const enum values, currently.

Here are two approaches to avoiding these pitfalls:

1. Do not use const enums at all. You can easily ban const enums with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.
2. Do not publish ambient const enums, by deconstifying them with the help of `preserveConstEnums`. This is the approach taken internally by the TypeScript project itself. `preserveConstEnums` emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files in a build step.

    This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.

## Ambient enums
Ambient enums are used to describe the shape of already existing enum types.
```ts
declare enum Enum {
  A = 1,
  B,
  C = 2,
}
```

One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is always considered computed.

## Objects vs Enums
In modern TypeScript, you may not need an enum when an object with `as const` could suffice:
```ts
const enum EDirection {
  Up,
  Down,
  Left,
  Right,
}

const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

// EDirection.Up = 0
EDirection.Up;

// Up: 0
ODirection.Up;

// Using the enum as a parameter
function walk(dir: EDirection) {}

// It requires an extra line to pull out the values
type Direction = typeof ODirection[keyof typeof ODirection];
function run(dir: Direction) {}

walk(EDirection.Left);
run(ODirection.Right);
```

The biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and `when/if` enums are added to JavaScript then you can move to the additional syntax.
