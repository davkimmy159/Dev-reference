
##### 반환 `promise` <sub>(객체)</sub> `await` X
- `unhandled rejection` <sub>(예외)</sub> 발생 가능
  - d
- Because the returned promise isn’t `await`-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try…finally`:
```ts
async function f() {
  try {
    return g(); // also reports an unhandled rejection
  }

  finally {
    await somethingElse();
  }
}
```

To avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:
```ts
async function f() {
  await using x = new C();
  return await g();
}
```

<br />

## `using` and `await using` in `for` and ``for…of`` statements
Both `using` and `await using` can be used in a `for` statement:
```ts
for (using x = getReader(); !x.eof; x.next()) {
  // ...
}
```

In this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.

In addition to `for` statements, both declarations can also be used in `for…of` statements:
```ts
function * g() {
  yield createResource1();
  yield createResource2();
}

for (using x of g()) {
  // ...
}
```

Here, `x` is disposed at the end of each iteration of the loop, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.

<br />

## `using` and `await using` in older runtimes
`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.
