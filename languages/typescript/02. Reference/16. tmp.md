
##### 반환 `promise` <sub>(객체)</sub> `await` X
- `unhandledrejection` <sub>(이벤트)</sub> 발생 가능
  - `x` <sub>(변수)</sub> 비동기 청소 중 실행 중단
  - 반환 `Promise` <sub>(객체)</sub> 처리 X
- 문제 발생 가능 경우
  - `await using` 선언
  - 비동기 <sub>(`async`)</sub> 함수 내 `try…finally`
```ts
async function f() {
  try {

    // unhandledrejection (이벤트) 발생
    return g();
  }

  finally {
    await somethingElse();
  }
}
```

##### `Promise` <sub>(객체)</sub> 반환 시
- `await` <sub>(키워드)</sub> 명시
```ts
async function f() {
  await using x = new C();
  return await g();
}
```

<br />

## `for[…of]` 내 `[await] using`
Both `using` and `await using` can be used in a `for` statement:
```ts
for (using x = getReader(); !x.eof; x.next()) {
  // ...
}
```

In this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.

In addition to `for` statements, both declarations can also be used in `for…of` statements:
```ts
function * g() {
  yield createResource1();
  yield createResource2();
}

for (using x of g()) {
  // ...
}
```

Here, `x` is disposed at the end of each iteration of the loop, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.

<br />

## `using` and `await using` in older runtimes
`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.
