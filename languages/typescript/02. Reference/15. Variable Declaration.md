변수 선언
========

## `var` 선언

##### 전통적인 변수 선언 방식
```ts
var a = 10;
```

##### 함수 내 선언
```ts
function f() {
  var message = "Hello, world!";
  return message;
}
```

##### 타 함수 접근
- `g`
  - `f` <sub>(함수)</sub> 내 `a` <sub>(변수)</sub> 캡쳐
- `g` 호출 시 `a` 값
  - `f` <sub>(함수)</sub> 내 `a` <sub>(변수)</sub> 바인딩
- `f` <sub>(함수)</sub> 실행 종료 후 `g` 호출 시
  - `a` <sub>(변수)</sub> 접근 · 수정 가능
```ts
function f() {
  var a = 10;

  return function g() {
    var b = a + 1;
    return b;
  };
}

var g = f();
g(); // 11
```

```ts
function f() {
  var a = 1;

  a = 2;
  var b = g();
  a = 3;

  return b;

  function g() {
    return a;
  }
}

f(); // 2
```

### 범위 설정 규칙

##### 이상한 범위 설정 규칙 적용
```ts
function f(shouldInitialize: boolean) {
  if (shouldInitialize) {
    var x = 10;
  }

  return x;
}

f(true);  // 10
f(false); // undefined
```

##### 속한 범위 내 어디서든 접근 가능
- 함수 범위
- 모듈 범위
- 네임스페이스 범위
- 전역 범위

##### 별명
- _'var scoping'_
- _'function scoping'_

##### 문제점 야기
- 복수 동일 변수 선언 가능
```ts
function sumMatrix(matrix: number[][]) {
  var sum = 0;

  for (var i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i];

    // 바깥 for (반복문) 내 i (변수) 덮어씀
    // - 함수 범위 변수
    for (var i = 0; i < currentRow.length; i++) {
      sum += currentRow[i];
    }
  }

  return sum;
}
```

### 변수 캡쳐링 문제
```ts
for (var i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100 * i);
}
```
- 예상 결과
```
0
1
2
3
4
5
6
7
8
9
```
- 실제 결과
```
10
10
10
10
10
10
10
10
10
10
```

##### `setTimeout` <sub>(함수)</sub> 내 모든 함수 표현식
- 동일 범위 내 동일 `i` <sub>(변수)</sub> 참조
1. `setTimeout` <sub>(함수)</sub>
    - 임의 밀리초 후 실행
    - `for` <sub>(반복문)</sub> 종료 후 실행
2. `for` <sub>(반복문)</sub> 종료
    - `i` <sub>(변수)</sub> 값
      - `10`

##### IIFE <sub>(Immediately Invoked Function Expression)</sub>
- 각 반복 내 `i` <sub>(변수)</sub> 캡쳐
```ts
for (var i = 0; i < 10; i++) {

  // 현재 값 함께 함수 실행
  // - i (변수) 현재 상태 캡쳐
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 100 * i);
  })(i);
}
```

##### `i` <sub>(매개변수)</sub>
- `for` <sub>(반복문)</sub> 내 `i` <sub>(변수)</sub> 가림

<br />

## `let` 선언

##### `var` 선언 동일
```ts
let hello = "Hello!";
```

### 블록 범위 설정

##### 블록 범위 특징 ①
- 최근접 속한 범위 · 반복문 외부에서 접근 X
- `var` 범위
  - 속한 범위 전체로 새어나감

##### 별명
- _'lexical scoping'_
- _'block scoping'_

##### 지역 변수 <sub>(`a` · `b`)</sub>
- `a` 범위
  - `f`<sub>(함수)</sub> 본문
- `b` 범위
  - `if` <sub>(문)</sub> 블록
```ts
function f(input: boolean) {
  let a = 100;

  if (input) {

    // a 참조 가능
    let b = a + 1;
    return b;
  }

  // 에러 발생
  // - b 부재 (블록 외부)
  //   - Error: 'b' doesn't exist here
  return b;
}
```

##### `catch` <sub>(절)</sub> 내 선언 변수
- 유사 범위 규칙 적용 <sub>(블록 범위)</sub>
```ts
try {
  throw "oh no!";
} catch (e) {
  console.log("Oh well.");
}

// 에러 발생
// - Error: 'e' doesn't exist here
console.log(e);
```

##### 블록 범위 특징 ②
- 선언 전 접근 X
  - 실제로는 속한 범위 내 존재
  - 할당 전 사용 X
```ts
// 에러 발생
// - illegal to use 'a' before it's declared;
a++;
let a;
```

##### 특이사항
- 블록 범위 변수
  - 선언 전 캡쳐 가능
  - 선언 전 함수 호출 X
- 모던 런타임
  - 에러 발생
- TS
  - 에러 발생 X
```ts
function foo() {

  // 에러 발생 X
  return a;
}

// 에러 발생
// - a (변수) 선언 전 함수 호출 X
foo();

let a;
```

### 재선언 · 가리기

##### `var` 선언
- 복수 동일 변수 선언 가능
```ts
// 모든 x (변수) 선언
// - 동일 x 참조
function f(x) {
  var x;
  var x;

  if (true) {
    var x;
  }
}
```

##### `let` 선언
- 복수 동일 변수 선언 X
```ts
let x = 10;

// 에러 발생
// - error: can't re-declare 'x' in the same scope
let x = 20;
```
- 혼합 범위 사용 무관
```ts
function f(x) {

  // 에러 발생
  // - error: interferes with parameter declaration
  let x = 100;
}

function g() {
  let x = 100;

  // 에러 발생
  // - error: can't have both declarations of 'x'
  var x = 100;
}
```

##### 함수 범위 설정 가능
- 명확히 다른 블록 내 선언
```ts
function f(condition, x) {
  if (condition) {
    let x = 100;
    return x;
  }

  return x;
}

f(false, 0); // 0
f(true, 0);  // 100
```

##### 변수명 가리기
- 더 깊은 중첩 범위 내 새 기존 변수명 선언
- 양날의 검
  - 특정 버그 발생 가능
    - 우연한 변수명 가리기
  - 특정 버그 방지
```ts
function sumMatrix(matrix: number[][]) {
  let sum = 0;

  for (let i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i];

    // 바깥 for (반복문) 내 i (변수) 가리기
    // - 문제 없이 동작
    for (let i = 0; i < currentRow.length; i++) {
      sum += currentRow[i];
    }
  }

  return sum;
}
```

##### 가능하면 사용 지양
- 깔끔한 코드 작성 방해
- 정말 필요할 때만 사용

### 블록 범위 변수 캡쳐링

##### 환경
- 각 범위 실행 시
  - 변수 환경 생성
- 환경 · 캡쳐된 변수
  - 속한 범위 실행 종료 후 존재 가능
```ts
function theCityThatAlwaysSleeps() {
  let getCity;

  if (true) {

    // 환경 내 변수 캡쳐
    // - if (문) 종료 후 접근 가능
    let city = "Seattle";

    getCity = function () {
      return city;
    };
  }

  return getCity();
}
```

##### IIFE <sub>(Immediately Invoked Function Expression)</sub>
- 반복문 내 각 반복
  - 새 변수 환경 생성 <sub>(변수 상태 캡쳐)</sub>

##### `let` 선언
- 반복문 내 각 반복
  - 새 범위 생성
```ts
for (let i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100 * i);
}
```
- 결과
```
0
1
2
3
4
5
6
7
8
9
```

<br />

## `const` 선언

##### 선언 후 값 변경 X
- `let` 선언 동일 범위 규칙
- 값 재할당 X
```ts
const numLivesForCat = 9;
```

##### 변경 불가능 참조 X
- 재할당 X
- 참조 내부 변경 가능
```ts
const numLivesForCat = 9;
const kitty = {
  name: "Aurora",
  numLives: numLivesForCat,
};

// 에러 발생
// - 재할당 X
kitty = {
  name: "Danielle",
  numLives: numLivesForCat,
};

// 에러 발생 X
// - 참조 내부 수정
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;
```

##### `readonly` <sub>(제한자)</sub>
- 참조 내부 수정 방지

<br />

## `let` vs `const`

##### 상황 따라 선택
- `const`
  - 가능하면 주로 사용
- `let`
  - 값 변경 필요할 때만 사용
- 이유
  - 협업 시 혼동 방지
  - 코드 예측성 ↑ <sub>(데이터 흐름 분석)</sub>

<br />

## 구조 분해

### 배열 구조 분해

##### 배열 구조 분해 할당
```ts
let input = [1, 2];
let [first, second] = input;
console.log(first);  // 1
console.log(second); // 2
```
- 인덱싱 사용 코드 동일 효과
  - 편리성 ↑
```ts
first = input[0];
second = input[1];
```

##### 기존 선언 변수 사용
```ts
// 변수 교체
[first, second] = [second, first];
```

##### 함수 매개변수
```ts
function f([first, second]: [number, number]) {
  console.log(first);
  console.log(second);
}

f([1, 2]);
```

##### `...` <sub>(나머지 문법)</sub>
- 여분 요소 모으기
```ts
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // 1
console.log(rest);  // [ 2, 3, 4 ]
```
- 여분 요소 무시
```ts
let [first] = [1, 2, 3, 4];
console.log(first); // 1
```
- 여분 요소 내 특정 요소 선택
```ts
let [, second, , fourth] = [1, 2, 3, 4];
console.log(second); // 2
console.log(fourth); // 4
```

### `tuple` 구조 분해

##### 배열 구조 분해 유사
- `tuple` 내 각 상응 멤버 타입 적용
```ts
let tuple: [number, string, boolean] = [7, "hello", true];

// a: number
// b: string
// c: boolean
let [a, b, c] = tuple;
```

##### 범위 초과 시 에러 발생
```ts
// 에러 발생
// - Error, no element at index 3
let [a, b, c, d] = tuple;
```

##### `...` <sub>(나머지 문법)</sub>
```ts
// bc: [string, boolean]
let [a, ...bc] = tuple;

// d: [] (빈 tuple)
let [a, b, c, ...d] = tuple;
```

##### 여분 · 특정 요소 무시
```ts
// a: number
let [a] = tuple;

// b: string
let [, b] = tuple;
```

### 객체 구조 분해
```ts
let o = {
  a: "foo",
  b: 12,
  c: "bar",
};

// o.a → a
// o.b → b
// o.c 생략
let { a, b } = o;
```

##### 기존 선언 변수 사용
- `()` <sub>(소괄호)</sub> 필요
  - `{` <sub>(중괄호)</sub> 블록 인식
```ts
({ a, b } = { a: "baz", b: 101 });
```

##### `...` <sub>(나머지 문법)</sub>
- 여분 프로퍼티 모으기
```ts
let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
```

#### 프로퍼티명 재지정
```ts
// let newName1 = o.a;
// let newName2 = o.b;
let { a: newName1, b: newName2 } = o;
```

##### 타입 명시
- 구조 분해 다음 명시
```ts
let { a: newName1, b: newName2 }: { a: string; b: number } = o;
```

#### 기본값

##### `undefined` 프로퍼티 방지
```ts
function keepWholeObject(wholeObject: { a: string; b?: number }) {
  let { a, b = 1001 } = wholeObject;
}
```

<br />

## 함수 선언

##### 구조 분해
```ts
type C = { a: string; b?: number };
function f({ a, b }: C): void { … }
```

##### 기본값 설정
- 매개변수 리스트 자체 기본값 설정 유용
1. 기본값 설정 전 패턴 작성
```ts
function f({ a = "", b = 0 } = {}): void { … }

f();
```
2. 기본값 설정
    - 선택 프로퍼티 <sub>(구조 분해)</sub>
    - 자체 기본값
      - 필수 프로퍼티
```ts
function f({ a, b = 0 } = { a: "" }): void { … }

// b = 0
f({ a: "yes" });

// { a: "" }, b = 0
f();

// 에러 발생
// - a 필수
f({});
```

##### 주의
- 문법 자체 약간 복잡
  - 혼동 가능성 ↑
- 권장 구조 분해 표현식 코드
  - 단순
  - 小

<br />

## 스프레드 문법 <sub>(전개 구문)</sub>

##### 구조 분해 반대 동작
- 배열 펼치기 <sub>(얕은 복사)</sub>
```ts
let first = [1, 2];
let second = [3, 4];

// [0, 1, 2, 3, 4, 5]
let bothPlus = [0, ...first, ...second, 5];
```

- 객체 펼치기 <sub>(얕은 복사)</sub>
```ts
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };

// { food: "rich", price: "$$", ambiance: "noisy" }
let search = { ...defaults, food: "rich" };
```

##### 객체 펼치기
- 배열 펼치기보다 복잡
- 프로퍼티 중복 시
  - 앞 프로퍼티 덮어쓰기
```ts
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };

// { food: "spicy", price: "$$", ambiance: "noisy" }
// "rich" → "spicy" (덮어쓰기)
let search = { food: "rich", ...defaults };
```

##### 객체 펼치기 한계
1. 자체 · 열거 가능 프로퍼티만 적용
    - 메서드 배제
```ts
class C {
  p = 12;
  m() {}
}

let c = new C();

// let clone: { p: number }
let clone = { ...c };

clone.p;

// 에러 발생
clone.m();
```

2. 제네릭 함수 내 타입 매개변수 X
    - 차후 TS 버전 기대

<br />

## `using` 선언

##### JS 차후 버전 기능
- `const` 선언 유사
- 두 개념 연결
  - 선언 바인딩된 값 수명
  - 변수 범위

##### `[Symbol.dispose]` <sub>(해당 `using` 선언 값 메서드)</sub>
- `using` 선언 속한 블록 종료 시 실행
  - 해당 값 청소 실행
```ts
function f() {
  using x = new C();
  doSomethingWith(x);
} // x[Symbol.dispose]() 호출
```
- 동일 효과 런타임 코드
```ts
function f() {
  const x = new C();

  try {
    doSomethingWith(x);
  }

  finally {
    x[Symbol.dispose]();
  }
}
```

##### 메모리 누수 방지 유용
- 특정 JS 객체 대상 작업
  - 네이티브 참조 <sub>(파일 핸들러 등)</sub> 보유
```ts
{
  using file = await openFile();
  file.write(text);
  doSomethingThatMayThrow();
} // file (변수) 제거 (에러 발생 여부 무관)
```
- 범위 지정 작업 <sub>(트레이싱 등)</sub>
```ts
function f() {

  // 함수 진입 추적
  using activity = new TraceActivity("f");
  …
} // 함수 종료 추적
```
- 구조 분해 미지원

### `null` · `undefined`

##### `null` · `undefined` 값 가능
- 블록 끝 삭제 동작 X
```ts
{
  using x = b ? new C() : null;
  …
}
```

- 동일 효과 런타임 코드
```ts
{
  const x = b ? new C() : null;

  try {
    …
  }

  finally {
    x?.[Symbol.dispose]();
  }
}
```

##### 조건부 자원 획득
- 복잡한 분기 · 반복 X

### 1회용 자원 정의하기

##### `Disposable` 인터페이스
- 특정 클래스 · 객체
  - 제거 가능 설정
```ts
/* 네이티브 코드 */
interface Disposable {
  [Symbol.dispose](): void;
}

// 사용법
class TraceActivity implements Disposable {
  readonly name: string;

  constructor(name: string) {
    this.name = name;
    console.log(`Entering: ${name}`);
  }

  [Symbol.dispose](): void {
    console.log(`Exiting: ${name}`);
  }
}

function f() {
  using _activity = new TraceActivity("f");
  console.log("Hello world!");
}

/* 출력 순서
 1. Entering: f
 2. Hello world!
 3. Exiting: f
 */
f();
```

<br />

## `await using` 선언

##### 특정 자원 · 동작
- 비동기 청소 필요
```ts
async function f() {
  await using x = new C();
} // await x[Symbol.asyncDispose]() 호출
```

##### `[Symbol.asyncDispose]` <sub>(해당 `using` 선언 값 메서드)</sub>
- `using` 선언 속한 블록 종료 시 실행
  - 해당 값 청소 실행
- 
- An `await using` declaration invokes, and awaits, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.

As with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.

### 1회용 비동기 자원 정의하기
Just as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:
```ts
/* from the default lib: */
interface AsyncDisposable {
  [Symbol.asyncDispose]: PromiseLike<void>;
}

// usage:
class DatabaseTransaction implements AsyncDisposable {
  public success = false;
  private db: Database | undefined;

  private constructor(db: Database) {
    this.db = db;
  }

  static async create(db: Database) {
    await db.execAsync("BEGIN TRANSACTION");
    return new DatabaseTransaction(db);
  }

  async [Symbol.asyncDispose]() {
    if (this.db) {
      const db = this.db:
      this.db = undefined;

      if (this.success) {
        await db.execAsync("COMMIT TRANSACTION");
      } else {
        await db.execAsync("ROLLBACK TRANSACTION");
      }
    }
  }
}

async function transfer(db: Database, account1: Account, account2: Account, amount: number) {
  using tx = await DatabaseTransaction.create(db);
  if (await debitAccount(db, account1, amount)) {
    await creditAccount(db, account2, amount);
  }

  // if an exception is thrown before this line, the transaction will roll back
  tx.success = true;

  // now the transaction will commit
}
```

### `await using` vs `await`
The `await` keyword that is part of the `await using` declaration only indicates that the disposal of the resource is `await`-ed. It does not `await` the value itself:
```ts
{
  await using x = getResourceSynchronously();
} // performs `await x[Symbol.asyncDispose]()`

{
  await using y = await getResourceAsynchronously();
} // performs `await y[Symbol.asyncDispose]()`
```

### `await using` and `return`
It’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`-ing it:
```ts
function g() {
  return Promise.reject("error!");
}

async function f() {
  await using x = new C();
  return g(); // missing an `await`
}
```

Because the returned promise isn’t `await`-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try…finally`:
```ts
async function f() {
  try {
    return g(); // also reports an unhandled rejection
  }

  finally {
    await somethingElse();
  }
}
```

To avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:
```ts
async function f() {
  await using x = new C();
  return await g();
}
```

<br />

## `using` and `await using` in `for` and ``for…of`` statements
Both `using` and `await using` can be used in a `for` statement:
```ts
for (using x = getReader(); !x.eof; x.next()) {
  // ...
}
```

In this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.

In addition to `for` statements, both declarations can also be used in `for…of` statements:
```ts
function * g() {
  yield createResource1();
  yield createResource2();
}

for (using x of g()) {
  // ...
}
```

Here, `x` is disposed at the end of each iteration of the loop, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.

<br />

## `using` and `await using` in older runtimes
`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.
