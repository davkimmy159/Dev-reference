변수 선언
========

## `var` 선언

##### 전통적인 변수 선언 방식
```ts
var a = 10;
```

##### 함수 내 선언
```ts
function f() {
  var message = "Hello, world!";
  return message;
}
```

##### 타 함수 접근
- `g`
  - `f` <sub>(함수)</sub> 내 `a` <sub>(변수)</sub> 캡쳐
- `g` 호출 시 `a` 값
  - `f` <sub>(함수)</sub> 내 `a` <sub>(변수)</sub> 바인딩
- `f` <sub>(함수)</sub> 실행 종료 후 `g` 호출 시
  - `a` <sub>(변수)</sub> 접근 · 수정 가능
```ts
function f() {
  var a = 10;

  return function g() {
    var b = a + 1;
    return b;
  };
}

var g = f();
g(); // 11
```

```ts
function f() {
  var a = 1;

  a = 2;
  var b = g();
  a = 3;

  return b;

  function g() {
    return a;
  }
}

f(); // 2
```

### 범위 설정 규칙

##### 이상한 범위 설정 규칙 적용
```ts
function f(shouldInitialize: boolean) {
  if (shouldInitialize) {
    var x = 10;
  }

  return x;
}

f(true);  // 10
f(false); // undefined
```

##### 속한 범위 내 어디서든 접근 가능
- 함수 범위
- 모듈 범위
- 네임스페이스 범위
- 전역 범위

##### 별명
- _'var scoping'_
- _'function scoping'_

##### 문제점 야기
- 복수 동일 변수 선언 가능
```ts
function sumMatrix(matrix: number[][]) {
  var sum = 0;

  for (var i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i];

    // 바깥 for (반복문) 내 i (변수) 덮어씀
    // - 함수 범위 변수
    for (var i = 0; i < currentRow.length; i++) {
      sum += currentRow[i];
    }
  }

  return sum;
}
```

### 변수 캡쳐링 문제
```ts
for (var i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100 * i);
}
```
- 예상 결과
```
0
1
2
3
4
5
6
7
8
9
```
- 실제 결과
```
10
10
10
10
10
10
10
10
10
10
```

##### `setTimeout` <sub>(함수)</sub> 내 모든 함수 표현식
- 동일 범위 내 동일 `i` <sub>(변수)</sub> 참조
1. `setTimeout` <sub>(함수)</sub>
    - 임의 밀리초 후 실행
    - `for` <sub>(반복문)</sub> 종료 후 실행
2. `for` <sub>(반복문)</sub> 종료
    - `i` <sub>(변수)</sub> 값
      - `10`

##### IIFE <sub>(Immediately Invoked Function Expression)</sub>
- 각 반복 내 `i` <sub>(변수)</sub> 캡쳐
```ts
for (var i = 0; i < 10; i++) {

  // 현재 값 함께 함수 실행
  // - i (변수) 현재 상태 캡쳐
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 100 * i);
  })(i);
}
```

##### `i` <sub>(매개변수)</sub>
- `for` <sub>(반복문)</sub> 내 `i` <sub>(변수)</sub> 가림

<br />

## `let` 선언

##### `var` 선언 동일
```ts
let hello = "Hello!";
```

### 블록 범위 설정

##### 블록 범위 특징 ①
- 최근접 속한 범위 · 반복문 외부에서 접근 X
- `var` 범위
  - 속한 범위 전체로 새어나감

##### 별명
- _'lexical scoping'_
- _'block scoping'_

##### 지역 변수 <sub>(`a` · `b`)</sub>
- `a` 범위
  - `f`<sub>(함수)</sub> 본문
- `b` 범위
  - `if` <sub>(문)</sub> 블록
```ts
function f(input: boolean) {
  let a = 100;

  if (input) {

    // a 참조 가능
    let b = a + 1;
    return b;
  }

  // 에러 발생
  // - b 부재 (블록 외부)
  //   - Error: 'b' doesn't exist here
  return b;
}
```

##### `catch` <sub>(절)</sub> 내 선언 변수
- 유사 범위 규칙 적용 <sub>(블록 범위)</sub>
```ts
try {
  throw "oh no!";
} catch (e) {
  console.log("Oh well.");
}

// 에러 발생
// - Error: 'e' doesn't exist here
console.log(e);
```

##### 블록 범위 특징 ②
- 선언 전 접근 X
  - 실제로는 속한 범위 내 존재
  - 할당 전 사용 X
```ts
// 에러 발생
// - illegal to use 'a' before it's declared;
a++;
let a;
```

##### 특이사항
- 블록 범위 변수
  - 선언 전 캡쳐 가능
  - 선언 전 함수 호출 X
- 모던 런타임
  - 에러 발생
- TS
  - 에러 발생 X
```ts
function foo() {

  // 에러 발생 X
  return a;
}

// 에러 발생
// - a (변수) 선언 전 함수 호출 X
foo();

let a;
```

### 재선언 · 가리기

##### `var` 선언
- 복수 동일 변수 선언 가능
```ts
// 모든 x (변수) 선언
// - 동일 x 참조
function f(x) {
  var x;
  var x;

  if (true) {
    var x;
  }
}
```

##### `let` 선언
- 복수 동일 변수 선언 X
```ts
let x = 10;

// 에러 발생
// - error: can't re-declare 'x' in the same scope
let x = 20;
```
- 혼합 범위 사용 무관
```ts
function f(x) {

  // 에러 발생
  // - error: interferes with parameter declaration
  let x = 100;
}

function g() {
  let x = 100;

  // 에러 발생
  // - error: can't have both declarations of 'x'
  var x = 100;
}
```

##### 함수 범위 설정 가능
- 명확히 다른 블록 내 선언
```ts
function f(condition, x) {
  if (condition) {
    let x = 100;
    return x;
  }

  return x;
}

f(false, 0); // 0
f(true, 0);  // 100
```

##### 변수명 가리기
- 더 깊은 중첩 범위 내 새 기존 변수명 선언
- 양날의 검
  - 특정 버그 발생 가능
    - 우연한 변수명 가리기
  - 특정 버그 방지
```ts
function sumMatrix(matrix: number[][]) {
  let sum = 0;

  for (let i = 0; i < matrix.length; i++) {
    var currentRow = matrix[i];

    // 바깥 for (반복문) 내 i (변수) 가리기
    // - 문제 없이 동작
    for (let i = 0; i < currentRow.length; i++) {
      sum += currentRow[i];
    }
  }

  return sum;
}
```

##### 가능하면 사용 지양
- 깔끔한 코드 작성 방해
- 정말 필요할 때 사용

### 블록 범위 변수 캡쳐링

##### 환경
- 각 범위 실행 시
  - 변수 환경 생성
- 환경 · 캡쳐된 변수
  - 속한 범위 실행 종료 후 존재 가능
```ts
function theCityThatAlwaysSleeps() {
  let getCity;

  if (true) {

    // 환경 내 변수 캡쳐
    // - if (문) 종료 후 접근 가능
    let city = "Seattle";

    getCity = function () {
      return city;
    };
  }

  return getCity();
}
```

##### IIFE <sub>(Immediately Invoked Function Expression)</sub>
- 반복문 내 각 반복 내 변수 상태 캡쳐
- use an IIFE to capture the state of a variable for every iteration of the `for` loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.

`let` declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope per iteration. Since this is what we were doing anyway with our IIFE, we can change our old `setTimeout` example to just use a `let` declaration.
```ts
for (let i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i);
  }, 100 * i);
}
```

and as expected, this will print out
```
0
1
2
3
4
5
6
7
8
9
```

<br />

## `const` declarations
`const` declarations are another way of declaring variables.
```
const numLivesForCat = 9;
```

They are like `let` declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as `let`, but you can’t re-assign to them.

This should not be confused with the idea that the values they refer to are immutable.
```ts
const numLivesForCat = 9;
const kitty = {
  name: "Aurora",
  numLives: numLivesForCat,
};

// Error
kitty = {
  name: "Danielle",
  numLives: numLivesForCat,
};

// all "okay"
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;
```

Unless you take specific measures to avoid it, the internal state of a `const` variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are `readonly`. The chapter on Interfaces has the details.

<br />

## `let` vs `const`
Given that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.

Applying the principle of least privilege, all declarations other than those you plan to modify should use const. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using `const` also makes code more predictable when reasoning about flow of data.

Use your best judgement, and if applicable, consult the matter with the rest of your team.

The majority of this handbook uses `let` declarations.

<br />

## Destructuring
Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see the article on the Mozilla Developer Network. In this section, we’ll give a short overview.

### Array destructuring
The simplest form of destructuring is array destructuring assignment:
```ts
let input = [1, 2];
let [first, second] = input;
console.log(first); // outputs 1
console.log(second); // outputs 2
```

This creates two new variables named `first` and `second`. This is equivalent to using indexing, but is much more convenient:
```ts
first = input[0];
second = input[1];
```

Destructuring works with already-declared variables as well:
```ts
// swap variables
[first, second] = [second, first];
```

And with parameters to a function:
```ts
function f([first, second]: [number, number]) {
  console.log(first);
  console.log(second);
}

f([1, 2]);
```

You can create a variable for the remaining items in a list using the syntax `...`:
```ts
let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]
```

Of course, since this is JavaScript, you can just ignore trailing elements you don’t care about:
```ts
let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1
```

Or other elements:
```ts
let [, second, , fourth] = [1, 2, 3, 4];
console.log(second); // outputs 2
console.log(fourth); // outputs 4
```

### Tuple destructuring
Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:
```ts
let tuple: [number, string, boolean] = [7, "hello", true];
let [a, b, c] = tuple; // a: number, b: string, c: boolean
```

It’s an error to destructure a tuple beyond the range of its elements:
```ts
let [a, b, c, d] = tuple; // Error, no element at index 3
```

As with arrays, you can destructure the rest of the tuple with `...`, to get a shorter tuple:
```ts
let [a, ...bc] = tuple; // bc: [string, boolean]
let [a, b, c, ...d] = tuple; // d: [], the empty tuple
```

Or ignore trailing elements, or other elements:
```ts
let [a] = tuple; // a: number
let [, b] = tuple; // b: string
```

### Object destructuring
You can also destructure objects:
```ts
let o = {
  a: "foo",
  b: 12,
  c: "bar",
};

let { a, b } = o;
```

This creates new variables `a` and `b` from `o.a` and `o.b`. Notice that you can skip `c` if you don’t need it.

Like array destructuring, you can have assignment without declaration:
```ts
({ a, b } = { a: "baz", b: 101 });
```

Notice that we had to surround this statement with parentheses. JavaScript normally parses a `{` as the start of block.

You can create a variable for the remaining items in an object using the syntax `...`:
```ts
let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;
```

#### Property renaming
You can also give different names to properties:
```ts
let { a: newName1, b: newName2 } = o;
```

Here the syntax starts to get confusing. You can read `a: newName1` as ”`a` as `newName1`”. The direction is left-to-right, as if you had written:
```ts
let newName1 = o.a;
let newName2 = o.b;
```

Confusingly, the colon here does not indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:
```ts
let { a: newName1, b: newName2 }: { a: string; b: number } = o;
```

#### Default values
Default values let you specify a default value in case a property is undefined:
```ts
function keepWholeObject(wholeObject: { a: string; b?: number }) {
  let { a, b = 1001 } = wholeObject;
}
```

In this example the `b?` indicates that `b` is optional, so it may be `undefined`. `keepWholeObject` now has a variable for `wholeObject` as well as the properties `a` and `b`, even if `b` is undefined.

<br />

## Function declarations
Destructuring also works in function declarations. For simple cases this is straightforward:
```ts
type C = { a: string; b?: number };
function f({ a, b }: C): void {
  // ...
}
```

But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.
```ts
function f({ a = "", b = 0 } = {}): void {
  // ...
}

f();
```

Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that `C` was defined with `b` optional:
```ts
function f({ a, b = 0 } = { a: "" }): void {
  // ...
}

f({ a: "yes" }); // ok, default b = 0
f(); // ok, default to { a: "" }, which then defaults b = 0
f({}); // error, 'a' is required if you supply an argument
```

Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets really hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.

<br />

## Spread
The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:
```ts
let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
```

This gives bothPlus the value `[0, 1, 2, 3, 4, 5]`. Spreading creates a shallow copy of `first` and `second`. They are not changed by the spread.

You can also spread objects:
```ts
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };
```

Now `search` is `{ food: "rich", price: "$$", ambiance: "noisy" }`. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:
```ts
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };
```

Then the `food` property in `defaults` overwrites `food: "rich"`, which is not what we want in this case.

Object spread also has a couple of other surprising limits. First, it only includes an objects’ own, enumerable properties. Basically, that means you lose methods when you spread instances of an object:
```ts
class C {
  p = 12;
  m() {}
}

let c = new C();
let clone = { ...c };

clone.p; // ok
clone.m(); // error!
```

Second, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.

<br />

## `using` declarations
`using` declarations are an upcoming feature for JavaScript that are part of the Stage 3 Explicit Resource Management proposal. A `using` declaration is much like a `const` declaration, except that it couples the lifetime of the value bound to the declaration with the scope of the variable.

When control exits the block containing a `using` declaration, the `[Symbol.dispose]()` method of the declared value is executed, which allows that value to perform cleanup:
```ts
function f() {
  using x = new C();
  doSomethingWith(x);
} // `x[Symbol.dispose]()` is called
```

At runtime, this has an effect roughly equivalent to the following:
```ts
function f() {
  const x = new C();

  try {
    doSomethingWith(x);
  }

  finally {
    x[Symbol.dispose]();
  }
}
```

`using` declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles
```ts
{
  using file = await openFile();
  file.write(text);
  doSomethingThatMayThrow();
} // `file` is disposed, even if an error is thrown
```

or scoped operations like tracing
```ts
function f() {
  using activity = new TraceActivity("f"); // traces entry into function
  // ...
} // traces exit of function
```

Unlike `var`, `let`, and `const`, `using` declarations do not support destructuring.

### `null` and `undefined`
It’s important to note that the value can be `null` or `undefined`, in which case nothing is disposed at the end of the block:
```ts
{
  using x = b ? new C() : null;
  // ...
}
```

which is roughly equivalent to:
```ts
{
  const x = b ? new C() : null;

  try {
    // ...
  }

  finally {
    x?.[Symbol.dispose]();
  }
}
```

This allows you to conditionally acquire resources when declaring a `using` declaration without the need for complex branching or repetition.

### Defining a disposable resource
You can indicate the classes or objects you produce are disposable by implementing the `Disposable` interface:
```ts
/* from the default lib: */
interface Disposable {
  [Symbol.dispose](): void;
}

// usage:
class TraceActivity implements Disposable {
  readonly name: string;

  constructor(name: string) {
    this.name = name;
    console.log(`Entering: ${name}`);
  }

  [Symbol.dispose](): void {
    console.log(`Exiting: ${name}`);
  }
}

function f() {
  using _activity = new TraceActivity("f");
  console.log("Hello world!");
}

f();
// prints:
//   Entering: f
//   Hello world!
//   Exiting: f
```

<br />

## `await using` declarations
Some resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the Explicit Resource Management proposal also introduces the `await using` declaration:
```ts
async function f() {
  await using x = new C();
} // `await x[Symbol.asyncDispose]()` is invoked
```

An `await using` declaration invokes, and awaits, its value’s `[Symbol.asyncDispose]()` method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.

As with `await`, `await using` can only be used in an `async` function or method, or at the top level of a module.

### Defining an asynchronously disposable resource
Just as `using` relies on objects that are `Disposable`, an `await using` relies on objects that are `AsyncDisposable`:
```ts
/* from the default lib: */
interface AsyncDisposable {
  [Symbol.asyncDispose]: PromiseLike<void>;
}

// usage:
class DatabaseTransaction implements AsyncDisposable {
  public success = false;
  private db: Database | undefined;

  private constructor(db: Database) {
    this.db = db;
  }

  static async create(db: Database) {
    await db.execAsync("BEGIN TRANSACTION");
    return new DatabaseTransaction(db);
  }

  async [Symbol.asyncDispose]() {
    if (this.db) {
      const db = this.db:
      this.db = undefined;

      if (this.success) {
        await db.execAsync("COMMIT TRANSACTION");
      } else {
        await db.execAsync("ROLLBACK TRANSACTION");
      }
    }
  }
}

async function transfer(db: Database, account1: Account, account2: Account, amount: number) {
  using tx = await DatabaseTransaction.create(db);
  if (await debitAccount(db, account1, amount)) {
    await creditAccount(db, account2, amount);
  }

  // if an exception is thrown before this line, the transaction will roll back
  tx.success = true;

  // now the transaction will commit
}
```

### `await using` vs `await`
The `await` keyword that is part of the `await using` declaration only indicates that the disposal of the resource is `await`-ed. It does not `await` the value itself:
```ts
{
  await using x = getResourceSynchronously();
} // performs `await x[Symbol.asyncDispose]()`

{
  await using y = await getResourceAsynchronously();
} // performs `await y[Symbol.asyncDispose]()`
```

### `await using` and `return`
It’s important to note that there is a small caveat with this behavior if you are using an `await using` declaration in an `async` function that returns a `Promise` without first `await`-ing it:
```ts
function g() {
  return Promise.reject("error!");
}

async function f() {
  await using x = new C();
  return g(); // missing an `await`
}
```

Because the returned promise isn’t `await`-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while `await`-ing the asynchronous disposal of `x`, without having subscribed to the returned promise. This is not a problem that is unique to `await using`, however, as this can also occur in an `async` function that uses `try…finally`:
```ts
async function f() {
  try {
    return g(); // also reports an unhandled rejection
  }

  finally {
    await somethingElse();
  }
}
```

To avoid this situation, it is recommended that you `await` your return value if it may be a `Promise`:
```ts
async function f() {
  await using x = new C();
  return await g();
}
```

<br />

## `using` and `await using` in `for` and ``for…of`` statements
Both `using` and `await using` can be used in a `for` statement:
```ts
for (using x = getReader(); !x.eof; x.next()) {
  // ...
}
```

In this case, the lifetime of `x` is scoped to the entire `for` statement and is only disposed when control leaves the loop due to `break`, `return`, `throw`, or when the loop condition is false.

In addition to `for` statements, both declarations can also be used in `for…of` statements:
```ts
function * g() {
  yield createResource1();
  yield createResource2();
}

for (using x of g()) {
  // ...
}
```

Here, `x` is disposed at the end of each iteration of the loop, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.

<br />

## `using` and `await using` in older runtimes
`using` and `await using` declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for `Symbol.dispose`/`Symbol.asyncDispose`, such as the one provided by default in recent editions of NodeJS.
