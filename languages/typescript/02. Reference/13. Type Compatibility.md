타입 호환
=========

##### TS 타입 호환
- 구조적 하위 타입 지정 기반
  - 오직 타입 내 멤버 기반 타입 연관
  - ↔ 명목상 타입 지정
```ts
interface Pet {
  name: string;
}

class Dog {
  name: string;
}

let pet: Pet;

// 에러 발생 X
// - 구조적 타입 지정
pet = new Dog();
```

##### 명목적 타입 언어 <sub>(C# · Java 등)</sub>
- `Dog` <sub>(클래스)</sub>
  - `Pet` <sub>(인터페이스)</sub> 명시적 구현 X
    - 에러 발생

##### TS <sub>(구조적 타입 언어)</sub>
- JS 코드 기반 <sub>(광범위한 익명 객체 사용)</sub>
  - 함수 표현식
  - 객체 리터럴
  - 기타 등등
- 구조적 타입
  - JS 코드 관계 표현 용이

## 건전성 참고

##### TS 타입 시스템 내 특정 동작
- 컴파일 시 타입 불안전
  - '불건전한 동작' <sub>(주의 요구)</sub>

## 기본

##### 기본 규칙 <sub>(구조적 타입 시스템)</sub>
- `x` · `y` 호환 조건
  - 최소한 동일 멤버 보유

##### `Pet` <sub>(인터페이스)</sub>
- `name` <sub>(프로퍼티)</sub>
```ts
interface Pet {
  name: string;
}

let pet: Pet;

// 타입 추론
// - let dog: { name: string; owner: string; }
let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
pet = dog;
```

##### `dog` → `pet` 할당 가능성 체크 규칙
- `pet` 내 각 프로퍼티 체크 <sub>(컴파일러)</sub>
  - `dog` 내 호환 가능 상응 프로퍼티 검색
    - `name: string` 필수

##### 함수 호출 시 인수 체크 규칙
- 할당 가능성 동일
```ts
interface Pet {
  name: string;
}

// 타입 추론
// - let dog: { name: string; owner: string; }
let dog = { name: "Lassie", owner: "Rudd Weatherwax" };

function greet(pet: Pet) {
  console.log("Hello, " + pet.name);
}

// 에러 발생 X
greet(dog);
```

##### 타겟 타입 <sub>(`Pet`)</sub> 멤버만 호환성 체크
- `dog.owner` <sub>(여분 프로퍼티)</sub> 무관
- 재귀적 비교 진행
  - 각 멤버 · 하위 멤버 타입

##### 객체 리터럴
- 알려진 속성만 지정 가능
- 타 타입 변수 할당 시
  - 여분 프로퍼티 미허용
```ts
// 에러 발생
let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" };
```

## 두 함수 비교하기 <sub>(호환성)</sub>

#### 1. 매개변수 리스트
- 상응 매개변수 체크
  - 이름 무관
  - 타입 상응 필수
- `x` → `y` 할당 가능
  - 모든 상응 매개변수 有
- `y` → `x` 할당 X
  - `x` 내 2번째 필수 매개변수 X
```ts
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x;
x = y; // 에러 발생
```
- `y` → `x` 할당 가능
  - `y` 내 2번째 매개변수 optional 명시
```ts
let x = (a: number) => 0;
let y = (b: number, s?: string) => 0;

y = x;
x = y; // 에러 발생 X (optional)

```

##### 여분 매개변수 버리기
- JS 내 자주 발생
- ex\) `Array#forEach` 전달 콜백
  - 명시 매개변수 3개
  - 1번째만 전달해도 동작
```ts
let items = [1, 2, 3];

items.forEach((item, index, array) => console.log(item));
items.forEach((item) => console.log(item));
```

#### 2. 반환 타입
- 소스 함수 반환 타입
  - 타겟 함수 반환 타입의 하위 타입 강제
```ts
let x = () => ({ name: "Alice" });
let y = () => ({ name: "Alice", location: "Seattle" });

x = y;
y = x; // 에러 발생
       // - x 반환 타입 내 location 프로퍼티 X
```


### 함수 매개변수 이변형 <sub>(Bivariance)</sub>

##### 함수 매개변수 비교
- 소스 ↔ 타겟 <sub>(매개변수)</sub> 할당 가능 시
  - 함수 할당 성공

##### 부적절한 특이점 <sub>(드물게 발생)</sub>
- 호출자 함수 매개면수
  - 더 구체적인 타입
- 실제 호출 함수 매개변수
  - 덜 구체적인 타입

##### 다수 JS 패턴
- 부적절한 특이점 특징 활용
```ts
enum EventType {
  Mouse,
  Keyboard,
}

interface Event {
  timestamp: number;
}

interface MyMouseEvent extends Event {
  x: number;
  y: number;
}

interface MyKeyEvent extends Event {
  keyCode: number;
}

function listenEvent(eventType: EventType, handler: (n: Event) => void) {
  /* … */
}

// 부적절한 특이점 코드
// - 유용 · 자주 사용
listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y));

// 적절한 유효 코드
// - 바람직 X
listenEvent(EventType.Mouse, (e: Event) =>
  console.log((e as MyMouseEvent).x + "," + (e as MyMouseEvent).y)
);
listenEvent(EventType.Mouse, ((e: MyMouseEvent) =>
  console.log(e.x + "," + e.y)) as (e: Event) => void);

// 에러 발생
// - 완전 비호환 타입
listenEvent(EventType.Mouse, (e: number) => console.log(e));
```

##### `strictFunctionTypes` <sub>(옵션)</sub>
- 부적절한 특이점 코드 에러 발생

## Optional Parameters and Rest Parameters
When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.

When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.

This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing `undefined` in that position is equivalent for most functions.

The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:
```ts
function invokeLater(args: any[], callback: (...args: any[]) => void) {
  /* ... Invoke callback with 'args' ... */
}

// Unsound - invokeLater "might" provide any number of arguments
invokeLater([1, 2], (x, y) => console.log(x + ", " + y));

// Confusing (x and y are actually required) and undiscoverable
invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y));
```

### Functions with overloads
When a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.

## `enum`
Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,
```ts
enum Status {
  Ready,
  Waiting,
}

enum Color {
  Red,
  Blue,
  Green,
}

let status = Status.Ready;
status = Color.Green; // Error
```

## 클래스
Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.
```ts
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) {}
}

class Size {
  feet: number;
  constructor(numFeet: number) {}
}

let a: Animal;
let s: Size;
a = s; // OK
s = a; // OK
```

### Private and protected members in classes
Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but not with classes from a different inheritance hierarchy which otherwise have the same shape.

## Generics
Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,
```ts
interface Empty<T> {}
let x: Empty<number>;
let y: Empty<string>;
x = y; // OK, because y matches structure of x
```

In the above, `x` and `y` are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to `Empty<T>` shows how this works:
```ts
interface NotEmpty<T> {
  data: T;
}

let x: NotEmpty<number>;
let y: NotEmpty<string>;
x = y; // Error, because x and y are not compatible
```
In this way, a generic type that has its type arguments specified acts just like a non-generic type.

For generic types that do not have their type arguments specified, compatibility is checked by specifying `any` in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.

For example,
```ts
let identity = function <T>(x: T): T {
  // ...
};

let reverse = function <U>(y: U): U {
  // ...
};

identity = reverse; // OK, because (x: any) => any matches (y: any) => any
```

## Advanced Topics

### Subtype vs Assignment
So far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from `any`, and to and from `enum` with corresponding numeric values.

Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the `implements` and `extends` clauses.

## `any` · `unknown` · `object` · `void` · `undefined` · `null` · `never` assignability
The following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”△” indicates a combination that is compatible only when `strictNullChecks` is off.

||any|unknown|object|void|undefined|null|never|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|any||✓|✓|✓|✓|✓|✕|
|unknown|✓||✕|✕|✕|✕|✕|
|object|✓|✓||✕|✕|✕|✕|
|void|✓|✓|✕||✕|✕|✕|
|undefined|✓|✓|△|✓||△|✕|
|null|✓|✓|△|△|△||✕|
|never|✓|✓|✓|✓|✓|✓||

Reiterating The Basics:
- Everything is assignable to itself.
- `any` and `unknown` are the same in terms of what is assignable to them, different in that `unknown` is not assignable to anything except `any`.
- `unknown` and `never` are like inverses of each other. Everything is assignable to `unknown`, `never` is assignable to everything. Nothing is assignable to `never`, `unknown` is not assignable to anything (except `any`).
- `void` is not assignable to or from anything, with the following exceptions: `any`, `unknown`, `never`, `undefined`, and `null` (if `strictNullChecks` is off, see table for details).
- When `strictNullChecks` is off, `null` and `undefined` are similar to `never`: assignable to most types, most types are not assignable to them. They are assignable to each other.
- When `strictNullChecks` is on, `null` and `undefined` behave more like `void`: not assignable to or from anything, except for `any`, `unknown`, and `void` (`undefined` is always assignable to `void`).