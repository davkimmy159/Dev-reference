
## 기타 타입

##### TS 추가 타입
- 함수 타입 작업 시 자주 등장
- 모든 곳에 사용 가능
  - 주로 함수 컨텍스트 관련

### `void`

##### 값 미반환 함수 반환 타입
- 추론된 타입
  - 함수 내 `return` <sub>(문)</sub> X
  - `return` <sub>(문)</sub> 내 명시적 반환값 X
```ts
// 추론된 반환 타입
// - void
function noop() {
  return;
}
```

##### 값 미반환 JS 함수
- `undefined` 암시적 반환

##### `void` vs `undefined`
- 상이 타입

### `object`

##### 非원시 타입 표현
- `string`
- `number`
- `bigint`
- `boolean`
- `symbol`
- `null`
- `undefined`

##### 유사 · 상이 타입
- `{}` <sub>(빈 객체 타입)</sub>
- `Object` <sub>(전역 타입)</sub>
  - 아주 드물게 사용

##### JS 함수 == 객체형
- 프로퍼티 有
- `Object.prototype` <sub>(프로토타입 체인)</sub>
- `instanceof Object` <sub>(`true`)</sub>
- `Object.keys` 호출 가능
- 기타 등등

##### TS 함수 타입
- `object`

### `unknown`

##### 모든 값 표현 <sub>(`any` 유사)</sub>
- 관련 작업 허용 X
  - `any` 보다 더 안전
```ts
function f1(a: any) {
  a.b();
}

function f2(a: unknown) {

  // 에러 발생
  // - 'a' is of type 'unknown'.
  a.b();
}
```

##### 함수 타입 작성 시 유용
- `any` 매개변수 표현 가능
  - `any` 미사용
- 반환 타입 사용 가능
```ts
function safeParse(s: string): unknown {
  return JSON.parse(s);
}

// obj: unknown
// - 반환값 사용 시 주의
const obj = safeParse(someRandomString);
```

### `never`

##### 관찰된 적 업는 값 표현
- 함수 반환 타입
  - 예외 던지기
  - 프로그램 종료
- union 내 선택지 없어짐

##### 항시 값 미반환 함수
```ts
function fail(msg: string): never {
  throw new Error(msg);
}
```

##### union 내 선택지 X
```ts
function fn(x: string | number) {
  if (typeof x === "string") {
    …
  } else if (typeof x === "number") {
    …
  } else {
    x; // x: never
  }
}
```

### `Function` <sub>(전역 타입)</sub>

##### 모든 JS 함수값 내 호출 가능 공통 프로퍼티 표현
- `bind`
- `call`
- `apply`
- 기타 등등

##### 특수 프로퍼티 보유
- 값 <sub>(`Function` 타입)</sub> 호출 가능화
  - `any` 반환

##### 가급적 사용 X
- 타입 불안전 <sub>(`any` 반환)</sub>
- 값 미반환 임의 함수 전달 필요 시 <sub>(호출 X)</sub>
  - `() => void` 사용 <sub>(더 안전)</sub>
    - _**이해 X**_
```ts
function doSomething(f: Function) {
  return f(1, 2, 3);
}
```

## 나머지 매개변수 · 인수

### 나머지 매개변수

##### 가변적인 함수 매개변수 개수 표현
- 인수 리스트 마지막 위치
- `...` + 매개변수명

##### 타입
- 암시적 `any[]`
- 타입 매개변수 사용 시 형태
  - `T[]`
  - `Array<T>`
  - tuple
```ts
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}

// a 값
// - [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4);
```

### 나머지 인수

##### 다수 인수 전달
- `...` <sub>(스프레드 문법)</sub>
  - 이터러블 <sub>(객체)</sub> 적용 <sub>(펼치기)</sub>
```ts
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
arr1.push(...arr2);
```

##### TS 내 배열
- 보통 변경 가능 취급 <sub>(Not immutable)</sub>
```ts
// number[] (추론 타입)
// - 배열 길이 제한 X
const args = [8, 5];

// 에러 발생
// - 함수 인수 2개 필요
//   - A spread argument must either have a tuple type or be passed to a rest parameter.

const angle = Math.atan2(...args);
```

##### 대표적 해결 방법
- `const`
```ts
// 튜플 (추론 타입)
// - 길이 : 2
const args = [8, 5] as const;

const angle = Math.atan2(...args);
```

##### 나머지 인수 사용
- 오래된 JS 런타임
  - `downlevelIteration` <sub>(옵션)</sub> 고려

## 매개변수 구조 분해

##### 객체 <sub>(인수)</sub> → 다수 지역 변수
```ts
function sum({ a, b, c }) {
  console.log(a + b + c);
}
sum({ a: 10, b: 3, c: 9 });
```

##### 객체 타입 주석 위치
- 구조 분해 문법 다음 명시
```ts
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

##### 타입 별칭 사용
```ts
// Same as prior example
type ABC = { a: number; b: number; c: number };

function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

## Assignability of Functions

### `void` <sub>(함수 반환 타입)</sub>

##### `void` 반환 함수 타입
- 드문 · 예상 가능 행동 구현 가능

##### Contextual typing · `void` <sub>(함수 반환 타입)</sub>
- 함수 미반환 강제 X
  - Contextual 함수 타입 <sub>(`void` 반환)</sub>
  - `type voidFunc = () => void`
- 함수 구현 시
  - 모든 값 반환 가능 <sub>(반환값 무시)</sub>
```ts
type voidFunc = () => void;

const f1: voidFunc = () => {
  return true;
};

const f2: voidFunc = () => true;

const f3: voidFunc = function () {
  return true;
};
```

And when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:
```ts
const v1 = f1();

const v2 = f2();

const v3 = f3();
```

This behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.
```ts
const src = [1, 2, 3];
const dst = [0];

src.forEach((el) => dst.push(el));
```

There is one other special case to be aware of, when a literal function definition has a `void` return type, that function must not return anything.
```ts
function f2(): void {
  // @ts-expect-error
  return true;
}

const f3 = function (): void {
  // @ts-expect-error
  return true;
};
```
