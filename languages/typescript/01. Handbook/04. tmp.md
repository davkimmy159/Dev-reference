
## 기타 타입

##### TS 추가 타입
- 함수 타입 작업 시 자주 등장
- 모든 곳에 사용 가능
  - 주로 함수 컨텍스트 관련

### `void`

##### 값 미반환 함수 반환 타입
- 추론된 타입
  - 함수 내 `return` <sub>(문)</sub> X
  - `return` <sub>(문)</sub> 내 명시적 반환값 X
```ts
// 추론된 반환 타입
// - void
function noop() {
  return;
}
```

##### 값 미반환 JS 함수
- `undefined` 암시적 반환

##### `void` vs `undefined`
- 상이 타입

### `object`

##### 非원시 타입 표현
- `string`
- `number`
- `bigint`
- `boolean`
- `symbol`
- `null`
- `undefined`

##### 유사 · 상이 타입
- `{}` <sub>(빈 객체 타입)</sub>
- `Object` <sub>(전역 타입)</sub>
  - 아주 드물게 사용

##### JS 함수 == 객체형
- 프로퍼티 有
- `Object.prototype` <sub>(프로토타입 체인)</sub>
- `instanceof Object` <sub>(`true`)</sub>
- `Object.keys` 호출 가능
- 기타 등등

##### TS 함수 타입
- `object`

### `unknown`

##### 모든 값 표현 <sub>(`any` 유사)</sub>
- 관련 작업 허용 X
  - `any` 보다 더 안전
```ts
function f1(a: any) {
  a.b();
}

function f2(a: unknown) {

  // 에러 발생
  // - 'a' is of type 'unknown'.
  a.b();
}
```

##### 함수 타입 작성 시 유용
- `any` 매개변수 표현 가능
  - `any` 미사용
- 반환 타입 사용 가능
```ts
function safeParse(s: string): unknown {
  return JSON.parse(s);
}

// obj: unknown
// - 반환값 사용 시 주의
const obj = safeParse(someRandomString);
```

### `never`

##### 관찰된 적 업는 값 표현
- 함수 반환 타입
  - 예외 던지기
  - 프로그램 종료
- union 내 선택지 없어짐

##### 항시 값 미반환 함수
```ts
function fail(msg: string): never {
  throw new Error(msg);
}
```

##### union 내 선택지 X
```ts
function fn(x: string | number) {
  if (typeof x === "string") {
    …
  } else if (typeof x === "number") {
    …
  } else {
    x; // x: never
  }
}
```

### `Function` <sub>(전역 타입)</sub>

- The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript

##### 모든 JS 함수값 내 호출 가능 공통 프로퍼티 표현
- `bind`
- `call`
- `apply`
- 기타 등등

##### 특수 프로퍼티 보유
- 값 <sub>(`Function` 타입)</sub> 호출 가능화
  - `any` 반환
```ts
function doSomething(f: Function) {
  return f(1, 2, 3);
}
```

This is an untyped function call and is generally best avoided because of the unsafe `any` return type.

If you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.

## Rest Parameters and Arguments

### Rest Parameters
In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.

A rest parameter appears after all other parameters, and uses the `...` syntax:
```ts
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
// 'a' gets value [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4);
```

In TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).

### Rest Arguments
Conversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:
```ts
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
arr1.push(...arr2);
```

Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:
```ts
// Inferred type is number[] -- "an array with zero or more numbers",
// not specifically two numbers
const args = [8, 5];

// A spread argument must either have a tuple type or be passed to a rest parameter.
const angle = Math.atan2(...args);
```

The best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:
```ts
// Inferred as 2-length tuple
const args = [8, 5] as const;
// OK
const angle = Math.atan2(...args);
```

Using rest arguments may require turning on `downlevelIteration` when targeting older runtimes.

## Parameter Destructuring
You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:
```ts
function sum({ a, b, c }) {
  console.log(a + b + c);
}
sum({ a: 10, b: 3, c: 9 });
```

The type annotation for the object goes after the destructuring syntax:
```ts
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

This can look a bit verbose, but you can use a named type here as well:
```ts
// Same as prior example
type ABC = { a: number; b: number; c: number };
function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

## Assignability of Functions

### Return type `void`
The `void` return type for functions can produce some unusual, but expected behavior.

Contextual typing with a return type of `void` does not force functions to not return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return any other value, but it will be ignored.

Thus, the following implementations of the type `() => void` are valid:
```ts
type voidFunc = () => void;

const f1: voidFunc = () => {
  return true;
};

const f2: voidFunc = () => true;

const f3: voidFunc = function () {
  return true;
};
```

And when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:
```ts
const v1 = f1();

const v2 = f2();

const v3 = f3();
```

This behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.
```ts
const src = [1, 2, 3];
const dst = [0];

src.forEach((el) => dst.push(el));
```

There is one other special case to be aware of, when a literal function definition has a `void` return type, that function must not return anything.
```ts
function f2(): void {
  // @ts-expect-error
  return true;
}

const f3 = function (): void {
  // @ts-expect-error
  return true;
};
```
