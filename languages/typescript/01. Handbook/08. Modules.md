Modules
=======

## JS 모듈 정의 방식

##### TS 모듈
- 최상위 `[im·ex]port` 포함 파일
  - ES2015 방식 동일

##### TS 스크립트 <sub>(전역 범위 사용 가능)</sub>
- 최상위 `[im·ex]port` 부재 파일

##### 모듈 범위
- 모듈 내 선언 · 정의
  - 변수
  - 함수
  - 클래스
  - 기타 등등
- 외부에서 접근 X
  - `export` 필요
- 외부에서 사용
  - `import` 필요

<br />

## 非모듈

##### JS 非모듈 파일 <sub>(스크립트)</sub>
- 특정 키워드 부재 파일
  - `export`
  - `import`
  - 최상위 `await`

##### 스크립트 파일
- 변수 · 타입
  - 전역 범위
- `outFile` <sub>(옵션)</sub>
  - 다수 입력 파일 → 1개 출력 파일
- 순서대로 다수 `<script>` <sub>(태그)</sub> 사용
- Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the `outFile` compiler option to join multiple input files into one output file, or use multiple `<script>` tags in your HTML to load these files (in the correct order!).

If you have a file that doesn’t currently have any `import`s or `export`s, but you want to be treated as a module, add the line:
```ts
export {};
```

which will change the file to be a module exporting nothing. This syntax works regardless of your module target.

<br />

## Modules in TypeScript
There are three main things to consider when writing module-based code in TypeScript:
##### Syntax
- What syntax do I want to use to import and export things?

##### Module Resolution
- What is the relationship between module names (or paths) and files on disk?

##### Module Output Target
- What should my emitted JavaScript module look like?

### ES Module Syntax
A file can declare a main export via `export default`:
```ts
// @filename: hello.ts
export default function helloWorld() {
  console.log("Hello, world!");
}
```

This is then imported via:
```ts
import helloWorld from "./hello.js";
helloWorld();
```

In addition to the default export, you can have more than one export of variables and functions via the `export` by omitting `default`:
```ts
// @filename: maths.ts
export var pi = 3.14;
export let squareTwo = 1.41;
export const phi = 1.61;

export class RandomNumberGenerator {}

export function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}
```

These can be used in another file via the `import` syntax:
```ts
import { pi, phi, absolute } from "./maths.js";

console.log(pi);

// const absPhi: number
const absPhi = absolute(phi);
```

### Additional Import Syntax
An import can be renamed using a format like `import {old as new}`:
```ts
import { pi as π } from "./maths.js";

// (별칭) var π: number
// - import π
console.log(π);
```

You can mix and match the above syntax into a single `import`:
```ts
// @filename: maths.ts
export const pi = 3.14;
export default class RandomNumberGenerator {}

// @filename: app.ts
import RandomNumberGenerator, { pi as π } from "./maths.js";

// (별칭) class RandomNumberGenerator
// import RandomNumberGenerator
RandomNumberGenerator;

// (별칭) const π: 3.14
// import π
console.log(π);
```

You can take all of the exported objects and put them into a single namespace using `* as name`:
```ts
// @filename: app.ts
import * as math from "./maths.js";

console.log(math.pi);

// const positivePhi: number
const positivePhi = math.absolute(math.phi);
```

You can import a file and not include any variables into your current module via `import "./file"`:
```ts
// @filename: app.ts
import "./maths.js";

console.log("3.14");
```

In this case, the `import` does nothing. However, all of the code in `maths.ts` was evaluated, which could trigger side-effects which affect other objects.

#### TypeScript Specific ES Module Syntax
Types can be exported and imported using the same syntax as JavaScript values:
```ts
// @filename: animal.ts
export type Cat = {
  breed: string;
  yearOfBirth: number
};

export interface Dog {
  breeds: string[];
  yearOfBirth: number;
}

// @filename: app.ts
import { Cat, Dog } from "./animal.js";
type Animals = Cat | Dog;
```

TypeScript has extended the `import` syntax with two concepts for declaring an import of a type:

##### 1. import type
Which is an import statement which can only import types:
```ts
/* @filename: animal.ts */
export type Cat = { breed: string; yearOfBirth: number };
export type Dog = { breeds: string[]; yearOfBirth: number };
export const createCatName = () => "fluffy";
```
```ts
/* @filename: valid.ts */
import type { Cat, Dog } from "./animal.js";
export type Animals = Cat | Dog;
```
```ts
/* @filename: app.ts */
import type { createCatName } from "./animal.js";

// 'createCatName' cannot be used as a value because it was imported using 'import type'.
const name = createCatName();
```

##### 2. Inline type imports
TypeScript 4.5 also allows for individual imports to be prefixed with `type` to indicate that the imported reference is a type:
```ts
/* @filename: app.ts */
import { createCatName, type Cat, type Dog } from "./animal.js";

export type Animals = Cat | Dog;
const name = createCatName();
```

Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.

#### ES Module Syntax with CommonJS Behavior
TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD `require`. Imports using ES Module are for most cases the same as the `require` from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:
```ts
import fs = require("fs");
const code = fs.readFileSync("hello.ts", "utf8");
```

You can learn more about this syntax in the modules reference page.

<br />

## CommonJS Syntax
CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.

##### `Exporting`
Identifiers are exported via setting the `exports` property on a global called `module`.
```ts
function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}

module.exports = {
  pi: 3.14,
  squareTwo: 1.41,
  phi: 1.61,
  absolute,
};
```

Then these files can be imported via a `require` statement:
```ts
const maths = require("./maths");

// any
maths.pi;
```

Or you can simplify a bit using the destructuring feature in JavaScript:
```ts
const { squareTwo } = require("./maths");

// const squareTwo: any
squareTwo;
```

#### CommonJS and ES Modules interop
There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with `esModuleInterop`.

<br />

## TypeScript’s Module Resolution Options
Module resolution is the process of taking a string from the `import` or `require` statement, and determining what file that string refers to.

TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option `module` is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.

There are many TSConfig flags which influence the module strategy within TypeScript: `moduleResolution`, `baseUrl`, `paths`, `rootDirs`.

For the full details on how these strategies work, you can consult the `Module Resolution` reference page.

<br />

## TypeScript’s Module Output Options
There are two options which affect the emitted JavaScript output:

##### `target`
- determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact

##### `module`
- determines what code is used for modules to interact with each other

Which `target` you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.

All communication between modules happens via a module loader, the compiler option `module` determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.

For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for `module`:
```ts
import { valueOfPi } from "./constants.js";

export const twoPi = valueOfPi * 2;
```

##### ES2020
```ts
import { valueOfPi } from "./constants.js";
export const twoPi = valueOfPi * 2;
```

##### CommonJS
```ts
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.twoPi = void 0;
const constants_js_1 = require("./constants.js");
exports.twoPi = constants_js_1.valueOfPi * 2;
```

##### UMD
```ts
(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "./constants.js"], factory);
  }
})(function (require, exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.twoPi = void 0;
  const constants_js_1 = require("./constants.js");
  exports.twoPi = constants_js_1.valueOfPi * 2;
});
```

<br />

<hr />

Note that ES2020 is effectively the same as the original `index.ts`.

<hr />

You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.

<br />

## TypeScript namespaces
TypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in the namespaces reference page.

<br />

## 추가

함수 정의를 가져오기(import)와 내보내기(export) 하는 것은 다른 것과 마찬가지 방식으로 동작한다. 타입스크립트만의 특별한 것은 모듈을 정의하면서 .d.ts 파일을 만들 때다.
```ts
const sum = (a: number, b: number): number => a + b;
sum.operator = '+';
```

다음 예제는 기본으로 내보내기(default export)이다.
```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export default sum;
```

그리고 다음 예제는 이름 있는 내보내기(named export)이다.
```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export { sum };
```
