Modules
=======

## JS 모듈 정의 방식

##### TS 모듈
- 최상위 `[im·ex]port` 포함 파일
  - ES2015 방식 동일

##### TS 스크립트 <sub>(전역 범위 사용 가능)</sub>
- 최상위 `[im·ex]port` 부재 파일

##### 모듈 범위
- 모듈 내 선언 · 정의
  - 변수
  - 함수
  - 클래스
  - 기타 등등
- 외부에서 접근 X
  - `export` 필요
- 외부에서 사용
  - `import` 필요

<br />

## 非모듈

##### JS 非모듈 파일 <sub>(스크립트)</sub>
- 특정 키워드 부재 파일
  - `export`
  - `import`
  - 최상위 `await`

##### 스크립트 파일
- 변수 · 타입
  - 전역 범위
- `outFile` <sub>(옵션)</sub> 사용
  - 다수 입력 파일 → 1개 출력 파일
- 다수 `<script>` <sub>(태그)</sub> 사용
  - 올바른 순서 준수

##### `[im·ex]port` 부재 파일 모듈화
- `export {};` 추가
```ts
// 빈 export
export {};
```

<br />

## TS 모듈

##### TS 모듈 기반 코드 작성 핵심 <sub>(3가지)</sub>
1. 문법 선택
    - `[im·ex]port` 시 사용
2. 모듈 해상도 <sub>(관계)</sub>
    - 모듈 이름 · 경로
    - 디스크 내 파일
3. 모듈 출력 타겟
    - 생성된 JS 파일 형태

### ES 모듈 문법

##### 기본 · 주 `export`
- `export default`
```ts
/* hello.ts */
export default function helloWorld() {
  console.log("Hello, world!");
}
```
- `import a`
  - `{}` <sub>(중괄호)</sub> X
```ts
import helloWorld from "./hello.js";
helloWorld();
```

##### 다수 `export`
- `default` <sub>(키워드)</sub> X
```ts
/* maths.ts */
export var pi = 3.14;
export let squareTwo = 1.41;
export const phi = 1.61;

export class RandomNumberGenerator {}

export function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}
```
- `import { a, b, c }`
  - `{}` <sub>(중괄호)</sub> 내 나열
```ts
import { pi, phi, absolute } from "./maths.js";

console.log(pi);

// const absPhi: number
const absPhi = absolute(phi);
```

### 추가 `import` 문법

##### 이름 재정의
- `as` <sub>(키워드)</sub>
  - `import { a as b }`
```ts
import { pi as π } from "./maths.js";

// var π: number
console.log(π);
```

##### 단일 `import` 내 문법 조합 가능
```ts
/* maths.ts */
export default class RandomNumberGenerator {}
export const pi = 3.14;
```
```ts
/* app.ts */
import RandomNumberGenerator, { pi as π } from "./maths.js";

// class RandomNumberGenerator
RandomNumberGenerator;

// const π: 3.14
console.log(π);
```

##### 모든 `export` 멤버 → 단일 네임스페이스
- `import * as name`
```ts
/* app.ts */
import * as math from "./maths.js";

console.log(math.pi);

// const positivePhi: number
const positivePhi = math.absolute(math.phi);
```

##### 파일만 `import` <sub>(모듈 내 멤버 X)</sub>
- `import "./file"`
  - `import` 기능 실행 X
  - 모듈 내 코드 평가
    - 부작용 발생 <sub>(타 객체 영향 끼침)</sub>
```ts
/* app.ts */
import "./maths.js";

console.log("3.14");
```

#### TS 전용 ES 모듈 문법

##### 타입 `[im·ex]port`
- 값 문법 동일
```ts
/* animal.ts */
export type Cat = {
  breed: string;
  yearOfBirth: number
};

export interface Dog {
  breeds: string[];
  yearOfBirth: number;
}
```
```ts
/* app.ts */
import { Cat, Dog } from "./animal.js";
type Animals = Cat | Dog;
```

#### TS `import` 문법 확장 <sub>(타입)</sub>

##### 1. import type
- 타입만 적용 가능
```ts
/* animal.ts */
export type Cat = {
  breed: string;
  yearOfBirth: number
};

export type Dog = {
  breeds: string[];
  yearOfBirth: number
};

export const createCatName = () => "fluffy";
```
```ts
/* valid.ts */
import type { Cat, Dog } from "./animal.js";
export type Animals = Cat | Dog;
```
```ts
/* app.ts */
import type { createCatName } from "./animal.js";

// 에러 발생
// - 타입 X · 값
//   - 'createCatName' cannot be used as a value because it was imported using 'import type'.
const name = createCatName();
```

##### 2. Inline 타입 `import` <sub>(TS 4.5)</sub>
- `import` <sub>(문)</sub> 내 개별 `type` <sub>(접두사)</sub>
```ts
/* app.ts */
import { createCatName, type Cat, type Dog } from "./animal.js";

export type Animals = Cat | Dog;
const name = createCatName();
```

#### ES 모듈 문법 · CommonJS 동작

##### TS 내 ES 모듈 문법
- `require` <sub>(CommonJS · AMD)</sub> 대응 有
- `import` <sub>(ES 모듈 문법)</sub>
  - 대다수 경우 `require` 동일
  - 1:1 매칭 필수 <sub>(TS 파일 : CommonJS 출력)</sub>
```ts
import fs = require("fs");
const code = fs.readFileSync("hello.ts", "utf8");
```

<br />

## CommonJS 문법

##### 대다수 NPM 모듈 전달 포맷
- CommonJS 문법 작동 방식 이해
  - 디버깅에 도움

##### `Export`
- `module.exports` 할당
  - `module` <sub>(전역 범위)</sub>
  - `exports` <sub>(프로퍼티)</sub>
```ts
function absolute(num: number) {
  if (num < 0) return num * -1;
  return num;
}

module.exports = {
  pi: 3.14,
  squareTwo: 1.41,
  phi: 1.61,
  absolute,
};
```

##### `import`
- `require` <sub>(문)</sub>
```ts
const maths = require("./maths");

// any
maths.pi;
```

- 구조 분해 할당
```ts
const { squareTwo } = require("./maths");

// const squareTwo: any
squareTwo;
```

#### CommonJS · ES 모듈 상호 이용

##### CommonJS · ES 모듈 상이 특징
- 기본 `import`
- 모듈 네임스페이스 객체 `import`

##### `esModuleInterop` <sub>(옵션)</sub>
- 두 상이 제약 마찰 완화

<br />

## TS 모듈 해상도 옵션

##### 모듈 해상도
- 참조 파일 결정 과정
  - `import` · `require` <sub>(문)</sub> 문자열

#### TS 모듈 해상도 종류

##### Classic <sub>(기본)</sub>
- `module` <sub>(옵션)</sub>
  - `commonjs` X
  - 하위 호환성 유지 설정

##### Node
- CommonJS 모드 내 Node.js 동작 방식 복제
- Classic, the default when the compiler option `module` is not `commonjs`, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for `.ts` and `.d.ts`.

There are many TSConfig flags which influence the module strategy within TypeScript: `moduleResolution`, `baseUrl`, `paths`, `rootDirs`.

For the full details on how these strategies work, you can consult the `Module Resolution` reference page.

<br />

## TypeScript’s Module Output Options
There are two options which affect the emitted JavaScript output:

##### `target`
- determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact

##### `module`
- determines what code is used for modules to interact with each other

Which `target` you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.

All communication between modules happens via a module loader, the compiler option `module` determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.

For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for `module`:
```ts
import { valueOfPi } from "./constants.js";

export const twoPi = valueOfPi * 2;
```

##### ES2020
```ts
import { valueOfPi } from "./constants.js";
export const twoPi = valueOfPi * 2;
```

##### CommonJS
```ts
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.twoPi = void 0;
const constants_js_1 = require("./constants.js");
exports.twoPi = constants_js_1.valueOfPi * 2;
```

##### UMD
```ts
(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "./constants.js"], factory);
  }
})(function (require, exports) {
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.twoPi = void 0;
  const constants_js_1 = require("./constants.js");
  exports.twoPi = constants_js_1.valueOfPi * 2;
});
```

<br />

<hr />

Note that ES2020 is effectively the same as the original `index.ts`.

<hr />

You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.

<br />

## TypeScript namespaces
TypeScript has its own module format called `namespaces` which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in the namespaces reference page.

<br />

## 추가

함수 정의를 가져오기(import)와 내보내기(export) 하는 것은 다른 것과 마찬가지 방식으로 동작한다. 타입스크립트만의 특별한 것은 모듈을 정의하면서 .d.ts 파일을 만들 때다.
```ts
const sum = (a: number, b: number): number => a + b;
sum.operator = '+';
```

다음 예제는 기본으로 내보내기(default export)이다.
```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export default sum;
```

그리고 다음 예제는 이름 있는 내보내기(named export)이다.
```ts
declare const sum: {
  (a: number, b: number): number;
  operator: string;
};
export { sum };
```
