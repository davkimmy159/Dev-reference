Classes
=======

## 클래스 멤버

##### 베이스 클래스 <sub>(학습용)</sub>
```ts
class Point {}
```

### 필드

##### 필드 선언
- 프로퍼티 생성
  - `public`
  - 수정 가능
- 타입 주석 생략
  - 암시적 `any` <sub>(타입)</sub>
```ts
class Point {
  x: number;
  y: number;

  // x: any
  z;
}

const pt = new Point();
pt.x = 0;
pt.y = 0;
```

##### 필드 초기화
- 클래스 인스턴스 생성 시 자동 실행
```ts
class Point {

  // x: number
  x = 0;

  // y: number
  y = 0;
}

const pt = new Point();

// Prints 0, 0
console.log(`${pt.x}, ${pt.y}`);
```
- 타입 추론
```ts
const pt = new Point();

// 에러 발생
// - Type 'string' is not assignable to type 'number'.
pt.x = "0";
```

#### `--strictPropertyInitialization` <sub>(옵션)</sub>
- 생성자 내 클래스 필드 초기화 여부
```ts
class BadGreeter {

  // 에러 발생
  // - Property 'name' has no initializer and is not definitely assigned in the constructor.
  name: string;
}
```
```ts
class GoodGreeter {
  name: string;

  constructor() {
    this.name = "hello";
  }
}
```

##### 생성자 내 필드 초기화 필수
- 생성자 내 메서드 호출 분석 X <sub>(초기화 탐지 X)</sub>
  - 하위 클래스 메서드 오버라이드 가능
    - 멤버 초기화 실패

##### 필드 초기화 확실한 경우
- 생성자 외 방식
  - ex\) 외부 라이브러리 초기화 실행
- `…!` <sub>(확정적 할당 주장 연산자)</sub>
```ts
class OKGreeter {

  // 초기화 X
  // - 에러 발생 X
  name!: string;
}
```

### `readonly` <sub>(제한자)</sub>

##### 생성자 외 필드 할당 방지
```ts
class Greeter {
  readonly name: string = "world";

  constructor(otherName?: string) {
    if (otherName !== undefined) {
      this.name = otherName;
    }
  }

  err() {

    // 에러 발생
    // - Cannot assign to 'name' because it is a read-only property.
    this.name = "not ok";
  }
}
const g = new Greeter();

// 에러 발생
// - Cannot assign to 'name' because it is a read-only property.
g.name = "also not ok";
```

### 생성자

##### 일반 함수 유사
- 매개변수
  - 타입 주석
  - 기본값
  - 오버로드
```ts
class Point {
  x: number;
  y: number;

  // 일반적 생성자 (기본값 有)
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
}
```
```ts
class Point {
  x: number = 0;
  y: number = 0;

  // 생성자 오버로드
  constructor(x: number, y: number);
  constructor(xy: string);
  constructor(x: string | number, y: number = 0) { … }
}
```

#### 생성자 vs 함수

##### 1. 생성자 타입 매개변수 X
- these belong on the outer class declaration, which we’ll learn about later

##### 2. 생성자 반환 타입 주석 X
- 항상 클래스 인스턴스 타입

#### `super()`

##### 하위 클래스 <sub>(상속)</sub>
- `super()` 호출 필수 <sub>(`this.` 사용 전)</sub>
```ts
class Base {
  k = 4;
}

class Derived extends Base {
  constructor() {

    // 에러 발생
    // - Prints a wrong value in ES5; throws exception in ES6
    //   - 'super' must be called before accessing 'this' in the constructor of a derived class.
    console.log(this.k);
    super();
  }
}
```

### 메서드

##### 함수 프로퍼티
- 타입 주석 사용
  - 특수 · 전용 타입 주석 X
  - 함수 · 생성자 동일
```ts
class Point {
  x = 10;
  y = 10;

  scale(n: number): void {
    this.x *= n;
    this.y *= n;
  }
}
```

##### 필드 · 타 메서드 접근
- `this.` 필수
- `this.` 생략 시
  - 메서드 범위 내 해당 이름 검색
```ts
let x: number = 0;

class C {
  x: string = "hello";

  m() {

    // 에러 발생
    // - This is trying to modify 'x' from line 1, not the class property
    //   - Type 'string' is not assignable to type 'number'.
    x = "world";
  }
}
```

### \[G·S\]etters
```ts
class C {

  _length = 0;

  get length() {
    return this._length;
  }

  set length(value) {
    this._length = value;
  }
}
```

##### 단순 \[g·s\]etter <sub>(추가 로직 X)</sub>
- 쓸모 X
- `public` 필드 사용

#### 특별 추론 규칙 적용

##### 1. `get` 有 · `set` X
- 자동 `readonly`

##### 2. `set` 매개변수 타입 생략
- `get` 반환 타입 사용

##### 상이 타입 사용 가능 <sub>(TS 4.3)</sub>
```ts
class Thing {
  _size = 0;

  get size(): number {
    return this._size;
  }

  set size(value: string | number | boolean) {
    let num = Number(value);

    if (!Number.isFinite(num)) {
      this._size = 0;
      return;
    }

    this._size = num;
  }
}
```

### Index Signatures
```ts
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);

  check(s: string) {
    return this[s] as boolean;
  }
}
```

##### 메서드 타입 명시 필수
- 클래스 내 사용 어려움
  - 클래스 외 위치 권장

<br />

## 클래스 상속

### `implements` <sub>(절)</sub>


##### `interface` 구현 여부 체크
- 다수 구현 가능
```ts
class C implements I1, I2 { … }
```
```ts
interface Pingable {
  ping(): void;
}

interface Pongable {
  pong(): void;
}

class Sonar implements Pingable, Pongable {
  ping() {
    console.log("ping!");
  }

  pong() {
    console.log("pong!");
  }
}

/*
 에러 발생
 - interface 미구현
   - Class 'Ball' incorrectly implements interface 'Pingable'.
     - Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
 */
class Ball implements Pingable, Pongable {
  pong() {
    console.log("pong!");
  }
}
```


#### 주의점

##### 클래스 · 메서드 타입 변경 X
- 클래스 본문
  - 체크 영향 X
  - 타입 추론 영향 X
```ts
interface Checkable {
  check(name: string): boolean;
}

class NameChecker implements Checkable {

  // s (매개변수): (암시적) any (타입)
  check(s) {

    // any
    console.log(s.toLowerCase());

    // 에러 발생 X
    return s.toLowerCase() === "ok";
  }
}
```

##### optional 프로퍼티
- 해당 프로퍼티 생성 X
```ts
interface A {
  x: number;
  y?: number;
}

class C implements A {
  x = 0;
}

const c = new C();

// 에러 발생
// - Property 'y' does not exist on type 'C'.
c.y = 10;
```

### `extends` <sub>(절)</sub>

##### 클래스 상속
```ts
class Animal {
  move() {
    console.log("Moving along!");
  }
}

class Dog extends Animal {
  woof(times: number) {
    for (let i = 0; i < times; i++) {
      console.log("woof!");
    }
  }
}

const d = new Dog();

// 상위 클래스 메서드
d.move();

// 하위 클래스 메서드
d.woof(3);
```

#### 메서드 오버라이딩

##### 상위 클래스 필드 · 프로퍼티 재정의
- `super` <sub>(키워드)</sub> 사용 가능
  - 부모 클래스 메서드 접근

##### 하위 클래스
- 항상 상위 클래스 하위 타입
  - 상위 클래스 타입 준수 필수
```ts
class Base {
  greet() {
    console.log("Hello, world!");
  }
}

class Derived extends Base {
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(`Hello, ${name.toUpperCase()}`);
    }
  }
}

const d = new Derived();
d.greet();
d.greet("reader");
```

##### 상위 클래스 타입
- 하위 클래스 인스턴스 참조 가능
```ts
// 상위 클래스 타입 변수
// - 하위 클래스 인스턴스 할당
const b: Base = d;

b.greet();
```

##### 상위 클래스 타입 미준수
- 에러 발생
```ts
class Base {
  greet() {
    console.log("Hello, world!");
  }
}

class Derived extends Base {

  // 에러 발생
  // - Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
  //   - Type '(name: string) => void' is not assignable to type '() => void'.
  //     - Target signature provides too few arguments. Expected 1 or more, but got 0.
  greet(name: string) {
    console.log(`Hello, ${name.toUpperCase()}`);
  }
}
```
- 코드 컴파일 시
  - 충돌 발생
```ts
const b: Base = new Derived();

// 충돌 발생
// - name (인수)
//   - undefined
b.greet();
```

#### Type-only Field Declarations
#### 타입 전용 필드 선언

##### `target >= ES2022` · `useDefineForClassFields = true` <sub>(옵션)</sub>
- 클래스 필드 초기화
  - 부모 생성자 완료 후 실행
  - 부모 클래스 내 할당 값 덮어씀
- 상속 필드
  - 더 구체적인 타입 재선언 시 문제 발생
- `declare` <sub>(키워드)</sub>
  - 해당 선언 런타임 영향 無 설정
```ts
interface Animal {
  dateOfBirth: any;
}

interface Dog extends Animal {
  breed: any;
}

class AnimalHouse {
  resident: Animal;
  constructor(animal: Animal) {
    this.resident = animal;
  }
}

class DogHouse extends AnimalHouse {

  // JS 코드 생성 X
  // - 타입 문제 없음만 보장
  declare resident: Dog;
  constructor(dog: Dog) {
    super(dog);
  }
}
```

#### 초기화 순서
```ts
class Base {
  name = "base";

  constructor() {
    console.log("My name is " + this.name);
  }
}

class Derived extends Base {
  name = "derived";
}

const d = new Derived(); // "base"

```

##### JS 클래스 초기화 순서
1. 부모 클래스 필드
2. 부모 생성자
3. 자식 클래스 필드
4. 자식 생성자


#### 내장 타입 상속하기 <sub>(ES6 · ES2015 ↓)</sub>

Note: If you don’t plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6/ES2015 or above, you may skip this section

##### ES2015
- 객체 반환 생성자
  - `this` 값 암시적 교체
    - `this` 값 → `super(…)` 호출자
- 생성된 생성자 코드
  1. 잠재적인 `super(…)` 반환값 캡쳐
  2. `this` 값 교체
- 내장 타입 생성자 함수
  - `new.target` <sub>(ES6)</sub> 사용
    - 프로토타입 체인 조정

##### ES6 · ES2015 ↓
- 내장 타입 생성자 함수
  - `new.target` 값 보장 방법 X
- 내장 타입 상속 시
  - 정상 동작 X

##### `Error` <sub>(내장 클래스)</sub> 상속
```ts
class MsgError extends Error {
  constructor(m: string) {
    super(m);
  }

  sayHello() {
    return "hello " + this.message;
  }
}
```

##### 문제점
1. 생성된 하위 클래스 객체
    - 추가 메서드 부재 <sub>(`undefined`)</sub>
      - 호출 시 에러 발생
2. `instanceof` <sub>(연산자)</sub> 문제 발생
    - 하위 클래스 객체
    - 하위 클래스 인스턴스
```ts
// false
console.log((new MsgError()) instanceof MsgError);
```

##### 프로토타입 수동 조정
- `super(…)` 호출 직후
```ts
class MsgError extends Error {
  constructor(m: string) {
    super(m);

    // 프로토타입 명시적 설정
    Object.setPrototypeOf(this, MsgError.prototype);
  }

  sayHello() {
    return "hello " + this.message;
  }
}
```

##### `MsgError` <sub>(클래스)</sub> 하위 클래스
- 프로토타입 수동 조정 필요
- `Object.setPrototypeOf` 미지원 시
  - `__proto__` 사용

##### IE10 이하
- 프로토타입 수동 조정 <sub>(우회 방법)</sub>
  - 정상 동작 X
- 프로토타입 조정 불가능
  - 메서드 수동 복사
    - prototype → 인스턴스

<br />

## Member Visibility
You can use TypeScript to control whether certain methods or properties are visible to code outside the class.

### `public`
The default visibility of class members is `public`. A `public` member can be accessed anywhere:
```ts
class Greeter {
  public greet() {
    console.log("hi!");
  }
}
const g = new Greeter();
g.greet();
```

Because `public` is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style/readability reasons.

### `protected`
`protected` members are only visible to subclasses of the class they’re declared in.
```ts
class Greeter {
  public greet() {
    console.log("Hello, " + this.getName());
  }

  protected getName() {
    return "hi";
  }
}

class SpecialGreeter extends Greeter {
  public howdy() {
    // OK to access protected member here
    console.log("Howdy, " + this.getName());
  }
}
const g = new SpecialGreeter();
g.greet(); // OK

// Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.
g.getName();
```

#### Exposure of `protected` members
Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making `protected` members `public`:
```ts
class Base {
  protected m = 10;
}

class Derived extends Base {

  // No modifier, so default is 'public'
  m = 15;
}
const d = new Derived();
console.log(d.m); // OK
```

Note that `Derived` was already able to freely read and write `m`, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the `protected` modifier if this exposure isn’t intentional.

#### Cross-hierarchy `protected` access
Different OOP languages disagree about whether it’s legal to access a `protected` member through a base class reference:
```ts
class Base {
  protected x: number = 1;
}

class Derived1 extends Base {
  protected x: number = 5;
}

class Derived2 extends Base {

  f1(other: Derived2) {
    other.x = 10;
  }

  f2(other: Derived1) {

    // Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.
    other.x = 10;
  }
}
```

Java, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.

TypeScript sides with C# and C++ here, because accessing `x` in `Derived2` should only be legal from `Derived2`’s subclasses, and `Derived1` isn’t one of them. Moreover, if accessing `x` through a `Derived1` reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.

See also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning.

### `private`
`private` is like `protected`, but doesn’t allow access to the member even from subclasses:
```ts
class Base {
  private x = 0;
}

const b = new Base();

// Can't access from outside the class
// Property 'x' is private and only accessible within class 'Base'.
console.log(b.x);
```
```ts
class Derived extends Base {
  showX() {

    // Can't access in subclasses
    // Property 'x' is private and only accessible within class 'Base'.
    console.log(this.x);
  }
}
```

Because `private` members aren’t visible to derived classes, a derived class can’t increase their visibility:
```ts
class Base {
  private x = 0;
}

// Class 'Derived' incorrectly extends base class 'Base'.
class Derived extends Base {

  // Property 'x' is private in type 'Base' but not in type 'Derived'.
  x = 1;
}
```

#### Cross-instance `private` access
Different OOP languages disagree about whether different instances of the same class may access each others’ `private` members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.

TypeScript does allow cross-instance `private` access:
```ts
class A {
  private x = 10;

  public sameAs(other: A) {

    // No error
    return other.x === this.x;
  }
}
```

#### Caveats
Like other aspects of TypeScript’s type system, `private` and `protected` are only enforced during type checking.

This means that JavaScript runtime constructs like `in` or simple property lookup can still access a `private` or `protected` member:
```ts
class MySafe {
  private secretKey = 12345;
}
```
```ts
// In a JavaScript file...
const s = new MySafe();

// Will print 12345
console.log(s.secretKey);
```

`private` also allows access using bracket notation during type checking. This makes `private`-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy.
```ts
class MySafe {
  private secretKey = 12345;
}

const s = new MySafe();

// Not allowed during type checking
// Property 'secretKey' is private and only accessible within class 'MySafe'.
console.log(s.secretKey);

// OK
console.log(s["secretKey"]);
```

Unlike TypeScripts’s private, JavaScript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.
```ts
class Dog {
  #barkAmount = 0;
  personality = "happy";

  constructor() {}
}
```
```ts
"use strict";
class Dog {
  #barkAmount = 0;
  personality = "happy";

  constructor() { }
}
```

When compiling to ES2021 or less, TypeScript will use WeakMaps in place of `#`.
```ts
"use strict";
var _Dog_barkAmount;

class Dog {
  constructor() {
    _Dog_barkAmount.set(this, 0);
    this.personality = "happy";
  }
}

_Dog_barkAmount = new WeakMap();
```

If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.

<br />
