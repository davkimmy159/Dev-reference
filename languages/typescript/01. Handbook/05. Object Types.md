Object Types
============

##### 무기명 객체 타입
```ts
function greet(person: { name: string; age: number }) {
  return "Hello " + person.name;
}
```

##### 기명 객체 타입
- `interface`
```ts
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return "Hello " + person.name;
}
```
- 타입 별칭 <sub>(`type`)</sub>
```ts
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return "Hello " + person.name;
}
```

## Quick Reference

##### 제어 흐름 분석

![Control Flow Analysis](../images/01/05/TypeScript%20Control%20Flow%20Analysis.png)

##### 타입

![Types](../images/01/05/TypeScript%20Types.png)

##### `class`

![](../images/01/05/TypeScript%20Classes.png)

##### `interface`

![](../images/01/05/TypeScript%20Interfaces.png)

<br />

## 프로퍼티 제한자

##### 객체 내 각 프로퍼티 구성
- 타입
- optional 유무
- 수정 가능 유무

### optional 프로퍼티

##### `…?: …`
```ts
interface PaintOptions {
  shape: Shape;
  xPos?: number; // optional
  yPos?: number; // optional
}

function paintShape(opts: PaintOptions) { … }

const shape = getShape();

// 전부 유효한 호출
paintShape({ shape });
paintShape({ shape, xPos: 100 });
paintShape({ shape, yPos: 100 });
paintShape({ shape, xPos: 100, yPos: 100 });
```

##### Optional 프로퍼티 읽기
- `strictNullChecks` <sub>(옵션)</sub> 설정 시
  - `undefined` 가능성 경고 표시
```ts
function paintShape(opts: PaintOptions) {

  // PaintOptions.xPos?: number | undefined
  // let xPos: number | undefined
  let xPos = opts.xPos;

  // PaintOptions.yPos?: number | undefined
  // let yPos: number | undefined
  let yPos = opts.yPos;

  // ...
}
```

##### `undefined` 체크
```ts
function paintShape(opts: PaintOptions) {

  // let xPos: number
  let xPos = opts.xPos === undefined ? 0 : opts.xPos;

  // let yPos: number
  let yPos = opts.yPos === undefined ? 0 : opts.yPos;

  // ...
}
```

##### 매개변수 기본값 설정
- 함수 본문 내 항상 값 할당 상태
```ts
// 매개변수 구조 분해 할당 · 기본값 설정
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {

  // xPos: number
  console.log("x coordinate at", xPos);

  // yPos: number
  console.log("y coordinate at", yPos);

  // ...
}
```

<br />

##### 구조 분해 할당 내 타입 주석 X
- JS 문법 충돌
  - JS 객체 분해 변수 연결
```ts
// 객체 프로퍼티 · 변수 연결
// - shape 값 → Shape  (변수) 할당
// - xPos  값 → number (변수) 할당
function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {

  // 에러 발생
  // - Cannot find name 'shape'. Did you mean 'Shape'?
  render(shape);

  // 에러 발생
  // - Cannot find name 'xPos'.
  render(xPos);
}
```

<hr />

### `readonly` 프로퍼티

##### 타입 체크 중 수정
- 런타임 영향 X
```ts
interface SomeType {
  readonly prop: string;
}

function doSomething(obj: SomeType) {

  // 프로퍼티 읽기
  console.log(`prop has the value '${obj.prop}'.`);

  // 재할당 (수정) X
  // - 에러 발생
  //   - Cannot assign to 'prop' because it is a read-only property.
  obj.prop = "hello";
}
```

##### `readonly` 제한자
- 프로퍼티 자체에만 적용
  - 내용 수정 가능
```ts
interface Home {

  // 객체형 프로퍼티
  readonly resident: { name: string; age: number };
}

function visitForBirthday(home: Home) {

  // 객체 (home.resident) 내 프로퍼티
  // - 읽기 · 수정 가능
  console.log(`Happy birthday ${home.resident.name}!`);
  home.resident.age++;
}

function evict(home: Home) {

  /* 객체형 프로퍼티 자체
   수정 · 변경 X
   - 에러 발생
     - Cannot assign to 'resident' because it is a read-only property.
   */
  home.resident = {
    name: "Victor the Evictor",
    age: 42,
  };
}
```

##### 타입 체크
- `readonly` 고려 X
```ts
interface Person {
  name: string;
  age: number;
}

interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let writablePerson: Person = {
  name: "Person McPersonface",
  age: 42,
};

// 정상 실행
let readonlyPerson: ReadonlyPerson = writablePerson;

console.log(readonlyPerson.age); // 42
writablePerson.age++;
console.log(readonlyPerson.age); // 43
```

##### 매핑 제한자
- `readonly` <sub>(제한자)</sub> 제거 가능

### Index Signatures
```ts
interface StringArray {

  // Index Signatures 명시
  // - number (인덱스) 접근 시
  //   - 문자열 반환
  [index: number]: string;
}

const myArray: StringArray = getStringArray();

// const secondItem: string
const secondItem = myArray[1];
```

##### 일부 타입만 허용
- `string`
- `number`
- `symbol`
- 템플릿 문자열 패턴
- `union`

#### 다수 타입 지정

##### 숫자 · 문자열 <sub>(인덱스)</sub> 동시 사용
- 숫자 인덱스 타입
  - 문자열 인덱스 하위 타입 지정 필수
- 숫자 인덱스 → 문자열 <sub>(인덱싱 전 변환)</sub>
  - ex\) `100` → `"100"`
  - 일관성 필요
```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface NotOkay {

  [x: string]: Dog;

  // 에러 발생
  // - 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
  [x: number]: Animal;

}
```

##### 문자열 index signatures
- 사전 패턴 유용
- 모든 프로퍼티 타입 제한
  - `obj.property` == `obj["property"]`
```ts
interface NumberDictionary {

  // 모든 프로퍼티 타입 제한
  // - 숫자형
  [index: string]: number;

  length: number;

  // 에러 발생
  // - Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
  name: string;
}
```
- `union` <sub>(타입)</sub>
  - 타입 제한 X
```ts
interface NumberOrString {
  [index: string]: number | string;

  // NumberOrString.length: number
  length: number;

  // NumberOrString.name: string
  name: string;
}
```

##### `readonly` index signatures
```ts
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = getReadOnlyStringArray();

// 에러 발생
// - 할당 불가
//   - Index signature in type 'ReadonlyStringArray' only permits reading.
myArray[2] = "Mallory";
```

<br />

## 잉여 프로퍼티 체크

##### 객체 타입 할당 위치 · 방법
- 타입 시스템 내 차이점 생성
  - ex\) 잉여 프로퍼티 체크 등

##### 잉여 프로퍼티 체크
- 객체 생성 · 타입 할당 시
  - 더 철저히 객체 검증
```ts
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  return {
    color: config.color || "red",
    area: config.width ? config.width * config.width : 20,
  };
}

// 에러 발생 (오타)
// - Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

##### 객체 리터럴
- 타 변수 할당 · 인수 전달 시
  - 잉여 프로퍼티 체크 작동
- 타겟 타입 외 프로퍼티 보유 시
  - 에러 발생
```ts
// 에러 발생
// - colour (잉여 프로퍼티)
//   - Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

#### 해결 방법

##### 1. 타입 주장 <sub>(Type Assertion)</sub>
```ts
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

##### 2. 문자열 index signature 추가
- 객체 내 추가 프로퍼티
  - 문제 없는 경우
```ts
interface SquareConfig {
  color?: string;
  width?: number;

  // 추가 프로퍼티
  // - colour
  // - 기타 등등
  [propName: string]: any;
}
```

##### 3. 타 변수 할당
- 객체 리터럴 X
  - 잉여 프로퍼티 체크 X
```ts
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```
- 공통 프로퍼티 필요
```ts
let squareOptions = { colour: "red" };

// 에러 발생
// - 공통 프로퍼티 X
//   - Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.
let mySquare = createSquare(squareOptions);
```

##### 대다수 잉여 프로퍼티 체크 에러
- 실제 버그 가능성 ↑
  - 타입 선언 수정 필요
- 위 예시
  - 타입 내 `colour` <sub>(프로퍼티)</sub> 추가
```ts
interface SquareConfig {
  color?: string;
  colour?: string;
  width?: number;
}
```

<br />

## 타입 확장

##### 개발 중 흔한 타입 정의 상황
- 더 구체적인 하위 타입
  - 기존 상위 타입 대비

##### `BasicAddress` <sub>(타입)</sub>
- 필요 프로퍼티 명시
  - 편지 보내기
  - 소포 보내기
```ts
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}
```

##### `AddressWithUnit` <sub>(타입)</sub>
- 해당 주소지 내 다수 unit 존재 시
  - unit 숫자 <sub>(추가 주소 정보)</sub> 필요
```ts
interface AddressWithUnit {
  name?: string;
  unit: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}
```

##### 문제점
- 단순 정보 추가
  - 다수 중복 정보 반복

##### 기존 타입 확장 <sub>(상속)</sub>
```ts
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}

interface AddressWithUnit extends BasicAddress {
  unit: string;
}
```

#### `interface` 내 `extends` <sub>(키워드)</sub>

##### 기능
- 타 기명 타입 멤버 효과적으로 복사
  - 새 멤버 추가 가능

##### 장점
- 유사 타입 선언 코드량 ↓
- 정보 연관 가능성 의도 전달
  - 다수 타 선언 내 동일 프로퍼티

##### ex\) `street` <sub>(프로퍼티)</sub>
- 반복 명시 X
- `BasicAddress` <sub>(타입)</sub> 유래
  - 두 타입 연관 관계 의미
    - `BasicAddress`
    - `AddressWithUnit`

##### `interface` 다수 확장
```ts
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

interface ColorfulCircle extends Colorful, Circle {}

const cc: ColorfulCircle = {
  color: "red",
  radius: 42,
};
```

<br />

## 교차 타입

- 기존 객체 타입 결합

##### 교차 타입 정의
- `&` <sub>(연산자)</sub>
```ts
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

type ColorfulCircle = Colorful & Circle;
```

##### 기존 타입 결합 → 새 타입 정의
- `Colorful & Circle`
  - 두 타입 내 모든 멤법 보유
```ts
function draw(circle: Colorful & Circle) {
  console.log(`Color was ${circle.color}`);
  console.log(`Radius was ${circle.radius}`);
}

draw({ color: "blue", radius: 42 });

/*
 객체 리터럴
 - 잉여 프로퍼티 체크 (raidus)
 에러 발생
 - Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?
 */
draw({ color: "red", raidus: 42 });
```

<br />

## `interface`s vs 교차 타입

##### `interface`s
- `extends` <sub>(키워드)</sub>
- 타 타입 확장

##### 교차 타입
- `&` <sub>(연산자)</sub>
- 타입 결합
  - 새 타입 별칭 저장

##### 차이점 <sub>(선택 기준)</sub>
- 타입 충돌 관리

<br />
