Object Types
============

##### 무기명 객체 타입
```ts
function greet(person: { name: string; age: number }) {
  return "Hello " + person.name;
}
```

##### 기명 객체 타입
- `interface`
```ts
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return "Hello " + person.name;
}
```
- 타입 별칭 <sub>(`type`)</sub>
```ts
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return "Hello " + person.name;
}
```

## Quick Reference

##### 제어 흐름 분석

![Control Flow Analysis](../images/01/05/TypeScript%20Control%20Flow%20Analysis.png)

##### 타입

![Types](../images/01/05/TypeScript%20Types.png)

##### `class`

![](../images/01/05/TypeScript%20Classes.png)

##### `interface`

![](../images/01/05/TypeScript%20Interfaces.png)

<br />

## 프로퍼티 제한자

##### 객체 내 각 프로퍼티 구성
- 타입
- optional 유무
- 수정 가능 유무

### optional 프로퍼티

##### `…?: …`
```ts
interface PaintOptions {
  shape: Shape;
  xPos?: number; // optional
  yPos?: number; // optional
}

function paintShape(opts: PaintOptions) { … }

const shape = getShape();

// 전부 유효한 호출
paintShape({ shape });
paintShape({ shape, xPos: 100 });
paintShape({ shape, yPos: 100 });
paintShape({ shape, xPos: 100, yPos: 100 });
```

##### Optional 프로퍼티 읽기
- `strictNullChecks` <sub>(옵션)</sub> 설정 시
  - `undefined` 가능성 경고 표시
```ts
function paintShape(opts: PaintOptions) {

  // PaintOptions.xPos?: number | undefined
  // let xPos: number | undefined
  let xPos = opts.xPos;

  // PaintOptions.yPos?: number | undefined
  // let yPos: number | undefined
  let yPos = opts.yPos;

  // ...
}
```

##### `undefined` 체크
```ts
function paintShape(opts: PaintOptions) {

  // let xPos: number
  let xPos = opts.xPos === undefined ? 0 : opts.xPos;

  // let yPos: number
  let yPos = opts.yPos === undefined ? 0 : opts.yPos;

  // ...
}
```

##### 매개변수 기본값 설정
- 함수 본문 내 항상 값 할당 상태
```ts
// 매개변수 구조 분해 할당 · 기본값 설정
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {

  // xPos: number
  console.log("x coordinate at", xPos);

  // yPos: number
  console.log("y coordinate at", yPos);

  // ...
}
```

<br />

##### 구조 분해 할당 내 타입 주석 X
- JS 문법 충돌
  - JS 객체 분해 변수 연결
```ts
// 객체 프로퍼티 · 변수 연결
// - shape 값 → Shape  (변수) 할당
// - xPos  값 → number (변수) 할당
function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {

  // 에러 발생
  // - Cannot find name 'shape'. Did you mean 'Shape'?
  render(shape);

  // 에러 발생
  // - Cannot find name 'xPos'.
  render(xPos);
}
```

<hr />

### `readonly` 프로퍼티

##### 타입 체크 중 수정
- 런타임 영향 X
```ts
interface SomeType {
  readonly prop: string;
}

function doSomething(obj: SomeType) {

  // 프로퍼티 읽기
  console.log(`prop has the value '${obj.prop}'.`);

  // 재할당 (수정) X
  // - 에러 발생
  //   - Cannot assign to 'prop' because it is a read-only property.
  obj.prop = "hello";
}
```

##### `readonly` 제한자
- 프로퍼티 자체에만 적용
  - 내용 수정 가능
```ts
interface Home {

  // 객체형 프로퍼티
  readonly resident: { name: string; age: number };
}

function visitForBirthday(home: Home) {

  // 객체 (home.resident) 내 프로퍼티
  // - 읽기 · 수정 가능
  console.log(`Happy birthday ${home.resident.name}!`);
  home.resident.age++;
}

function evict(home: Home) {

  /* 객체형 프로퍼티 자체
   수정 · 변경 X
   - 에러 발생
     - Cannot assign to 'resident' because it is a read-only property.
   */
  home.resident = {
    name: "Victor the Evictor",
    age: 42,
  };
}
```

##### 타입 체크
- `readonly` 고려 X
```ts
interface Person {
  name: string;
  age: number;
}

interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let writablePerson: Person = {
  name: "Person McPersonface",
  age: 42,
};

// 정상 실행
let readonlyPerson: ReadonlyPerson = writablePerson;

console.log(readonlyPerson.age); // 42
writablePerson.age++;
console.log(readonlyPerson.age); // 43
```

##### 매핑 제한자
- `readonly` <sub>(제한자)</sub> 제거 가능

### Index Signatures
```ts
interface StringArray {

  // Index Signatures 명시
  // - number (인덱스) 접근 시
  //   - 문자열 반환
  [index: number]: string;
}

const myArray: StringArray = getStringArray();

// const secondItem: string
const secondItem = myArray[1];
```

##### 일부 타입만 허용
- `string`
- `number`
- `symbol`
- 템플릿 문자열 패턴
- `union`

#### 다수 타입 지정

##### 숫자 · 문자열 <sub>(인덱스)</sub> 동시 사용
- 숫자 인덱스 타입
  - 문자열 인덱스 하위 타입 지정 필수
- 숫자 인덱스 → 문자열 <sub>(인덱싱 전 변환)</sub>
  - ex\) `100` → `"100"`
  - 일관성 필요
```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface NotOkay {

  [x: string]: Dog;

  // 에러 발생
  // - 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.
  [x: number]: Animal;

}
```

##### 문자열 index signatures
- 사전 패턴 유용
- 모든 프로퍼티 타입 제한
  - `obj.property` == `obj["property"]`
```ts
interface NumberDictionary {

  // 모든 프로퍼티 타입 제한
  // - 숫자형
  [index: string]: number;

  length: number;

  // 에러 발생
  // - Property 'name' of type 'string' is not assignable to 'string' index type 'number'.
  name: string;
}
```
- `union` 타입
  - 타입 제한 X
```ts
interface NumberOrString {
  [index: string]: number | string;

  // NumberOrString.length: number
  length: number;

  // NumberOrString.name: string
  name: string;
}
```

##### `readonly` index signatures
```ts
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = getReadOnlyStringArray();

// 에러 발생
// - 할당 불가
//   - Index signature in type 'ReadonlyStringArray' only permits reading.
myArray[2] = "Mallory";
```

<br />

## 잉여 프로퍼티 체크

##### 객체 타입 할당 위치 · 방법
- 타입 시스템 내 차이점 생성
  - ex\) 잉여 프로퍼티 체크 등

##### 잉여 프로퍼티 체크
- 객체 생성 · 타입 할당 시
  - 더 철저히 객체 검증
```ts
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  return {
    color: config.color || "red",
    area: config.width ? config.width * config.width : 20,
  };
}

// 에러 발생 (오타)
// - Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

##### 객체 리터럴
- 타 변수 할당 · 인수 전달 시
  - 잉여 프로퍼티 체크 작동
- 타겟 타입 외 프로퍼티 보유 시
  - 에러 발생
```ts
// 에러 발생
// - colour (잉여 프로퍼티)
//   - Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

#### 해결 방법

##### 1. 타입 주장 <sub>(Type Assertion)</sub>
```ts
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

##### 2. 문자열 index signature 추가
- 객체 내 추가 프로퍼티
  - 문제 없는 경우
```ts
interface SquareConfig {
  color?: string;
  width?: number;

  // 추가 프로퍼티
  // - colour
  // - 기타 등등
  [propName: string]: any;
}
```

##### 3. 타 변수 할당
- 객체 리터럴 X
  - 잉여 프로퍼티 체크 X
```ts
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```
- 공통 프로퍼티 필요
```ts
let squareOptions = { colour: "red" };

// 에러 발생
// - 공통 프로퍼티 X
//   - Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.
let mySquare = createSquare(squareOptions);
```

##### 대다수 잉여 프로퍼티 체크 에러
- 실제 버그 가능성 ↑
  - 타입 선언 수정 필요
- `colour` <sub>(예시 프로퍼티)</sub>
  - 타입 내 추가
```ts
interface SquareConfig {
  color?: string;
  colour?: string;
  width?: number;
}
```

<br />

## 타입 확장
It’s pretty common to have types that might be more specific versions of other types. For example, we might have a `BasicAddress` type that describes the fields necessary for sending letters and packages in the U.S.
```ts
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}
```

In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an `AddressWithUnit`.
```ts
interface AddressWithUnit {
  name?: string;
  unit: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}
```

This does the job, but the downside here is that we had to repeat all the other fields from `BasicAddress` when our changes were purely additive. Instead, we can extend the original `BasicAddress` type and just add the new fields that are unique to `AddressWithUnit`.
```ts
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}

interface AddressWithUnit extends BasicAddress {
  unit: string;
}
```

The `extends` keyword on an `interface` allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, `AddressWithUnit` didn’t need to repeat the `street` property, and because `street` originates from `BasicAddress`, a reader will know that those two types are related in some way.

`interfaces` can also extend from multiple types.
```ts
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

interface ColorfulCircle extends Colorful, Circle {}

const cc: ColorfulCircle = {
  color: "red",
  radius: 42,
};
```

<br />

## Intersection Types
`interface`s allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.

An intersection type is defined using the `&` operator.
```ts
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

type ColorfulCircle = Colorful & Circle;
```

Here, we’ve intersected `Colorful` and `Circle` to produce a new type that has all the members of `Colorful` and `Circle`.
```ts
function draw(circle: Colorful & Circle) {
  console.log(`Color was ${circle.color}`);
  console.log(`Radius was ${circle.radius}`);
}

// okay
draw({ color: "blue", radius: 42 });

// oops
// Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?
draw({ color: "red", raidus: 42 });
```

<br />

## Interfaces vs Intersections
We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an `extends` clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.

<br />

## Generic Object Types
Let’s imagine a `Box` type that can contain any value - `string`s, `number`s, `Giraffe`s, whatever.
```ts
interface Box {
  contents: any;
}
```

Right now, the `contents` property is typed as `any`, which works, but can lead to accidents down the line.

We could instead use `unknown`, but that would mean that in cases where we already know the type of `contents`, we’d need to do precautionary checks, or use error-prone type assertions.
```ts
interface Box {
  contents: unknown;
}

let x: Box = {
  contents: "hello world",
};

// we could check 'x.contents'
if (typeof x.contents === "string") {
  console.log(x.contents.toLowerCase());
}

// or we could use a type assertion
console.log((x.contents as string).toLowerCase());
```

One type safe approach would be to instead scaffold out different `Box` types for every type of `contents`.
```ts
interface NumberBox {
  contents: number;
}

interface StringBox {
  contents: string;
}

interface BooleanBox {
  contents: boolean;
}
```

But that means we’ll have to create different functions, or overloads of functions, to operate on these types.
```ts
function setContents(box: StringBox, newContents: string): void;
function setContents(box: NumberBox, newContents: number): void;
function setContents(box: BooleanBox, newContents: boolean): void;
function setContents(box: { contents: any }, newContents: any) {
  box.contents = newContents;
}
```

That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.

Instead, we can make a generic `Box` type which declares a type parameter.
```ts
interface Box<Type> {
  contents: Type;
}
```

You might read this as “A `Box` of `Type` is something whose `contents` have type `Type`”. Later on, when we refer to `Box`, we have to give a type argument in place of `Type`.
```ts
let box: Box<string>;
```

Think of `Box` as a template for a real type, where `Type` is a placeholder that will get replaced with some other type. When TypeScript sees `Box<string>`, it will replace every instance of `Type` in `Box<Type>` with `string`, and end up working with something like `{ contents: string }`. In other words, `Box<string>` and our earlier `StringBox` work identically.
```ts
interface Box<Type> {
  contents: Type;
}

interface StringBox {
  contents: string;
}

// boxA.contents
// - Box<string>.contents: string
let boxA: Box<string> = { contents: "hello" };

// boxB.contents
// - StringBox.contents: string
let boxB: StringBox = { contents: "world" };
```

`Box` is reusable in that `Type` can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new `Box` type at all (though we certainly could if we wanted to).
```ts
interface Box<Type> {
  contents: Type;
}

interface Apple {
  // ....
}

// Same as '{ contents: Apple }'.
type AppleBox = Box<Apple>;
```

This also means that we can avoid overloads entirely by instead using generic functions.
```ts
function setContents<Type>(box: Box<Type>, newContents: Type) {
  box.contents = newContents;
}
```

It is worth noting that type aliases can also be generic. We could have defined our new `Box<Type>` interface, which was:
```ts
interface Box<Type> {
  contents: Type;
}
```

by using a type alias instead:
```ts
type Box<Type> = {
  contents: Type;
};
```

Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.
```ts
type OrNull<Type> = Type | null;

type OneOrMany<Type> = Type | Type[];

// type OneOrManyOrNull<Type> = OneOrMany<Type> | null
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;

// type OneOrManyOrNullStrings = OneOrMany<string> | null
type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
```

We’ll circle back to type aliases in just a little bit.

### `Array` Type
Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.

It turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.
```ts
function doSomething(value: Array<string>) {
  // ...
}

let myArray: string[] = ["hello", "world"];

// either of these work!
doSomething(myArray);
doSomething(new Array("hello", "world"));
```

Much like the `Box` type above, `Array` itself is a generic type.
```ts
// Global type 'Array' must have 1 type parameter(s).
// All declarations of 'Array' must have identical type parameters.
interface Array<Type> {

  /**
   * Gets or sets the length of the array.
   */
  length: number;

  /**
   * Removes the last element from an array and returns it.
   */
  pop(): Type | undefined;

  /**
   * Appends new elements to an array, and returns the new length of the array.
   */
  // A rest parameter must be of an array type.
  push(...items: Type[]): number;

  // ...
}
```

Modern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.

### `ReadonlyArray` Type
The `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.
```ts
function doStuff(values: ReadonlyArray<string>) {

  // We can read from 'values'...
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // ...but we can't mutate 'values'.
  // Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

Much like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.

Unlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.
```ts
// 'ReadonlyArray' only refers to a type, but is being used as a value here.
new ReadonlyArray("red", "green", "blue");
```

Instead, we can assign regular `Array`s to `ReadonlyArray`s.
```ts
const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
```

Just as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.
```ts
function doStuff(values: readonly string[]) {

  // We can read from 'values'...
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // ...but we can't mutate 'values'.
  // Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

One last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.
```ts
let x: readonly string[] = [];
let y: string[] = [];

x = y;

// The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
y = x;
```

### Tuple Types
A tuple type is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.
```ts
type StringNumberPair = [string, number];
```

Here, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.
```ts
function doSomething(pair: [string, number]) {

  // const a: string
  const a = pair[0];

  // const b: number
  const b = pair[1];

  // ...
}

doSomething(["hello", 42]);
```

If we try to index past the number of elements, we’ll get an error.
```ts
function doSomething(pair: [string, number]) {
  // ...

  // Tuple type '[string, number]' of length '2' has no element at index '2'.
  const c = pair[2];
}
```

We can also destructure tuples using JavaScript’s array destructuring.
```ts
function doSomething(stringHash: [string, number]) {
  const [inputString, hash] = stringHash;

  // const inputString: string
  console.log(inputString);

  // const hash: number
  console.log(hash);
}
```

<br />

<hr />

Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.

However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.

<hr />

Other than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.
```ts
interface StringNumberPair {

  // specialized properties
  length: 2;
  0: string;
  1: number;

  // Other 'Array<string | number>' members...
  slice(start?: number, end?: number): Array<string | number>;
}
```

Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.
```ts
type Either2dOr3d = [number, number, number?];

function setCoordinate(coord: Either2dOr3d) {

  // const z: number | undefined
  const [x, y, z] = coord;

  // length: 2 | 3
  console.log(`Provided coordinates had ${coord.length} dimensions`);
}
```

Tuples can also have rest elements, which have to be an array/tuple type.
```ts
type StringNumberBooleans = [string, number, ...boolean[]];
type StringBooleansNumber = [string, ...boolean[], number];
type BooleansStringNumber = [...boolean[], string, number];
```

##### `StringNumberBooleans`
- describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.

##### `StringBooleansNumber`
- describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.

##### `BooleansStringNumber`
- describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.

A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.
```ts
const a: StringNumberBooleans = ["hello", 1];
const b: StringNumberBooleans = ["beautiful", 2, true];
const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
```

Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:
```ts
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  // ...
}
```

is basically equivalent to:
```ts
function readButtonInput(name: string, version: number, ...input: boolean[]) {
  // ...
}
```

This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.

### `readonly` Tuple Types
One final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.
```ts
function doSomething(pair: readonly [string, number]) {
  // ...
}
```

As you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.
```ts
function doSomething(pair: readonly [string, number]) {

  // Cannot assign to '0' because it is a read-only property.
  pair[0] = "hello!";
}
```

Tuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.
```ts
let point = [3, 4] as const;

function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

// Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
// The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.
distanceFromOrigin(point);
```

Here, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.

<br />

## 요약

객체의 속성과 함수
다음 예제는 객체의 함수다.
```ts
const math = {
  sum(a: number, b: number): number {
    return a + b;
  },
};
```

다음은 속성이 함수 표현식인 예제다.
```ts
const math = {
  sum: function sum(a: number, b: number): number {
    return a + b;
  },
};
```

속성이 (리턴을 생략한) 화살표 함수인 예제다.
```ts
const math = {
  sum: (a: number, b: number): number => a + b,
};
```

아쉽지만, 함수 스스로를 정의할 수 없는 타입을 작성하기 위해서는 객체로 감싸는 형태로 타입을 정의해야 한다. 객체 리터럴 안에 정의될 때는 속성의 함수 타입을 스스로 지정할 수 없다.
```ts
type MathFn = (a: number, b: number) => number;

const math: { sum: MathFn } = {
  sum: (a, b) => a + b,
};
```

심지어, 앞선 예제처럼 타입에 속성을 추가하려고 한다면 객체 리터럴 안에서는 불가능하다. 함수 선언을 완전하게 타입 정의해야 한다.
```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};
const sum: MathFn = (a, b) => a + b;
sum.operator = '+';

const math = { sum };
```

이 예제는 const math = {sum}에 더하기만 추가한 앞선 예제와 같다는 것을 눈치챘을 것이다. 그렇다, 객체 선언에서 이 모든 것을 인라인화할 수 있는 방법은 없다.
