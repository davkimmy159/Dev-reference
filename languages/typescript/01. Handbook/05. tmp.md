## 제네릭 객체 타입

##### `Box` <sub>(타입)</sub>
- 모든 타입 값 저장
  - `string` <sub>(문자열)</sub>
  - `number` <sub>(숫자)</sub>
  - `Giraffe`
  - 기타 등등
```ts
interface Box {
  contents: any;
}
```

##### `any` <sub>(타입)</sub>
- 타입 불안전성 ↑

##### `unknown` <sub>(타입)</sub>
- 항상 사전 타입 체크 필요
- 불안전한 타입 주장 <sub>(type assertions)</sub> 필요
  - 에러 발생률 ↑
```ts
interface Box {
  contents: unknown;
}

let x: Box = {
  contents: "hello world",
};

// 사전 타입 체크
if (typeof x.contents === "string") {
  console.log(x.contents.toLowerCase());
}

// 타입 주장 (type assertion)
console.log((x.contents as string).toLowerCase());
```

##### 한 가지 해결 방법 <sub>(타입 안전)</sub>
- 종류별 타입 선언
```ts
interface NumberBox {
  contents: number;
}

interface StringBox {
  contents: string;
}

interface BooleanBox {
  contents: boolean;
}
```

##### 종류별 함수 (오버로드) 구현 필요
- 반복적인 코드량 ↑
- 추후 새 타입 · 함수 오버로드 추가 가능
  - 반복적인 코드량 ↑↑

```ts
function setContents(box: StringBox, newContents: string): void;
function setContents(box: NumberBox, newContents: number): void;
function setContents(box: BooleanBox, newContents: boolean): void;
function setContents(box: { contents: any }, newContents: any) {
  box.contents = newContents;
}
```

##### 제네릭 `Box` <sub>(타입)</sub>
- 타입 매개변수 선언 <sub>(`Type`)</sub>
```ts
interface Box<Type> {
  contents: Type;
}
```

##### 제네릭 타입 이용 시
- 타입 매개변수 전달
```ts
let box: Box<string>;
```

##### `Box` <sub>(타입)</sub>
- 실제 타입 템플릿

##### `Type` <sub>(타입 매개변수)</sub>
- placeholder
  - 추후 타 타입 대체

##### `Box<string>`
- `Type` <sub>(타입 매개변수)</sub>
  - `string`
- `{ contents: Type }`
  - `{ contents: string }`

##### `Box<string>` == `StringBox`
```ts
interface Box<Type> {
  contents: Type;
}

interface StringBox {
  contents: string;
}

// boxA.contents
// - Box<string>.contents: string
let boxA: Box<string> = { contents: "hello" };

// boxB.contents
// - StringBox.contents: string
let boxB: StringBox = { contents: "world" };
```

##### 제네릭 `Box` <sub>(타입)</sub>
- `Type` <sub>(타입 매개변수)</sub> 대체
  - 재사용 가능
  - 새 타입 사용 가능
```ts
interface Box<Type> {
  contents: Type;
}

interface Apple { … }

// { contents: Apple }
type AppleBox = Box<Apple>;
```

##### 제네릭 함수
- 함수 오버로드 불필요
```ts
function setContents<Type>(box: Box<Type>, newContents: Type) {
  box.contents = newContents;
}
```

##### 제네릭 타입 별칭
```ts
interface Box<Type> {
  contents: Type;
}

↓↓↓

type Box<Type> = {
  contents: Type;
};
```

##### 객체 타입 외 다수 타입 정의 가능 <sub>(`interface` X)</sub>
- 제네릭 헬퍼 타입 정의
```ts
type OrNull<Type> = Type | null;

type OneOrMany<Type> = Type | Type[];

// OneOrMany<Type> | null
// Type | Type[] | null
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;

// OneOrMany<string> | null
// string | string[] | null
type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
```

### `Array` <sub>(배열 타입)</sub>

##### 제네릭 객체 타입
- 컨테이너 타입 역할
  - 내부 요소 타입 연관 X
- 데이터 구조 적합
  - 다수 데이터 타입 대상 재사용

##### 배열 타입
- `number[]`
  - `Array<number>` 축약
- `string[]`
  - `Array<string>` 축약
```ts
function doSomething(value: Array<string>) { … }

let myArray: string[] = ["hello", "world"];

doSomething(myArray);
doSomething(new Array("hello", "world"));
```

##### `Array` <sub>(타입)</sub> 자체 → 제네릭 타입
```ts
/*
 Array (전역 타입)
 - 타입 매개변수 1개 필수
 모든 Array 선언
 - 동일 타입 매개변수 보유 필수
 */
interface Array<Type> {

  // 배열 길이
  length: number;

  // 끝 요소 제거 후 반환
  pop(): Type | undefined;

  /*
   끝에 새 요소 추가
   - 갱신된 배열 길이 반환
   나머지 매개변수
   - 배열 (타입)
   */
  push(...items: Type[]): number;

  …
}
```

##### 모던 JS
- 다양한 제네릭 데이터 구조 제공
  - `Map<K, V>`
  - `Set<T>`
  - `Promise<T>`
  - 기타 등등

### `ReadonlyArray` <sub>(특수 타입)</sub>

##### 변경 불가 배열 <sub>(타입)</sub>
```ts
function doStuff(values: ReadonlyArray<string>) {

  // 읽기
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // 수정 X
  // - 에러 발생
  //   - Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

##### 명확한 의도 전달
- `ReadonlyArray` 반환 함수
  - 배열 내용 변경 금지
- `ReadonlyArray` 인수 함수
  - 함수 내 배열 내용 변경 걱정 X

##### `ReadonlyArray` 생성자 X
```ts
// 'ReadonlyArray' only refers to a type, but is being used as a value here.
new ReadonlyArray("red", "green", "blue");
```

##### 일반 배열 할당
```ts
const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
```

##### `readonly Type[]`
- `ReadonlyArray<Type>` 축약
```ts
function doStuff(values: readonly string[]) {

  // 읽기
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // 수정 X
  // - 에러 발생
  //   - Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

##### 할당 가능성 <sub>(assignability)</sub>
- 양방향 X
  - `Array` → `ReadonlyArray`
  - `Array` ↚ `ReadonlyArray`
```ts
let x: readonly string[] = [];
let y: string[] = [];

// Array → ReadonlyArray
x = y;

// Array ↚ ReadonlyArray
// - 에러 발생
//   - The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
y = x;
```

### `tuple` <sub>(타입)</sub>

##### 배열 일종
- 배열 내 요소 개수 인지
- 특정 위치 요소 타입 인지

##### `StringNumberPair` <sub>(타입)</sub>
```ts
type StringNumberPair = [string, number];
```
- `tuple` 타입
  - `string`
  - `number`
- 런타임
  - 실체 X
- 타입 시스템
  - `StringNumberPair[0]`
    - `string`
  - `StringNumberPair[1]`
    - `number`
```ts
function doSomething(pair: [string, number]) {

  // const a: string
  const a = pair[0];

  // const b: number
  const b = pair[1];

  …
}

doSomething(["hello", 42]);
```

##### 범위 초과 접근 시 에러 발생
```ts
function doSomething(pair: [string, number]) {
  …

  // 에러 발생
  // - Tuple type '[string, number]' of length '2' has no element at index '2'.
  const c = pair[2];
}
```

##### 배열 구조 분해 할당 적용
```ts
function doSomething(stringHash: [string, number]) {
  const [inputString, hash] = stringHash;

  // const inputString: string
  console.log(inputString);

  // const hash: number
  console.log(hash);
}
```

<br />

##### 유용한 상황
- 각 요소 의미 명확
  - 원하는 변수명 사용 가능 <sub>(구조 분해 할당)</sub>
- ex\)
  - `stringHash[0]` <sub>(`tuple` 타입)</sub>
    - `inputString`
  - `stringHash[1]` <sub>(`tuple` 타입)</sub>
    - `hash`
- 상황 따라 사용
  - `tuple` 타입
  - 객체 <sub>(추가 프로퍼티 有)</sub>

Other than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.
```ts
interface StringNumberPair {

  // specialized properties
  length: 2;
  0: string;
  1: number;

  // Other 'Array<string | number>' members...
  slice(start?: number, end?: number): Array<string | number>;
}
```

Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.
```ts
type Either2dOr3d = [number, number, number?];

function setCoordinate(coord: Either2dOr3d) {

  // const z: number | undefined
  const [x, y, z] = coord;

  // length: 2 | 3
  console.log(`Provided coordinates had ${coord.length} dimensions`);
}
```

Tuples can also have rest elements, which have to be an array/tuple type.
```ts
type StringNumberBooleans = [string, number, ...boolean[]];
type StringBooleansNumber = [string, ...boolean[], number];
type BooleansStringNumber = [...boolean[], string, number];
```

##### `StringNumberBooleans`
- describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.

##### `StringBooleansNumber`
- describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.

##### `BooleansStringNumber`
- describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.

A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.
```ts
const a: StringNumberBooleans = ["hello", 1];
const b: StringNumberBooleans = ["beautiful", 2, true];
const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
```

Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:
```ts
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  // ...
}
```

is basically equivalent to:
```ts
function readButtonInput(name: string, version: number, ...input: boolean[]) {
  // ...
}
```

This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.

### `readonly` Tuple Types
One final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.
```ts
function doSomething(pair: readonly [string, number]) {
  // ...
}
```

As you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.
```ts
function doSomething(pair: readonly [string, number]) {

  // Cannot assign to '0' because it is a read-only property.
  pair[0] = "hello!";
}
```

Tuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.
```ts
let point = [3, 4] as const;

function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

// Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
// The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.
distanceFromOrigin(point);
```

Here, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.

<br />

## 요약

객체의 속성과 함수
다음 예제는 객체의 함수다.
```ts
const math = {
  sum(a: number, b: number): number {
    return a + b;
  },
};
```

다음은 속성이 함수 표현식인 예제다.
```ts
const math = {
  sum: function sum(a: number, b: number): number {
    return a + b;
  },
};
```

속성이 (리턴을 생략한) 화살표 함수인 예제다.
```ts
const math = {
  sum: (a: number, b: number): number => a + b,
};
```

아쉽지만, 함수 스스로를 정의할 수 없는 타입을 작성하기 위해서는 객체로 감싸는 형태로 타입을 정의해야 한다. 객체 리터럴 안에 정의될 때는 속성의 함수 타입을 스스로 지정할 수 없다.
```ts
type MathFn = (a: number, b: number) => number;

const math: { sum: MathFn } = {
  sum: (a, b) => a + b,
};
```

심지어, 앞선 예제처럼 타입에 속성을 추가하려고 한다면 객체 리터럴 안에서는 불가능하다. 함수 선언을 완전하게 타입 정의해야 한다.
```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};
const sum: MathFn = (a, b) => a + b;
sum.operator = '+';

const math = { sum };
```

이 예제는 const math = {sum}에 더하기만 추가한 앞선 예제와 같다는 것을 눈치챘을 것이다. 그렇다, 객체 선언에서 이 모든 것을 인라인화할 수 있는 방법은 없다.
