## 제네릭 객체 타입

##### `Box` <sub>(타입)</sub>
- 모든 타입 값 저장
  - `string` <sub>(문자열)</sub>
  - `number` <sub>(숫자)</sub>
  - `Giraffe`
  - 기타 등등
```ts
interface Box {
  contents: any;
}
```

##### `any` <sub>(타입)</sub>
- 타입 불안전성 ↑

##### `unknown` <sub>(타입)</sub>
- 항상 사전 타입 체크 필요
- 불안전한 타입 주장 <sub>(type assertions)</sub> 필요
  - 에러 발생률 ↑
```ts
interface Box {
  contents: unknown;
}

let x: Box = {
  contents: "hello world",
};

// 사전 타입 체크
if (typeof x.contents === "string") {
  console.log(x.contents.toLowerCase());
}

// 타입 주장 (type assertion)
console.log((x.contents as string).toLowerCase());
```

##### 한 가지 해결 방법 <sub>(타입 안전)</sub>
- 종류별 타입 선언
```ts
interface NumberBox {
  contents: number;
}

interface StringBox {
  contents: string;
}

interface BooleanBox {
  contents: boolean;
}
```

##### 종류별 함수 (오버로드) 구현 필요
- 반복적인 코드량 ↑
- 추후 새 타입 · 함수 오버로드 추가 가능
  - 반복적인 코드량 ↑↑

```ts
function setContents(box: StringBox, newContents: string): void;
function setContents(box: NumberBox, newContents: number): void;
function setContents(box: BooleanBox, newContents: boolean): void;
function setContents(box: { contents: any }, newContents: any) {
  box.contents = newContents;
}
```

##### 제네릭 `Box` <sub>(타입)</sub>
- 타입 매개변수 선언 <sub>(`Type`)</sub>
```ts
interface Box<Type> {
  contents: Type;
}
```

##### 제네릭 타입 이용 시
- 타입 매개변수 전달
```ts
let box: Box<string>;
```

##### `Box` <sub>(타입)</sub>
- 실제 타입 템플릿

##### `Type` <sub>(타입 매개변수)</sub>
- placeholder
  - 추후 타 타입 대체

##### `Box<string>`
- `Type` <sub>(타입 매개변수)</sub>
  - `string`
- `{ contents: Type }`
  - `{ contents: string }`

##### `Box<string>` == `StringBox`
```ts
interface Box<Type> {
  contents: Type;
}

interface StringBox {
  contents: string;
}

// boxA.contents
// - Box<string>.contents: string
let boxA: Box<string> = { contents: "hello" };

// boxB.contents
// - StringBox.contents: string
let boxB: StringBox = { contents: "world" };
```

##### 제네릭 `Box` <sub>(타입)</sub>
- `Type` <sub>(타입 매개변수)</sub> 대체
  - 재사용 가능
  - 새 타입 사용 가능
```ts
interface Box<Type> {
  contents: Type;
}

interface Apple { … }

// { contents: Apple }
type AppleBox = Box<Apple>;
```

##### 제네릭 함수
- 함수 오버로드 불필요
```ts
function setContents<Type>(box: Box<Type>, newContents: Type) {
  box.contents = newContents;
}
```

##### 제네릭 타입 별칭
```ts
interface Box<Type> {
  contents: Type;
}

↓↓↓

type Box<Type> = {
  contents: Type;
};
```

##### 객체 타입 외 다수 타입 정의 가능 <sub>(`interface` X)</sub>
- 제네릭 헬퍼 타입 정의
```ts
type OrNull<Type> = Type | null;

type OneOrMany<Type> = Type | Type[];

// OneOrMany<Type> | null
// Type | Type[] | null
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;

// OneOrMany<string> | null
// string | string[] | null
type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
```

### `Array` <sub>(배열 타입)</sub>

##### 제네릭 객체 타입
- 컨테이너 타입 역할
  - 내부 요소 타입 연관 X
- 데이터 구조 적합
  - 다수 데이터 타입 대상 재사용

##### 배열 타입
- `number[]`
  - `Array<number>` 축약
- `string[]`
  - `Array<string>` 축약
```ts
function doSomething(value: Array<string>) { … }

let myArray: string[] = ["hello", "world"];

doSomething(myArray);
doSomething(new Array("hello", "world"));
```

##### `Array` <sub>(타입)</sub> 자체 → 제네릭 타입
```ts
/*
 Array (전역 타입)
 - 타입 매개변수 1개 필수
 모든 Array 선언
 - 동일 타입 매개변수 보유 필수
 */
interface Array<Type> {

  // 배열 길이
  length: number;

  // 끝 요소 제거 후 반환
  pop(): Type | undefined;

  /*
   끝에 새 요소 추가
   - 갱신된 배열 길이 반환
   나머지 매개변수
   - 배열 (타입)
   */
  push(...items: Type[]): number;

  …
}
```

##### 모던 JS
- 다양한 제네릭 데이터 구조 제공
  - `Map<K, V>`
  - `Set<T>`
  - `Promise<T>`
  - 기타 등등

### `ReadonlyArray` <sub>(특수 타입)</sub>

##### 변경 불가 배열 <sub>(타입)</sub>
```ts
function doStuff(values: ReadonlyArray<string>) {

  // 읽기
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // 수정 X
  // - 에러 발생
  //   - Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

##### 명확한 의도 전달
- `ReadonlyArray` 반환 함수
  - 배열 내용 변경 금지
- `ReadonlyArray` 인수 함수
  - 함수 내 배열 내용 변경 걱정 X

##### `ReadonlyArray` 생성자 X
```ts
// 'ReadonlyArray' only refers to a type, but is being used as a value here.
new ReadonlyArray("red", "green", "blue");
```

##### 일반 배열 할당
```ts
const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
```

##### `readonly Type[]`
- `ReadonlyArray<Type>` 축약
```ts
function doStuff(values: readonly string[]) {

  // 읽기
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // 수정 X
  // - 에러 발생
  //   - Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

##### 할당 가능성 <sub>(assignability)</sub>
- 양방향 X
  - `Array` → `ReadonlyArray`
  - `Array` ↚ `ReadonlyArray`
```ts
let x: readonly string[] = [];
let y: string[] = [];

// Array → ReadonlyArray
x = y;

// Array ↚ ReadonlyArray
// - 에러 발생
//   - The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
y = x;
```

### `tuple` <sub>(타입)</sub>

##### 배열 일종
- 배열 내 요소 개수 인지
- 특정 위치 요소 타입 인지

##### `StringNumberPair` <sub>(타입)</sub>
```ts
type StringNumberPair = [string, number];
```
- `tuple` <sub>(타입)</sub>
  - `string`
  - `number`
- 런타임
  - 실체 X
- 타입 시스템
  - `StringNumberPair[0]`
    - `string`
  - `StringNumberPair[1]`
    - `number`
```ts
function doSomething(pair: [string, number]) {

  // const a: string
  const a = pair[0];

  // const b: number
  const b = pair[1];

  …
}

doSomething(["hello", 42]);
```

##### 범위 초과 접근 시 에러 발생
```ts
function doSomething(pair: [string, number]) {
  …

  // 에러 발생
  // - Tuple type '[string, number]' of length '2' has no element at index '2'.
  const c = pair[2];
}
```

##### 배열 구조 분해 할당 적용
```ts
function doSomething(stringHash: [string, number]) {
  const [inputString, hash] = stringHash;

  // const inputString: string
  console.log(inputString);

  // const hash: number
  console.log(hash);
}
```

<br />

##### 유용한 상황
- 각 요소 의미 명확
  - 원하는 변수명 사용 가능 <sub>(구조 분해 할당)</sub>
- ex\)
  - `stringHash[0]` <sub>(`tuple` 타입)</sub>
    - `inputString`
  - `stringHash[1]` <sub>(`tuple` 타입)</sub>
    - `hash`
- 상황 따라 사용
  - `tuple` 타입
  - 객체 <sub>(추가 프로퍼티 有)</sub>

##### 단순 `tuple` <sub>(타입)</sub>
- 특정 배열 동일
  - 특정 인덱스 선언
  - `length` <sub>(프로퍼티)</sub> 선언 <sub>(상수)</sub>
```ts
interface StringNumberPair {

  // 배열 특수 프로퍼티
  length: 2;
  0: string;
  1: number;

  // 기타 배열 프로퍼티들
  slice(start?: number, end?: number): Array<string | number>;
  …
}
```

##### optional 프로퍼티
- `…?`
- 항상 마지막 위치
- `length` <sub>(프로퍼티)</sub> 타입에 영향
```ts
type Either2dOr3d = [number, number, number?];

function setCoordinate(coord: Either2dOr3d) {

  // const z: number | undefined
  const [x, y, z] = coord;

  // length: 2 | 3
  console.log(`Provided coordinates had ${coord.length} dimensions`);
}
```

##### 나머지 요소
- `...`
- 배열 · `tuple` <sub>(타입)</sub>
```ts
type SNB = [string, number, ...boolean[]];
type SBN = [string, ...boolean[], number];
type BSN = [...boolean[], string, number];
```
- `length` <sub>(프로퍼티)</sub> X
```ts
const a: SNB = ["hello", 1];
const b: SNB = ["beautiful", 2, true];
const c: SNB = ["world", 3, true, false, true, false, true];
```

##### 유용한 상황 <sub>(optional · 나머지 요소)</sub>
- 매개변수 리스트 상응
  - 나머지 매개변수 · 인수 대체
- 최소한의 요소 사용
  - 중간 변수 X
```ts
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  …
}

↓↓↓

function readButtonInput(name: string, version: number, ...input: boolean[]) {
  …
}
```

### `readonly tuple` <sub>(타입)</sub>

```ts
function doSomething(pair: readonly [string, number]) { … }
```

##### 요소 수정 X
```ts
function doSomething(pair: readonly [string, number]) {

  // 에러 발생
  // - Cannot assign to '0' because it is a read-only property.
  pair[0] = "hello!";
}
```

##### 흔한 `tuple` <sub>(타입)</sub> 사용 방식
- 생성 후 미수정 상태 유지
  - `readonly` 적극 권장
- `[ … ] as const` <sub>(배열 리터럴 상수)</sub>
  - `readonly tuple` <sub>(타입)</sub> 추론
```ts
// point: readonly [3, 4]
// - [number, number] X
// - readonly [number, number]
let point = [3, 4] as const;

function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

// 에러 발생
// - readonly (제한자) 필요
//   - Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
//     - The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.
distanceFromOrigin(point);
```

<br />

## 추가

##### 객체 함수
```ts
const math = {
  sum1(a: number, b: number): number {
    return a + b;
  },

  // 함수 표현식
  sum2: function sum(a: number, b: number): number {
    return a + b;
  },

  // 화살표 함수 (반환 생략)
  sum3: (a: number, b: number): number => a + b,

};
```

##### 객체 리터럴 내 정의
- 함수 타입 자체 지정 X
  - 객체로 감싸는 형태 필요
```ts
type MathFn = (a: number, b: number) => number;

const math: { sum: MathFn } = {
  sum: (a, b) => a + b,
};
```
- 타입 내 속성 추가 X
  - 완전한 함수 선언 타입 정의 필요
```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};

const sum: MathFn = (a, b) => a + b;
sum.operator = '+';

const math = { sum };
```

이 예제는 const math = {sum}에 더하기만 추가한 앞선 예제와 같다는 것을 눈치챘을 것이다. 그렇다, 객체 선언에서 이 모든 것을 인라인화할 수 있는 방법은 없다.
