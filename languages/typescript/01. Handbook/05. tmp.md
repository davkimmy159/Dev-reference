## 제네릭 객체 타입

##### `Box` <sub>(타입)</sub>
- 모든 타입 값 저장
  - `string` <sub>(문자열)</sub>
  - `number` <sub>(숫자)</sub>
  - `Giraffe`
  - 기타 등등
```ts
interface Box {
  contents: any;
}
```

##### `any` <sub>(타입)</sub>
- 타입 불안전성 ↑

##### `unknown` <sub>(타입)</sub>
- 항상 사전 타입 체크 필요
- 불안전한 타입 주장 <sub>(type assertions)</sub> 필요
  - 에러 발생률 ↑
```ts
interface Box {
  contents: unknown;
}

let x: Box = {
  contents: "hello world",
};

// 사전 타입 체크
if (typeof x.contents === "string") {
  console.log(x.contents.toLowerCase());
}

// 타입 주장 (type assertion)
console.log((x.contents as string).toLowerCase());
```

##### 한 가지 해결 방법 <sub>(타입 안전)</sub>
- 종류별 타입 선언
```ts
interface NumberBox {
  contents: number;
}

interface StringBox {
  contents: string;
}

interface BooleanBox {
  contents: boolean;
}
```

##### 종류별 함수 (오버로드) 구현 필요
- 반복적인 코드량 ↑
- 추후 새 타입 · 함수 오버로드 추가 가능
  - 반복적인 코드량 ↑↑

```ts
function setContents(box: StringBox, newContents: string): void;
function setContents(box: NumberBox, newContents: number): void;
function setContents(box: BooleanBox, newContents: boolean): void;
function setContents(box: { contents: any }, newContents: any) {
  box.contents = newContents;
}
```

##### 제네릭 `Box` <sub>(타입)</sub>
- 타입 매개변수 선언 <sub>(`Type`)</sub>
```ts
interface Box<Type> {
  contents: Type;
}
```

##### 제네릭 타입 이용 시
- 타입 매개변수 전달
```ts
let box: Box<string>;
```

##### `Box` <sub>(타입)</sub>
- 실제 타입 템플릿

##### `Type` <sub>(타입 매개변수)</sub>
- placeholder
  - 추후 타 타입 대체

##### `Box<string>`
- `Type` <sub>(타입 매개변수)</sub>
  - `string`
- `{ contents: Type }`
  - `{ contents: string }`

##### `Box<string>` == `StringBox`
```ts
interface Box<Type> {
  contents: Type;
}

interface StringBox {
  contents: string;
}

// boxA.contents
// - Box<string>.contents: string
let boxA: Box<string> = { contents: "hello" };

// boxB.contents
// - StringBox.contents: string
let boxB: StringBox = { contents: "world" };
```

##### 제네릭 `Box` <sub>(타입)</sub>
- `Type` <sub>(타입 매개변수)</sub> 대체
  - 재사용 가능
  - 새 타입 사용 가능
```ts
interface Box<Type> {
  contents: Type;
}

interface Apple { … }

// { contents: Apple }
type AppleBox = Box<Apple>;
```

##### 제네릭 함수
- 함수 오버로드 불필요
```ts
function setContents<Type>(box: Box<Type>, newContents: Type) {
  box.contents = newContents;
}
```

##### 제네릭 타입 별칭
```ts
interface Box<Type> {
  contents: Type;
}

↓↓↓

type Box<Type> = {
  contents: Type;
};
```

##### 객체 타입 외 다수 타입 정의 가능 <sub>(`interface` X)</sub>
- 제네릭 헬퍼 타입 정의
```ts
type OrNull<Type> = Type | null;

type OneOrMany<Type> = Type | Type[];

// type OneOrManyOrNull<Type> = OneOrMany<Type> | null
type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;

// type OneOrManyOrNullStrings = OneOrMany<string> | null
type OneOrManyOrNullStrings = OneOrManyOrNull<string>;
```

We’ll circle back to type aliases in just a little bit.

### `Array` Type
Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.

It turns out we’ve been working with a type just like that throughout this handbook: the `Array` type. Whenever we write out types like `number[]` or `string[]`, that’s really just a shorthand for `Array<number>` and `Array<string>`.
```ts
function doSomething(value: Array<string>) {
  // ...
}

let myArray: string[] = ["hello", "world"];

// either of these work!
doSomething(myArray);
doSomething(new Array("hello", "world"));
```

Much like the `Box` type above, `Array` itself is a generic type.
```ts
// Global type 'Array' must have 1 type parameter(s).
// All declarations of 'Array' must have identical type parameters.
interface Array<Type> {

  /**
   * Gets or sets the length of the array.
   */
  length: number;

  /**
   * Removes the last element from an array and returns it.
   */
  pop(): Type | undefined;

  /**
   * Appends new elements to an array, and returns the new length of the array.
   */
  // A rest parameter must be of an array type.
  push(...items: Type[]): number;

  // ...
}
```

Modern JavaScript also provides other data structures which are generic, like `Map<K, V>`, `Set<T>`, and `Promise<T>`. All this really means is that because of how `Map`, `Set`, and `Promise` behave, they can work with any sets of types.

### `ReadonlyArray` Type
The `ReadonlyArray` is a special type that describes arrays that shouldn’t be changed.
```ts
function doStuff(values: ReadonlyArray<string>) {

  // We can read from 'values'...
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // ...but we can't mutate 'values'.
  // Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

Much like the `readonly` modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns `ReadonlyArray`s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes `ReadonlyArray`s, it tells us that we can pass any array into that function without worrying that it will change its contents.

Unlike `Array`, there isn’t a `ReadonlyArray` constructor that we can use.
```ts
// 'ReadonlyArray' only refers to a type, but is being used as a value here.
new ReadonlyArray("red", "green", "blue");
```

Instead, we can assign regular `Array`s to `ReadonlyArray`s.
```ts
const roArray: ReadonlyArray<string> = ["red", "green", "blue"];
```

Just as TypeScript provides a shorthand syntax for `Array<Type>` with `Type[]`, it also provides a shorthand syntax for `ReadonlyArray<Type>` with `readonly Type[]`.
```ts
function doStuff(values: readonly string[]) {

  // We can read from 'values'...
  const copy = values.slice();
  console.log(`The first value is ${values[0]}`);

  // ...but we can't mutate 'values'.
  // Property 'push' does not exist on type 'readonly string[]'.
  values.push("hello!");
}
```

One last thing to note is that unlike the `readonly` property modifier, assignability isn’t bidirectional between regular `Array`s and `ReadonlyArray`s.
```ts
let x: readonly string[] = [];
let y: string[] = [];

x = y;

// The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
y = x;
```

### Tuple Types
A tuple type is another sort of `Array` type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.
```ts
type StringNumberPair = [string, number];
```

Here, `StringNumberPair` is a tuple type of `string` and `number`. Like `ReadonlyArray`, it has no representation at runtime, but is significant to TypeScript. To the type system, `StringNumberPair` describes arrays whose `0` index contains a `string` and whose `1` index contains a `number`.
```ts
function doSomething(pair: [string, number]) {

  // const a: string
  const a = pair[0];

  // const b: number
  const b = pair[1];

  // ...
}

doSomething(["hello", 42]);
```

If we try to index past the number of elements, we’ll get an error.
```ts
function doSomething(pair: [string, number]) {
  // ...

  // Tuple type '[string, number]' of length '2' has no element at index '2'.
  const c = pair[2];
}
```

We can also destructure tuples using JavaScript’s array destructuring.
```ts
function doSomething(stringHash: [string, number]) {
  const [inputString, hash] = stringHash;

  // const inputString: string
  console.log(inputString);

  // const hash: number
  console.log(hash);
}
```

<br />

<hr />

Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements `0` and `1` to whatever we wanted.

However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.

<hr />

Other than those length checks, simple tuple types like these are equivalent to types which are versions of `Array`s that declare properties for specific indexes, and that declare `length` with a numeric literal type.
```ts
interface StringNumberPair {

  // specialized properties
  length: 2;
  0: string;
  1: number;

  // Other 'Array<string | number>' members...
  slice(start?: number, end?: number): Array<string | number>;
}
```

Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (`?` after an element’s type). Optional tuple elements can only come at the end, and also affect the type of `length`.
```ts
type Either2dOr3d = [number, number, number?];

function setCoordinate(coord: Either2dOr3d) {

  // const z: number | undefined
  const [x, y, z] = coord;

  // length: 2 | 3
  console.log(`Provided coordinates had ${coord.length} dimensions`);
}
```

Tuples can also have rest elements, which have to be an array/tuple type.
```ts
type StringNumberBooleans = [string, number, ...boolean[]];
type StringBooleansNumber = [string, ...boolean[], number];
type BooleansStringNumber = [...boolean[], string, number];
```

##### `StringNumberBooleans`
- describes a tuple whose first two elements are `string` and `number` respectively, but which may have any number of `boolean`s following.

##### `StringBooleansNumber`
- describes a tuple whose first element is `string` and then any number of `boolean`s and ending with a `number`.

##### `BooleansStringNumber`
- describes a tuple whose starting elements are any number of `boolean`s and ending with a `string` then a `number`.

A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.
```ts
const a: StringNumberBooleans = ["hello", 1];
const b: StringNumberBooleans = ["beautiful", 2, true];
const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];
```

Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:
```ts
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  // ...
}
```

is basically equivalent to:
```ts
function readButtonInput(name: string, version: number, ...input: boolean[]) {
  // ...
}
```

This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.

### `readonly` Tuple Types
One final note about tuple types - tuple types have `readonly` variants, and can be specified by sticking a `readonly` modifier in front of them - just like with array shorthand syntax.
```ts
function doSomething(pair: readonly [string, number]) {
  // ...
}
```

As you might expect, writing to any property of a `readonly` tuple isn’t allowed in TypeScript.
```ts
function doSomething(pair: readonly [string, number]) {

  // Cannot assign to '0' because it is a read-only property.
  pair[0] = "hello!";
}
```

Tuples tend to be created and left un-modified in most code, so annotating types as `readonly` tuples when possible is a good default. This is also important given that array literals with `const` assertions will be inferred with `readonly` tuple types.
```ts
let point = [3, 4] as const;

function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

// Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.
// The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.
distanceFromOrigin(point);
```

Here, `distanceFromOrigin` never modifies its elements, but expects a mutable tuple. Since `point`’s type was inferred as `readonly [3, 4]`, it won’t be compatible with `[number, number]` since that type can’t guarantee `point`’s elements won’t be mutated.

<br />

## 요약

객체의 속성과 함수
다음 예제는 객체의 함수다.
```ts
const math = {
  sum(a: number, b: number): number {
    return a + b;
  },
};
```

다음은 속성이 함수 표현식인 예제다.
```ts
const math = {
  sum: function sum(a: number, b: number): number {
    return a + b;
  },
};
```

속성이 (리턴을 생략한) 화살표 함수인 예제다.
```ts
const math = {
  sum: (a: number, b: number): number => a + b,
};
```

아쉽지만, 함수 스스로를 정의할 수 없는 타입을 작성하기 위해서는 객체로 감싸는 형태로 타입을 정의해야 한다. 객체 리터럴 안에 정의될 때는 속성의 함수 타입을 스스로 지정할 수 없다.
```ts
type MathFn = (a: number, b: number) => number;

const math: { sum: MathFn } = {
  sum: (a, b) => a + b,
};
```

심지어, 앞선 예제처럼 타입에 속성을 추가하려고 한다면 객체 리터럴 안에서는 불가능하다. 함수 선언을 완전하게 타입 정의해야 한다.
```ts
type MathFn = {
  (a: number, b: number): number;
  operator: string;
};
const sum: MathFn = (a, b) => a + b;
sum.operator = '+';

const math = { sum };
```

이 예제는 const math = {sum}에 더하기만 추가한 앞선 예제와 같다는 것을 눈치챘을 것이다. 그렇다, 객체 선언에서 이 모든 것을 인라인화할 수 있는 방법은 없다.
