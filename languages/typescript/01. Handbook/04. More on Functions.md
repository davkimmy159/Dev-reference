More on Functions
=================

## 함수 타입 표현식

##### 함수 타입 표현식 <sub>(가장 간단한 방법)</sub>
- 화살표 함수
  - 문법적 유사
```ts
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

#### `(a: string) => void`

##### 매개변수
- 1개
  - `a` <sub>(문자열)</sub>
- 타입 생략 시
  - 암시적 `any`
- 이름 필수
  - ex\) `(string) => void`
    - 이름 : `string`
    - 타입 : `any`

##### 반환값
- X

##### 타입 별칭 사용 가능
```ts
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) { … }
```

<br />

## Call Signatures

##### Call Signature
- 함수 매개변수 · 반환값 타입 정의
```ts
// Call Signatures
type Add = (a: number, b: number) => number

const add : Add = (a, b) => a + b
```

##### JS 함수
- 프로퍼티 보유 가능

##### 함수 타입 표현식 <sub>(TS)</sub>
- 프로퍼티 보유 X
  - 객체형 Call Signatures 사용
```ts
// 객체형 Call Signatures
// - 프로퍼티 보유 가능
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}
myFunc.description = "default description";

doSomething(myFunc);
```

##### 작은 문법적 차이
- `=>` <sub>(화살표)</sub> → `:` <sub>(콜론)</sub>
  - 매개변수 리스트 · 반환 타입 사이
```ts
// '=>'
type funcType1 = (a: number) => boolean;

// ':'
type funcType2 = {
  prop: string;
  (a: number): boolean;
};
```

<br />

## Construct Signatures

##### Construct Signatures
- 생성자 함수 형태 정의
  - 매개변수
  - 생성 객체 타입

##### JS 함수
- `new` <sub>(연산자)</sub> 함께 호출 가능
  - 생성자 함수 방식 동작

##### TS
- `new` <sub>(연산자)</sub> 함께 호출 함수
  - 생성자 취급

##### Construct Signatures 정의
- `new` <sub>(키워드)</sub>
  - 타입 가장 앞에 추가

```ts
// Construct Signatures
// type SomeConstructor = new (s: string) => SomeObject;
type SomeConstructor = {
  new (s: string): SomeObject;
};

function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

##### 일부 객체 <sub>(`Date` 객체 등)</sub>
- `new` 없이 · 함께 호출 가능

##### call · construct signatures 조합 가능
```ts
interface CallOrConstruct {

  // call signatures
  (n?: number): string;

  // construct signatures
  new (s: string): Date;
}
```

<br />

## 재네릭 함수

##### 함수 작성 시 흔한 상황
- 입력 <sub>(매개변수)</sub> · 출력 <sub>(반환값)</sub> 타입 연계
- 입력 <sub>(매개변수)</sub> 2개 타입 연계
- 기타 등등

##### 전달받은 배열 내 1번째 요소 반환 함수
- `any` 타입 반환
  - 배열 타입 반환 시 유용
```ts
function firstElement(arr: any[]) {
  return arr[0];
}
```

##### 타입 매개변수 선언 <sub>(제네릭)</sub>
- 두 값 사이 타입 연계
```ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

##### `Type` <sub>(타입 매개변수)</sub>
- 추가 후 사용
  - 매개변수 타입
  - 반환 타입
- 타입 연계
  - 입력 <sub>(매개변수)</sub>
  - 출력 <sub>(반환값)</sub>

##### 함수 호출 시 더 구체적인 타입 사용
```ts
// s: string
const s = firstElement(["a", "b", "c"]);

// n: number
const n = firstElement([1, 2, 3]);

// u: undefined
const u = firstElement([]);
```

### 추론

##### 호출 시 타입 명시 X
- 타입 추론 <sub>(자동 명시)</sub>

##### 다수 타입 매개변수 사용
- ex\) `map` <sub>(함수)</sub>
- `Input` <sub>(타입 매개변수)</sub>
  - `string[]` <sub>(`["1", "2", "3"]`)</sub>
- `Output` <sub>(타입 매개변수)</sub>
  - `number` <sub>(함수 반환값 · `parseInt(n)`)</sub>
```ts
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// n (매개변수): string
// parsed: number[]
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

### 타입 매개변수 제약

##### 타입 연계 시
- 특정 값 하위 타입 제약

##### `longest` <sub>(길이 비교 함수)</sub>
- 길이 비교
  - `length` <sub>(프로퍼티)</sub> 필요
- 타입 매개변수 제약 적용
  - `extends` <sub>(절)</sub>
- 반환 타입
  - 명시 X
  - 추론
```ts
Type extends { length: number }
```
```ts
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray: number[]
const longerArray = longest([1, 2], [1, 2, 3]);

// longerString: 'alice' | 'bob'
const longerString = longest("alice", "bob");

// 에러 발생
// - 숫자 내 length (프로퍼티) X
//   - Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
const notOK = longest(10, 100);
```

##### `Type extends { length: number }` <sub>(제약)</sub>
- `a` · `b` <sub>(매개변수)</sub>
  - `length` <sub>(프로퍼티)</sub> 접근 가능
- 제약 부재 시 해당 프로퍼티 접근 X
  - 해당 프로퍼티 부재 타입 가능성 有
- `longer[Array·String]` 타입
  - 인자 기반 추론

##### `longest(10, 100)` 호출 에러
- 숫자형
  - `length` <sub>(프로퍼티)</sub> X

### 제네릭 제약 다루기

##### 제네릭 제약 적용 시 흔한 실수
```ts
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {

    // 에러 발생
    // - Type '{ length: number; }' is not assignable to type 'Type'.
    // - '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
    return { length: minimum };
  }
}
```

##### 문제점
- 반환 타입 <sub>(`Type`)</sub>
  - `obj` <sub>(1번째 매개변수)</sub> 타입 <sub>(`Type`)</sub>
  - 제약만 부합하는 타입 X

##### 위 코드 정상 실행 시 문제 발생
```ts
// arr
// - 타입 : number[]
// - 갑   : { length: 6 }
const arr = minimumLength([1, 2, 3], 6);

/* 문제 발생
 배열 타입
 - slice (메서드) 有
 실제 값
 - slice (메서드) X
 */
console.log(arr.slice(0));
```

### 타입 인자 명시하기

##### 제네릭 함수 호출 시
- 대개 타입 인자 추론 가능
  - 항상 X
  - 가끔 추론 X

##### 두 배열 결합 함수
```ts
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

##### 보통 타입 불일치 시 에러 발생
```ts
// 에러 발생
// - Type 'string' is not assignable to type 'number'.
const arr = combine([1, 2, 3], ["hello"]);
```

##### 타입 직접 명시
```ts
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

### 제네릭 함수 작성 가이드라인

##### 다수 불필요 타입 매개변수 · 제약
- 추론 성공률 ↓
- 어려운 함수 이용

#### 타입 매개변수 내려놓기

##### 유사 함수 작성법 <sub>(2가지)</sub>
```ts
function firstElement1<Type>(arr: Type[]) {
  return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0];
}

// a: number (good)
const a = firstElement1([1, 2, 3]);

// b: any (bad)
// - 표현식 (arr[0]) 계산 실행 (제약 적용)
const b = firstElement2([1, 2, 3]);
```

##### 규칙 ①
- 제약 사용 자제


#### 타입 매개변수 적게 사용하기

##### 유사 함수 <sub>(2개)</sub>
```ts
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}

function filter2<Type, Func extends (arg: Type) => boolean>(
  arr: Type[],
  func: Func
): Type[] {
  return arr.filter(func);
}
```

##### `Func` <sub>(타입 매개변수)</sub>
- 두 값 타입 연계 X <sub>(불필요)</sub>
  - 아무 이유없이 타입 명시 필요
- 함수 내 역할 X
- 가독성 · 이해도 ↓

##### 규칙 ②
- 가능하면 적게 사용

#### 타입 매개변수 2곳 이상 사용

##### 가끔 함수 작성 시 불필요 제네릭 사용
```ts
function greet<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}

greet("world");
```
- 제네릭 불필요
```ts
function greet(s: string) {
  console.log("Hello, " + s);
}
```

##### 타입 매개변수 역할
- 다수 값 타입 연계
- 함수 내 한 곳에서만 등장 시
  - 타입 연계 역할 X

##### 추론된 반환 타입 연계 포함
- ex\) `Str` <sub>(위 함수 타입 매개변수)</sub>
  - 함수 반환 타입 일부 구성 시
    - 타입 연계 역할 수행
    - 표면상 한 곳에서만 등장

##### 규칙 ③
- 한 곳에서만 등장 시 사용 재고

##### 타입 매개변수 <sub>(제네릭)</sub> 규칙 요약
1. 제약 사용 자제
2. 가능하면 적게 사용
3. 한 곳에서만 등장 시 사용 재고

<br />

## 선택 매개변수

##### JS 함수
- 다양한 인자 有

##### `toFixed` <sub>(숫자형 메서드)</sub>
- 선택 숫자 수 전달
```ts
function f(n: number) {
  console.log(n.toFixed()); // 0 arguments
  console.log(n.toFixed(3)); // 1 argument
}
```

##### `?` <sub>(선택 매개변수 지정)</sub>
- 실제 매개변수 타입
  - `명시 타입 | undefined`
```ts
// x: number | undefined
function f(x?: number) { … }

f();
f(10);
```

##### 매개변수 기본값 설정
- 인수 미전달 시
  - `undefined` → 기본값 <sub>(명시 타입)</sub>
```ts
// x: number
// - 인수 미전달 시
//   - undefined → 10 (숫자형)
function f(x = 10) { … }
```

##### 선택 매개변수 존재 시
- `undefined` 전달 가능
  - 인수 부재 표현
```ts
f();
f(10);
f(undefined);
```

### 콜백 내 선택 매개변수

##### 콜백 내 선택 매개변수 추가 시 흔한 실수
```ts
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

##### 원하는 콜백 동작
```ts
myForEach([1, 2, 3], (a) => console.log(a));
myForEach([1, 2, 3], (a, i) => console.log(a, i));
```

##### 불가능한 코드
```ts
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {

    // I don't feel like providing the index today
    callback(arr[i]);
  }
}
```

##### 불가능 동작
- 에러 발생
```ts
myForEach([1, 2, 3], (a, i) => {

  // 에러 발생
  // - 'i' is possibly 'undefined'.
  console.log(i.toFixed());
});
```

##### 함수 매개변수
- 초과 매개변수
  - 무시
- 적은 파라미터 개수 함수
  - 많은 파라미터 개수 함수 대체 가능

##### 규칙 <sub>(콜백 선택 매개변수)</sub>
- 선택 매개변수 사용 지양
- 매개변수 없는 호출 시만 사용

## 함수 오버로드

##### 일부 함수
- 다양한 인자 전달 가능
- ex\) `makeDate` <sub>(함수 · `Date` 반환)</sub> 인자
  - 타임스탬프 <sub>(1개)</sub>
  - 월 · 일 · 년 <sub>(3개)</sub>

##### overload signatures
- 다양한 함수 호출 방식 표현
- function signatures
  - 2개 이상 작성
```ts
// overload signatures 1
function makeDate(timestamp: number): Date;

// overload signatures 2
function makeDate(m: number, d: number, y: number): Date;

// implementation signature
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);

// 인수 2개 오버로드 X
const d3 = makeDate(1, 3);
```

### Overload · Implementation Signature
This is a common source of confusion. Often people will write code like this and not understand why there is an error:
```ts
function fn(x: string): void;
function fn() { … }

// 에러 발생
// - Expected 1 arguments, but got 0.
fn();
```

##### 함수 본문 <sub>(Implementation)</sub> Signature
- 함수 내부 구현 전용
  - 호출자 사용 X
  - 밖에서 보이지 않음
- Overload Signature
  - 바로 위 위치
  - 2개 이상 필요

##### Overload · Implementation Signature
- 호환 <sub>(매칭)</sub> 필수
```ts
// overload signatures 1
function fn(x: boolean): void;

// overload signatures 2
// - 인자 타입 부적절
//   - implementation signature 호환 X
function fn(x: string): void;

// implementation signature
function fn(x: boolean) {}
```
```ts
// overload signatures 1
function fn(x: string): string;

// overload signatures 2
// - 반환 타입 부적절
//   - implementation signature 호환 X
function fn(x: number): boolean;

function fn(x: string | number) {
  return "oops";
}
```

### 함수 오버로드 작성 가이드라인

##### `len` <sub>(함수)</sub>
- 문자열 · 배열 길이 반환
```ts
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) {
  return x.length;
}
```

##### 문제점
- 확실한 단일 타입만 가능
- 불확실한 타입 X
```ts
len(""); // OK
len([0]); // OK

/* 에러 발생
 Overload 1 of 2, '(s: string): number', gave the following error.
   Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
     Type 'number[]' is not assignable to type 'string'.
 Overload 2 of 2, '(arr: any[]): number', gave the following error.
   Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
     Type 'string' is not assignable to type 'any[]'.
 */
len(Math.random() > 0.5 ? "hello" : [0]);
```

##### 매개변수 개수 동일 · 반환 타입 동일
- union 사용
  1. 오버로드 제거
  2. 오버로드 유지 <sub>(반환 타입 명시 필수)</sub>
```ts
// (1)
// 오버로드 제거
function len(x: any[] | string) {
  return x.length;
}

// (2)
// 오버로드 유지
// - 반환 타입 명시 필수
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any[] | string) {
  return x.length;
}
```

##### 규칙 <sub>(오버로드)</sub>
- 가능하면 union 타입 선고려

### 함수 내 `this` 선언하기

##### 함수 내 `this`
- 코드 흐름 분석해 추론
```ts
const user = {
  id: 123,

  admin: false,
  becomeAdmin: function () {
    this.admin = true;
  },
};
```

##### `this` 매개변수 <sub>(함수)</sub>
- JS 내 사용 X
- TS 사용 가능
  - 함수 본문 내 `this` 타입 선언
```ts
interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();
const admins = db.filterUsers(function (this: User) {
  return this.admin;
});
```

This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:
```ts
interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();

// The containing arrow function captures the global value of 'this'.
// Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.
const admins = db.filterUsers(() => this.admin);
```

## Other Types to Know About
There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.

### `void`
void represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:
```ts
// The inferred return type is void
function noop() {
  return;
}
```

In JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.

**`void` is not the same as `undefined`.**

### `object`
The special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the empty object type `{}`, and also different from the global type `Object`. It’s very likely you will never use `Object`.

**`object` is not `Object`. Always use `object`!**

Note that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.

### `unknown`
The `unknown` type represents any value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:
```ts
function f1(a: any) {
  a.b(); // OK
}
function f2(a: unknown) {
  a.b();
'a' is of type 'unknown'.
}
```

This is useful when describing function types because you can describe functions that accept `any` value without having any values in your function body.

Conversely, you can describe a function that returns a value of unknown type:
```ts
function safeParse(s: string): unknown {
  return JSON.parse(s);
}

// Need to be careful with 'obj'!
const obj = safeParse(someRandomString);
```

### `never`
Some functions never return a value:
```ts
function fail(msg: string): never {
  throw new Error(msg);
}
```

The `never` type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.

`never` also appears when TypeScript determines there’s nothing left in a `union`.
```ts
function fn(x: string | number) {
  if (typeof x === "string") {
    // do something
  } else if (typeof x === "number") {
    // do something else
  } else {
    x; // has type 'never'!
  }
}
```

### `Function`
The global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:
```ts
function doSomething(f: Function) {
  return f(1, 2, 3);
}
```

This is an untyped function call and is generally best avoided because of the unsafe `any` return type.

If you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.

## Rest Parameters and Arguments

### Rest Parameters
In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.

A rest parameter appears after all other parameters, and uses the `...` syntax:
```ts
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}
// 'a' gets value [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4);
```

In TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>` or `T[]`, or a tuple type (which we’ll learn about later).

### Rest Arguments
Conversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the `push` method of arrays takes any number of arguments:
```ts
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
arr1.push(...arr2);
```

Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:
```ts
// Inferred type is number[] -- "an array with zero or more numbers",
// not specifically two numbers
const args = [8, 5];

// A spread argument must either have a tuple type or be passed to a rest parameter.
const angle = Math.atan2(...args);
```

The best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:
```ts
// Inferred as 2-length tuple
const args = [8, 5] as const;
// OK
const angle = Math.atan2(...args);
```

Using rest arguments may require turning on `downlevelIteration` when targeting older runtimes.

## Parameter Destructuring
You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:
```ts
function sum({ a, b, c }) {
  console.log(a + b + c);
}
sum({ a: 10, b: 3, c: 9 });
```

The type annotation for the object goes after the destructuring syntax:
```ts
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

This can look a bit verbose, but you can use a named type here as well:
```ts
// Same as prior example
type ABC = { a: number; b: number; c: number };
function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

## Assignability of Functions

### Return type `void`
The `void` return type for functions can produce some unusual, but expected behavior.

Contextual typing with a return type of `void` does not force functions to not return something. Another way to say this is a contextual function type with a `void` return type (`type voidFunc = () => void`), when implemented, can return any other value, but it will be ignored.

Thus, the following implementations of the type `() => void` are valid:
```ts
type voidFunc = () => void;

const f1: voidFunc = () => {
  return true;
};

const f2: voidFunc = () => true;

const f3: voidFunc = function () {
  return true;
};
```

And when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:
```ts
const v1 = f1();

const v2 = f2();

const v3 = f3();
```

This behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.
```ts
const src = [1, 2, 3];
const dst = [0];

src.forEach((el) => dst.push(el));
```

There is one other special case to be aware of, when a literal function definition has a `void` return type, that function must not return anything.
```ts
function f2(): void {
  // @ts-expect-error
  return true;
}

const f3 = function (): void {
  // @ts-expect-error
  return true;
};
```
