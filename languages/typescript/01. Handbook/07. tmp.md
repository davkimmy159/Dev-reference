## Static 멤버

##### 클래스 생성자 객체 자체
- 인스턴스 X
```ts
class MyClass {
  static x = 0;

  static printX() {
    console.log(MyClass.x);
  }
}

console.log(MyClass.x);
MyClass.printX();
```

##### 가시성 제한자
- `public`
- `protected`
- `private`
```ts
class MyClass {
  private static x = 0;
}

// 에러 발생
// - Property 'x' is private and only accessible within class 'MyClass'.
console.log(MyClass.x);
```

##### 상속
```ts
class Base {
  static getGreeting() {
    return "Hello world";
  }
}

class Derived extends Base {
  myGreeting = Derived.getGreeting();
}
```

#### 특별 Static 이름

##### `Function` 프로토타입 내 프로퍼티
- 값 덮어쓰기
  - 불안전
  - 불가능
- 클래스 == 함수 <sub>(`new` 함께 호출 가능)</sub>
  - 특정 `static` 이름 사용 X
- `static` 정의 불가능 멤버
  - `name`
  - `length`
  - `call`
  - 기타 등등
```ts
class S {

  // 에러 발생
  // - Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
  static name = "S!";
}
```

#### Static 클래스 X

##### JS · TS
- `static class` 문법 X
  - 최상위 함수
  - 객체 리터럴
```ts
// static class 불필요
class MyStaticClass {
  static doSomething() {}
}

// 최상위 함수 (대안 1)
function doSomething() {}

// 객체 리터럴 (대안 2)
const MyHelperObject = {
  dosomething() {},
};
```

<br />

## 클래스 내 `static` 블록

##### `static` 블록
- `static` 컨텍스트 접근 <sub>(클래스 선언 시점)</sub>
  - `static` 코드 작성
  - `static` 필드 초기화
  - 클래스 내부 모든 접근 가능
```ts
class Foo {
  static #count = 0;

  get count() {
    return Foo.#count;
  }

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    }
    catch {}
  }
}
```

<br />

## 제네릭 클래스

##### 인스턴스화 <sub>(`new` 연산자)</sub>
- 클래스 타입 매개변수 추론
  - 함수 호출 동일 방식
- 타입 매개변수
  - 제약
  - 기본값
```ts
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }
}

// const b: Box<string>
const b = new Box("hello!");
```

#### `static` 멤버 타입 매개변수 X

##### `static` 멤버
- 클래스 타입 매개변수 참조 X
```ts
class Box<Type> {

  // 에러 발생
  // - Static members cannot reference class type parameters.
  static defaultValue: Type;
}
```

<br />

## 런타임 시 클래스 내 `this`

##### TS
- 런타임 시 JS 행동 변경 X

##### JS `this` 처리
- 특이함
```js
class MyClass {
  name = "MyClass";

  getName() {
    return this.name;
  }
}

const c = new MyClass();
const obj = {
  name: "obj",
  getName: c.getName,
};

// "obj"
// "MyClass" X
console.log(obj.getName());
```

##### 런타임 시 `this` 값
- 함수 내 `this` 값
  - 함수 호출 방식 따라 결정
- ex\) `obj.getName()`
  - `obj` 참조 통해 호출
    - `this` == `obj`

#### 화살표 함수

##### `this` 컨텍스트 X
- 외부 `this` 값 이용
  - 클래스 내 `this` <sub>(인스턴스)</sub>
```ts
class MyClass {
  name = "MyClass";

  getName = () => {
    return this.name;
  };
}

const c = new MyClass();
const g = c.getName;

// "MyClass"
// - 에러 발생 X
console.log(g());
```

##### 장단점 <sub>(↔ `this` 매개변수)</sub>
- 런타임 시 올바른 `this` 값 항상 보장
  - 순수 JS 코드 작동
- 메모리 사용량 ↑
  - 각 인스턴스 함수 할당
- `super` <sub>(키워드)</sub> X <sub>(하위 클래스)</sub>
  - 프로토타입 내 부재

#### `this` 매개변수

##### 1번째 `this` 매개변수 <sub>(TS 함수 · 메서드)</sub>
- 컴파일 시 제거
```ts
// TS
function fn(this: SomeType, x: number) { … }

↓↓↓

// JS
function fn(x) { … }
```

##### 함수 호출 시 `this` 컨텍스트 체크
- 메서드 내 `this` 타입 정적 강제
  - `this` 값 혼동 방지
```ts
class MyClass {
  name = "MyClass";

  getName(this: MyClass) {
    return this.name;
  }
}

const c = new MyClass();
c.getName();

const g = c.getName;

// 에러 발생
// - The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.
console.log(g());
```

##### 장단점 <sub>(↔ 화살표 함수)</sub>
- 런타임 시 잘못된 `this` 값 가능
  - JS 호출자
- 메모리 사용량 ↓
  - 클래스 당 함수 1개 할당
- `super` <sub>(키워드)</sub> 가능 <sub>(하위 클래스)</sub>
  - 프로토타입 내 有

<br />

## `this` 타입

##### 클래스 내 `this` <sub>(특수 타입)</sub>
- 현재 클래스 동적 참조
```ts
class Box {
  contents: string = "";

  /* Box.set(value: string): this
   메서드 반환 타입 추론
   - Box  (X)
   - this (O)
   */
  set(value: string) {
    this.contents = value;
    return this;
  }
}
```

##### `Box` 하위 클래스 내 해당 상속 메서드 <sub>(`this` 반환)</sub>
- 하위 클래스 타입 반환
```ts
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();

// const b: ClearableBox
const b = a.set("hello");
```

##### 메서드 매개변수 타입 주석
- 하위 클래스 내 해당 상속 메서드
  - 해당 클래스 타입만 허용
```ts
class Box {
  content: string = "";

  // this (타입) 매개변수
  sameAsThis(other: this) {
    return other.content === this.content;
  }

  // Box (타입) 매개변수
  sameAsBox(other: Box) {
    return other.content === this.content;
  }
}

class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();

// 에러 발생
// - Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
//   - Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.
derived.sameAsThis(base);

// 에러 발생 X
derived.sameAsBox(base);
```

#### `this`-based type guards
You can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.
```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  isNetworked(): this is Networked & this {
    return this.networked;
  }

  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {

  // const fso: FileRep
  fso.content;

} else if (fso.isDirectory()) {

  // const fso: Directory
  fso.children;

} else if (fso.isNetworked()) {

  // const fso: Networked & FileSystemObject
  fso.host;
}
```

A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:
```ts
class Box<T> {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box<string>();
box.value = "Gameboy";

// (property) Box<string>.value?: string
box.value;

if (box.hasValue()) {

  // (property) value: string
  box.value;
}
```

<br />

## Parameter Properties
TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):
```ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);

// (property) Params.x: number
console.log(a.x);

// Property 'z' is private and only accessible within class 'Params'.
console.log(a.z);
```

<br />

## Class Expressions
Class expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:
```ts
const someClass = class<Type> {
  content: Type;
  constructor(value: Type) {
    this.content = value;
  }
};

// const m: someClass<string>
const m = new someClass("Hello, world");
```

<br />

## Constructor Signatures
JavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the `InstanceType` utility type models this operation.
```ts
class Point {
  createdAt: number;
  x: number;
  y: number

  constructor(x: number, y: number) {
    this.createdAt = Date.now()
    this.x = x;
    this.y = y;
  }
}
type PointInstance = InstanceType<typeof Point>

function moveRight(point: PointInstance) {
  point.x += 5;
}

const point = new Point(3, 4);
moveRight(point);
point.x; // => 8
```

<br />

## `abstract` Classes and Members
Classes, methods, and fields in TypeScript may be abstract.

An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.

The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.

Let’s look at an example:
```ts
abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hello, " + this.getName());
  }
}

// Cannot create an instance of an abstract class.
const b = new Base();
```

We can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:
```ts
class Derived extends Base {
  getName() {
    return "world";
  }
}

const d = new Derived();
d.printName();
```

Notice that if we forget to implement the base class’s abstract members, we’ll get an error:
```ts
// Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
class Derived extends Base {
  // forgot to do anything
}
```

#### Abstract Construct Signatures
Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.

For example, you might want to write this code:
```ts
function greet(ctor: typeof Base) {

  // Cannot create an instance of an abstract class.
  const instance = new ctor();

  instance.printName();
}
```

TypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:
```ts
// Bad!
greet(Base);
```

Instead, you want to write a function that accepts something with a construct signature:
```ts
function greet(ctor: new () => Base) {
  const instance = new ctor();
  instance.printName();
}
greet(Derived);

// Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
// Cannot assign an abstract constructor type to a non-abstract constructor type.
greet(Base);
```

Now TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.

<br />

## Relationships Between Classes
In most cases, classes in TypeScript are compared structurally, the same as other types.

For example, these two classes can be used in place of each other because they’re identical:
```ts
class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

// OK
const p: Point1 = new Point2();
```

Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:
```ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

// OK
const p: Person = new Employee();
```

This sounds straightforward, but there are a few cases that seem stranger than others.

Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:
```ts
class Empty {}

function fn(x: Empty) {
  // can't do anything with 'x', so I won't
}

// All OK!
fn(window);
fn({});
fn(fn);
```

<br />

## 추가

클래스는 그 자체로는 (new와 함께 호출되어야 하는) 특별한 함수지만, 이번에는 클래스 본문에서 함수가 어떻게 정의되는지 이야기할 것이다. 클래스 본문 안에서 가장 흔한 형태의 함수 예제다.
```ts
class MathUtils {
  sum(a: number, b: number): number {
    return a + b;
  }
}

const math = new MathUtils();
math.sum(1, 2);
```

이 클래스의 어떤 인스턴스에 바인딩하고 싶은 함수가 있다면 클래스 필드를 사용할 수도 있다.
```ts
class MathUtils {
  sum = (a: number, b: number): number => {
    return a + b;
  };
}

// 다음과 같이 하면 그렇게 할 수 있다.
const math = new MathUtils();
const sum = math.sum;
sum(1, 2);

// 그러나 일반적인 객체의 속성에 대해서 클래스로 사용하는 방식은 대부분의 성능 향상을 상쇄시켜 버릴 수 있다.
```

그러면 타입을 정의해 보자. 첫 번째 예제의 메서드의 타입 정의는 다음과 같다.
```ts
interface MathUtilsInterface {
  sum(a: number, b: number): number;
}

class MathUtils implements MathUtilsInterface {
  sum(a: number, b: number): number {
    return a + b;
  }
}
```

흥미롭게도, 상속 구현해야 하는 인터페이스의 일부임에도 불구하고 여전히 그 함수를 위한 타입을 정의해야 한다🤔 🤷‍♂️.

마지막으로 알아야 할 것이다. 타입스크립트에서는 public과 private, protected를 쓸 수 있다. 개인적으로는 클래스를 잘 쓰지 않고 이들을 위한 특정 타입스크립트 기능을 좋아하지 않는다.  자바스크립트에 private 멤버를 위한 깔끔하면서도 특별한 문법이 나올 것이다(더 배워보기).
