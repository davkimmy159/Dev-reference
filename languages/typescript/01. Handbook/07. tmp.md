## Static Members
Classes may have `static` members. These members arenâ€™t associated with a particular instance of the class. They can be accessed through the class constructor object itself:
```ts
class MyClass {
  static x = 0;

  static printX() {
    console.log(MyClass.x);
  }
}

console.log(MyClass.x);
MyClass.printX();
```
Static members can also use the same `public`, `protected`, and `private` visibility modifiers:
```ts
class MyClass {
  private static x = 0;
}

// Property 'x' is private and only accessible within class 'MyClass'.
console.log(MyClass.x);
```

Static members are also inherited:
```ts
class Base {
  static getGreeting() {
    return "Hello world";
  }
}

class Derived extends Base {
  myGreeting = Derived.getGreeting();
}
```

#### Special Static Names
Itâ€™s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names canâ€™t be used. Function properties like `name`, `length`, and `call` arenâ€™t valid to define as `static` members:
```ts
class S {

  // Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
  static name = "S!";
}
```

#### Why No Static Classes?
TypeScript (and JavaScript) donâ€™t have a construct called `static class` the same way as, for example, C# does.

Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesnâ€™t exist in TypeScript, thereâ€™s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript.

For example, we donâ€™t need a â€œstatic classâ€ syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:
```ts
// Unnecessary "static" class
class MyStaticClass {
  static doSomething() {}
}

// Preferred (alternative 1)
function doSomething() {}

// Preferred (alternative 2)
const MyHelperObject = {
  dosomething() {},
};
```

<br />

## static Blocks in Classes
Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our classâ€™s internals.
```ts
class Foo {
  static #count = 0;

  get count() {
    return Foo.#count;
  }

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    }
    catch {}
  }
}
```

<br />

## Generic Classes
Classes, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:
```ts
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }
}

// const b: Box<string>
const b = new Box("hello!");
```

Classes can use generic constraints and defaults the same way as interfaces.

#### Type Parameters in Static Members
This code isnâ€™t legal, and it may not be obvious why:
```ts
class Box<Type> {

  // Static members cannot reference class type parameters.
  static defaultValue: Type;
}
```

Remember that types are always fully erased! At runtime, thereâ€™s only one `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would also change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the classâ€™s type parameters.

<br />

## `this` at Runtime in Classes
Itâ€™s important to remember that TypeScript doesnâ€™t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.

JavaScriptâ€™s handling of `this` is indeed unusual:
```ts
class MyClass {
  name = "MyClass";

  getName() {
    return this.name;
  }
}

const c = new MyClass();
const obj = {
  name: "obj",
  getName: c.getName,
};

// Prints "obj", not "MyClass"
console.log(obj.getName());
```

Long story short, by default, the value of `this` inside a function depends on how the function was called. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.

This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.

#### Arrow Functions
If you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:
```ts
class MyClass {
  name = "MyClass";

  getName = () => {
    return this.name;
  };
}

const c = new MyClass();
const g = c.getName;

// Prints "MyClass" instead of crashing
console.log(g());
```

This has some trade-offs:
- The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript
- This will use more memory, because each class instance will have its own copy of each function defined this way
- You canâ€™t use `super.getName` in a derived class, because thereâ€™s no entry in the prototype chain to fetch the base class method from

#### `this` parameters
In a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:
```ts
// TypeScript input with 'this' parameter
function fn(this: SomeType, x: number) {
  /* ... */
}
```
```ts
// JavaScript output
function fn(x) {
  /* ... */
}
```

TypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:
```ts
class MyClass {
  name = "MyClass";

  getName(this: MyClass) {
    return this.name;
  }
}

const c = new MyClass();
// OK
c.getName();

// Error, would crash
const g = c.getName;

// The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.
console.log(g());
```

This method makes the opposite trade-offs of the arrow function approach:
- JavaScript callers might still use the class method incorrectly without realizing it
- Only one function per class definition gets allocated, rather than one per class instance
- Base method definitions can still be called via `super`.

<br />

## `this` Types
In classes, a special type called `this` refers dynamically to the type of the current class. Letâ€™s see how this is useful:
```ts
class Box {
  contents: string = "";

  // (method) Box.set(value: string): this
  set(value: string) {
    this.contents = value;
    return this;
  }
}
```

Here, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now letâ€™s make a subclass of `Box`:
```ts
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();

// const b: ClearableBox
const b = a.set("hello");
```

You can also use `this` in a parameter type annotation:
```ts
class Box {
  content: string = "";

  sameAs(other: this) {
    return other.content === this.content;
  }
}
```

This is different from writing `other: Box` â€” if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:
```ts
class Box {
  content: string = "";

  sameAs(other: this) {
    return other.content === this.content;
  }
}

class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();

// Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
// Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.
derived.sameAs(base);
```

#### `this`-based type guards
You can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.
```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  isNetworked(): this is Networked & this {
    return this.networked;
  }

  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {

  // const fso: FileRep
  fso.content;

} else if (fso.isDirectory()) {

  // const fso: Directory
  fso.children;

} else if (fso.isNetworked()) {

  // const fso: Networked & FileSystemObject
  fso.host;
}
```

A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:
```ts
class Box<T> {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box<string>();
box.value = "Gameboy";

// (property) Box<string>.value?: string
box.value;

if (box.hasValue()) {

  // (property) value: string
  box.value;
}
```

<br />

## Parameter Properties
TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):
```ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);

// (property) Params.x: number
console.log(a.x);

// Property 'z' is private and only accessible within class 'Params'.
console.log(a.z);
```

<br />

## Class Expressions
Class expressions are very similar to class declarations. The only real difference is that class expressions donâ€™t need a name, though we can refer to them via whatever identifier they ended up bound to:
```ts
const someClass = class<Type> {
  content: Type;
  constructor(value: Type) {
    this.content = value;
  }
};

// const m: someClass<string>
const m = new someClass("Hello, world");
```

<br />

## Constructor Signatures
JavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the `InstanceType` utility type models this operation.
```ts
class Point {
  createdAt: number;
  x: number;
  y: number

  constructor(x: number, y: number) {
    this.createdAt = Date.now()
    this.x = x;
    this.y = y;
  }
}
type PointInstance = InstanceType<typeof Point>

function moveRight(point: PointInstance) {
  point.x += 5;
}

const point = new Point(3, 4);
moveRight(point);
point.x; // => 8
```

<br />

## `abstract` Classes and Members
Classes, methods, and fields in TypeScript may be abstract.

An abstract method or abstract field is one that hasnâ€™t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.

The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesnâ€™t have any abstract members, it is said to be concrete.

Letâ€™s look at an example:
```ts
abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hello, " + this.getName());
  }
}

// Cannot create an instance of an abstract class.
const b = new Base();
```

We canâ€™t instantiate `Base` with `new` because itâ€™s abstract. Instead, we need to make a derived class and implement the abstract members:
```ts
class Derived extends Base {
  getName() {
    return "world";
  }
}

const d = new Derived();
d.printName();
```

Notice that if we forget to implement the base classâ€™s abstract members, weâ€™ll get an error:
```ts
// Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
class Derived extends Base {
  // forgot to do anything
}
```

#### Abstract Construct Signatures
Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.

For example, you might want to write this code:
```ts
function greet(ctor: typeof Base) {

  // Cannot create an instance of an abstract class.
  const instance = new ctor();

  instance.printName();
}
```

TypeScript is correctly telling you that youâ€™re trying to instantiate an abstract class. After all, given the definition of `greet`, itâ€™s perfectly legal to write this code, which would end up constructing an abstract class:
```ts
// Bad!
greet(Base);
```

Instead, you want to write a function that accepts something with a construct signature:
```ts
function greet(ctor: new () => Base) {
  const instance = new ctor();
  instance.printName();
}
greet(Derived);

// Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
// Cannot assign an abstract constructor type to a non-abstract constructor type.
greet(Base);
```

Now TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because itâ€™s concrete, but `Base` cannot.

<br />

## Relationships Between Classes
In most cases, classes in TypeScript are compared structurally, the same as other types.

For example, these two classes can be used in place of each other because theyâ€™re identical:
```ts
class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

// OK
const p: Point1 = new Point2();
```

Similarly, subtype relationships between classes exist even if thereâ€™s no explicit inheritance:
```ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

// OK
const p: Person = new Employee();
```

This sounds straightforward, but there are a few cases that seem stranger than others.

Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (donâ€™t!), anything can be used in place of it:
```ts
class Empty {}

function fn(x: Empty) {
  // can't do anything with 'x', so I won't
}

// All OK!
fn(window);
fn({});
fn(fn);
```

<br />

## ì¶”ê°€

í´ë˜ìŠ¤ëŠ” ê·¸ ìì²´ë¡œëŠ” (newì™€ í•¨ê»˜ í˜¸ì¶œë˜ì–´ì•¼ í•˜ëŠ”) íŠ¹ë³„í•œ í•¨ìˆ˜ì§€ë§Œ, ì´ë²ˆì—ëŠ” í´ë˜ìŠ¤ ë³¸ë¬¸ì—ì„œ í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ ì •ì˜ë˜ëŠ”ì§€ ì´ì•¼ê¸°í•  ê²ƒì´ë‹¤. í´ë˜ìŠ¤ ë³¸ë¬¸ ì•ˆì—ì„œ ê°€ì¥ í”í•œ í˜•íƒœì˜ í•¨ìˆ˜ ì˜ˆì œë‹¤.
```ts
class MathUtils {
  sum(a: number, b: number): number {
    return a + b;
  }
}

const math = new MathUtils();
math.sum(1, 2);
```

ì´ í´ë˜ìŠ¤ì˜ ì–´ë–¤ ì¸ìŠ¤í„´ìŠ¤ì— ë°”ì¸ë”©í•˜ê³  ì‹¶ì€ í•¨ìˆ˜ê°€ ìˆë‹¤ë©´ í´ë˜ìŠ¤ í•„ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆë‹¤.
```ts
class MathUtils {
  sum = (a: number, b: number): number => {
    return a + b;
  };
}

// ë‹¤ìŒê³¼ ê°™ì´ í•˜ë©´ ê·¸ë ‡ê²Œ í•  ìˆ˜ ìˆë‹¤.
const math = new MathUtils();
const sum = math.sum;
sum(1, 2);

// ê·¸ëŸ¬ë‚˜ ì¼ë°˜ì ì¸ ê°ì²´ì˜ ì†ì„±ì— ëŒ€í•´ì„œ í´ë˜ìŠ¤ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì€ ëŒ€ë¶€ë¶„ì˜ ì„±ëŠ¥ í–¥ìƒì„ ìƒì‡„ì‹œì¼œ ë²„ë¦´ ìˆ˜ ìˆë‹¤.
```

ê·¸ëŸ¬ë©´ íƒ€ì…ì„ ì •ì˜í•´ ë³´ì. ì²« ë²ˆì§¸ ì˜ˆì œì˜ ë©”ì„œë“œì˜ íƒ€ì… ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
```ts
interface MathUtilsInterface {
  sum(a: number, b: number): number;
}

class MathUtils implements MathUtilsInterface {
  sum(a: number, b: number): number {
    return a + b;
  }
}
```

í¥ë¯¸ë¡­ê²Œë„, ìƒì† êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ì¼ë¶€ì„ì—ë„ ë¶ˆêµ¬í•˜ê³  ì—¬ì „íˆ ê·¸ í•¨ìˆ˜ë¥¼ ìœ„í•œ íƒ€ì…ì„ ì •ì˜í•´ì•¼ í•œë‹¤ğŸ¤” ğŸ¤·â€â™‚ï¸.

ë§ˆì§€ë§‰ìœ¼ë¡œ ì•Œì•„ì•¼ í•  ê²ƒì´ë‹¤. íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” publicê³¼ private, protectedë¥¼ ì“¸ ìˆ˜ ìˆë‹¤. ê°œì¸ì ìœ¼ë¡œëŠ” í´ë˜ìŠ¤ë¥¼ ì˜ ì“°ì§€ ì•Šê³  ì´ë“¤ì„ ìœ„í•œ íŠ¹ì • íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ê¸°ëŠ¥ì„ ì¢‹ì•„í•˜ì§€ ì•ŠëŠ”ë‹¤.  ìë°”ìŠ¤í¬ë¦½íŠ¸ì— private ë©¤ë²„ë¥¼ ìœ„í•œ ê¹”ë”í•˜ë©´ì„œë„ íŠ¹ë³„í•œ ë¬¸ë²•ì´ ë‚˜ì˜¬ ê²ƒì´ë‹¤(ë” ë°°ì›Œë³´ê¸°).
