## Static ë©¤ë²„

##### í´ë˜ìŠ¤ ìƒì„±ì ê°ì²´ ìì²´
- ì¸ìŠ¤í„´ìŠ¤ X
```ts
class MyClass {
  static x = 0;

  static printX() {
    console.log(MyClass.x);
  }
}

console.log(MyClass.x);
MyClass.printX();
```

##### ê°€ì‹œì„± ì œí•œì
- `public`
- `protected`
- `private`
```ts
class MyClass {
  private static x = 0;
}

// ì—ëŸ¬ ë°œìƒ
// - Property 'x' is private and only accessible within class 'MyClass'.
console.log(MyClass.x);
```

##### ìƒì†
```ts
class Base {
  static getGreeting() {
    return "Hello world";
  }
}

class Derived extends Base {
  myGreeting = Derived.getGreeting();
}
```

#### íŠ¹ë³„ Static ì´ë¦„

##### `Function` í”„ë¡œí† íƒ€ì… ë‚´ í”„ë¡œí¼í‹°
- ê°’ ë®ì–´ì“°ê¸°
  - ë¶ˆì•ˆì „
  - ë¶ˆê°€ëŠ¥
- í´ë˜ìŠ¤ == í•¨ìˆ˜ <sub>(`new` í•¨ê»˜ í˜¸ì¶œ ê°€ëŠ¥)</sub>
  - íŠ¹ì • `static` ì´ë¦„ ì‚¬ìš© X
- `static` ì •ì˜ ë¶ˆê°€ëŠ¥ ë©¤ë²„
  - `name`
  - `length`
  - `call`
  - ê¸°íƒ€ ë“±ë“±
```ts
class S {

  // ì—ëŸ¬ ë°œìƒ
  // - Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
  static name = "S!";
}
```

#### Static í´ë˜ìŠ¤ X

##### JS Â· TS
- `static class` ë¬¸ë²• X
  - ìµœìƒìœ„ í•¨ìˆ˜
  - ê°ì²´ ë¦¬í„°ëŸ´
```ts
// static class ë¶ˆí•„ìš”
class MyStaticClass {
  static doSomething() {}
}

// ìµœìƒìœ„ í•¨ìˆ˜ (ëŒ€ì•ˆ 1)
function doSomething() {}

// ê°ì²´ ë¦¬í„°ëŸ´ (ëŒ€ì•ˆ 2)
const MyHelperObject = {
  dosomething() {},
};
```

<br />

## í´ë˜ìŠ¤ ë‚´ `static` ë¸”ë¡

##### `static` ë¸”ë¡
- `static` ì»¨í…ìŠ¤íŠ¸ ì ‘ê·¼ <sub>(í´ë˜ìŠ¤ ì„ ì–¸ ì‹œì )</sub>
  - `static` ì½”ë“œ ì‘ì„±
  - `static` í•„ë“œ ì´ˆê¸°í™”
  - í´ë˜ìŠ¤ ë‚´ë¶€ ëª¨ë“  ì ‘ê·¼ ê°€ëŠ¥
```ts
class Foo {
  static #count = 0;

  get count() {
    return Foo.#count;
  }

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    }
    catch {}
  }
}
```

<br />

## ì œë„¤ë¦­ í´ë˜ìŠ¤

##### ì¸ìŠ¤í„´ìŠ¤í™” <sub>(`new` ì—°ì‚°ì)</sub>
- í´ë˜ìŠ¤ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì¶”ë¡ 
  - í•¨ìˆ˜ í˜¸ì¶œ ë™ì¼ ë°©ì‹
- íƒ€ì… ë§¤ê°œë³€ìˆ˜
  - ì œì•½
  - ê¸°ë³¸ê°’
```ts
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }
}

// const b: Box<string>
const b = new Box("hello!");
```

#### `static` ë©¤ë²„ íƒ€ì… ë§¤ê°œë³€ìˆ˜ X

##### `static` ë©¤ë²„
- í´ë˜ìŠ¤ íƒ€ì… ë§¤ê°œë³€ìˆ˜ ì°¸ì¡° X
```ts
class Box<Type> {

  // ì—ëŸ¬ ë°œìƒ
  // - Static members cannot reference class type parameters.
  static defaultValue: Type;
}
```

<br />

## ëŸ°íƒ€ì„ ì‹œ í´ë˜ìŠ¤ ë‚´ `this`

##### TS
- ëŸ°íƒ€ì„ ì‹œ JS í–‰ë™ ë³€ê²½ X

##### JS `this` ì²˜ë¦¬
- íŠ¹ì´í•¨
```js
class MyClass {
  name = "MyClass";

  getName() {
    return this.name;
  }
}

const c = new MyClass();
const obj = {
  name: "obj",
  getName: c.getName,
};

// "obj"
// "MyClass" X
console.log(obj.getName());
```

##### ëŸ°íƒ€ì„ ì‹œ `this` ê°’
- í•¨ìˆ˜ ë‚´ `this` ê°’
  - í•¨ìˆ˜ í˜¸ì¶œ ë°©ì‹ ë”°ë¼ ê²°ì •
- ex\) `obj.getName()`
  - `obj` ì°¸ì¡° í†µí•´ í˜¸ì¶œ
    - `this` == `obj`

#### í™”ì‚´í‘œ í•¨ìˆ˜

##### `this` ì»¨í…ìŠ¤íŠ¸ X
- ì™¸ë¶€ `this` ê°’ ì´ìš©
  - í´ë˜ìŠ¤ ë‚´ `this` <sub>(ì¸ìŠ¤í„´ìŠ¤)</sub>
```ts
class MyClass {
  name = "MyClass";

  getName = () => {
    return this.name;
  };
}

const c = new MyClass();
const g = c.getName;

// "MyClass"
// - ì—ëŸ¬ ë°œìƒ X
console.log(g());
```

##### ì¥ë‹¨ì  <sub>(â†” `this` ë§¤ê°œë³€ìˆ˜)</sub>
- ëŸ°íƒ€ì„ ì‹œ ì˜¬ë°”ë¥¸ `this` ê°’ í•­ìƒ ë³´ì¥
  - ìˆœìˆ˜ JS ì½”ë“œ ì‘ë™
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â†‘
  - ê° ì¸ìŠ¤í„´ìŠ¤ í•¨ìˆ˜ í• ë‹¹
- `super` <sub>(í‚¤ì›Œë“œ)</sub> X <sub>(í•˜ìœ„ í´ë˜ìŠ¤)</sub>
  - í”„ë¡œí† íƒ€ì… ë‚´ ë¶€ì¬

#### `this` ë§¤ê°œë³€ìˆ˜

##### 1ë²ˆì§¸ `this` ë§¤ê°œë³€ìˆ˜ <sub>(TS í•¨ìˆ˜ Â· ë©”ì„œë“œ)</sub>
- ì»´íŒŒì¼ ì‹œ ì œê±°
```ts
// TS
function fn(this: SomeType, x: number) { â€¦ }

â†“â†“â†“

// JS
function fn(x) { â€¦ }
```

##### í•¨ìˆ˜ í˜¸ì¶œ ì‹œ `this` ì»¨í…ìŠ¤íŠ¸ ì²´í¬
- ë©”ì„œë“œ ë‚´ `this` íƒ€ì… ì •ì  ê°•ì œ
  - `this` ê°’ í˜¼ë™ ë°©ì§€
```ts
class MyClass {
  name = "MyClass";

  getName(this: MyClass) {
    return this.name;
  }
}

const c = new MyClass();
c.getName();

const g = c.getName;

// ì—ëŸ¬ ë°œìƒ
// - The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.
console.log(g());
```

##### ì¥ë‹¨ì  <sub>(â†” í™”ì‚´í‘œ í•¨ìˆ˜)</sub>
- ëŸ°íƒ€ì„ ì‹œ ì˜ëª»ëœ `this` ê°’ ê°€ëŠ¥
  - JS í˜¸ì¶œì
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â†“
  - í´ë˜ìŠ¤ ë‹¹ í•¨ìˆ˜ 1ê°œ í• ë‹¹
- `super` <sub>(í‚¤ì›Œë“œ)</sub> ê°€ëŠ¥ <sub>(í•˜ìœ„ í´ë˜ìŠ¤)</sub>
  - í”„ë¡œí† íƒ€ì… ë‚´ æœ‰

<br />

## `this` íƒ€ì…

##### í´ë˜ìŠ¤ ë‚´ `this` <sub>(íŠ¹ìˆ˜ íƒ€ì…)</sub>
- í˜„ì¬ í´ë˜ìŠ¤ ë™ì  ì°¸ì¡°
```ts
class Box {
  contents: string = "";

  /* Box.set(value: string): this
   ë©”ì„œë“œ ë°˜í™˜ íƒ€ì… ì¶”ë¡ 
   - Box  (X)
   - this (O)
   */
  set(value: string) {
    this.contents = value;
    return this;
  }
}
```

##### `Box` í•˜ìœ„ í´ë˜ìŠ¤ ë‚´ í•´ë‹¹ ìƒì† ë©”ì„œë“œ <sub>(`this` ë°˜í™˜)</sub>
- í•˜ìœ„ í´ë˜ìŠ¤ íƒ€ì… ë°˜í™˜
```ts
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();

// const b: ClearableBox
const b = a.set("hello");
```

##### ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ íƒ€ì… ì£¼ì„
- í•˜ìœ„ í´ë˜ìŠ¤ ë‚´ í•´ë‹¹ ìƒì† ë©”ì„œë“œ
  - í•´ë‹¹ í´ë˜ìŠ¤ íƒ€ì…ë§Œ í—ˆìš©
```ts
class Box {
  content: string = "";

  // this (íƒ€ì…) ë§¤ê°œë³€ìˆ˜
  sameAsThis(other: this) {
    return other.content === this.content;
  }

  // Box (íƒ€ì…) ë§¤ê°œë³€ìˆ˜
  sameAsBox(other: Box) {
    return other.content === this.content;
  }
}

class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();

// ì—ëŸ¬ ë°œìƒ
// - Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
//   - Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.
derived.sameAsThis(base);

// ì—ëŸ¬ ë°œìƒ X
derived.sameAsBox(base);
```

#### `this`-based type guards
You can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.
```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  isNetworked(): this is Networked & this {
    return this.networked;
  }

  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {

  // const fso: FileRep
  fso.content;

} else if (fso.isDirectory()) {

  // const fso: Directory
  fso.children;

} else if (fso.isNetworked()) {

  // const fso: Networked & FileSystemObject
  fso.host;
}
```

A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:
```ts
class Box<T> {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box<string>();
box.value = "Gameboy";

// (property) Box<string>.value?: string
box.value;

if (box.hasValue()) {

  // (property) value: string
  box.value;
}
```

<br />

## Parameter Properties
TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):
```ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);

// (property) Params.x: number
console.log(a.x);

// Property 'z' is private and only accessible within class 'Params'.
console.log(a.z);
```

<br />

## Class Expressions
Class expressions are very similar to class declarations. The only real difference is that class expressions donâ€™t need a name, though we can refer to them via whatever identifier they ended up bound to:
```ts
const someClass = class<Type> {
  content: Type;
  constructor(value: Type) {
    this.content = value;
  }
};

// const m: someClass<string>
const m = new someClass("Hello, world");
```

<br />

## Constructor Signatures
JavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the `InstanceType` utility type models this operation.
```ts
class Point {
  createdAt: number;
  x: number;
  y: number

  constructor(x: number, y: number) {
    this.createdAt = Date.now()
    this.x = x;
    this.y = y;
  }
}
type PointInstance = InstanceType<typeof Point>

function moveRight(point: PointInstance) {
  point.x += 5;
}

const point = new Point(3, 4);
moveRight(point);
point.x; // => 8
```

<br />

## `abstract` Classes and Members
Classes, methods, and fields in TypeScript may be abstract.

An abstract method or abstract field is one that hasnâ€™t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.

The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesnâ€™t have any abstract members, it is said to be concrete.

Letâ€™s look at an example:
```ts
abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hello, " + this.getName());
  }
}

// Cannot create an instance of an abstract class.
const b = new Base();
```

We canâ€™t instantiate `Base` with `new` because itâ€™s abstract. Instead, we need to make a derived class and implement the abstract members:
```ts
class Derived extends Base {
  getName() {
    return "world";
  }
}

const d = new Derived();
d.printName();
```

Notice that if we forget to implement the base classâ€™s abstract members, weâ€™ll get an error:
```ts
// Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
class Derived extends Base {
  // forgot to do anything
}
```

#### Abstract Construct Signatures
Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.

For example, you might want to write this code:
```ts
function greet(ctor: typeof Base) {

  // Cannot create an instance of an abstract class.
  const instance = new ctor();

  instance.printName();
}
```

TypeScript is correctly telling you that youâ€™re trying to instantiate an abstract class. After all, given the definition of `greet`, itâ€™s perfectly legal to write this code, which would end up constructing an abstract class:
```ts
// Bad!
greet(Base);
```

Instead, you want to write a function that accepts something with a construct signature:
```ts
function greet(ctor: new () => Base) {
  const instance = new ctor();
  instance.printName();
}
greet(Derived);

// Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
// Cannot assign an abstract constructor type to a non-abstract constructor type.
greet(Base);
```

Now TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because itâ€™s concrete, but `Base` cannot.

<br />

## Relationships Between Classes
In most cases, classes in TypeScript are compared structurally, the same as other types.

For example, these two classes can be used in place of each other because theyâ€™re identical:
```ts
class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

// OK
const p: Point1 = new Point2();
```

Similarly, subtype relationships between classes exist even if thereâ€™s no explicit inheritance:
```ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

// OK
const p: Person = new Employee();
```

This sounds straightforward, but there are a few cases that seem stranger than others.

Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (donâ€™t!), anything can be used in place of it:
```ts
class Empty {}

function fn(x: Empty) {
  // can't do anything with 'x', so I won't
}

// All OK!
fn(window);
fn({});
fn(fn);
```

<br />

## ì¶”ê°€

í´ë˜ìŠ¤ëŠ” ê·¸ ìì²´ë¡œëŠ” (newì™€ í•¨ê»˜ í˜¸ì¶œë˜ì–´ì•¼ í•˜ëŠ”) íŠ¹ë³„í•œ í•¨ìˆ˜ì§€ë§Œ, ì´ë²ˆì—ëŠ” í´ë˜ìŠ¤ ë³¸ë¬¸ì—ì„œ í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ ì •ì˜ë˜ëŠ”ì§€ ì´ì•¼ê¸°í•  ê²ƒì´ë‹¤. í´ë˜ìŠ¤ ë³¸ë¬¸ ì•ˆì—ì„œ ê°€ì¥ í”í•œ í˜•íƒœì˜ í•¨ìˆ˜ ì˜ˆì œë‹¤.
```ts
class MathUtils {
  sum(a: number, b: number): number {
    return a + b;
  }
}

const math = new MathUtils();
math.sum(1, 2);
```

ì´ í´ë˜ìŠ¤ì˜ ì–´ë–¤ ì¸ìŠ¤í„´ìŠ¤ì— ë°”ì¸ë”©í•˜ê³  ì‹¶ì€ í•¨ìˆ˜ê°€ ìˆë‹¤ë©´ í´ë˜ìŠ¤ í•„ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆë‹¤.
```ts
class MathUtils {
  sum = (a: number, b: number): number => {
    return a + b;
  };
}

// ë‹¤ìŒê³¼ ê°™ì´ í•˜ë©´ ê·¸ë ‡ê²Œ í•  ìˆ˜ ìˆë‹¤.
const math = new MathUtils();
const sum = math.sum;
sum(1, 2);

// ê·¸ëŸ¬ë‚˜ ì¼ë°˜ì ì¸ ê°ì²´ì˜ ì†ì„±ì— ëŒ€í•´ì„œ í´ë˜ìŠ¤ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì€ ëŒ€ë¶€ë¶„ì˜ ì„±ëŠ¥ í–¥ìƒì„ ìƒì‡„ì‹œì¼œ ë²„ë¦´ ìˆ˜ ìˆë‹¤.
```

ê·¸ëŸ¬ë©´ íƒ€ì…ì„ ì •ì˜í•´ ë³´ì. ì²« ë²ˆì§¸ ì˜ˆì œì˜ ë©”ì„œë“œì˜ íƒ€ì… ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
```ts
interface MathUtilsInterface {
  sum(a: number, b: number): number;
}

class MathUtils implements MathUtilsInterface {
  sum(a: number, b: number): number {
    return a + b;
  }
}
```

í¥ë¯¸ë¡­ê²Œë„, ìƒì† êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ì¼ë¶€ì„ì—ë„ ë¶ˆêµ¬í•˜ê³  ì—¬ì „íˆ ê·¸ í•¨ìˆ˜ë¥¼ ìœ„í•œ íƒ€ì…ì„ ì •ì˜í•´ì•¼ í•œë‹¤ğŸ¤” ğŸ¤·â€â™‚ï¸.

ë§ˆì§€ë§‰ìœ¼ë¡œ ì•Œì•„ì•¼ í•  ê²ƒì´ë‹¤. íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” publicê³¼ private, protectedë¥¼ ì“¸ ìˆ˜ ìˆë‹¤. ê°œì¸ì ìœ¼ë¡œëŠ” í´ë˜ìŠ¤ë¥¼ ì˜ ì“°ì§€ ì•Šê³  ì´ë“¤ì„ ìœ„í•œ íŠ¹ì • íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ê¸°ëŠ¥ì„ ì¢‹ì•„í•˜ì§€ ì•ŠëŠ”ë‹¤.  ìë°”ìŠ¤í¬ë¦½íŠ¸ì— private ë©¤ë²„ë¥¼ ìœ„í•œ ê¹”ë”í•˜ë©´ì„œë„ íŠ¹ë³„í•œ ë¬¸ë²•ì´ ë‚˜ì˜¬ ê²ƒì´ë‹¤(ë” ë°°ì›Œë³´ê¸°).
