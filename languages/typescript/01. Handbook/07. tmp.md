## Static Members
Classes may have `static` members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:
```ts
class MyClass {
  static x = 0;

  static printX() {
    console.log(MyClass.x);
  }
}

console.log(MyClass.x);
MyClass.printX();
```
Static members can also use the same `public`, `protected`, and `private` visibility modifiers:
```ts
class MyClass {
  private static x = 0;
}

// Property 'x' is private and only accessible within class 'MyClass'.
console.log(MyClass.x);
```

Static members are also inherited:
```ts
class Base {
  static getGreeting() {
    return "Hello world";
  }
}

class Derived extends Base {
  myGreeting = Derived.getGreeting();
}
```

#### Special Static Names
It’s generally not safe/possible to overwrite properties from the `Function` prototype. Because classes are themselves functions that can be invoked with `new`, certain `static` names can’t be used. Function properties like `name`, `length`, and `call` aren’t valid to define as `static` members:
```ts
class S {

  // Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
  static name = "S!";
}
```

#### Why No Static Classes?
TypeScript (and JavaScript) don’t have a construct called `static class` the same way as, for example, C# does.

Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript.

For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:
```ts
// Unnecessary "static" class
class MyStaticClass {
  static doSomething() {}
}

// Preferred (alternative 1)
function doSomething() {}

// Preferred (alternative 2)
const MyHelperObject = {
  dosomething() {},
};
```

<br />

## static Blocks in Classes
Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.
```ts
class Foo {
  static #count = 0;

  get count() {
    return Foo.#count;
  }

  static {
    try {
      const lastInstances = loadLastInstances();
      Foo.#count += lastInstances.length;
    }
    catch {}
  }
}
```

<br />

## Generic Classes
Classes, much like interfaces, can be generic. When a generic class is instantiated with `new`, its type parameters are inferred the same way as in a function call:
```ts
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }
}

// const b: Box<string>
const b = new Box("hello!");
```

Classes can use generic constraints and defaults the same way as interfaces.

#### Type Parameters in Static Members
This code isn’t legal, and it may not be obvious why:
```ts
class Box<Type> {

  // Static members cannot reference class type parameters.
  static defaultValue: Type;
}
```

Remember that types are always fully erased! At runtime, there’s only one `Box.defaultValue` property slot. This means that setting `Box<string>.defaultValue` (if that were possible) would also change `Box<number>.defaultValue` - not good. The `static` members of a generic class can never refer to the class’s type parameters.

<br />

## `this` at Runtime in Classes
It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.

JavaScript’s handling of `this` is indeed unusual:
```ts
class MyClass {
  name = "MyClass";

  getName() {
    return this.name;
  }
}

const c = new MyClass();
const obj = {
  name: "obj",
  getName: c.getName,
};

// Prints "obj", not "MyClass"
console.log(obj.getName());
```

Long story short, by default, the value of `this` inside a function depends on how the function was called. In this example, because the function was called through the `obj` reference, its value of `this` was `obj` rather than the class instance.

This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.

#### Arrow Functions
If you have a function that will often be called in a way that loses its `this` context, it can make sense to use an arrow function property instead of a method definition:
```ts
class MyClass {
  name = "MyClass";

  getName = () => {
    return this.name;
  };
}

const c = new MyClass();
const g = c.getName;

// Prints "MyClass" instead of crashing
console.log(g());
```

This has some trade-offs:
- The `this` value is guaranteed to be correct at runtime, even for code not checked with TypeScript
- This will use more memory, because each class instance will have its own copy of each function defined this way
- You can’t use `super.getName` in a derived class, because there’s no entry in the prototype chain to fetch the base class method from

#### `this` parameters
In a method or function definition, an initial parameter named `this` has special meaning in TypeScript. These parameters are erased during compilation:
```ts
// TypeScript input with 'this' parameter
function fn(this: SomeType, x: number) {
  /* ... */
}
```
```ts
// JavaScript output
function fn(x) {
  /* ... */
}
```

TypeScript checks that calling a function with a `this` parameter is done so with a correct context. Instead of using an arrow function, we can add a `this` parameter to method definitions to statically enforce that the method is called correctly:
```ts
class MyClass {
  name = "MyClass";

  getName(this: MyClass) {
    return this.name;
  }
}

const c = new MyClass();
// OK
c.getName();

// Error, would crash
const g = c.getName;

// The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.
console.log(g());
```

This method makes the opposite trade-offs of the arrow function approach:
- JavaScript callers might still use the class method incorrectly without realizing it
- Only one function per class definition gets allocated, rather than one per class instance
- Base method definitions can still be called via `super`.

<br />

## `this` Types
In classes, a special type called `this` refers dynamically to the type of the current class. Let’s see how this is useful:
```ts
class Box {
  contents: string = "";

  // (method) Box.set(value: string): this
  set(value: string) {
    this.contents = value;
    return this;
  }
}
```

Here, TypeScript inferred the return type of `set` to be `this`, rather than `Box`. Now let’s make a subclass of `Box`:
```ts
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();

// const b: ClearableBox
const b = a.set("hello");
```

You can also use `this` in a parameter type annotation:
```ts
class Box {
  content: string = "";

  sameAs(other: this) {
    return other.content === this.content;
  }
}
```

This is different from writing `other: Box` — if you have a derived class, its `sameAs` method will now only accept other instances of that same derived class:
```ts
class Box {
  content: string = "";

  sameAs(other: this) {
    return other.content === this.content;
  }
}

class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();

// Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
// Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.
derived.sameAs(base);
```

#### `this`-based type guards
You can use `this is Type` in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. `if` statements) the type of the target object would be narrowed to the specified `Type`.
```ts
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  isNetworked(): this is Networked & this {
    return this.networked;
  }

  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {

  // const fso: FileRep
  fso.content;

} else if (fso.isDirectory()) {

  // const fso: Directory
  fso.children;

} else if (fso.isNetworked()) {

  // const fso: Networked & FileSystemObject
  fso.host;
}
```

A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an `undefined` from the value held inside box when `hasValue` has been verified to be true:
```ts
class Box<T> {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box<string>();
box.value = "Gameboy";

// (property) Box<string>.value?: string
box.value;

if (box.hasValue()) {

  // (property) value: string
  box.value;
}
```

<br />

## Parameter Properties
TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers `public`, `private`, `protected`, or `readonly`. The resulting field gets those modifier(s):
```ts
class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);

// (property) Params.x: number
console.log(a.x);

// Property 'z' is private and only accessible within class 'Params'.
console.log(a.z);
```

<br />

## Class Expressions
Class expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:
```ts
const someClass = class<Type> {
  content: Type;
  constructor(value: Type) {
    this.content = value;
  }
};

// const m: someClass<string>
const m = new someClass("Hello, world");
```

<br />

## Constructor Signatures
JavaScript classes are instantiated with the `new` operator. Given the type of a class itself, the `InstanceType` utility type models this operation.
```ts
class Point {
  createdAt: number;
  x: number;
  y: number

  constructor(x: number, y: number) {
    this.createdAt = Date.now()
    this.x = x;
    this.y = y;
  }
}
type PointInstance = InstanceType<typeof Point>

function moveRight(point: PointInstance) {
  point.x += 5;
}

const point = new Point(3, 4);
moveRight(point);
point.x; // => 8
```

<br />

## `abstract` Classes and Members
Classes, methods, and fields in TypeScript may be abstract.

An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.

The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.

Let’s look at an example:
```ts
abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hello, " + this.getName());
  }
}

// Cannot create an instance of an abstract class.
const b = new Base();
```

We can’t instantiate `Base` with `new` because it’s abstract. Instead, we need to make a derived class and implement the abstract members:
```ts
class Derived extends Base {
  getName() {
    return "world";
  }
}

const d = new Derived();
d.printName();
```

Notice that if we forget to implement the base class’s abstract members, we’ll get an error:
```ts
// Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.
class Derived extends Base {
  // forgot to do anything
}
```

#### Abstract Construct Signatures
Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.

For example, you might want to write this code:
```ts
function greet(ctor: typeof Base) {

  // Cannot create an instance of an abstract class.
  const instance = new ctor();

  instance.printName();
}
```

TypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of `greet`, it’s perfectly legal to write this code, which would end up constructing an abstract class:
```ts
// Bad!
greet(Base);
```

Instead, you want to write a function that accepts something with a construct signature:
```ts
function greet(ctor: new () => Base) {
  const instance = new ctor();
  instance.printName();
}
greet(Derived);

// Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.
// Cannot assign an abstract constructor type to a non-abstract constructor type.
greet(Base);
```

Now TypeScript correctly tells you about which class constructor functions can be invoked - `Derived` can because it’s concrete, but `Base` cannot.

<br />

## Relationships Between Classes
In most cases, classes in TypeScript are compared structurally, the same as other types.

For example, these two classes can be used in place of each other because they’re identical:
```ts
class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

// OK
const p: Point1 = new Point2();
```

Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:
```ts
class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

// OK
const p: Person = new Employee();
```

This sounds straightforward, but there are a few cases that seem stranger than others.

Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:
```ts
class Empty {}

function fn(x: Empty) {
  // can't do anything with 'x', so I won't
}

// All OK!
fn(window);
fn({});
fn(fn);
```

<br />

## 추가

클래스는 그 자체로는 (new와 함께 호출되어야 하는) 특별한 함수지만, 이번에는 클래스 본문에서 함수가 어떻게 정의되는지 이야기할 것이다. 클래스 본문 안에서 가장 흔한 형태의 함수 예제다.
```ts
class MathUtils {
  sum(a: number, b: number): number {
    return a + b;
  }
}

const math = new MathUtils();
math.sum(1, 2);
```

이 클래스의 어떤 인스턴스에 바인딩하고 싶은 함수가 있다면 클래스 필드를 사용할 수도 있다.
```ts
class MathUtils {
  sum = (a: number, b: number): number => {
    return a + b;
  };
}

// 다음과 같이 하면 그렇게 할 수 있다.
const math = new MathUtils();
const sum = math.sum;
sum(1, 2);

// 그러나 일반적인 객체의 속성에 대해서 클래스로 사용하는 방식은 대부분의 성능 향상을 상쇄시켜 버릴 수 있다.
```

그러면 타입을 정의해 보자. 첫 번째 예제의 메서드의 타입 정의는 다음과 같다.
```ts
interface MathUtilsInterface {
  sum(a: number, b: number): number;
}

class MathUtils implements MathUtilsInterface {
  sum(a: number, b: number): number {
    return a + b;
  }
}
```

흥미롭게도, 상속 구현해야 하는 인터페이스의 일부임에도 불구하고 여전히 그 함수를 위한 타입을 정의해야 한다🤔 🤷‍♂️.

마지막으로 알아야 할 것이다. 타입스크립트에서는 public과 private, protected를 쓸 수 있다. 개인적으로는 클래스를 잘 쓰지 않고 이들을 위한 특정 타입스크립트 기능을 좋아하지 않는다.  자바스크립트에 private 멤버를 위한 깔끔하면서도 특별한 문법이 나올 것이다(더 배워보기).
