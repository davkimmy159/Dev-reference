템플렛 리터럴 타입
======================

##### 문자열 상수 타입 기반
- `union` <sub>(타입)</sub> 이용해 확장
- 보통 대량 문자열 `union` <sub>(타입)</sub> 생성 시 권장
  - 일부 소량 케이스 적절

##### 템플릿 리터럴 문자열 <sub>(JS)</sub> 문법 유사 · 차이점
- 타입 위치 사용
- 상수 타입 함께 사용 시
  - 내용 조합해 새 문자열 상수 타입 생성
```ts
type World = "world";

// type Greeting = "hello world"
type Greeting = `hello ${World}`;
```

##### 중간 삽입 위치
- `union` <sub>(타입)</sub> 내 모든 조합 가능 멤버
```ts
type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";

/*
type AllLocaleIDs =
    "welcome_email_id"
  | "email_heading_id"
  | "footer_title_id"
  | "footer_sendoff_id"
 */
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
```
```ts
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
type Lang = "en" | "ja" | "pt";

/*
type LocaleMessageIDs =
   "en_welcome_email_id"
 | "en_email_heading_id"
 | "en_footer_title_id"
 | "en_footer_sendoff_id"
 | "ja_welcome_email_id"
 | "ja_email_heading_id"
 | "ja_footer_title_id"
 | "ja_footer_sendoff_id"
 | "pt_welcome_email_id"
 | "pt_email_heading_id"
 | "pt_footer_title_id"
 | "pt_footer_sendoff_id"
 */
type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
```

#### 타입 내 문자열 `union` <sub>(타입)</sub>
- 타입 내 정보 기반 새 문자열 타입 정의 시 유용

##### `makeWatchedObject` <sub>(함수)</sub>
- 전달 객체 내 `on()` <sub>(함수)</sub> 추가
```js
makeWatchedObject(baseObject);
```
- 전달 객체 형태
```ts
const passedObject = {
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26,
};
```

##### `eventName` <sub>(`on()` 함수 1번째 인수 · 문자열)</sub>
- `${객체 프로퍼티} + "Changed"` <sub>(형태)</sub>
  - ex\) `firstNameChanged` <sub>(`firstName`)</sub>

##### `callback` <sub>(`on()` 함수 2번째 인수 · 콜백 함수)</sub>


The `callback` function, when called:
- Should be passed a value of the type associated with the name
`attributeInThePassedObject`; thus, since `firstName` is typed as `string`, the callback for the `firstNameChanged` event expects a `string` to be passed to it at call time. Similarly events associated with `age` should expect to be called with a `number` argument
- Should have `void` return type (for simplicity of demonstration)

The naive function signature of `on()` might thus be: `on(eventName: string, callback: (newValue: any) => void)`. However, in the preceding description, we identified important type constraints that we’d like to document in our code. Template Literal types let us bring these constraints into our code.
```ts
const person = makeWatchedObject({
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26,
});

// makeWatchedObject has added `on` to the anonymous Object

person.on("firstNameChanged", (newValue) => {
  console.log(`firstName was changed to ${newValue}!`);
});
```

Notice that `on` listens on the event `"firstNameChanged"`, not just `"firstName"`. Our naive specification of `on()` could be made more robust if we were to ensure that the set of eligible event names was constrained by the union of attribute names in the watched object with “Changed” added at the end. While we are comfortable with doing such a calculation in JavaScript i.e. `Object.keys(passedObject).map(x => `${x}Changed`)`, template literals inside the type system provide a similar approach to string manipulation:
```ts
type PropEventSource<Type> = {
    on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;
};

/// Create a "watched object" with an `on` method
/// so that you can watch for changes to properties.
declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;
```

With this, we can build something that errors when given the wrong property:
```ts
const person = makeWatchedObject({
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26
});

person.on("firstNameChanged", () => {});

// Prevent easy human error (using the key instead of the event name)
// Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.
person.on("firstName", () => {});

// It's typo-resistant
// Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.
person.on("frstNameChanged", () => {});
```

#### Inference with Template Literals
Notice that we did not benefit from all the information provided in the original passed object. Given change of a `firstName` (i.e. a `firstNameChanged` event), we should expect that the callback will receive an argument of type `string`. Similarly, the callback for a change to `age` should receive a `number` argument. We’re naively using `any` to type the `callback`’s argument. Again, template literal types make it possible to ensure an attribute’s data type will be the same type as that attribute’s callback’s first argument.

The key insight that makes this possible is this: we can use a function with a generic such that:
1. The literal used in the first argument is captured as a literal type
2. That literal type can be validated as being in the union of valid attributes in the generic
3. The type of the validated attribute can be looked up in the generic’s structure using Indexed Access
4. This typing information can then be applied to ensure the argument to the callback function is of the same type
```ts
type PropEventSource<Type> = {
    on<Key extends string & keyof Type>
        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;
};

declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;

const person = makeWatchedObject({
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26
});

// (매개변수) newName: string
person.on("firstNameChanged", newName => {
    console.log(`new name is ${newName.toUpperCase()}`);
});

// (매개변수) newAge: number
person.on("ageChanged", newAge => {
    if (newAge < 0) {
        console.warn("warning! negative age");
    }
})
```

Here we made `on` into a generic method.

When a user calls with the string `"firstNameChanged"`, TypeScript will try to infer the right type for `Key`. To do that, it will match `Key` against the content before `"Changed"` and infer the string `"firstName"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when called with `"ageChanged"`, TypeScript finds the type for the property `age` which is `number`.

Inference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways.

### Intrinsic String Manipulation Types
To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.

#### `Uppercase<StringType>`
Converts each character in the string to the uppercase version.

##### Example
```ts
type Greeting = "Hello, world"

// type ShoutyGreeting = "HELLO, WORLD"
type ShoutyGreeting = Uppercase<Greeting>

type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}`

// type MainID = "ID-MY_APP"
type MainID = ASCIICacheKey<"my_app">
```

#### `Lowercase<StringType>`
Converts each character in the string to the lowercase equivalent.

##### Example
```ts
type Greeting = "Hello, world"

// type QuietGreeting = "hello, world"
type QuietGreeting = Lowercase<Greeting>

type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}`

// type MainID = "id-my_app"
type MainID = ASCIICacheKey<"MY_APP">
```

#### `Capitalize<StringType>`
Converts the first character in the string to an uppercase equivalent.

##### Example
```ts
type LowercaseGreeting = "hello, world";

// type Greeting = "Hello, world"
type Greeting = Capitalize<LowercaseGreeting>;
```

#### `Uncapitalize<StringType>`
Converts the first character in the string to a lowercase equivalent.

##### Example
```ts
type UppercaseGreeting = "HELLO WORLD";

// type UncomfortableGreeting = "hELLO WORLD"
type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;
```

Technical details on the intrinsic string manipulation types
