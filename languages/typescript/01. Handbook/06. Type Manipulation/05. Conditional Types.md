조건부 타입
=================

##### 입력 · 출력 타입 관계 표현 시 유용
```ts
interface Animal {
  live(): void;
}

interface Dog extends Animal {
  woof(): void;
}

// type Example1 = number
type Example1 = Dog extends Animal ? number : string;

// type Example2 = string
type Example2 = RegExp extends Animal ? number : string;
```

##### `?` <sub>(조건부 연산자)</sub> 표현식 형태 유사
```js
condition ? trueValue : falseValue
```
```ts
SomeType extends OtherType ? TrueType : FalseType;
```

##### 제네릭 조합 시 유용
- `createLabel` <sub>(함수)</sub>
```ts
interface IdLabel {
  id: number /* some fields */;
}

interface NameLabel {
  name: string /* other fields */;
}

function createLabel(id: number): IdLabel;
function createLabel(name: string): NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel {
  throw "unimplemented";
}
```

##### `createLabel` <sub>(함수)</sub> 오버로드
- 입력 종류 따라 동작 선택

##### 문제점
1. 유사 선택지 계속 등장 시
    - 반복적인 동일 코드 작성
2. 새 타입 추가 시
    - 오버로드 코드량 증가

##### 조건부 타입 로직
- 함수 단순화
  - 오버로드 제거
```ts
type NameOrId<T extends number | string> = T extends number
  ? IdLabel
  : NameLabel;

function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
  throw "unimplemented";
}

// let a: NameLabel
let a = createLabel("typescript");

// let b: IdLabel
let b = createLabel(2.8);

// let c: NameLabel | IdLabel
let c = createLabel(Math.random() ? "hello" : 42);
```

#### 조건부 타입 제약

##### 조건부 타입 체크
- 추가 정보 제공
  - 타입 좁히기 <sub>(타입가드)</sub> 유사
- 참 분기
  - 더 구체적인 타입 제약 적용

#### `MessageOf` <sub>(타입)</sub>

##### 제약 미적용 <sub>(모든 타입 가능)</sub>
- `message` <sub>(프로퍼티)</sub> 보장 X
```ts
// 에러 발생
// - message (프로퍼티) 보장 X
//   - Type '"message"' cannot be used to index type 'T'.
type MessageOf<T> = T["message"];
```

##### 제약 적용 <sub>(특정 기준 타입)</sub>
- `message` <sub>(프로퍼티)</sub> 보장
```ts
type MessageOf<T extends { message: unknown }> = T["message"];

interface Email {
  message: string;
}

// type EmailMessageContents = string
type EmailMessageContents = MessageOf<Email>;
```

##### 타입 조건 추가
- 모든 타입 가능
- `message` <sub>(프로퍼티)</sub> 부재 시
  - `never` <sub>(타입)</sub>
- 코드 수정
  - 제약 밖으로 이동
  - 조건부 타입 적용
- 참 분기
  - `T` <sub>(타입)</sub> 내 `message` <sub>(프로퍼티)</sub> 인지
```ts
type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;

interface Email {
  message: string;
}

interface Dog {
  bark(): void;
}

// type EmailMessageContents = string
type EmailMessageContents = MessageOf<Email>;

// type DogMessageContents = never
type DogMessageContents = MessageOf<Dog>;
```


As another example, we could also write a type called `Flatten` that flattens array types to their element types, but leaves them alone otherwise:
```ts
type Flatten<T> = T extends any[] ? T[number] : T;

// type Str = string
type Str = Flatten<string[]>;

// type Num = number
type Num = Flatten<number>;
```

When `Flatten` is given an array type, it uses an indexed access with `number` to fetch out `string[]`’s element type. Otherwise, it just returns the type it was given.

#### Inferring Within Conditional Types
We just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.

Conditional types provide us with a way to infer from types we compare against in the true branch using the `infer` keyword. For example, we could have inferred the element type in `Flatten` instead of fetching it out “manually” with an indexed access type:
```ts
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;
```

Here, we used the `infer` keyword to declaratively introduce a new generic type variable named `Item` instead of specifying how to retrieve the element type of `Type` within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.

We can write some useful helper type aliases using the `infer` keyword. For example, for simple cases, we can extract the return type out from function types:
```ts
type GetReturnType<Type> = Type extends (...args: never[]) => infer Return
  ? Return
  : never;

// type Num = number
type Num = GetReturnType<() => number>;

// type Str = string
type Str = GetReturnType<(x: string) => string>;

// type Bools = boolean[]
type Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;
```

When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.
```ts
declare function stringOrNum(x: string): number;
declare function stringOrNum(x: number): string;
declare function stringOrNum(x: string | number): string | number;

// type T1 = string | number
type T1 = ReturnType<typeof stringOrNum>;
```

### Distributive Conditional Types
When conditional types act on a generic type, they become distributive when given a union type. For example, take the following:
```ts
type ToArray<Type> = Type extends any ? Type[] : never;
```

If we plug a union type into `ToArray`, then the conditional type will be applied to each member of that union.
```ts
type ToArray<Type> = Type extends any ? Type[] : never;

// type StrArrOrNumArr = string[] | number[]
type StrArrOrNumArr = ToArray<string | number>;
```

What happens here is that ToArray distributes on:
```ts
string | number;
```

and maps over each member type of the union, to what is effectively:
```ts
ToArray<string> | ToArray<number>;
```

which leaves us with:
```ts
string[] | number[];
```

Typically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the `extends` keyword with square brackets.
```ts
type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;

// 'ArrOfStrOrNum' is no longer a union.
// type ArrOfStrOrNum = (string | number)[]
type ArrOfStrOrNum = ToArrayNonDist<string | number>;
```
