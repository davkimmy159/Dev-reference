Everyday Types
==============

## 원시 타입
- `string`
- `number`
- `boolean`

## `Array`

##### `string[]` · `number[]` · `boolean[]`
- `['a', 'b', 'c']`
- `[1, 2, 3]`
- `[true, true, false]`

## `any`

##### 특정 타입 한정 X
- 아무 프로퍼티 <sub>(`any` 타입)</sub> 접근 가능
  - 타입 체크 X
  - 컴파일 에러 X
- 아주 명확한 긴 타입 생략
```ts
let obj: any = { x: 0 };

obj.foo();
obj();
obj.bar = 100;
obj = "hello";
const n: number = obj;
```

### `noImplicitAny`

##### 타입 생략 시
- 타입 추론 X
  - `any` 결론
- 암시적 `any`
  - 에러 간주
```ts
// 함수
function add(a, b) {
  return a+b;
}

// 타입 추론
// - 암시적 any
function add(a: any, b: any): any
```

## 함수
Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.

### 매개변수 타입 어노테이션
```ts
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}

// 에러 발생
// - Argument of type 'number' is not assignable to parameter of type 'string'.
greet(42);
```

##### 생략 시
- 함수 전달 인수 개수 체크

### 반환 타입 어노테이션

##### 함수 반환 타입
- 명시 불필요 경우 多
  - 타입스크립트 추론
- 용도
  - doc
  - 취향
```ts
function getFavoriteNumber(): number {
  return 26;
}
```

#### `Promise` 반환 함수
```ts
async function getFavoriteNumber(): Promise<number> {
  return 26;
}
```

### 무기명 함수
Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.

Here’s an example:
```ts
const names = ["Alice", "Bob", "Eve"];

// Contextual typing for function - parameter s inferred to have type string
names.forEach(function (s) {
  console.log(s.toUpperCase());
});

// Contextual typing also applies to arrow functions
names.forEach((s) => {
  console.log(s.toUpperCase());
});
```

Even though the parameter `s` didn’t have a type annotation, TypeScript used the types of the `forEach` function, along with the inferred type of the array, to determine the type `s` will have.

This process is called contextual typing because the context that the function occurred within informs what type it should have.

Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.