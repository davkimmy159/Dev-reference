Narrowing
=========

### `padLeft` <sub>(함수)</sub>
```ts
function padLeft(padding: number | string, input: string): string {
  throw new Error("Not implemented yet!");
}
```

#### `padding` <sub>(1번째 인수)</sub>

##### 숫자
- `input` <sub>(2번째 인수)</sub> 앞 공백 추가
  - 해당 숫자 만큼

##### 문자열
- `input` <sub>(2번째 인수)</sub> 앞 추가
```ts
function padLeft(padding: number | string, input: string): string {
  // 에러 발생
  // - Argument of type 'string | number' is not assignable to parameter of type 'number'.
  // - Type 'string' is not assignable to type 'number'.
  return " ".repeat(padding) + input;
}
```

##### 타입 체크 필요
- `repeat` <sub>(함수)</sub>
  - 숫자 인수만 허용
```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

##### JS 런타임 제어 흐름 구조 내 타입 체크
- `if` · `else`
- `?` <sub>(3항 조건부 연산자)</sub>
- 반복문
- 유효값 <sub>(truthiness)</sub> 체크
- 기타 등등

##### 타입 좁히기 <sub>(narrowing)</sub>
- 코드 실행 흐름 따라 진행
- 구체적인 가능 타입 분석 <sub>(특정 위치 내)</sub>
  - 특수 타입 체크 <sub>(타입 가드)</sub>
  - 할당문
  - 타입 정제 과정 <sub>(타입 구체화)</sub>
  - 선언문 X

##### `if (typeof padding === "number")`
- 타입 가드
```ts
function padLeft(padding: number | string, input: string): string {

  // padding: number
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }

  // padding: string
  return padding + input;
}
```

## `typeof` 타입 가드

##### 특정 문자열 반환
- `"string"`
- `"number"`
- `"bigint"`
- `"boolean"`
- `"symbol"`
- `"undefined"`
- `"object"`
- `"function"`

Like we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.

##### `typeof` <sub>(연산자)</sub> 반환값 비교
- 타입 가드
- JS 특이사항 인지
  - ex\) `"null"` 반환 X
- JS `typeof null`
  - `"object"` <sub>(역사적 이유)</sub>
```ts
function printAll(strs: string | string[] | null) {

  // string[] | null
  // string[] X
  if (typeof strs === "object") {

    // 에러 발생
    // - 'strs' is possibly 'null'.
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  } else {
    /* 작업 X */
  }
}
```

## 유효값 <sub>(Truthiness)</sub> 좁히기 <sub>(narrowing)</sub>

##### 표현식 사용 위치
- 조건문
- `&&` <sub>(AND 연산자)</sub>
- `||` <sub>(OR 연산자)</sub>
- `if` <sub>(문)</sub>
- `!` <sub>(NOT 연산자)</sub>
- 기타 등등

##### `if` <sub>(문)</sub>
- `boolean` 외 표현식 가능
```ts
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

##### JS 구조 <sub>(`if` 등)</sub>
1. 조건식 → `boolean` <sub>(변환)</sub>
2. 분기 진행

##### `falsy` 값 <sub>(`false`)</sub>
- `0`
- `NaN`
- `""` <sub>(빈 문자열)</sub>
- `0n` <sub>(`bigint`)</sub>
- `null`
- `undefined`

##### truthy 값 <sub>(`true`)</sub>
- `falsy` 값 외 전부

##### `boolean` 형 변환
1. `Boolean` <sub>(함수)</sub>
    - `boolean`
2. `!!` <sub>(이중 NOT 연산자)</sub>
    - `true` <sub>(상수)</sub>
```ts
Boolean("hello"); // 타입: boolean, 값: true
!!"world";        // 타입: true,    값: true
```

##### 함수 개선
```ts
function printAll(strs: string | string[] | null) {

// truthiness 체크 추가 (에러 방지)
// - TypeError: null is not iterable
//if (        typeof strs === "object") {
  if (strs && typeof strs === "object") {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

##### 원시값 대상 truthiness 체크
- 에러 발생 가능성 ↑
- linter 사용 가능
```ts
function printAll(strs: string | string[] | null) {

  // "" (빈 문자열) 처리 X
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs);
    }
  }
}
```

##### Boolean 부정 · `!` <sub>(NOT 연산자)</sub>
```ts
function multiplyAll(
  values: number[] | undefined,
  factor: number
): number[] | undefined {

  // undefined
  if (!values) {
    return values;

  // number[]
  } else {
    return values.map((x) => x * factor);
  }
}
```

## 동등 좁히기 <sub>(narrowing)</sub>

##### `switch` <sub>(문)</sub> · \[일치·동등\] 비교 연산자
- `===` · `!==`
- `==` · `!=`
```ts
function example(x: string | number, y: string | boolean) {

  // x · y : string
  // - 값 일치 → 타입 일치
  if (x === y) {

    // String.toUpperCase(): string
    x.toUpperCase();

    // String.toLowerCase(): string
    y.toLowerCase();

  } else {
    // x: string | number
    console.log(x);

    // y: string | boolean
    console.log(y);
  }
}
```

##### 특정 상숫값 비교
- `typeof` <sub>(연산자)</sub> 반환값
```ts
function printAll(strs: string | string[] | null) {
  if (strs !== null) {

    // strs: string[]
    if (typeof strs === "object") {

      for (const s of strs) {
        console.log(s);
      }

    // strs: string
    } else if (typeof strs === "string") {
      console.log(strs);
    }
  }
}
```

##### (느슨한) 동등 비교 연산자 <sub>(`==` · `!=`)</sub>
- `null` · `undefined` 동시 비교
  - `== null`
  - `== undefined`
```ts
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {

  // null · undefined 동시 비교
  // Container.value: number
  if (container.value != null) {

    console.log(container.value);

    container.value *= factor;
  }
}
```

## `in` <sub>(연산자)</sub> 좁히기 <sub>(narrowing)</sub>
JavaScript has an operator for determining if an object or its prototype chain has a property with a name: the `in` operator. TypeScript takes this into account as a way to narrow down potential types.

For example, with the code: `"value" in x`. where `"value"` is a string literal and `x` is a union type. The “true” branch narrows `x`’s types which have either an optional or required property `value`, and the “false” branch narrows to types which have an optional or missing property `value`.
```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    return animal.swim();
  }

  return animal.fly();
}
```
To reiterate, optional properties will exist in both sides for narrowing. For example, a human could both swim and fly (with the right equipment) and thus should show up in both sides of the `in` check:
```ts
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {

  // animal: Fish | Human
  if ("swim" in animal) {
    animal;

  // animal: Bird | Human
  } else {
    animal;
  }
}
```

## `instanceof` <sub>(연산자)</sub> 좁히기 <sub>(narrowing)</sub>
JavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript `x instanceof Foo` checks whether the prototype chain of `x` contains Foo.prototype. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with `new`. As you might have guessed, `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`s.
```ts
function logValue(x: Date | string) {

  // x: Date
  if (x instanceof Date) {
    console.log(x.toUTCString());

    // x: string
  } else {
    console.log(x.toUpperCase());
  }
```
}

## Assignments
As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.
```ts
// let x: string | number
let x = Math.random() < 0.5 ? 10 : "hello world!";

// let x: number
x = 1;

// let x: string
x = "goodbye!";
```
Notice that each of these assignments is valid. Even though the observed type of `x` changed to `number` after our first assignment, we were still able to assign a `string` to `x`. This is because the declared type of `x` - the type that `x` started with - is `string | number`, and assignability is always checked against the declared type.

If we’d assigned a `boolean` to `x`, we’d have seen an error since that wasn’t part of the declared type.
```ts
// let x: string | number
let x = Math.random() < 0.5 ? 10 : "hello world!";

// let x: number
x = 1;

// 에러 발생
// - Type 'boolean' is not assignable to type 'string | number'.
// let x: string | number
x = true;
```

## Control flow analysis
Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in `if`s, `while`s, conditionals, etc. For example
```ts
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

`padLeft` returns from within its first `if` block. TypeScript was able to analyze this code and see that the rest of the body (`return padding + input;`) is unreachable in the case where `padding` is a `number`. As a result, it was able to remove `number` from the type of padding (narrowing from `string | number` to `string`) for the rest of the function.

This analysis of code based on reachability is called control flow analysis, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.
```ts
function example() {
  let x: string | number | boolean;

// let x: boolean
  x = Math.random() < 0.5;

  if (Math.random() < 0.5) {

    // let x: string
    x = "hello";

  } else {

    // let x: number
    x = 100;
  }

  // let x: string | number
  return x;
}
```

## Using type predicates
We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.

To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:
```ts
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

`pet is Fish` is our type predicate in this example. A predicate takes the form `parameterName is Type`, where `parameterName` must be the name of a parameter from the current function signature.

Any time `isFish` is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.
```ts
// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();

if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}
```

Notice that TypeScript not only knows that `pet` is a `Fish` in the `if` branch; it also knows that in the `else` branch, you don’t have a `Fish`, so you must have a `Bird`.

You may use the type guard `isFish` to filter an array of `Fish | Bird` and obtain an array of `Fish`:
```ts
const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter(isFish) as Fish[];

// The predicate may need repeating for more complex examples
const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
  if (pet.name === "sharkey") return false;
  return isFish(pet);
});
```

## Assertion functions
Types can also be narrowed using Assertion functions.

## Discriminated unions
