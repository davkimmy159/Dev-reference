Narrowing
=========

### `padLeft` <sub>(함수)</sub>
```ts
function padLeft(padding: number | string, input: string): string {
  throw new Error("Not implemented yet!");
}
```

#### `padding` <sub>(1번째 인수)</sub>

##### 숫자
- `input` <sub>(2번째 인수)</sub> 앞 공백 추가
  - 해당 숫자 만큼

##### 문자열
- `input` <sub>(2번째 인수)</sub> 앞 추가
```ts
function padLeft(padding: number | string, input: string): string {
  // 에러 발생
  // - Argument of type 'string | number' is not assignable to parameter of type 'number'.
  // - Type 'string' is not assignable to type 'number'.
  return " ".repeat(padding) + input;
}
```

##### 타입 체크 필요
- `repeat` <sub>(함수)</sub>
  - 숫자 인수만 허용
```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

##### JS 런타임 제어 흐름 구조 내 타입 체크
- `if` · `else`
- `?` <sub>(3항 조건부 연산자)</sub>
- 반복문
- 유효값 <sub>(truthiness)</sub> 체크
- 기타 등등

##### `if (typeof padding === "number")` <sub>(타입 가드)</sub>
- 코드 실행 흐름 따라 진행
- 구체적인 가능한 타입 분석
- 
Within our `if` check, TypeScript sees `typeof padding === "number"` and understands that as a special form of code called a type guard. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing. In many editors we can observe these types as they change, and we’ll even do so in our examples.
```ts
function padLeft(padding: number | string, input: string): string {

  // padding: number
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }

  // padding: string
  return padding + input;
}
```
There are a couple of different constructs TypeScript understands for narrowing.