Narrowing
=========

### `padLeft` <sub>(함수)</sub>
```ts
function padLeft(padding: number | string, input: string): string {
  throw new Error("Not implemented yet!");
}
```

#### `padding` <sub>(1번째 인수)</sub>

##### 숫자
- `input` <sub>(2번째 인수)</sub> 앞 공백 추가
  - 해당 숫자 만큼

##### 문자열
- `input` <sub>(2번째 인수)</sub> 앞 추가
```ts
function padLeft(padding: number | string, input: string): string {
  // 에러 발생
  // - Argument of type 'string | number' is not assignable to parameter of type 'number'.
  // - Type 'string' is not assignable to type 'number'.
  return " ".repeat(padding) + input;
}
```

##### 타입 체크 필요
- `repeat` <sub>(함수)</sub>
  - 숫자 인수만 허용
```ts
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

##### JS 런타임 제어 흐름 구조 내 타입 체크
- `if` · `else`
- `?` <sub>(3항 조건부 연산자)</sub>
- 반복문
- 유효값 <sub>(truthiness)</sub> 체크
- 기타 등등

##### 타입 좁히기 <sub>(narrowing)</sub>
- 코드 실행 흐름 따라 진행
- 구체적인 가능 타입 분석 <sub>(특정 위치 내)</sub>
  - 특수 타입 체크 <sub>(타입 가드)</sub>
  - 할당문
  - 타입 정제 과정 <sub>(타입 구체화)</sub>
  - 선언문 X

##### `if (typeof padding === "number")`
- 타입 가드
```ts
function padLeft(padding: number | string, input: string): string {

  // padding: number
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }

  // padding: string
  return padding + input;
}
```

## `typeof` 타입 가드

##### 특정 문자열 반환
- `"string"`
- `"number"`
- `"bigint"`
- `"boolean"`
- `"symbol"`
- `"undefined"`
- `"object"`
- `"function"`

Like we saw with `padLeft`, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.

##### `typeof` <sub>(연산자)</sub> 반환값 비교
- 타입 가드
- JS 특이사항 인지
  - ex\) `"null"` 반환 X
- JS `typeof null`
  - `"object"` <sub>(역사적 이유)</sub>
```ts
function printAll(strs: string | string[] | null) {

  // string[] | null
  // string[] X
  if (typeof strs === "object") {

    // 에러 발생
    // - 'strs' is possibly 'null'.
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  } else {
    /* 작업 X */
  }
}
```

## 유효값 <sub>(Truthiness)</sub> 좁히기 <sub>(narrowing)</sub>

##### 표현식 사용 위치
- 조건문
- `&&` <sub>(AND 연산자)</sub>
- `||` <sub>(OR 연산자)</sub>
- `if` <sub>(문)</sub>
- `!` <sub>(NOT 연산자)</sub>
- 기타 등등

##### `if` <sub>(문)</sub>
- `boolean` 외 표현식 가능
```ts
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

##### JS 구조 <sub>(`if` 등)</sub>
1. 조건식 → `boolean` <sub>(변환)</sub>
2. 분기 진행

##### `falsy` 값 <sub>(`false`)</sub>
- `0`
- `NaN`
- `""` <sub>(빈 문자열)</sub>
- `0n` <sub>(`bigint`)</sub>
- `null`
- `undefined`

##### truthy 값 <sub>(`true`)</sub>
- `falsy` 값 외 전부

##### `boolean` 형 변환
1. `Boolean` <sub>(함수)</sub>
    - `boolean`
2. `!!` <sub>(이중 NOT 연산자)</sub>
    - `true` <sub>(상수)</sub>
```ts
Boolean("hello"); // 타입: boolean, 값: true
!!"world";        // 타입: true,    값: true
```

##### 함수 개선
```ts
function printAll(strs: string | string[] | null) {

// truthiness 체크 추가 (에러 방지)
// - TypeError: null is not iterable
//if (        typeof strs === "object") {
  if (strs && typeof strs === "object") {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

##### 원시값 대상 truthiness 체크
- 에러 발생 가능성 ↑
- linter 사용 가능
```ts
function printAll(strs: string | string[] | null) {

  // "" (빈 문자열) 처리 X
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs);
    }
  }
}
```

##### Boolean 부정 · `!` <sub>(NOT 연산자)</sub>
```ts
function multiplyAll(
  values: number[] | undefined,
  factor: number
): number[] | undefined {

  // undefined
  if (!values) {
    return values;

  // number[]
  } else {
    return values.map((x) => x * factor);
  }
}
```

## 동등 좁히기 <sub>(narrowing)</sub>

##### `switch` <sub>(문)</sub> · \[일치·동등\] 연산자 sub{(`===`, `!==`, `==`, `!=`)}
- and equality checks like `===`, `!==`, `==`, and `!=` to narrow types. For example:
```ts
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // We can now call any 'string' method on 'x' or 'y'.

    // (method) String.toUpperCase(): string
    x.toUpperCase();

    // (method) String.toLowerCase(): string
    y.toLowerCase();
  } else {
    // (parameter) x: string | number
    console.log(x);

    // (parameter) y: string | boolean
    console.log(y);
  }
}
```

When we checked that `x` and `y` are both equal in the above example, TypeScript knew their types also had to be equal. Since `string` is the only common type that both `x` and `y` could take on, TypeScript knows that `x` and `y` must be `string`s in the first branch.

Checking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a `printAll` function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out `null`s, and TypeScript still correctly removes `null` from the type of `strs`.
```ts
function printAll(strs: string | string[] | null) {
  if (strs !== null) {
    if (typeof strs === "object") {

      // (parameter) strs: string[]
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {

      // (parameter) strs: string
      console.log(strs);
    }
  }
}
```

JavaScript’s looser equality checks with `==` and `!=` also get narrowed correctly. If you’re unfamiliar, checking whether something `== null` actually not only checks whether it is specifically the value `null` - it also checks whether it’s potentially `undefined`. The same applies to `== undefined`: it checks whether a value is either `null` or `undefined`.
```ts
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {
  // Remove both 'null' and 'undefined' from the type.
  if (container.value != null) {

    // (property) Container.value: number
    console.log(container.value);

    // Now we can safely multiply 'container.value'.
    container.value *= factor;
  }
}
```

## `in` <sub>(연산자)</sub> 좁히기 <sub>(narrowing)</sub>
