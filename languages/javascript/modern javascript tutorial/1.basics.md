엄격모드
============

- ES5 변경사항 적용 (모던 자바스크립트)

### `"use strict"`
- 스크립트 최상단
- 함수 본문 맨 앞
  - 해당 함수만 엄격 모드

### 브라우저 콘솔
- 기본적으로 `"use strict"` 적용 X
  - 적용 시 최상단 `"use strict"` 입력

### `use strict` 사용 필수?
- 클래스 · 모듈 사용 시 `"use strict"` 생략 가능

<br />

변수와 상수
==========

```javascript
let m1;
m1 = 'Hello!';
let m2 = 'Hello!';

// (권장 X)
let m3 = 'John', m4 = 25, m5 = 'Hello';

// (권장)
let m6 = 'John';
let m7 = 25;
let m8 = 'Hello';

// (취향)
let m9 = 'John',
  m10 = 25,
  m11 = 'Hello';
let m12 = 'John'
  , m13 = 25
  , m14 = 'Hello';
```

### 변수 명명 규칙
- 변수명
  - 문자
  - 숫자
  - $
  - _
- 첫 글자 숫자 X

### 잘못된 변수명 예시
```javascript
let 1a;      // 숫자 시작
let my-name; // '-' 사용
```
### 대 · 소문자 구별
- apple ≠ AppLE

### 비 라틴계 언어 사용 OK, 권장 X
- 영어 변수명 사용 (국제적 관습)
```javascript
let имя = '…';
let 我 = '…';
```

### 예약어 (reserved name)
```javascript
let let = 5;    // 'let'   변수명 사용 X
let return = 5; // 'return'변수명 사용 X
```

### `"use strict"` 없이 변수 할당
- 과거 `let` 없이 값 할당해 변수 생성 가능
  - 과거 스크립트 호환성
  - 나쁜 관습

### 상수
- 변하지 않는 변수 선언
- `const`
```javascript
const m1 = '18.04.1982';
```

### 대문자 상수
- 대문자·밑줄
  - 기억 용이
  - 오타 확률 ↓
  - 가독성 ↑
```javascript
const COLOR_ORANGE = "#FF7F00";
let color = COLOR_ORANGE;
```

### 바람직한 변수명
- 읽을 수 있는 이름
- 줄임말 or 짧은 이름 X
- 최대한 서술적 · 간결

<br />

자료형
=====

- 동적 타입 (dynamically typed)
  - 변수는 자료형 관계없이 모든 데이터일 수 있음
  - 어떤 순간에 문자열, 다른 순간엔 숫자
```javascript
// no error
let message = "hello";
message = 123456;
```

### 숫자형
- 정수, 부동소수점 숫자 (floating point number)
```javascript
let n = 123;
n = 12.345;
```
#### Infinity : 무한대 (∞)
- 어느 숫자든 0으로 나누면 무한대
```javascript
alert( 1 / 0 ); // 무한대
```
- Infinity 직접 참조
```javascript
alert(Infinity); // 무한대
```
#### `NaN`
- 계산 중 에러 발생 (부정확 or 미정의 수학 연산 사용 시 에러 발생)
  - `NaN` 반환
```javascript
alert( "숫자가 아님" / 2 ); // NaN, 문자열 숫자로 나누면 오류 발생
```
- `NaN` 여간해선 안바뀜
- `NaN` 에 어떤 추가 연산 : `NaN` 반환
```javascript
alert( "숫자가 아님" / 2 + 5 ); // NaN
```
- 연산 과정 어디선가 `NaN` 반환 시, 모든 결과에 영향

#### 수학 연산 안전
- 자바스크립트 행해지는 수학 연산 '안전’
- 이례적인 연산 자바스크립트에서 가능
  - 0으로 나누기, 비숫자가 문자열 숫자로 취급 등
- 불가능 연산 실행 시 에러 X → `NaN` 반환 & 종료

#### BigInt
- 숫자형 사용 불가 (내부 표현 방식 문제)
  - n (정수) > (253-1)(9007199254740991)
  - n (정수) < -(253-1)
- 아주 큰 숫자 필요한 상황(암호 관련 작업) or 아주 높은 정밀도 작업
- 길이 상관없이 정수 표현
- 정수 리터럴 끝에 `n`
```javascript
// 끝에 'n' 붙으면 BigInt형 자료
const bigInt = 1234567890123456789012345678901234567890n;
```

### 문자형
- 따옴표
  - 큰따옴표  `"Hello"`
  - 작은따옴표 `'Hello'`
  - 백틱    ``` `Hello` ```
```javascript
let str1 = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```
- 큰따옴표 · 작은따옴표
  - ‘기본적인’ 따옴표 (차이 X)
- 백틱 `${…}` : 변수, 표현식 (무엇이든)
  - 평가 후 문자열 일부
```javascript
let name = "John";

// 변수 문자열 중간에 삽입
alert( `Hello, ${name}!` );        // Hello, John!

// 표현식 문자열 중간에 삽입
alert( `the result is ${1 + 2}` ); // the result is 3
```

### 글자형 (char)
- 미존재

### 불린형
- `true`
- `false`
<br /><br />
- 비교 결과 저장
```javascript
let isGreater = 4 > 1;
alert(isGreater); // true (비교 결과: "yes")
```

### `null` 값
- `null` 값만 포함하는 별도 자료형
```javascript
let age = null;
```
#### 타 언어 `null`
- 미존재 객체 참조
- 널 포인터 (null pointer)
#### 자바스크립트 `null`
- ‘존재하지 않는’ 값 (nothing)
- ‘비어 있는’ 값    (empty)
- ‘알 수 없는’ 값   (unknown)
```javascript
let age = null; // 나이(age) 알 수 없음 or 값 비어있음
```

### `undefined` 값
- `undefined` 값만 포함하는 별도 자료형
- 값 미할당 상태
- 변수 선언 & 값 미할당
  - `undefined` 자동 할당
```javascript
let age;
alert(age); // 'undefined'
```
- 명시적 할당
```javascript
let age = 100;
age = undefined; // undefined 값 명시적으로 할당
alert(age);      // 'undefined'
```
- `undefined` 직접 할당 권장 X
- ‘비어있거나’ ‘알 수 없는’ 상태
  - `null`

### 객체, 심볼
#### 객체 (object)
- 데이터 컬렉션
- 복잡한 개체 (entity)
#### 심볼 (symbol)
- 객체 고유 식별자 (unique identifier)

### typeof 연산자
- 인수 자료형 반환
- 형태
  - 연산자 : `typeof x`
  - 함수  : `typeof(x)`
```javascript
typeof 0            // "number"
typeof 10n          // "bigint"
typeof "foo"        // "string"
typeof true         // "boolean"
typeof Math         // "object"   - 내장 객체
typeof alert        // "function" - 함수형 미존재, 함수 = 객체형
                    //             (하위 호환성 : 언어 자체의 오류)
typeof Symbol("id") // "symbol"
typeof undefined    // "undefined"
typeof null         // "object"   - null ≠ object
                    //             (하위 호완성 : 언어 자체의 오류)
```

<br />

형변환
=====

### 문자형 변환
- 문자형 값 필요 시 자동 변환
- `String(value)` 함수
```javascript
let value = true;
alert(typeof value);   // boolean

value = String(value); // 변수 value 문자열 "true" 저장
alert(typeof value);   // string
```

### 숫자형 변환
- 수학 관련 함수 · 표현식 자동 변환
```javascript
alert( "6" / "2" ); // 3, 문자열 → 숫자형 자동변환 후 연산
```
- `Number(value)` 함수
```javascript
let str = "123";
alert(typeof str);     // string

let num = Number(str); // 문자열 "123" → 숫자 123 변환
alert(typeof num);     // number
```
- 숫자형 값 문자 기반 폼(form) 통해 입력받는 경우 명시적 형 변환 필수
- 숫자 이외 글자 있는 문자열 숫자형 변환 시
  - `NaN`
```javascript
let age = Number("임의의 문자열 123");
alert(age); // NaN, 형 변환이 실패합니다.
```
- 숫자형 변환 규칙
- ※ `null` · `undefined` 숫자형 변환 시 결과 다름

|값|형 변환 후|
|---|---|
|`undefined`|`NaN`|
|`null`|`0`|
|`true` & `false`|`1` & `0`|
|`string`| ① 문자열 처음 · 끝 공백 제거<br /> ② 공백 제거 후 문자열 없으면 `0` or 문자열에서 숫자 읽음<br /> ③ 변환 실패 시 : `NaN`|

```javascript
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN ("z" 숫자 변환 실패)
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```
### 불린형 변환
- 논리 연산 수행 시 발생
- `Boolean(value)` 함수
- 불린형 변환 규칙

|값|형 변환 후|
|---|---|
|직관적으로 “비어있는” 값<br />- `0` (숫자)<br /> - `""` (빈 문자열)<br /> - `null` <br /> - `undefined`<br /> - `NaN` 등 |`false`|
|그 외의 값|`true`|

```javascript
alert( Boolean(1) );       // 숫자 1 (true)
alert( Boolean(0) );       // 숫자 0 (false)
alert( Boolean("hello") ); // 문자열 (true)
alert( Boolean("") );      // 빈 문자열 "" (false)
```
#### ※ 문자열 `"0"` == `true`
- PHP 등 일부 언어 문자열 `"0"` == `false`
- 자바스크립트 비어있지 않은 문자열 언제나 `true`
```javascript
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // 공백 있는 문자열 : 비어있지 않은 문자열
```

<br />

기본 연산자 · 수학
=================

- operand(피연산자)
  - 연산 수행 대상
  - `=` 인수(argument)
- unary(단항)
  - 피연산자 1개 받는 연산자
- binary(이항)
  - 피연산자 2개 받는 연산자

### 수학 연산자
- 덧셈 연산자   : `+`
- 뺄셈 연산자   : `-`
- 곱셈 연산자   : `*`
- 나눗셈 연산자  : `/`
- 나머지 연산자  : `%`
- 거듭제곱 연산자 : `**`

### 나머지 연산자 `%`
- 나눈 후 나머지 정수 반환
```javascript
alert( 5 % 2 ); // 5 / 2 나머지 : 1
alert( 8 % 3 ); // 8 / 3 나머지 : 2
```

### 거듭제곱 연산자 `**`
- `a ** b`
  - a를 b번 곱한 값
```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```
- 정수 아닌 숫자 가능
- 제곱근
  - 분수 이용
```javascript
alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱 : 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱 : 세제곱근)
```

### 이항 연산자 `+` 문자열 연결
- 이항 연산자 `+` 피연산자로 문자열 전달 시 문자열 병합 (연결)
```javascript
let s = "my" + "string";
alert(s);             // mystring
alert( '1' + 2 );     // "12"
alert( 2 + '1' );     // "21"
alert( 2 + 2 + '1' ); // '41' (연산 : 왼쪽 → 오른쪽 순차적 진행)
alert( 6 - '2' );     // 4 ('2' 숫자 변환 후 연산)
alert( '6' / '2' );   // 3 (두 피연산자 숫자로 변환 후 연산)
```

### 단항 연산자 `+` 숫자형 변환
- 피연산자 숫자 아닌 경우 숫자형 변환
- `Number(…)` 함수 동일
```javascript
// 숫자 영향 X
let x = 1;
alert( +x );    // 1
let y = -2;
alert( +y );    // -2

// 숫자형 아닌 피연산자 숫자형 변환
alert( +true ); // 1
alert( +"" );   // 0
```
- 단항 덧셈 연산자로 피연산자 숫자형 변환 후 연산 진행
```javascript
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자 적용 전 두 피연산자 숫자형 변환
alert( +apples + +oranges );               // 5
alert( Number(apples) + Number(oranges) ); // 5
```

### 연산자 우선순위

|순위|기호|연산자 이름|
|:---:|:---:|---|
|17|`+`|단항 덧셈|
|17|`-`|단항 부정|
|16|`**`|지수|
|15|`*`|곱셈|
|15|`/`|나눗셈|
|13|`+`|덧셈|
|13|`-`|뺄셈|
|…|…|…|
|3|`=`|할당|
|…|…|…|

### 할당 연산자 `=`
- 할당(assignment) 연산자
- `x = value`
  - `value` 가 `x` 에 쓰여진 후, `value` 반환
```javascript
let a = 1;
let b = 2;
let c = 3 - ( a = b + 1 ); // 비권장 트릭 (명확성 · 가독성 ↓)
alert( a );                // 3 ( a = b + 1 );
alert( c );                // 0
```

### 할당 연산자 체이닝
- 여러 개 연결
- 평가 우측부터 진행
- 모든 변수 단일 값 공유
- 비권장 (명확성 · 가독성 ↓)
```javascript
let a, b, c;

// 비권장
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4

// 권장
c = 2 + 2;
b = c;
a = c;
```
### 복합 할당 연산자
```javascript
// 할당
let n = 2;
n = n + 5;
n = n * 2;

// 복합 할당
let n = 2;
n += 5; // n == 7  (n = n + 5)
n *= 2; // n == 14 (n = n * 2)
```
- 산술 연산자, 비트 연산자 적용
  - `/=`
  - `-=` 등
- 우선순위 할당 연산자 동일
```javascript
let n = 2;
n *= 3 + 5;
alert( n ); // 16 (*= 우측 먼저 평가)
```

### 증가 · 감소 연산자 `++` · `--`
- 숫자 하나 증가 · 감소
```javascript
let counter = 2;
counter++; // 3 (counter = counter + 1)
let counter = 2;
counter--; // 1 (counter = counter - 1)
```
- 변수에만 적용
- 값에 사용 시 에러
  - ex) `5++`
- 전위형(prefix form) &nbsp;&nbsp;: `++counter`
  - 증가 · 감소 후 새로운 값 반환
- 후위형(postfix form) : `counter++`
  - 증가 · 감소 전 기존 값 반환
```javascript
let counter = 0;
alert( ++counter ); // 1
let counter = 0;
alert( counter++ ); // 0
```
#### 다른 연산자 사이 증가 · 감소 연산자
- `++` · `--` 연산자 표현식 중간 사용
- 증가 · 감소 연산자의 우선순위
  - 다른 대부분 산술 연산자보다 ↑
  - 평가 먼저 실행
- 가독성 ↓
```javascript
// 비권장
let counter1 = 1;
alert( 2 * ++counter1 ); // 4
let counter2 = 1;
alert( 2 * counter2++ ); // 2 (counter++ '기존'값 반환)

// 권장
let counter3 = 1;
alert( 2 * counter3 );
counter3++;
```

### 비트 연산자
- 32비트 정수 변환 후 이진 연산
- 저수준(2진 표현) 연산
<br /><br />
- `&` &nbsp;&nbsp;&nbsp;: 비트 AND
- `|` &nbsp;&nbsp;&nbsp;: 비트 OR
- `^` &nbsp;&nbsp;&nbsp;: 비트 XOR
- `~` &nbsp;&nbsp;&nbsp;: 비트 NOT
- `<<` &nbsp;&nbsp;: 왼쪽 시프트 (LEFT SHIFT)
- `>>` &nbsp;&nbsp;: 오른쪽 시프트(RIGHT SHIFT)
- `>>>` : 부호 없는 오른쪽 시프트 (ZERO-FILL RIGHT SHIFT)

### 쉼표 연산자 `,`
- 여러 표현식 코드 한 줄 평가
- 표현식 각각 모두 평가, 마지막 표현식 평가 결과만 반환
```javascript
let a = (1 + 2, 3 + 4);
alert( a ); // 7 (3 + 4의 결과, 앞 결과는 버려짐)
```
- 쉼표 우선순위 매우 ↓
  - 할당 연산자 `=` 보다 더 ↓
- 괄호 중요한 역할
- 가독성 ↓
```javascript
let a = 1 + 2, 3 + 4;
// 괄호 없이 진행 순서
// ① a = 3, 7
// ② a = 3
// ③ 7 무시
alert( a ); // 3
```
- 사용처
  - 여러 동작 하나의 줄 처리
```javascript
// 한 줄 세 개 연산 수행
for (a = 1, b = 3, c = a * b; a < 10; a++) {
  // …
}
```

<br />

비교 연산자
==========

- `a > b`
- `a < b`
- `a >= b`
- `a <= b`
- `a == b` (동등)
- `a != b` (부동)

### 불린형 반환
- 불린형값 반환
- `true`
  - ‘긍정’ · ‘참’ · '사실’
- `false`
  - ‘부정’ · ‘거짓’ · '사실이 아님’
```javascript
alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true

// 비교 결과를 변수에 할당
let result = 5 > 4;
alert( result ); // true
```
### 문자열 비교
- ‘사전’ 순 문자열 비교
  - 사전편집(lexicographical)
- 사전 앞쪽 문자열 < 사전 뒤쪽 문자열
```javascript
alert( 'A' < 'Z' );       // true
alert( 'Glee' < 'Glow' ); // true
alert( 'Be' < 'Bee' );    // true
```

1. 두 문자열 첫 글자 비교
2. 첫 번째 문자열 첫 글자 다른 문자열 첫 글자보다 크면(작으면),<br />첫 번째 문자열 두 번째 문자열보다 크다고(작다고) 결론,<br />비교 종료
3. 두 문자열 첫 글자 같으면 두 번째 글자 같은 방식 비교
4. 글자 간 비교 끝날 때까지 과정 반복
5. 비교 종료,<br />문자열 길이 같으면 두 문자열 동일 결론,<br />비교 종료 후 두 문자열 길이 다르면 길이 긴 문자열 더 크다고 결론
- 정확히 유니코드 순 O, 사전 순 X
- 대 · 소문자 구별
  - `'A'` < `'a'`

### 다른 형 값 간 비교
- 자료형 다르면 숫자형 변환
```javascript
alert( '2' > 1 );   // true (문자열 '2'  숫자 2 변환 후 비교)
alert( '01' == 1 ); // true (문자열 '01' 숫자 1 변환 후 비교)

// 불린값
alert( true == 1 );  // true (true  : 1 변환 후 비교)
alert( false == 0 ); // true (false : 0 변환 후 비교)
```

#### 흥미로운 상황
- 동등 비교 연산자 `==` 피연산자
  - 숫자형 변환 O
- `Boolean` 명시적 변환
  - 숫자형 변환 X
```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b);       // true!
```

### 일치 연산자
- 동등 연산자 `==`
  - `-0` · `false` · `""` (빈 문자열) 구별 X
- 형 다른 피연산자 비교 시 숫자형 변환 때문
  - `""` (빈 문자열) · `false` 숫자형
    - `0` 으로 변환
```javascript
alert( 0 == false );  // true
alert( '' == false ); // true
```
- 일치 연산자 `===` 형 변환 없이 값 비교
- 자료형 동등 여부까지 검사
```javascript
alert( 0 === false ); // false (피연산자 형 다름)
```
- 불일치 연산자 `!==`
- 비교 결과 명확
  - 에러 발생 확률 ↓

### `===` · `null` · `undefined` 비교
- 일치 연산자 `===` 사용하여 `null` · `undefined` 비교
  - 두 값 자료형 다르기 때문에 거짓 반환
```javascript
alert( null === undefined ); // false
```
- 동등 연산자 `==` 사용하여 `null` · `undefined` 비교
  - 특별한 규칙 적용하여 참 반환
  - `null` · `undefined` → '각별한 커플’ 취급
  - 두 값 자기들끼리 잘 어울리지만 다른 값들과는 X

```javascript
alert( null == undefined ); // true
```
#### 산술 연산자 or 기타 비교 연산자 `<` · `>` · `<=` · `>=` 사용하여 `null` · `undefined` 비교
- `null` · `undefined` 숫자형 변환
  - `null` → `0`
  - `undefined` → `NaN`
#### `null` vs `0`
- 동등 연산자 `==`
  - 기타 비교 연산자 `<` · `>` · `<=` · `>=` 동작 방식 다름
```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```
- (1), (3)
  - (기타 비교 연산자 동작 원리 따라) `null` 숫자형 변환되어 `0` 되기 때문
- (2)
  - 동등 연산자 `==` 피연산자 `null` · `undefined` 형 변환 X
    - `null` · `undefined` 비교 시
      - `true`
    - 그 이외 경우 (`null` · `undefined` 다른 값과 비교)
      - `false`

#### 비교 불가능한 `undefined`
- `undefined` 다른 값과 비교 금지
```javascript
alert( undefined > 0 );  // false (1)
alert( undefined < 0 );  // false (2)
alert( undefined == 0 ); // false (3)
```
- (1), (2)
  - `undefined` → `NaN` 변환 (숫자형 변환)
    - `NaN` 피연산자 경우 비교 연산자 항상 `false` 반환
- (3)
  - `undefined`는 `null` · `undefined` 일치, 그 이외 값 일치 X
#### 함정 피하기
- 일치 연산자 `===` 제외 비교 연산자 피연산자에 `null` · `undefined` 사용 X
- `null` · `undefined` 가능성 있는 변수 `<` · `>` · `<=` · `>=` 피연산자 되지 않도록 주의
  - `null` · `undefined` 가능성 있는 변수 따로 처리 코드 추가

<br />

`if` 문, `?` 연산자 조건 처리
===========================

### `if` 문
- `if (…)` 문 괄호 안 조건 평가
- 실행 구문 단 한 줄이어도 중괄호 `{…}` 사용해 코드 블록으로 감싸기
  - 가독성 ↑
### 불린형 변환
- `if (…)` 문 괄호 안 표현식 평가 후 불린값 변환
- `0` (숫자) · `""` (빈 문자열) · `null` · `undefined` · `NaN`
  - 불린형 변환 시 `false`
  - ‘falsy (거짓 같은)’ 값
- 이 외 값 불린형 변환 시 `true`
  - ‘truthy (참 같은)’ 값
```javascript
// 절대 실행 X
if (0) { // 0 : falsy
  …
}

// 절대 실행
if (1) { // 1 : truthy
  …
}

// 평가 통해 확정된 불린값 if문 전달
let cond = (year == 2015); // 동등 비교 통해 true/false 여부 결정
if (cond) {
  …
}
```
### `else` 절
- `else` 뒤 코드 블록
  - 조건 거짓일 때 실행

### `else if` 복수 조건 처리
- 조건 여러 개 처리
- 마지막 `else` 필수 X (선택사항)
```javascript
if (…) {
  …
} else if (…) {
  …
} else { // 선택사항
  …
}
```

### 조건부 연산자 `?`
- 더 짧고 간결
- '삼항(ternary) 연산자’ (피연산자 3개)
  - 피연산자 3개 받는 유일 연산자
```javascript
condition ? value1 : value2;
//             true  : false
```

```javascript
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');
if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);

// 조건부 연산자 '?'
let accessAllowed1 = (age > 18) ? true : false;

// 괄호 생략 가능
// 물음표 연산자 우선순위 ↓
// 가독성 ↓
let accessAllowed2 =  age > 18  ? true : false;

// 비교 연산자 자체 true/false 반환
let accessAllowed3 =  age > 18;
```

### 다중 `?`
- 복수 조건 처리
```javascript
let age = prompt('나이를 입력해주세요.', 18);
let message =
  (age < 3)   ? '아기야 안녕?' :
  (age < 18)  ? '안녕!'       :
  (age < 100) ? '환영합니다!'  :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력 하셨군요!';
alert( message );
```

### 부적절한 `?`
- 물음표 연산자 `?` 를 `if` 문 대용 사용 종종 有
- 간결성 ↑ · 가독성 ↓
- 물음표 연산자 `?` 목적
  - 조건 따라 반환 값 달리하기
- `if` 문
  - 여러 분기 처리
```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

// 비권장 (가독성 ↓)
(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');

// 권장 (가독성 ↑)
if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```

<br />

논리 연산자
==========

- 피연산자
  - 모든 타입 값 가능
- 연산 결과
  - 모든 타입 가능

### OR 연산자 `||`
```javascript
let result = a || b;
```
- 기본적으로 불린값 조작에 사용
  - 인수 중 하나라도 `true`이면 `true` 반환
  - 그렇지 않으면 `false` 반환
```javascript
alert( true  || true );  // true
alert( false || true );  // true
alert( true  || false ); // true
alert( false || false ); // false
```
- 피연산자 불린형 아닐 시 불린형 변환
```javascript
// 1 → true, 0 → false
if (1 || 0) { // if( true || false )
  alert( 'truthy!' );
}
```
- `if` 문에 자주 사용
- `if` 문 안에 여러 가지 조건 가능
```javascript
let hour = 12;
let isWeekend = true;
if (hour < 10 || hour > 18 || isWeekend) {
  alert( '영업시간이 아닙니다.' );
}
```

### 첫 번째 truthy 찾는 OR 연산자 `||`
#### 자바스크립트 추가 기능 알고리즘
- _OR 연산자, 피연산자 여러 개인 경우_
```javascript
let result = value1 || value2 || value3;
```
1. 가장 왼쪽 피연산자 → 오른쪽 피연산자 평가
2. 각 피연산자 불린형 변환<br /> 변환 후 값 `true`이면 평가 중단 후 해당 피연산자 변환 전 원래 값 반환
3. 피연산자 모두 평가한 경우 (모든 피연산자 `false` 평가), 마지막 피연산자 반환
- ※ _**반환 값 : 형 변환 안 된 원래 값**_
```javascript
alert( 1 || 0 );                 // 1 (1 : truthy)
alert( null || 1 );              // 1 (1 : truthy)
alert( null || 0 || 1 );         // 1 (1 : truthy)
alert( undefined || null || 0 ); // 0 (모두 falsy, 마지막 값 반환)
```

#### ⓐ 변수 · 표현식 구성 목록에서 첫 번째 truthy 얻기
- 실제 값 들어있는 변수 찾아 반환
- 모든 변수에 값 없는 경우 마지막 반환

```javascript
let firstName = "";
let lastName = "";
let nickName = "바이올렛";
alert( firstName || lastName || nickName || "익명"); // 바이올렛
// 모든 변수 falsy이면 "익명" 출력
```

#### ⓑ 단락 평가 (short circuit evaluation)
- 왼쪽 → 오른쪽 평가 진행 중 truthy 만나면 나머지 값들 건드리지 않은 채 평가 중단
- 두 번째 피연산자 변수 할당 같은 부수적인 효과(side effect) 가질 때 부각
- 주사용
  - 연산자 왼쪽 조건 falsy일 때만 명령어 실행

```javascript
true  || alert("not printed"); // true 만나자마자 평가 중단 : alert 실행 X
false || alert("printed");
```

### AND 연산자 `&&`
```javascript
let result = a && b;
```
- 기본적으로 두 피연산자 모두 참일 때 `true` 반환
- 그 외 경우 `false` 반환
```javascript
alert( true  && true );  // true
alert( false && true );  // false
alert( true  && false ); // false
alert( false && false ); // false
```
- 피연산자 타입 제약 X
```javascript
if (1 && 0) { // 피연산자 숫자형 → 논리형 변환 : true && false
  alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
}
```

### 첫 번째 falsy 찾는 AND 연산자 `&&`
#### 자바스크립트 추가 기능 알고리즘
- _OR 연산자, 피연산자 여러 개인 경우_
```javascript
let result = value1 && value2 && value3;
```
1. 가장 왼쪽 피연산자 → 오른쪽 피연산자 평가
2. 각 피연산자 불린형 변환<br /> 변환 후 값 `false`이면 평가 중단 후 해당 피연산자 변환 전 원래 값 반환
3. 피연산자 모두 평가한 경우(모든 피연산자 `true` 평가), 마지막 피연산자 반환
- ※ _**반환 값 : 형 변환 안 된 원래 값**_
<br /><br />
- `&&` vs `||`
  - AND `&&`
    - 첫 번째 falsy 반환
  - OR　`||`
    - 첫 번째 truthy 반환
```javascript
// 첫 번째 피연산자 truthy이면 두 번째 피연산자 반환
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자 falsy이면 첫 번째 피연산자 반환, 두 번째 피연산자 무시
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```
- 피연산자 다수 연속 전달 가능
```javascript
alert( 1 && 2 && null && 3 ); // null
```
- 피연산자 모두 truthy
  - 마지막 피연산자 반환
```javascript
alert( 1 && 2 && 3 ); // 3 (마지막 값)
```

#### 우선순위
- `&&` > `||`

```javascript
// 동일
 a && b  ||  c && d
(a && b) || (c && d)
```

#### `if` 문 대체 X
- 일부 개발자들 `if` 문 ‘짧게’ 줄이는 용도 사용
  - 명확성 · 가독성 ↓
```javascript
let x = 1;
(x > 0) && alert( '0보다 큽니다!' );

let x = 1;
if (x > 0) {
  alert( '0보다 큽니다!' );
}
```

### NOT `!`
```javascript
let result = !value;
```
- 인수 하나 요구
1. 피연산자 불린형 변환
2. 변환 값의 역 반환
```javascript
alert( !true ); // false
alert( !0 );    // true
```
- 두 개 연달아 사용 `!!`
  - 값 불린형 변환
  - `==` 내장 함수 `Boolean`
```javascript
// !!
alert( !!"non-empty string" ); // true
alert( !!null );               // false

// Boolean
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) );               // false
```
- 우선순위
  - `!` > `&&` > `||`

<br />

nullish 병합 연산자 `??`
=======================

_**※ 최근 스펙 추가 (구식 브라우저 폴리필 필요)**_

- 여러 피연산자 중 값 ‘확정되어있는’ 변수 찾음
```javascript
a ?? b
```
1. `a`가 `null` · `undefined` 아니면 `a`
2. 그 외 경우 `b`
```javascript
// 동일 구문
x = a ?? b
x = (a !== null && a !== undefined) ? a : b;
```
```javascript
let firstName = null;
let lastName = null;
let nickName = "바이올렛";
// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```

### `??` vs `||`
- `||` : 첫 번째 truthy 값 반환
- `??` : 첫 번째 정의된(defined) 값 반환
- `null` · `undefined` · `0` 구분 시 중요한 차이점
  - `0` 할당될 수 있는 변수
    - `??` 사용 적합
```javascript
let height1 = height1 ?? 100; // 값 정의되지 않은 경우 100

let height2 = 0;
alert(height2 || 100); // 100 (0 : falsy)
alert(height2 ?? 100); // 0   (null, undefined : falsy)
```

### 우선순위
- 5 (낮은편)
- `=` · `?` < `??` < 대부분 연산자
- 복잡한 표현식 괄호 사용
```javascript
let height = null;
let width = null;
let area = (height ?? 100) * (width ?? 50); // 괄호 사용
alert(area); // 5000
```
- 안정성 관련 이슈
  - `&&` · `||` 함께 사용 X
```javascript
let x =  1 && 2  ?? 3; // SyntaxError: Unexpected token '??'
let x = (1 && 2) ?? 3; // 정상 작동
```

<br />

`while` · `for` 반복문
=================

### `while` 반복문

```javascript
while (condition) {
  // 코드
  // 반복문 본문 (body)
}
```
```javascript
let i = 0;
while (i < 3) {
  alert( i ); // 0, 1, 2
  i++;
}
```
- 반복문 본문 한 번 실행
  - 반복 (iteration)
- 반복문 조건
  - 모든 종류 표현식, 변수 가능
  - `while` 에 의해 평가, 불린값 변환
```javascript
let i = 3;

// while (i != 0)
while (i) { // (0 : falsy)
  alert( i );
i--;
}
```
- 본문 한 줄
  - 중괄호 필요 X
```javascript
let i = 3;
while (i) alert(i--);
```

### `do…while` 반복문
- 반복문 본문 아래 condition
- 본문이 먼저 실행, 조건 확인 후 조건 truthy인 동안 본문 계속 실행
- 본문 최소한 한 번 실행
```javascript
do {
  // 반복문 본문
} while (condition);
```
```javascript
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

### `for` 반복문
```javascript
for (begin; condition; step) {
  // 반복문 본문
}
```
```javascript
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
```

#### 인라인 변수 선언
- ‘카운터’ 변수 `i` 반복문 안에서 선언
- 반복문 안에서만 접근 가능
```javascript
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // Error: i is not defined
```
- 기존 정의된 변수 사용 가능
```javascript
let i = 0;
for (i = 0; i < 3; i++) { // 기존 정의된 변수 사용
  alert(i); // 0, 1, 2
}
alert(i); // 3
```

#### 구성 요소 생략
```javascript
let i = 0;
for (; i < 3; i++) {
  alert( i ); // 0, 1, 2
}
```
```javascript
let i = 0;
for (; i < 3;) { // while (i < 3)
  alert( i++ );  // 0, 1, 2
}
```
- 모든 구성 요소 생략
  - 무한 반복문
```javascript
for (;;) {
  // 끊임 없이 본문 실행
}
```

### 반복문 빠져나오기
- `break`
```javascript
let sum = 0;
while (true) {
  let value = +prompt("숫자를 입력하세요.", '');
  if (!value) break; //
  sum += value;
}
alert( '합계: ' + sum );
```

### 다음 반복으로 넘어가기
- 전체 반복문 멈추지 않음
- 현재 실행 중인 이터레이션 멈춤, 다음 이터레이션 강제 실행(조건 통과할 때)
- 현재 반복 종료, 다음 반복 넘어가고 싶을 때 사용
```javascript
for (let i = 0; i < 10; i++) {

  // 조건 참이면 남아있는 본문 실행 X
  if (i % 2 == 0) continue;
  alert(i); // 1, 3, 5, 7, 9
}
```

#### `continue`
 - 중첩 줄이는 데 도움
```javascript
for (let i = 0; i < 10; i++) {

  // if (i % 2 == 0) continue;
  if (i % 2) {
    alert( i );
  }
}
```
#### `?` 오른쪽에 `break` · `continue` 불가능
- 표현식 아닌 문법 구조 (syntax construct) 삼항 연산자 `?` 에 사용 X
  - `break` · `continue` 같은 지시자 삼항 연산자에 사용 X
```javascript
if (i > 5) {
  alert(i);
} else {
  continue;
}

(i > 5) ? alert(i) : continue; // X
```

### `break` · `continue` · `레이블`
- 레이블 (`label`)
  - 여러 개의 중첩 반복문 한 번에 빠져나옴
```javascript
labelName: for (…) {
  …
}
```
```javascript
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`(${i},${j})의 값`, '');

    // outer 레이블 붙은 반복문 찾고 해당 반복문 빠져나옴
    if (!input) break outer;
    …
  }
}
alert('완료!');
```
- 레이블 별도 줄 가능
```javascript
outer:
for (let i = 0; i < 3; i++) {
  …
}
```
- `continue` · 레이블 함께 사용 가능
  - 레이블 붙은 반복문의 다음 이터레이션 실행

#### 레이블 마음대로 '점프’ X
- `break` · `continue` 지시자 반복문 안에서만 사용
- 레이블 반드시 `break` · `continue` 지시자 위에 위치
```javascript
break label; // 아래 for 문으로 점프 X
label: for (…)
```

<br />

`switch` 문
========

- 복수 `if` 조건문 → `switch` 문
- 특정 변수 다양한 상황에서 비교
- 코드 자체 비교 상황 잘 설명

### 문법
```javascript
switch(x) {
  case 'value1':  // if (x === 'value1')
    …
    [break]
  case 'value2':  // if (x === 'value2')
    …
    [break]
  default:        // 선택사항
    …
    [break]
}
```
- `case` 문 안 `break` 문 없으면 조건 부합 여부 상관 없이 다음 `case` 문 실행
```javascript
let a = 2 + 2;
switch (a) {
  case 3:
    alert( '비교하려는 값보다 작습니다.' );
  case 4:
    alert( '비교하려는 값과 일치합니다.' );       // 실행
  case 5:
    alert( '비교하려는 값보다 큽니다.' );         // 실행
  default:
    alert( "어떤 값인지 파악이 되지 않습니다." ); // 실행
}
```

#### 인수 모든 형태 표현식 가능
```javascript
let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("표현식 +a는 1, 표현식 b+1는 1이므로 이 코드가 실행됩니다.");
    break;
  default:
    alert("이 코드는 실행되지 않습니다.");
}
```

### 여러 `case` 문 묶기
- 코드 같은 `case` 문 한데 묶음 가능
```javascript
let a = 3;
switch (a) {
  case 4:
    alert('계산이 맞습니다!');
    break;
  case 3: // 두 case문 묶음
  case 5:
    alert('계산이 틀립니다!');
    alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
    break;
  default:
    alert('계산 결과가 이상하네요.');
}
```

### 자료형 중요성
- 일치 비교 조건 확인
```javascript
let arg = prompt("값을 입력해주세요.");
switch (arg) {
  case '0':
  case '1':
    alert( '0이나 1을 입력하셨습니다.' );
    break;
  case '2':
    alert( '2를 입력하셨습니다.' );
    break;
  case 3: // 3 ≠ '3'
    alert( '이 코드는 절대 실행되지 않습니다!' );
    break;
  default:
    alert( '알 수 없는 값을 입력하셨습니다.' );
}
```

<br />

함수
====

### 함수 선언
#### 함수 선언문
- `function` 키워드
- 함수명
- (매개변수…)
```javascript
function name(param1, param2, … paramN) {
  // 함수 본문
}
```
  - 용도
    - 중복 코드 피하기
```javascript
function showMessage() {
  alert( '안녕하세요!' );
}
showMessage();
showMessage();
```

### 지역 변수
- 함수 내 선언 변수
- 함수 안에서만 접근
```javascript
function showMessage() {
  let message = "안녕하세요!"; // 지역 변수
  alert( message );
}
showMessage(); // 안녕하세요!
alert( message ); // ReferenceError: message is not defined
```

### 외부 변수
- 함수 외부 변수 접근
```javascript
let userName = 'John'; // 외부 변수
function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}
showMessage(); // Hello, John
```
- 함수 외부 변수 수정
```javascript
let userName = 'John';
function showMessage() {
  userName = "Bob"; // 외부 변수 수정
  let message = 'Hello, ' + userName;
  alert(message);
}
alert( userName ); // John (함수 호출 전)
showMessage();
alert( userName ); // Bob (함수 호출 후)
```
- 지역 변수 없는 경우에만 외부 변수 사용
- 외부 변수와 동일한 이름 함수 내부 변수 선언 시 내부 변수가 외부 변수 가림
```javascript
let userName = 'John';
function showMessage() {
  let userName = "Bob"; // 동일한 이름 함수 내부 변수
  let message = 'Hello, ' + userName; // Bob
  alert(message);
}
showMessage();          // Hello, Bob (내부 변수 userName 사용)
alert( userName );      // John (외부 변수 접근 X)
```

#### 전역 변수
- 함수 외부 선언 변수
- 모든 함수에서 접근 가능
- 같은 이름 가진 지역 변수에 가려지면 접근 X
- 되도록 사용 X
- 프로젝트 전반 사용 데이터

### 매개변수 (인자)
- 임의의 데이터 함수 내부에 전달
```javascript
function showMessage(who, text) { // 인자: who, text
  alert(who + ': ' + text);
}
showMessage('Ann', 'Hello!');      // Ann: Hello!
showMessage('Ann', "What's up?");  // Ann: What's up?
```
- 복사된 값 사용
```javascript
function showMessage(who, text) {
  who = '*' + who + '*';
  alert( who + ': ' + text );
}
let who = "Ann";
showMessage(who, "Hello"); // *Ann*: Hello
alert( who );              // Ann (외부 변수 변화 X : 복사된 값 사용)
```

#### 매개변수(인자) vs 인수
- 매개변수
  - 함수 선언문 괄호 사이 변수 (선언)
- 인수
  - 함수 호출 시 매개변수 전달 값 (호출)

### 기본값
- 함수 호출 시 매개변수 인수 전달 X
  - `undefined`
```javascript
function showMessage(who, text) {
  alert(who + ': ' + text);
}
showMessage("Ann"); // "Ann: undefined"
```
- 기본값 (default value) 설정
```javascript
function showMessage(who, text = "no text given") {
  alert( who + ": " + text );
}
showMessage("Ann");            // Ann: no text given
showMessage("Ann", undefined); // Ann: no text given (명시적 undefined 값 전달)
```
- 복잡한 표현식 기본값
```javascript
function showMessage(from, text = anotherFunction()) {
  // text값 없을 때 : anotherFunction() 호출
  // text값        : anotherFunction() 반환 값
}
```

#### 매개변수 기본값 평가 시점
- 함수 호출할 때마다 기본값 평가
  - 해당 매개변수 없을 때만

#### 매개변수 기본값 설정 다른 방법
- 함수 선언 후 매개변수 기본값 설정
- 구식 자바스크립트 매개변수 기본값 설정 기존 방법<br />(원래 매개변수 기본값 관련 구문 X)
```javascript
function showMessage(who, text) {
  // if 문
  if (text === undefined) {
    text = 'no text given';
  }

  // 논리 연산자 ||
  // text 값 falsy : 기본값 할당
  // 빈문자열("")  : text 값 전달 X 간주
  text = text || 'no text given';

  alert( who + ": " + text );
}

function showMessage(who, text) {
  …
}
```
- 모던 자바스크립트 다른 방법
```javascript
function showCount(count) {
  alert(count ?? "unknown"); // `undefined` or `null` : 'unknown' 출력
}
showCount(0);    // 0
showCount(null); // unknown
showCount();     // unknown
```

### 반환 값
- 함수 호출한 곳에 특정 값 반환
```javascript
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3
```
- 지시자 `return` 함수 내 어디서든 사용 가능
- 실행 흐름 지시자 `return` 만나면 함수 실행 즉시 중단, 함수 호출한 곳에 값 반환
- 함수 하나 여러 `return` 문
```javascript
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('보호자의 동의를 받으셨나요?');
  }
}
let age = prompt('나이를 알려주세요', 18);
if ( checkAge(age) ) {
  alert( '접속 허용' );
} else {
  alert( '접속 차단' );
}
```
- 지시자 `return` 만 명시
   - 함수 즉시 종료
```javascript
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  // checkAge(age) false 반환 : 실행 X
  alert( "영화 상영" );
}
```

#### `return` 문 없거나 `return` 지시자만 있는 함수
- `undefined` 반환
```javascript
function doNothing1() {
  /* empty */
}
alert( doNothing1() === undefined ); // true

function doNothing2() {
  return; // == return undefined
}
alert( doNothing2() === undefined ); // true
```

#### `return` · 값 사이 줄 삽입 X
```javascript
return
 (some + long + expression + or + whatever * f(a) + f(b))

↓↓↓

return; // 세미콜론 자동 삽입
 (some + long + expression + or + whatever * f(a) + f(b))
```
- 대신 괄호 사용
```javascript
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
### 함수명 짓기
- 대개 동사 : 어떤 동작 수행 코드
- 간결 · 명확 : 함수명만 보고도 함수 기능 힌트
- 관습 : 축약설명해주는 동사 접두어
  - 팀 내 합의된 접두어

|접두어|의미|
|:---:|---|
|`get`|값 반환함|
|`calc`|무언가 계산함|
|`create`|무언가 생성함|
|`check`|무언가 확인 후 불린값 반환|

- 예시

|함수명|기능|
|---|---|
|`showMessage(…)`|메시지 보여줌|
|`getAge(…)`|나이 나타내는 값 얻고 반환|
|`calcSum(…)`|합계 계산 후 결과 반환|
|`createForm(…)`|form 생성 후 작성된 form 반환|
|`checkPermission(…)`|승인 여부 확인 후 `true` · `false` 반환|

#### 함수는 동작 하나만 담당
- 함수명에 언급되어 있는 동작 정확히 수행
- 그 이외 동작 수행 X
- 독립적인 두 개 동작
  - 독립된 함수 두 개 나눠서 수행

#### 빈번한 실수
- `getAge` 함수
  - O : 나이 얻어옴
  - X : `alert` 창 나이 출력
- `createForm` 함수
  - O : form 만들고 반환
  - X : form 문서 추가
- `checkPermission` 함수
  - O : 승인 여부 확인 후 그 결과 반환
  - X : 승인 여부 보여주는 메시지 띄움
- ※ 접두어 붙여 만든 모든 함수
  - 팀에서 만든 규칙 준수

#### 아주 짧은 이름
- 빈번히 쓰이는 함수 중 이름 아주 짧은 함수 (예외)
  - `$` (jQuery)
  - `_` (Lodash)

### 함수 == 주석
- 함수
  - 간결
    - 테스트 · 디버깅 용이
    - 함수 그 자체 주석 역할
      - 자기 설명적(self-describing) 코드
  - 한 가지 기능만 수행
  - 길어지면 함수 분리

```javascript
function showPrimes1(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }
    alert( i ); // 소수
  }
}

// 함수 분리
function showPrimes2(n) {
  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;
    alert(i);  // a prime
  }
}
function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

<br />

함수 표현식
==========

#### 함수 취급 차이
- 자바스크립트
  - "특별한 종류의 값"
- 타 언어
  - "특별한 동작을 하는 구조"

#### 함수 선언 (Function Declaration)
```javascript
function sayHi() {
  alert( "Hello" );
}
```
#### 함수 표현식 (Function Expression)
- 함수 생성 후 변수에 할당<br />(함수 어떤 방식으로 만들어졌는지 관계 X)
  - 함수 == 값
    - 변수 할당 가능
    - 함수 값처럼 취급
```javascript
// 함수 만들고 변수 'sayHi'에 할당
let sayHi = function() {
  alert( "Hello" );
};
```
- 함수 == 값
  - alert 이용하여 함수 코드 출력<br />
  - 함수 값처럼 취급
```javascript
function sayHi() {
  alert( "Hello" );
}

// 함수 코드 출력
// 함수 괄호 없음 → 함수 실행 X
alert( sayHi );
```
- 함수 호출 가능
  - 일반적인 값과 조금 다름 (특별한 종류의 값)
- ### _본질은 값 → 값에 할 수 있는 일 함수에도 가능_
- 함수 복사 후 다른 변수 할당
```javascript
function sayHi1() {       // (1) 함수 생성 (함수 선언문)
  alert( "Hello1" );
}
let sayHi2 = function() { // (1) 함수 생성 (함수 표현식)
  alert( "Hello2" );
};
let func = sayHi1;        // (2) 함수 복사 (괄호 X)
func();   // Hello1       // (3) 복사한 함수 실행
sayHi1(); // Hello1       //     본래 함수도 정상적 실행
```

#### 끝에 세미 콜론
- 함수 표현식 끝에 세미콜론 `;`
- 함수 선언문
  - 중괄호 코드 블록　→ 세미콜론 X
- 함수 표현식
  - 값 취급 · 변수 할당 → 세미콜론 O
```javascript
function sayHi1() {       // 중괄호 코드 블록
  …
}  // 세미콜론 X
let sayHi2 = function() { // 값 취급 · 변수 할당
  …
}; // 세미콜론 O
```

### 콜백 함수
```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "동의하셨습니다." );
}
function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 함수 showOk · showCancel → ask 함수 인수로 전달
// 함수 → 함수 인수 : 콜백 함수
ask("동의하십니까?", showOk, showCancel); //
```
- 간결한 버전
```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },         // 익명 함수
  function() { alert("취소 버튼을 누르셨습니다."); } // 익명 함수
);
```

#### 함수 : "동작" 나타내는 값
- 일반적인 값 : 데이터
  - 문자열, 숫자 등
- 함수 : 하나의 *동작 (action)*
  - 동작 대변하는 값인 함수 변수 간 전달 후, 동작 필요할 때 이 값 실행

### 함수 선언문 vs 함수 표현식
#### ① 문법
- 함수 선언문
  - 주요 코드 흐름 중간에 독자적인 구문 형태로 존재
- 함수 표현식
  - 표현식 or 구문 구성 (syntax construct) 내부에 생성
```javascript
// 함수 선언문
function sum1(a, b) {
  return a + b;
}

// 함수 표현식
// 할당 연산자 '=' 이용해 만든 “할당 표현식” 우측에 생성
let sum2 = function(a, b) {
  return a + b;
};
```

#### ② 자바스크립트 엔진 함수 생성 타이밍
- 함수 표현식
  - 실제 실행 흐름 해당 함수 도달했을 때 함수 생성
  - 실행 흐름 함수 도달했을 때부터 해당 함수 사용 가능
- 함수 선언문
  - 함수 선언문 정의 전 호출 가능
  - 전역 함수 선언문 스크립트 위치 상관없이 어디서든 사용 가능
- 자바스크립트 내부 알고리즘
  - 스크립트 진짜 실행 전 "초기화 단계"
    - 함수 선언 방식의 함수 생성
  - 모든 함수 선언문 처리 이후 스크립트 실행
```javascript
// 함수 선언문
sayHi1("John"); // Hello1, John
function sayHi1(name) {
  alert( `Hello1, ${name}` );
}

// 함수 표현식
sayHi2("John"); // error!
let sayHi2 = function(name) {
  alert( `Hello2, ${name}` );
};
```

#### ③ 스코프
- 엄격 모드
  - 함수 선언문 코드 블록 내 위치
    - 블록 내부 어디서든 함수 접근 가능
    - 블록 외부 함수 접근 X
```javascript
let age = prompt("나이를 알려주세요.", 18);
// 조건 따라 함수 선언
// if문 블록 내부에서만 유효
if (age < 18) {
  function welcome() {
    alert("안녕!");
  }
} else {
  function welcome() {
    alert("안녕하세요!");
  }
}
// 함수 나중에 호출
welcome(); // Error: welcome is not defined
```
```javascript
let age = 16;
if (age < 18) {
  welcome();               // \   (실행)
  function welcome() {     //  |
    alert("안녕!");        //   |  함수 선언 블록 내 어디서든 유효
  }                        //  |
  welcome();               // /   (실행)
} else {
  function welcome() {
    alert("안녕하세요!");
  }
}
// 중괄호 밖 : 중괄호 안 선언 함수 선언문 호출 X
welcome(); // Error: welcome is not defined
```
- 함수 표현식
  - 블록 외부에서 블록 내부 함수 접근
```javascript
let age = prompt("나이를 알려주세요.", 18);
let welcome;
if (age < 18) {
  welcome = function() {
    alert("안녕!");
  };
} else {
  welcome = function() {
    alert("안녕하세요!");
  };
}
welcome(); // 정상 동작
```
- 물음표 연산자 `?`
  - 코드 단순화
```javascript
let age = prompt("나이를 알려주세요.", 18);
let welcome = (age < 18) ?
  function() { alert("안녕!"); } :
  function() { alert("안녕하세요!"); };
welcome(); // 정상 동작
```

#### 함수 선언문 vs 함수 표현식
- 함수 선언문 먼저 고려
  - 함수 선언 전 호출 가능 (좀 더 자유롭게 구성)
  - 가독성 ↑ (더 눈에 띔)
- 함수 표현식 필요 시 사용

<br />

화살표 함수
==========

- 함수 표현식보다 단순 · 간결
```javascript
let func = function(arg1, arg2, ...argN) {
  return expression;
};

↓↓↓

let func = (arg1, arg2, ...argN) => expression;
```
```javascript
let sum = function(a, b) {
  return a + b;
};

↓↓↓

let sum = (a, b) => a + b;

alert( sum(1, 2) ); // 3
```
- 인수 1개
  - 인수 괄호 생략 가능
```javascript
let double = function(n) { return n * 2 }

↓↓↓

let double = n => n * 2;

alert( double(3) ); // 6
```
- 인수 X
  - 빈 괄호 (괄호 생략 X)
```javascript
let sayHi = () => alert("안녕하세요!");
sayHi();
```
- 함수 동적 생성
```javascript
let age = prompt("나이를 알려주세요.", 18);
let welcome = (age < 18) ?
  () => alert('안녕') :
  () => alert("안녕하세요!");
welcome();
```
- 함수 본문 한 줄 화살표 함수
  -  타이핑 ↓

### 본문 여러 줄 화살표 함수
- 중괄호 `(…)` · `return` 지시자 사용해 명시적으로 결과값 반환
```javascript
let sum = (a, b) => {  // 중괄호
  let result = a + b;
  return result;       // return 지시자 결과값 반환
};
alert( sum(1, 2) );    // 3
```
