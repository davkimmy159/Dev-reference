`y` <sub>(Sticky flag)</sub> · searching at position
=======================================

##### `y` <sub>(플래그)</sub>
- 특정 위치 검색 시작 가능

### 어휘 검사 <sub>(정규 표현식 대표 사용법 중 하나)</sub>

##### ex\) 프로그래밍 언어 <sub>(구조적 요소 분석)</sub>
- HTML
  - 태그
  - 속성
  - 기타 등등
- JS
  - 함수
  - 변수
  - 기타 등등
- 기타 등등

##### 공통 필수 동작
- 특정 위치 읽기

##### `let varName = "value"` <sub>(변수명 읽기)</sub>
- `varName` <sub>(변수명)</sub>
  - `4` <sub>(위치)</sub> 시작
- `str.match(/\w+/)`
  - 1번째 단어
  - 모든 단어 <sub>(`g` 플래그)</sub>

#### `regexp.exec(str)` <sub>(정규 표현식 메서드)</sub>
- 특정 위치 검색 시작

##### `g` · `y` <sub>(플래그)</sub> 無
- 1번째 일치 문자열 검색
  - `str.match(regexp)` 동일

##### `g` <sub>(플래그)</sub> 有
- 검색 시작 위치
  - `regexp.lastIndex`
- 검색 성공 시
  - `regexp.lastIndex` 값 수정
    - 일치 문자열 바로 다음 위치

When a regexp is created, its `lastIndex` is `0`.

So, successive calls to `regexp.exec(str)` return matches one after another.

An example (with flag `g`):
```javascript
let str = 'let varName';

let regexp = /\w+/g;
alert(regexp.lastIndex); // 0 (initially lastIndex=0)

let word1 = regexp.exec(str);
alert(word1[0]); // let (1st word)
alert(regexp.lastIndex); // 3 (position after the match)

let word2 = regexp.exec(str);
alert(word2[0]); // varName (2nd word)
alert(regexp.lastIndex); // 11 (position after the match)

let word3 = regexp.exec(str);
alert(word3); // null (no more matches)
alert(regexp.lastIndex); // 0 (resets at search end)
```

Every match is returned as an array with groups and additional properties.

We can get all matches in the loop:
```javascript
let str = 'let varName';
let regexp = /\w+/g;

let result;

while (result = regexp.exec(str)) {
  alert( `Found ${result[0]} at position ${result.index}` );
  // Found let at position 0, then
  // Found varName at position 4
}
```

Such use of `regexp.exec` is an alternative to method `str.matchAll`.

Unlike other methods, we can set our own `lastIndex`, to start the search from the given position.

For instance, let's find a word, starting from position `4`:
```javascript
let str = 'let varName = "value"';

let regexp = /\w+/g; // without flag "g", property lastIndex is ignored

regexp.lastIndex = 4;

let word = regexp.exec(str);
alert(word); // varName
```

We performed a search of `\w+`, starting from position `regexp.lastIndex = 4`.

Please note: the search starts at position `lastIndex` and then goes further. If there's no word at position `lastIndex`, but it's somewhere after it, then it will be found:
```javascript
let str = 'let varName = "value"';

let regexp = /\w+/g;

regexp.lastIndex = 3;

let word = regexp.exec(str);
alert(word[0]); // varName
alert(word.index); // 4
```

…So, with flag `g` property `lastIndex` sets the starting position for the search.

**Flag `y` makes regexp.exec to look exactly at position `lastIndex`, not before, not after it.**

Here's the same search with flag `y`:
```javascript
let str = 'let varName = "value"';

let regexp = /\w+/y;

regexp.lastIndex = 3;
alert( regexp.exec(str) ); // null (there's a space at position 3, not a word)

regexp.lastIndex = 4;
alert( regexp.exec(str) ); // varName (word at position 4)
```

As we can see, regexp `/\w+/y` doesn't match at position `3` (unlike the flag `g`), but matches at position `4`.

Imagine, we have a long text, and there are no matches in it, at all. Then searching with flag `g` will go till the end of the text, and this will take significantly more time than the search with flag `y`.

In such tasks like lexical analysis, there are usually many searches at an exact position. Using flag `y` is the key for a good performance.
