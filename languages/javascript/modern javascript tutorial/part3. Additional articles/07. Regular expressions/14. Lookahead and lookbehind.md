[전·후]방 탐색
=============

### 전방 탐색

##### `X(?=Y)`
- `X` 검색
- 검색 성공 조건
  - 바로 다음 `Y` 有
    - ex\) `XY`

##### 단순 테스트
- 결과 내 `(?=…)` <sub>(괄호 내용)</sub> 포함 X

##### `\d+(?=€)`
- 숫자 <sub>(바로 다음 `€` 有)</sub>
```javascript
let str = "1 turkey costs 30€";

// 30
alert( str.match(/\d+(?=€)/) );
```

##### `X(?=Y)(?=Z)`
1. `X` 검색
2. 바로 다음 `Y` 유무 여부 테스트 <sub>(부재 시 실패)</sub>
3. 바로 다음 `Z` 유무 여부 테스트 <sub>(부재 시 실패)</sub>
4. 테스트 통과 시 검색 성공
- `Y` · `Z`
  - 동시 有 필수
    - `XYZ`
  - 상호 베타 시 불가능

##### `\d+(?=\s)(?=.*30)`
1. 숫자 <sub>(1개 이상)</sub>
    - 검색 대상
2. 공백 문자 <sub>(1개)</sub>
    - 테스트
3. `\n` <sub>(줄 바꿈 문자)</sub> 제외 모든 문자 <sub>(0개 이상)</sub>
    - 테스트
4. `30`
    - 테스트
```javascript
let str = "1 turkey costs 30€";

// 1
alert( str.match(/\d+(?=\s)(?=.*30)/) );
```

### 부정 전방 탐색

##### `X(?!Y)`
- `X` 검색
- 검색 성공 조건
  - 바로 다음 `Y` 無
    - ex\) `XZ`
```javascript
let str = "2 turkeys cost 60€";

// 2
alert( str.match(/\d+(?!€)/) );
```

### 후방 탐색 <sub>(↔ 전방 탐색)</sub>

##### `(?<=Y)X`
- `X` 검색
- 검색 성공 조건
  - 바로 이전 `Y` 有
    - ex\) `YX`

##### `(?<!Y)X` <sub>(부정)</sub>
- - `X` 검색
- 검색 성공 조건
  - 바로 이전 `Y` 無
    - ex\) `ZX`

##### `(?<=\$)\d+`
```javascript
let str = "1 turkey costs $30";

// 30
alert( str.match(/(?<=\$)\d+/) );
```

##### `(?<!\$)\d+`
```javascript
let str = "2 turkeys cost $60";

// 2
alert( str.match(/(?<!\$)\d+/) );
```

### 캡처링 그룹

##### [전·후]방 탐색 그룹화
- `()` <sub>(괄호)</sub> 추가
  - 전체
  - 일부

##### `\d+(?=(€|kr))` <sub>(전방 탐색)</sub>
- `(?=(€|kr))` <sub>(`(€|kr)`)</sub>
```javascript
let str = "1 turkey costs 30€";
let regexp = /\d+(?=(€|kr))/;

// 30, €
alert( str.match(regexp) );
```

##### `(?<=(\$|£))\d+` <sub>(후방 탐색)</sub>
- `(?<=(\$|£))` <sub>(`(\$|£)`)</sub>
```javascript
let str = "1 turkey costs $30";
let regexp = /(?<=(\$|£))\d+/;

// 30, $
alert( str.match(regexp) );
```

<br />

## 요약

### [전·후]방 탐색

##### 기능
- 전 · 후 문맥 따라 검색

|패턴|탐색|matches|
|:---:|---|---|
|`X(?=Y)`|전방|`X` 바로 다음 `Y` 有|
|`X(?!Y)`|부정 전방|`X` 바로 다음 `Y` 無|
|`(?<=Y)X`|후방|`X` 바로 이전 `Y` 有|
|`(?<!Y)X`|부정 후방|`X` 바로 이전 `Y` 無|

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### Find non-negative integers
There's a string of integer numbers.

Create a regexp that looks for only non-negative ones (zero is allowed).

An example of use:
```javascript
let regexp = /your regexp/g;

let str = "0 12 -5 123 -18";

alert( str.match(regexp) ); // 0, 12, 123
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The regexp for an integer number is `\d+.

We can exclude negatives by prepending it with the negative lookahead: `(?<!-)\d+`.

Although, if we try it now, we may notice one more "extra" result:
```javascript
let regexp = /(?<!-)\d+/g;

let str = "0 12 -5 123 -18";

console.log( str.match(regexp) ); // 0, 12, 123, 8
```

As you can see, it matches `8`, from `-18`. To exclude it, we need to ensure that the regexp starts matching a number not from the middle of another (non-matching) number.

We can do it by specifying another negative lookbehind: `(?<!-)(?<!\d)\d+`. Now `(?<!\d)` ensures that a match does not start after another digit, just what we need.

We can also join them into a single lookbehind here:
```javascript
let regexp = /(?<![-\d])\d+/g;

let str = "0 12 -5 123 -18";

alert( str.match(regexp) ); // 0, 12, 123
```

<hr />

### Insert After Head
We have a string with an HTML Document.

Write a regular expression that inserts `<h1>Hello</h1>` immediately after `<body>` tag. The tag may have attributes.

For instance:
```javascript
let regexp = /your regular expression/;

let str = `
<html>
  <body style="height: 200px">
  ...
  </body>
</html>
`;

str = str.replace(regexp, `<h1>Hello</h1>`);
```

After that the value of `str` should be:
```javascript
<html>
  <body style="height: 200px"><h1>Hello</h1>
  ...
  </body>
</html>
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

In order to insert after the `<body>` tag, we must first find it. We can use the regular expression pattern `<body.*>` for that.

In this task we don't need to modify the `<body>` tag. We only need to add the text after it.

Here's how we can do it:
```javascript
let str = '...<body style="...">...';
str = str.replace(/<body.*>/, '$&<h1>Hello</h1>');

alert(str); // ...<body style="..."><h1>Hello</h1>...
```

In the replacement string `$&` means the match itself, that is, the part of the source text that corresponds to `<body.*>`. It gets replaced by itself plus `<h1>Hello</h1>`.

An alternative is to use lookbehind:
```javascript
let str = '...<body style="...">...';
str = str.replace(/(?<=<body.*>)/, `<h1>Hello</h1>`);

alert(str); // ...<body style="..."><h1>Hello</h1>...
```

As you can see, there's only lookbehind part in this regexp.

It works like this:
- At every position in the text.
- Check if it's preceeded by `<body.*>`.
- If it's so then we have the match.

The tag `<body.*>` won't be returned. The result of this regexp is literally an empty string, but it matches only at positions preceeded by `<body.*>`.

So we replaces the "empty line", preceeded by `<body.*>`, with `<h1>Hello</h1>`. That's the insertion after `<body>`.

P.S. Regexp flags, such as `s` and `i` can also useful: `/<body.*>/si`. The `s` flag makes the dot `.` match a newline character, and `i` flag makes `<body>` also match `<BODY>` case-insensitively.
