재앙적인 되돌리기
=========================

##### 일부 정규 표현식
- 초장시간 실행
  - JS 엔진 멈춤 현상 발생

##### 전형적인 증상
- 특정 문자열 대상
  - 정상 · 비정상 동작 혼재
    - CPU 자원 100% 소모 등

### 예제

#### `^(\w+\s?)*$`

##### 정상 동작
```javascript
let regexp = /^(\w+\s?)*$/;

// true
alert( regexp.test("A good string") );

// false
alert( regexp.test("Bad characters: $@#") );
```

##### 비정상 동작
- CPU 자원 100% 소모
- JS 멈춤 현상 발생
- 브라우저 멈춤 현상 발생
- 일정 시간 후 페이지 리로드 제안 표시
```javascript
let regexp = /^(\w+\s?)*$/;
let str = "An input string that takes a long time or even makes this regexp to hang!";

// 장시간 검색 수행
alert( regexp.test(str) );
```

##### 정규 표현식 엔진 종류
- 일부
  - 처리 가능
- 대다수
  - 처리 X

### 예제 단순화

#### `^(\d+)*$`
```javascript
let regexp = /^(\d+)*$/;
let str = "012345678901234567890123456789!";

// 장시간 검색 수행
alert( regexp.test(str) );
```

##### `(\d+)*`
- 다소 이상한 형태
  - `*` <sub>(수량자 · 0개 이상)</sub> 불필요

### 과정

#### 1.

##### 1.1 `\d+` <sub>(greedy 모드)</sub>
- 모든 숫자 검색 성공
```
\d+........
(123456789)!
```

##### 1.2 `*` <sub>(수량자 · 0개 이상)</sub>
- 잔여 숫자 X
  - 0개 검색 성공

##### 1.3 `$` <sub>(문자열 끝)</sub>
- `!` <sub>(잔여 문자)</sub>
  - 문자열 끝 검색 실패
```
           X
\d+........$
(123456789)!
```

#### 2.

##### 2.1 `+` <sub>(greedy 모드)</sub>
- 일치 결과 내 문자 1개 되돌리기

##### 2.2 `\d+` 검색 일치 결과 상태
- 마지막 숫자 <sub>(`9`)</sub> 외 모든 숫자 검색 성공
```
\d+.......
(12345678)9!
```

#### 3.

##### 3.1 `(\d+)*`
- 새 위치 <sub>(`9`)</sub> 검색 이어 시작
  - `*` <sub>(0개 이상)</sub>
    - `9`
```
\d+.......\d+
(12345678)(9)!
```

##### 3.2 `$` <sub>(문자열 끝)</sub>
- `!` <sub>(잔여 문자)</sub>
  - 문자열 끝 검색 실패
```
             X
\d+.......\d+$
(12345678)(9)!
```

#### 4. 일치 결과 내 문자 1개 되돌리기 계속 진행

##### 
- 
There's no match, so the engine will continue backtracking, decreasing the number of repetitions. Backtracking generally works like this: the last greedy quantifier decreases the number of repetitions until it can. Then the previous greedy quantifier decreases, and so on.

All possible combinations are attempted. Here are their examples.

The first number `\d+` has 7 digits, and then a number of 2 digits:
```
             X
\d+......\d+
(1234567)(89)!
```

The first number has 7 digits, and then two numbers of 1 digit each:
```
               X
\d+......\d+\d+
(1234567)(8)(9)!
```

The first number has 6 digits, and then a number of 3 digits:
```
             X
\d+..... \d+
(123456)(789)!
```

The first number has 6 digits, and then 2 numbers:
```
               X
\d+.....\d+ \d+
(123456)(78)(9)!
```

…And so on.

There are many ways to split a set of digits `123456789` into numbers. To be precise, there are 2<sup>n</sup>-1, where `n` is the length of the set.

For `n=20` there are about 1 million combinations, for `n=30` – a thousand times more. Trying each of them is exactly the reason why the search takes so long.

What to do?

Should we turn on the lazy mode?

Unfortunately, that won't help: if we replace `\d+` with `\d+?`, the regexp will still hang. The order of combinations will change, but not their total count.

Some regular expression engines have tricky tests and finite automations that allow to avoid going through all combinations or make it much faster, but not all engines, and not in all cases.

## Back to words and strings
The similar thing happens in our first example, when we look words by pattern `^(\w+\s?)*$` in the string `An input that hangs!`.

The reason is that a word can be represented as one `\w+` or many:
```
(input)
(inpu)(t)
(inp)(u)(t)
(in)(p)(ut)
...
```

For a human, it's obvious that there may be no match, because the string ends with an exclamation sign `!`, but the regular expression expects a wordly character `\w` or a space `\s` at the end. But the engine doesn't know that.

It tries all combinations of how the regexp `(\w+\s?)*` can "consume" the string, including variants with spaces `(\w+\s)*` and without them `(\w+)*` (because spaces `\s?` are optional). As there are many such combinations, the search takes a lot of time.

### How to fix?
There are two main approaches to fixing the problem.

The first is to lower the number of possible combinations.

Let's rewrite the regular expression as `^(\w+\s)*\w*` – we'll look for any number of words followed by a space `(\w+\s)*`, and then (optionally) a word `\w*`.

This regexp is equivalent to the previous one (matches the same) and works well:
```javascript
let regexp = /^(\w+\s)*\w*$/;
let str = "An input string that takes a long time or even makes this regex to hang!";

alert( regexp.test(str) ); // false
```

Why did the problem disappear?

Now the star `*` goes after `\w+\s` instead of `\w+\s?`. It became impossible to represent one word of the string with multiple successive `\w+`. The time needed to try such combinations is now saved.

For example, the previous pattern `(\w+\s?)*` could match the word `string` as two `\w+`:
```
\w+\w+
string
```

The previous pattern, due to the optional `\s` allowed variants `\w+`, `\w+\s`, `\w+\w+` and so on.

With the rewritten pattern `(\w+\s)*`, that's impossible: there may be `\w+\s` or `\w+\s\w+\s`, but not `\w+\w+`. So the overall combinations count is greatly decreased.

### Preventing backtracking
It's not always convenient to rewrite a regexp. And it's not always obvious how to do it.

The alternative approach is to forbid backtracking for the quantifier.

The regular expressions engine tries many combinations that are obviously wrong for a human.

E.g. in the regexp `(\d+)*$` it's obvious for a human, that `+` shouldn't backtrack. If we replace one `\d+` with two separate `\d+\d+`, nothing changes:
```
\d+........
(123456789)!

\d+...\d+....
(1234)(56789)!
```

And in the original example `^(\w+\s?)*$` we may want to forbid backtracking in `\w+`. That is: `\w+` should match a whole word, with the maximal possible length. There's no need to lower the repetitions count in `\w+`, try to split it into two words `\w+\w+` and so on.

Modern regular expression engines support possessive quantifiers for that. They are like greedy ones, but don't backtrack (so they are actually simpler than regular quantifiers).

There are also so-called "atomic capturing groups" – a way to disable backtracking inside parentheses.

Unfortunately, in JavaScript they are not supported. But there's another way.

#### Lookahead to the rescue!
We can prevent backtracking using lookahead.

The pattern to take as much repetitions of `\w` as possible without backtracking is: `(?=(\w+))\1`.

Let's decipher it:
- Lookahead `?=` looks forward for the longest word `\w+` starting at the current position.
- The contents of parentheses with `?=...` isn't memorized by the engine, so wrap `\w+` into parentheses. Then the engine will memorize their contents
- …And allow us to reference it in the pattern as `\1`.

That is: we look ahead – and if there's a word \w+, then match it as `\1`.

Why? That's because the lookahead finds a word `\w+` as a whole and we capture it into the pattern with `\1`. So we essentially implemented a possessive plus `+` quantifier. It captures only the whole word `\w+`, not a part of it.

For instance, in the word `JavaScript` it may not only match `Java`, but leave out `Script` to match the rest of the pattern.

Here's the comparison of two patterns:
```javascript
alert( "JavaScript".match(/\w+Script/)); // JavaScript
alert( "JavaScript".match(/(?=(\w+))\1Script/)); // null
```

1. In the first variant `\w+` first captures the whole word `JavaScript` but then `+` backtracks character by character, to try to match the rest of the pattern, until it finally succeeds (when `\w+` matches `Java`).
2. In the second variant `(?=(\w+))` looks ahead and finds the word `JavaScript`, that is included into the pattern as a whole by \1, so there remains no way to find `Script` after it.

We can put a more complex regular expression into `(?=(\w+))\1 `instead of `\w`, when we need to forbid backtracking for `+` after it.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

There's more about the relation between possessive quantifiers and lookahead in articles
  - [Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead](https://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead)
  - [Mimicking Atomic Groups](https://blog.stevenlevithan.com/archives/mimic-atomic-groups)

<br />

Let's rewrite the first example using lookahead to prevent backtracking:
```javascript
let regexp = /^((?=(\w+))\2\s?)*$/;

alert( regexp.test("A good string") ); // true

let str = "An input string that takes a long time or even makes this regex to hang!";

alert( regexp.test(str) ); // false, works and fast!
```

Here `\2` is used instead of `\1`, because there are additional outer parentheses. To avoid messing up with the numbers, we can give the parentheses a name, e.g. `(?<word>\w+)`.
```javascript
// parentheses are named ?<word>, referenced as \k<word>
let regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;

let str = "An input string that takes a long time or even makes this regex to hang!";

alert( regexp.test(str) ); // false

alert( regexp.test("A correct string") ); // true
```

The problem described in this article is called "catastrophic backtracking".

We covered two ways how to solve it:
- Rewrite the regexp to lower the possible combinations count.
- Prevent backtracking.
