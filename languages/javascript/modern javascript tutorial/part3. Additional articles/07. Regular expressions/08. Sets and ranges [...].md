세트 · 범위 <sub>(`[…]`)</sub>
=====================

### 세트

##### `[…]` <sub>(대괄호)</sub>
- 대괄호 내 다수 문자 · 클래스 중 하나

##### `[eao]`
- 3글자 <sub>(`a` · `e` · `o`)</sub> 중 하나

##### 세트 · 일반 문자 조합
```javascript
// top · mop
let regexp = /[tm]op/gi;

// Mop,top
alert( "Mop top".match(regexp) );
```

##### 1개 문자에만 대응
```javascript
// Vola · Vila
let regexp = /V[oi]la/;

// null
alert( "Voila".match(regexp) );
```

### 범위

##### `[…-…]` <sub>(대괄호 내 하이픈)</sub>
- 대괄호 내 `-` <sub>(하이픈)</sub> 양쪽 문자 내 범위

##### `[a-z]`
- `a` ~ `z` 내 문자 1개

##### `[0-5]`
- `0` ~ `5` 내 숫자 1개

##### 범위 · 일반 문자 조합
```javascript
// x + 문자 1개 (A ~ F · 0 ~ 9) + 문자 1개 (A ~ F · 0 ~ 9)
let regexp = /x[0-9A-F][0-9A-F]/g;

// xAF
alert( "Exception 0xAF".match(regexp) );
```

##### `[0-9A-F]`
- 범위 2개
  - `0` ~ `9`
  - `A` ~ `F`

##### `[0-9A-Fa-f]` · `/[0-9A-F]/i`
- 범위 3개
  - `0` ~ `9`
  - `A` ~ `F`
  - `a` ~ `f`

##### `[…]` <sub>(대괄호)</sub> · 문자 클래스 조합
- ex\) `[\w-]`
  - 단어 구성 문자 · `-` <sub>(하이픈)</sub> 중 하나
- ex\) `[\s\d]`
  - 공백 문자 · 숫자 중 하나

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **문자 클래스 == 특정 세트 축약**

|클래스|세트|
|---|---|
|`\d`|`[0-9]`|
|`\w`|`[a-zA-Z0-9_]`|
|`\s`|`[\t\n\v\f\r ]`|
||일부 드문 유니코드|
||기타 특정 공백 문자|
|…|…|

<br />

#### `\w` · 다중 언어

##### `\w`
- `[a-zA-Z0-9_]` 축약
- 타 언어 X
  - 상형 문자
  - 키릴 문자
  - 기타 등등

##### 다중 언어 단어 구성 문자 패턴 구현
- 유니코드 프로퍼티 사용

##### `[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`
- `Alphabetic` <sub>(`Alpha`)</sub>
  - 문자
- `Mark` <sub>(`M`)</sub>
  - 억양
- `Decimal_Number` <sub>(`Nd`)</sub>
  - 숫자
- `Connector_Punctuation` <sub>(`Pc`)</sub>
  - `_` <sub>(밑줄)</sub> · 유사 문자
- `Join_Control` <sub>(`Join_C`)</sub>
  - 특수 코드 <sub>(`200c` · `200d`)</sub>
    - 연결선에 사용 <sub>(아라비아어 등)</sub>
```javascript
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hi 你好 12`;

// H,i,你,好,1,2
alert( str.match(regexp) );
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Edge · Firefox <sub>(`p{…}` 유니코드 프로퍼티 미지원)</sub>**

##### `p{…}` <sub>(유니코드 프로퍼티)</sub> 미구현
- [XRegExp](https://xregexp.com/) <sub>(라이브러리)</sub> 사용
- 범위 <sub>(필요 언어)</sub> 사용
  - `[а-я]` <sub>(키릴 문자)</sub>
  - 기타 등등

<br />

### 범위 제외

##### `[^…]` <sub>(대괄호 내 `^` 캐럿 시작)</sub>
- 대괄호 내 `^` <sub>(캐럿)</sub> 뒤 문자 · 범위 제외

|범위 제외|검색 결과|
|---|---|
|`[^aeyo]`|`a` · `e` · `y` · `o` 외 문자|
|`[^0-9]` <sub>(`\D`)</sub>|숫자 외 문자|
|`[^\s]` <sub>(`\S`)</sub>|공백 문자 외 문자|

##### `/[^\d\sA-Z]/gi`
- 문자 · 숫자 · 공백 문자 제외
```javascript
// @ · .
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) );
```

### `[…]` <sub>(대괄호)</sub> 내 이스케이프

##### `[…]`<sub>(대괄호)</sub> 내 특수 문자
- 의미 有
  - 이스케이프 필요
- 의미 武
  - 이스케이프 X
- 대다수
  - 이스케이프 불필요

|특수 문자|필요|불필요|
|---|:---:|:---:|
|`.` <sub>(점)</sub> · `+` · `(` · `)`|X|항상|
|`-` <sub>(하이픈)</sub>|처음 · 끝|중간|
|`^` <sub>(캐럿)</sub>|중간 · 끝|처음|
|`]`<sub>(닫는 대괄호)</sub>|항상|X|

##### `[.,]`
- `.` <sub>(점)</sub> · `,` <sub>(콤마)</sub> 둘 중 하나

##### `[-().^+]`
```javascript
// 이스케이프 X
let regexp = /[-().^+]/g;

// '+' · '-'
alert( "1 + 2 - 3".match(regexp) );
```

…But if you decide to escape them "just in case", then there would be no harm:
```javascript
// Escaped everything
let regexp = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(regexp) ); // also works: +, -
```

### Ranges and flag `u`
If there are surrogate pairs in the set, flag `u` is required for them to work correctly.

For instance, let's look for `[𝒳𝒴]` in the string `𝒳`:
```javascript
alert( '𝒳'.match(/[𝒳𝒴]/) ); // shows a strange character, like [?]
// (the search was performed incorrectly, half-character returned)
```

The result is incorrect, because by default regular expressions "don't know" about surrogate pairs.

The regular expression engine thinks that `[𝒳𝒴]` – are not two, but four characters:
1. left half of `𝒳` `(1)`,
2. right half of `𝒳` `(2)`,
3. left half of `𝒴` `(3)`,
4. right half of `𝒴` `(4)`.

We can see their codes like this:
```javascript
for(let i=0; i<'𝒳𝒴'.length; i++) {
  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500
};
```

So, the example above finds and shows the left half of `𝒳`.

If we add flag `u`, then the behavior will be correct:
```javascript
alert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳
```

The similar situation occurs when looking for a range, such as [𝒳-𝒴].

If we forget to add flag `u`, there will be an error:
```javascript
'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression
```

The reason is that without flag `u` surrogate pairs are perceived as two characters, so `[𝒳-𝒴]` is interpreted as `[<55349><56499>-<55349><56500>]` (every surrogate pair is replaced with its codes). Now it's easy to see that the range `56499-55349` is invalid: its starting code `56499` is greater than the end `55349`. That's the formal reason for the error.

With the flag `u` the pattern works correctly:
```javascript
// look for characters from 𝒳 to 𝒵
alert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴
```

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `Java[^script]`
We have a regexp `/Java[^script]/`.

Does it match anything in the string `Java`? In the string `JavaScript`?

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

Answers: **no, yes**.

- In the script `Java` it doesn't match anything, because [^script] means "any character except given ones". So the regexp looks for `"Java"` followed by one such symbol, but there's a string end, no symbols after it.
```javascript
alert( "Java".match(/Java[^script]/) ); // null
```

- Yes, because the part [^script] part matches the character `"S"`. It's not one of `script`. As the regexp is case-sensitive (no `i` flag), it treats `"S"` as a different character from `"s"`.
```javascript
alert( "JavaScript".match(/Java[^script]/) ); // "JavaS"
```

<hr />

### Find the time as hh:mm or hh-mm
The time can be in the format `hours:minutes` or `hours-minutes`. Both hours and minutes have 2 digits: `09:00` or `21-30`.

Write a regexp to find time:
```javascript
let regexp = /your regexp/g;
alert( "Breakfast at 09:00. Dinner at 21-30".match(regexp) ); // 09:00, 21-30
```

P.S. In this task we assume that the time is always correct, there's no need to filter out bad strings like "45:67". Later we'll deal with that too.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

Answer: `\d\d[-:]\d\d`.
```javascript
let regexp = /\d\d[-:]\d\d/g;
alert( "Breakfast at 09:00. Dinner at 21-30".match(regexp) ); // 09:00, 21-30
```

Please note that the dash '-' has a special meaning in square brackets, but only between other characters, not when it's in the beginning or at the end, so we don't need to escape it.
