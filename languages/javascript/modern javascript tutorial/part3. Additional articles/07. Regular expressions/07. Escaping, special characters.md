이스케이핑 <sub>(`\`)</sub> · 특수 문자
============================

##### `\` <sub>(역슬래시)</sub>
- 정규 표현식 내 특수 문자
  - 문자 클래스 명시 시 사용
    - ex\) `\d`

##### 정규 표현식 내 특수 문자 <sub>(강력한 검색 기능)</sub>
- `[`
- `\`
- `^` · `$`
- `.`
- `|`
- `?`
- `*` · `+`
- `(` · `)`

### 이스케이프

##### 문자 이스케이프
- 특수 문자 앞에 `\` <sub>(역슬래시)</sub> 추가
  - ex\) `.` → `\.`
- 특수 문자 → 일반 문자

##### `.` <sub>(점)</sub> 문자 <sub>(문자 클래스 X)</sub> 검색
- `\d\.\d`

|문자열|검색 결과|
|---|---|
|`"5.1"`|`5.1`|
|`"511"`|null|

```javascript
// 5.1
alert( "Chapter 5.1".match(/\d\.\d/) );

// null (looking for a real dot \.)
alert( "Chapter 511".match(/\d\.\d/) );
```

##### `(` · `)` <sub>(괄호)</sub> 문자 검색
- `g\(\)/)`
  - `"g()"`
```javascript
// "g()"
alert( "function g()".match(/g\(\)/) );
```

##### `\` <sub>(역슬래시)</sub> 문자 검색
- `\\`
  - `"\"`
```javascript
// '\'
alert( "1\\2".match(/\\/) );
```

### A slash
A slash symbol `'/'` is not a special character, but in JavaScript it is used to open and close the regexp: `/...pattern.../`, so we should escape it too.

Here's what a search for a slash `'/'` looks like:
```javascript
alert( "/".match(/\//) ); // '/'
```

On the other hand, if we're not using `/.../`, but create a regexp using `new RegExp`, then we don't need to escape it:
```javascript
alert( "/".match(new RegExp("/")) ); // finds /
```

### new RegExp
If we are creating a regular expression with `new RegExp`, then we don't have to escape `/`, but need to do some other escaping.

For instance, consider this:
```javascript
let regexp = new RegExp("\d\.\d");

alert( "Chapter 5.1".match(regexp) ); // null
```

The similar search in one of previous examples worked with `/\d\.\d/`, but `new RegExp("\d\.\d")` doesn't work, why?

The reason is that backslashes are "consumed" by a string. As we may recall, regular strings have their own special characters, such as `\n`, and a backslash is used for escaping.

Here's how "\d.\d" is preceived:
```javascript
alert("\d\.\d"); // d.d
```

String quotes "consume" backslashes and interpret them on their own, for instance:
- `\n` – becomes a newline character,
- `\u1234` – becomes the Unicode character with such code,
- …And when there's no special meaning: like `\d` or `\z`, then the backslash is simply removed.

So `new RegExp` gets a string without backslashes. That's why the search doesn't work!

To fix it, we need to double backslashes, because string quotes turn `\\` into `\`:
```javascript
let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d (correct now)

let regexp = new RegExp(regStr);

alert( "Chapter 5.1".match(regexp) ); // 5.1
```

<br />

## 요약
- conTo search for special characters `[ \ ^ $ . | ? * + ( ) `literally, we need to prepend them with a backslash `\` ("escape them").
- We also need to escape `/` if we're inside `/.../` (but not inside `new RegExp`).
- When passing a string `new RegExp`, we need to double backslashes `\\`, cause string quotes consume one of them.tent
