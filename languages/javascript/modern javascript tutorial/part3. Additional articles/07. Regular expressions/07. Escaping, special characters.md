이스케이프 <sub>(`\`)</sub> · 특수 문자
============================

##### `\` <sub>(역슬래시)</sub>
- 정규 표현식 내 특수 문자
  - 문자 클래스 명시 시 사용
    - ex\) `\d`

##### 정규 표현식 내 특수 문자 <sub>(강력한 검색 기능)</sub>
- `[`
- `\`
- `^` · `$`
- `.`
- `|`
- `?`
- `*` · `+`
- `(` · `)`

### 이스케이프

##### 문자 이스케이프
- 특수 문자 앞에 `\` <sub>(역슬래시)</sub> 추가
  - ex\) `.` → `\.`
- 특수 문자 → 일반 문자

##### `.` <sub>(점)</sub> 문자 <sub>(문자 클래스 X)</sub> 검색
- `\d\.\d`

|문자열|검색 결과|
|---|---|
|`"5.1"`|`5.1`|
|`"511"`|null|

```javascript
// 5.1
alert( "Chapter 5.1".match(/\d\.\d/) );

// null (looking for a real dot \.)
alert( "Chapter 511".match(/\d\.\d/) );
```

##### `(` · `)` <sub>(괄호)</sub> 문자 검색
- `g\(\)/)`
  - `"g()"`
```javascript
// "g()"
alert( "function g()".match(/g\(\)/) );
```

##### `\` <sub>(역슬래시)</sub> 문자 검색
- `\\` <sub>(문자열 · 정규 표현식)</sub>
  - `"\"`
```javascript
// '\'
alert( "1\\2".match(/\\/) );
```

### `/` <sub>(슬래시)</sub>

##### 특수 문자 X <sub>(일반 문자)</sub>
- JS 내 정규 표현식 의미 <sub>(`/…/`)</sub>
  - 이스케이프 필요

##### `/` <sub>(슬래시)</sub> 문자 검색
- `\/`
  - `"/"`
```javascript
// '/'
alert( "/".match(/\//) );
```

##### `new RegExp` <sub>(생성자)</sub>
- 이스케이프 불필요
```javascript
// '/'
alert( "/".match(new RegExp("/")) );
```

### `new RegExp` <sub>(생성자)</sub>

##### 이스케이프 주의
- `/` <sub>(슬래시)</sub>
  - 불필요
- 타 특수 문자
  - `\` <sub>(역슬래시)</sub> 2개 필요

##### `new RegExp("\d\.\d")`
- 불일치
  - `/\d\.\d/` 결과 상이
```javascript
let regexp = new RegExp("\d\.\d");

// null
alert( "Chapter 5.1".match(regexp) );
```

The similar search in one of previous examples worked with `/\d\.\d/`, but `new RegExp("\d\.\d")` doesn't work, why?

The reason is that backslashes are "consumed" by a string. As we may recall, regular strings have their own special characters, such as `\n`, and a backslash is used for escaping.

Here's how "\d.\d" is preceived:
```javascript
alert("\d\.\d"); // d.d
```

String quotes "consume" backslashes and interpret them on their own, for instance:
- `\n` – becomes a newline character,
- `\u1234` – becomes the Unicode character with such code,
- …And when there's no special meaning: like `\d` or `\z`, then the backslash is simply removed.

So `new RegExp` gets a string without backslashes. That's why the search doesn't work!

To fix it, we need to double backslashes, because string quotes turn `\\` into `\`:
```javascript
let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d (correct now)

let regexp = new RegExp(regStr);

alert( "Chapter 5.1".match(regexp) ); // 5.1
```

<br />

## 요약
- conTo search for special characters `[ \ ^ $ . | ? * + ( ) `literally, we need to prepend them with a backslash `\` ("escape them").
- We also need to escape `/` if we're inside `/.../` (but not inside `new RegExp`).
- When passing a string `new RegExp`, we need to double backslashes `\\`, cause string quotes consume one of them.tent
