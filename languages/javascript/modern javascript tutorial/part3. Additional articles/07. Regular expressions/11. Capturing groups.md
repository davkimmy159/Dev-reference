캡처링 그룹
=========

##### 패턴 괄호 둘러싸기
- `(…)`

##### 기능
1. 검색 결과 일부
    - 별도 항목 취급
2. 수량자 조합
    - 괄호 통째로 적용

### 예시

#### `"gogogo"`

##### `go+`
- `g` 1개 + `o` 1개 이상
- 검색 결과
  - `goooo`
  - `gooooooooo`
  - 기타 등등

##### `(go)+`
- `go` 1개 이상
- 검색 결과
  - `go`
  - `gogo`
  - `gogogo`
  - 기타 등등
```javascript
// "Gogogo"
alert( 'Gogogo now!'.match(/(go)+/ig) );
```

#### 도메인 <sub>(웹사이트)</sub>
```javascript
mail.com
users.mail.com
smith.users.mail.com
```

##### 도메인 구성
- 단어 연속
  - `.` <sub>(점)</sub> 구분 <sub>(끝 제외)</sub>

##### `(\w+\.)+\w+`
```javascript
let regexp = /(\w+\.)+\w+/g;

// site.com, my.site.com
alert( "site.com my.site.com".match(regexp) );
```

##### 문제점
- 도메인 내 `-` <sub>(하이픈)</sub> 검색 X
  - `\w` <sub>(단어 구성 문자)</sub> X
  - ex\) `my-site.com`

##### `([\w-]+\.)+\w+`
- `\w` → `[\w-]` <sub>(끝 제외)</sub>
  - 도메인 내 `-` <sub>(하이픈)</sub> 검색 가능

#### 이메일
- 도메인 패턴 확장

##### 이메일 형식
- `name@domain`

##### `name`
- `[-.\w]+`
  - 아무 단어
  - `-` <sub>(하이픈)</sub>
  - `.` <sub>(점)</sub>
```javascript
let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

// my@mail.com, his@site.com.uk
alert("my@mail.com @ his@site.com.uk".match(regexp));
```

##### 신뢰할 수 있는 유일한 이메일 확인 방법
- 메일 보내기

### 검색 결과 내 괄호 내용

##### 접근 숫자 부여
- 좌 → 우
- 검색 결과 내 괄호 내용 접근 가능

##### `str.match(regexp)` · `g` <sub>(플래그)</sub> 無
- 1번째 일치 검색 · 배열 반환

|인덱스|값|
|:---:|---|
|`0`|전체 검색 결과|
|`1`|1번째 괄호 내용|
|`2`|2번째 괄호 내용|
|…|…|

##### HTML 태그
- `<.*?>`
  - 전체 검색 결과 <sub>(태그 전체)</sub>
- `<(.*?)>`
  - 전체 검색 결과 <sub>(태그 전체)</sub>
  - 1번째 괄호 내용 <sub>(태그 문자)</sub>
```javascript
let str = '<h1>Hello, world!</h1>';
let tag = str.match(/<(.*?)>/);

alert( tag[0] ); // <h1>
alert( tag[1] ); // h1
```

#### 중첩 그룹

##### 괄호
- 중첩 가능

##### 접근 숫자 부여
- 좌 → 우

#### `<span class="my">`

##### 검색 목표
1. 전체 태그 내용
    - `span class="my"`
2. 태그명
    - `span`
3. 속성
    - `class="my"`

##### `<(([a-z]+)\s*([^>]*))>`
- 숫자 부여 기준
  - `(` <sub>(여는 괄호)</sub>

![regexp-nested-groups-pattern](../../images/03/07/11/regexp-nested-groups-pattern.svg)

```javascript
let str = '<span class="my">';
let regexp = /<(([a-z]+)\s*([^>]*))>/;

let result = str.match(regexp);
alert(result[0]); // <span class="my">
alert(result[1]); // span class="my"
alert(result[2]); // span
alert(result[3]); // class="my"
```

![regexp-nested-groups-matches](../../images/03/07/11/regexp-nested-groups-matches.svg)

#### 선택 그룹

##### `(…)?` <sub>(캡처링 그룹 0 ~ 1개)</sub>
- 항상 결과 배열 자리 차지
  - 검색 실패 시 `undefined`

#### `a(z)?(c)?`
- `a` 1개 + `z` 0 ~ 1개 + `c` 0 ~ 1개

##### `a`
```javascript
let match = 'a'.match(/a(z)?(c)?/);

alert( match.length ); // 3
alert( match[0] );     // a
alert( match[1] );     // undefined
alert( match[2] );     // undefined
```

##### `ac`
```javascript
let match = 'ac'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] );     // ac
alert( match[1] );     // undefined
alert( match[2] );     // c
```

### `matchAll` <sub>(메서드)</sub>

##### `g` <sub>(플래그)</sub> 상응 기능
- 전체 일치 검색
  - 캡처링 그룹 포함

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최신 메서드 <sub>(미지원 시 폴리필 필요)</sub>**

##### 구식 브라우저 미지원
- [폴리필](https://github.com/ljharb/String.prototype.matchAll) 필요

<br />

##### `match` <sub>(메서드)</sub> · `g` <sub>(플래그)</sub> 有
- 캡처링 그룹 미반환

##### `str.match(/<(.*?)>/g)`
- 일치 태그 문자열 배열 반환
  - 캡처링 그룹 X
```javascript
let str = '<h1> <h2>';
let tags = str.match(/<(.*?)>/g);

alert( tags ); // <h1>,<h2>
```

#### `matchAll` <sub>(메서드)</sub> 특징

##### 1. 반환 값
- 이터러블 <sub>(객체)</sub>
- 배열 X

##### 2. `g` <sub>(플래그)</sub> 有
- 일치 문자열마다 배열 반환
  - `0` <sub>(인덱스)</sub>
    - 일치 문자열
  - `1` ~ <sub>(인덱스)</sub>
    - 캡처링 그룹 내용

##### 3. 검색 실패 시 반환 값
- 빈 이터러블 <sub>(객체)</sub>
- `null` X

##### `str.matchAll(/<(.*?)>/gi)`
```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

// 이터러블 (객체)
// - [object RegExp String Iterator]
alert(results);

// - 배열 · 유사 배열 객체 X
// - 이터러블 (객체)
alert(results[0]); // undefined

// 이터러블 (객체) → 배열
results = Array.from(results);

alert(results[0]); // <h1>,h1
alert(results[1]); // <h2>,h2
```

#### 반환 값 <sub>(이터러블 객체)</sub>

##### 배열 변환 없이 사용 가능
- `for…of` <sub>(반복문)</sub>
```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

for(let result of results) {
  // <h1>,h1
  // <h2>,h2
  alert(result);
}
```
- 구조 분해 할당
```javascript
let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
```

##### 내부 개별 검색 결과 값
- `match` <sub>(메서드 · `g` 플래그 X)</sub> 형식 동일

|인덱스|값|
|:---:|---|
|`0`|[전체 검색 결과, 1번째 괄호 그룹, …]|
|`1`|상동|
|…|…|
|n|상동|

##### 추가 프로퍼티
- `index`
  - 검색 성공 순서
- `input`
  - 검색 대상 문자열
```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

let [tag1, tag2] = results;

alert( tag1[0] ); // <h1>
alert( tag1[1] ); // h1
alert( tag1.index ); // 0
alert( tag1.input ); // <h1> <h2>
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`matchAll` <sub>(메서드)</sub> 이터러블 <sub>(객체)</sub> 반환 이유**

#### 최적화

##### `matchAll` <sub>(메서드)</sub> 호출 시
- 검색 수행 X
- 이터러블 <sub>(객체)</sub> 반환
  - 내부 검색 결과 無
  - 반복문 순회 당 검색 수행
    - 불필요한 검색 방지

##### ex\) 텍스트 <sub>(잠재적 일치문 100개)</sub> 검색
- `for…of` <sub>(반복문)</sub>
  - 5개만 검색 · 작업 후 중단
  - 불필요한 나머지 95개 검색 X

<br />

### 기명 그룹

##### 접근 그룹명 부여
- 숫자보다 의미 명확

#### `(?<name>…)`

##### `groups` <sub>(프로퍼티)</sub>
- 기명 그룹 저장

##### 단일 날짜 검색
- `match` <sub>(메서드)</sub>
- 그룹명
  - `year` <sub>(연)</sub>
  - `month` <sub>(월)</sub>
  - `day` <sub>(일)</sub>
```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
let str = "2019-04-30";
let groups = str.match(dateRegexp).groups;

alert(groups.year);  // 2019
alert(groups.month); // 04
alert(groups.day);   // 30
```

##### 전체 날짜 검색
- `matchAll` <sub>(메서드)</sub> · `g` <sub>(플래그)</sub>
- 그룹명
  - `year` <sub>(연)</sub>
  - `month` <sub>(월)</sub>
  - `day` <sub>(일)</sub>
```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
let str = "2019-10-30 2020-01-01";
let results = str.matchAll(dateRegexp);

for(let result of results) {
  let {year, month, day} = result.groups;

  // 30.10.2019
  // 01.01.2020
  alert(`${day}.${month}.${year}`);
}
```

### 치환 시 캡처링 그룹

##### `str.replace(regexp, replacement)`
- `str` 내 `regexp` 검색 결과
  - `replacement` 치환
    - 캡처링 그룹 사용 가능

##### `$n` <sub>(숫자)</sub>
```javascript
let str = "John Bull";
let regexp = /(\w+) (\w+)/;

// Bull, John
alert( str.replace(regexp, '$2, $1') );
```

##### `$<name>` <sub>(그룹명)</sub>
- `year-month-day` → `day.month.year`
```javascript
let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str = "2019-10-30, 2020-01-01";

alert( str.replace(regexp, '$<day>.$<month>.$<year>') );
// 30.10.2019, 01.01.2020
```

### 캡처링 제외 그룹

##### `(?:…)`
- 수량자 적용
- 괄호 내용 제외 <sub>(사용 X)</sub>
  - 검색 결과
  - 치환

##### `(?:go)+ (\w+)`
- `(go)+` 괄호 내용 제외
```javascript
let str = "Gogogo John!";
let regexp = /(?:go)+ (\w+)/i;
let result = str.match(regexp);

alert( result[0] );     // Gogogo John
alert( result[1] );     // John
alert( result.length ); // 2
```

<br />

## 요약

### `(…)` <sub>(괄호)</sub>

##### 패턴 일부 그룹화
- 수량자 통째로 적용

#### 검색 결과 내 괄호 내용

##### 접근 숫자 부여
- 좌 → 우
- `1` ~ <sub>(인덱스)</sub>

##### 접근 그룹명 부여 가능
- `(?<name>…)`
- `groups` <sub>(프로퍼티)</sub>

#### 문자열 검색 메서드 반환 결과 내 캡처링 그룹

##### `str.match` <sub>(메서드)</sub>
- `g` <sub>(플래그)</sub> 없으면 반환

##### `str.matchAll` <sub>()</sub>
- 항상 반환

##### 치환 <sub>(`str.replace`)</sub> 시 사용
- `$n` <sub>(숫자)</sub>
- `$<name>` <sub>(그룹명)</sub>

##### 괄호 내용 제외
- `(?:…)`
  - 검색 결과 · 치환 시 사용 X
  - 수량자만 적용

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### MAC 주소 체크

##### [MAC 주소](https://en.wikipedia.org/wiki/MAC_address) <sub>(네트워크 인터페이스)</sub>
- 2자리 숫자 6개
  - 16진수
  - `:` <sub>(콜론)</sub> 구분
- ex\) `'01:32:54:67:89:AB'`

##### 정규 표현식 작성
- MAC 주소 여부 체크
```javascript
let regexp = /…/;

// true
alert( regexp.test('01:32:54:67:89:AB') );

// false
// - ':' (콜론) X
alert( regexp.test('0132546789AB') );

// false
// - 숫자 5개
alert( regexp.test('01:32:54:67:89') );

// false
// - ZZ (무효 숫자)
alert( regexp.test('01:32:54:67:89:ZZ') );
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 2자리 16진수 숫자
- `[0-9a-f]{2}`
- `i` <sub>(플래그)</sub> 有

##### 검색 개수
- `nn` 1개 + `:nn` 5개
  - `[0-9a-f]{2}(:[0-9a-f]{2}){5}`

##### `^ … $`
  - 문장 전체 일치 여부 검색

##### `/^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i`
```javascript
let regexp = /^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i;

// true
alert( regexp.test('01:32:54:67:89:AB') );

// false
// - ':' (콜론) X
alert( regexp.test('0132546789AB') );

// false
// - 숫자 5개
alert( regexp.test('01:32:54:67:89') );

// false
// - ZZ (무효 숫자)
alert( regexp.test('01:32:54:67:89:ZZ') );
```

<hr />

### 색상 검색

##### 정규 표현식 작성
- 특정 형식 색상 검색
  - `#nnn` <sub>(`#` + 16진수 숫자 3개)</sub>
  - `#nnnnnn` <sub>(`#` + 16진수 숫자 6개)</sub>
- 
Write a RegExp that matches colors in the format `#abc` or `#abcdef`. That is: `#` followed by 3 or 6 hexadecimal digits.

Usage example:
```javascript
let regexp = /your regexp/g;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef
```

P.S. This should be exactly 3 or 6 hex digits. Values with 4 digits, such as `#abcd`, should not match.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

A regexp to search 3-digit color `#abc`: `/#[a-f0-9]{3}/i`.

We can add exactly 3 more optional hex digits. We don't need more or less. The color has either 3 or 6 digits.

Let's use the quantifier `{1,2}` for that: we'll have `/#([a-f0-9]{3}){1,2}/i`.

Here the pattern `[a-f0-9]{3}` is enclosed in parentheses to apply the quantifier `{1,2}`.

In action:
```javascript
let regexp = /#([a-f0-9]{3}){1,2}/gi;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef #abc
```

There's a minor problem here: the pattern found `#abc` in `#abcd`. To prevent that we can add `\b` to the end:
```javascript
let regexp = /#([a-f0-9]{3}){1,2}\b/gi;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef
```

<hr />

### Find all numbers
Write a regexp that looks for all decimal numbers including integer ones, with the floating point and negative ones.

An example of use:
```javascript
let regexp = /your regexp/g;

let str = "-1.5 0 2 -123.4.";

alert( str.match(regexp) ); // -1.5, 0, 2, -123.4
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

A positive number with an optional decimal part is (per previous task): `\d+(\.\d+)?`.

Let's add the optional `-` in the beginning:
```javascript
let regexp = /-?\d+(\.\d+)?/g;

let str = "-1.5 0 2 -123.4.";

alert( str.match(regexp) );   // -1.5, 0, 2, -123.4
```

<hr />

### Parse an expression
An arithmetical expression consists of 2 numbers and an operator between them, for instance:
- `1 + 2`
- `1.2 * 3.4`
- `-3 / -6`
- `-2 - 2`

The operator is one of: `"+"`, `"-"`, `"*"` or `"/"`.

There may be extra spaces at the beginning, at the end or between the parts.

Create a function `parse(expr)` that takes an expression and returns an array of 3 items:
1. The first number.
2. The operator.
3. The second number.

For example:
```javascript
let [a, op, b] = parse("1.2 * 3.4");

alert(a); // 1.2
alert(op); // *
alert(b); // 3.4
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

A regexp for a number is: `-?\d+(\.\d+)?`. We created it in previous tasks.

An operator is `[-+*/]`. The hyphen `-` goes first in the square brackets, because in the middle it would mean a character range, while we just want a character `-`.

The slash `/` should be escaped inside a JavaScript regexp `/.../`, we'll do that later.

We need a number, an operator, and then another number. And optional spaces between them.

The full regular expression: `-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?`.

It has 3 parts, with `\s*` between them:
1. `-?\d+(\.\d+)?` – the first number,
2. `[-+*/]` – the operator,
3. `-?\d+(\.\d+)?` – the second number.

To make each of these parts a separate element of the result array, let's enclose them in parentheses: `(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)`.

In action:
```javascript
let regexp = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(regexp) );
```

The result includes:
- `result[0] == "1.2 + 12"1 (full match)
- `result[1] == "1.2"` (first group `(-?\d+(\.\d+)?)` – the first number, including the decimal part)
- `result[2] == ".2"` (second group `(\.\d+)?` – the first decimal part)
- `result[3] == "+"` (third group `([-+*\/])` – the operator)
- `result[4] == "12"` (forth group `(-?\d+(\.\d+)?)` – the second number)
- `result[5] == undefined` (fifth group `(\.\d+)?` – the last decimal part is absent, so it's undefined)

We only want the numbers and the operator, without the full match or the decimal parts, so let's "clean" the result a bit.

The full match (the arrays first item) can be removed by shifting the array `result.shift()`.

Groups that contain decimal parts (number 2 and 4) `(.\d+)` can be excluded by adding `?:` to the beginning: `(?:\.\d+)?`.

The final solution:
```javascript
function parse(expr) {
  let regexp = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(regexp);

  if (!result) return [];
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
```
