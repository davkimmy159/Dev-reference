Shadow DOM 이벤트
================

#### 컴포넌트 내 발생 이벤트 <sub>(외부 핸들러 이벤트 처리)</sub>

##### 타겟 재조정 <sub>(브라우저 · 캡슐화 유지)</sub>
- 내부 이벤트 대상 요소 → 컴포넌트 자체
```html
<user-card></user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <p>
        <button>Click me</button>
      </p>`
    ;

    this.shadowRoot.firstElementChild.onclick = function(e) {
      alert("Inner target: " + e.target.tagName);
    }
  }
});

document.onclick = function(e) {
  alert("Outer target: " + e.target.tagName);
}
</script>
```

![shadow-dom-and-events-1-1](../../images/03/06/07/shadow-dom-and-events-1-1.png)

![shadow-dom-and-events-1-2](../../images/03/06/07/shadow-dom-and-events-1-2.png)

![shadow-dom-and-events-1-3](../../images/03/06/07/shadow-dom-and-events-1-3.png)

##### 1. 내부 핸들러 <sub>(컴포넌트 · Shadow DOM)</sub>
- `Inner target: BUTTON`
- 이벤트 발생 요소 <sub>(타겟)</sub>

##### 2. 외부 핸들러 <sub>(문서 · Light DOM)</sub>
- `Outer target: USER-CARD`
- 컴포넌트 자체 <sub>(타겟 재조정)</sub>

##### 타겟 재조정 이점
- 컴포넌트 외부 <sub>(문서 · Light DOM)</sub>
  - 컴포넌트 내부 정보 처리 X

#### `slot` 내 렌더링 요소 <sub>(Light DOM)</sub>

##### 타겟 재조정 X
- 문서 <sub>(Light DOM)</sub> 내 위치

##### `<span slot="username">` 클릭 이벤트
- 문서 <sub>(Light DOM)</sub> 내 위치 <sub>(타겟 재조정 X)</sub>
  - 내 · 외부 핸들러 타겟 동일
```html
<user-card id="userCard">
  <span slot="username">John Smith</span>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <div>
        <b>Name:</b>
        <slot name="username"></slot>
      </div>`
    ;

    this.shadowRoot.firstElementChild.onclick = function(e) {
      alert("Inner target: " + e.target.tagName);
    }
  }
});

userCard.onclick = function(e) {
  alert(`Outer target: ${e.target.tagName}`);
}
</script>
```

![shadow-dom-and-events-2](../../images/03/06/07/shadow-dom-and-events-2.png)

### 버블링 · `event.composedPath()`
For purposes of event bubbling, flattened DOM is used.

So, if we have a slotted element, and an event occurs somewhere inside it, then it bubbles up to the `<slot>` and upwards.

The full path to the original event target, with all the shadow elements, can be obtained using `event.composedPath()`. As we can see from the name of the method, that path is taken after the composition.

In the example above, the flattened DOM is:
```html
<user-card id="userCard">
  #shadow-root
    <div>
      <b>Name:</b>
      <slot name="username">
        <span slot="username">John Smith</span>
      </slot>
    </div>
</user-card>
```

So, for a click on `<span slot="username">`, a call to `event.composedPath()` returns an array: [`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`]. That's exactly the parent chain from the target element in the flattened DOM, after the composition.

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Shadow tree details are only provided for `{mode:'open'}` trees**

If the shadow tree was created with `{mode: 'closed'}`, then the composed path starts from the host: `user-card` and upwards.

That's the similar principle as for other methods that work with shadow DOM. Internals of closed trees are completely hidden.

<br />

### event.composed
Most events successfully bubble through a shadow DOM boundary. There are few events that do not.

This is governed by the `composed` event object property. If it's `true`, then the event does cross the boundary. Otherwise, it only can be caught from inside the shadow DOM.

If you take a look at [UI Events specification](https://www.w3.org/TR/uievents/), most events have `composed: true`:
- `blur`, `focus`, `focusin`, `focusout`,
- `click`, `dblclick`,
- `mousedown`, `mouseup` `mousemove`, `mouseout`, `mouseover`,
- `wheel`,
- `beforeinput`, `input`, `keydown`, `keyup`.

All touch events and pointer events also have `composed: true`.

There are some events that have `composed: false` though:
- `mouseenter`, `mouseleave` (they do not bubble at all),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

These events can be caught only on elements within the same DOM, where the event target resides.

### Custom events
When we dispatch custom events, we need to set both `bubbles` and `composed` properties to `true` for it to bubble up and out of the component.

For example, here we create `div#inner` in the shadow DOM of `div#outer` and trigger two events on it. Only the one with `composed: true` makes it outside to the document:
```html
<div id="outer"></div>

<script>
outer.attachShadow({mode: 'open'});

let inner = document.createElement('div');
outer.shadowRoot.append(inner);

/*
div(id=outer)
  #shadow-dom
    div(id=inner)
*/

document.addEventListener('test', event => alert(event.detail));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: true,
  detail: "composed"
}));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: false,
  detail: "not composed"
}));
</script>
```

<br />

## 요약
Events only cross shadow DOM boundaries if their `composed` flag is set to `true`.

Built-in events mostly have `composed: true`, as described in the relevant specifications:
- [UI Events](https://www.w3.org/TR/uievents)
- [Touch Events](https://w3c.github.io/touch-events)
- [Pointer Events](https://www.w3.org/TR/pointerevents)
- …And so on.

Some built-in events that have `composed: false`:
- `mouseenter`, `mouseleave` (also do not bubble),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

These events can be caught only on elements within the same DOM.

If we dispatch a `CustomEvent`, then we should explicitly set `composed: true`.

Please note that in case of nested components, one shadow DOM may be nested into another. In that case composed events bubble through all shadow DOM boundaries. So, if an event is intended only for the immediate enclosing component, we can also dispatch it on the shadow host and set `composed: false`. Then it's out of the component shadow DOM, but won't bubble up to higher-level DOM.
