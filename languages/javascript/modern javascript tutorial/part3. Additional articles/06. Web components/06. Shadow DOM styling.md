Shadow DOM 스타일
================

##### Shadow DOM 내 스타일 태그
- `<style>`
- `<link rel="stylesheet" href="…">`
  - HTTP 캐시 저장 <sub>(재다운로드 X)</sub>
    - 다수 컴포넌트 내 사용 용이

##### 일반 규칙 <sub>(예외 有)</sub>
- 컴포넌트 <sub>(Shadow DOM)</sub> 내 스타일 규칙
  - Shadow 트리만 적용
- 문서 <sub>(Light DOM)</sub> 내 스타일 규칙
  - Light 트리만 적용

### `:host` <sub>(CSS 선택자)</sub>

##### _"Shadow tree host"_ 선택
- Shadow root 보유 요소
- `shadowRoot.host` <sub>(프로퍼티)</sub>

##### `:host`
- `<custom-dialog>`
```html
<template id="tmpl">
  <style>
    /* 커스텀 요소 자제 스타일 */
    :host {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.append(tmpl.content.cloneNode(true));
  }
});
</script>

<custom-dialog>
  Hello!
</custom-dialog>
```

![host](../../images/03/06/06/host.png)

### 캐스케이딩

##### _"Shadow tree host"_ <sub>(커스텀 요소 자체)</sub>
- Light DOM 내 위치
  - 문서 <sub>(Light DOM)</sub> 스타일 규칙 적용

##### 스타일 규칙 중복 <sub>(`:host` 선택자 · 문서)</sub>
- 문서 <sub>(Light DOM)</sub> 규칙 적용
- `:host` <sub>(Shadow DOM)</sub> 규칙 무시
```html
<style>
/* 문서 (Light DOM) */
/* 커스텀 요소 패딩 제거 */
custom-dialog {
  padding: 0;
}
</style>
```

##### 컴포넌트 자체 스타일 규칙 기본값 역할
- 필요 시 문서 내 별도 컴포넌트 스타일 규칙 설정
  - 스타일 적용 편의성 ↑
- `!important` <sub>(예외)</sub>
  - 문서 <sub>(Light DOM)</sub> 규칙 무시

### `:host(…)` <sub>(CSS 선택자)</sub>

##### `:host` 유사
- 특정 커스텀 요소 조건

##### `:host([centered])`
- `<custom-dialog centered>`
```html
<template id="tmpl">
  <style>
    :host([centered]) {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-color: blue;
    }

    :host {
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
  }
});
</script>

<custom-dialog centered>
  Centered!
</custom-dialog>

<custom-dialog>
  Not centered.
</custom-dialog>
```

![host-selector](../../images/03/06/06/host-selector.png)

### `:host-context(…)` <sub>(CSS 선택자)</sub>

##### `:host` 유사
- 특정 커스텀 · 조상 요소 조건

##### `:host-context(.dark-theme)`
- `.dark-theme` <sub>(클래스)</sub> 有
  - 커스텀 요소 자체
  - 조상 요소
```html
<body class="dark-theme">
  <custom-dialog>…</custom-dialog>
</body>
```

### `slot` 스타일

##### `<slot>` <sub>(요소)</sub> 내 렌더링 요소
- 문서 <sub>(Light DOM)</sub> 내 스타일 규칙 적용
- 컴포넌트 <sub>(Shadow DOM)</sub> 내 스타일 규칙 X

##### `<slot>` <sub>(요소)</sub> 내 `<span>`
- `font-weight: bold` 적용
  - 문서 <sub>(Light DOM)</sub> 내 스타일
- `background: red` X
  - 컴포넌트 <sub>(Shadow DOM)</sub> 내 스타일
  
```html
<!-- 문서 (Light DOM) 스타일 -->
<style>
  span {
    font-weight: bold;
  }
</style>

<user-card>
  <div slot="username">
    <span>John Smith</span>
  </div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <!-- 컴포넌트 (Shadow DOM) 스타일 -->
      <style>
        span {
          background: red;
        }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
```

![styling-slotted-content-1](../../images/03/06/06/styling-slotted-content-1.png)

#### `<slot>` <sub>(요소)</sub> 내 스타일 적용 방법 <sub>(2가지)</sub>

##### 1. `<slot>` <sub>(요소)</sub> 자체 스타일 적용 <sub>(CSS 상속)</sub>
- 모든 CSS 속성 상속 X <sub>(CSS 한계)</sub>
```html
<user-card>
  <div slot="username">
    <span>John Smith</span>
  </div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <!-- 컴포넌트 (Shadow DOM) 스타일 -->
      <style>
        slot[name="username"] {
          font-weight: bold;
        }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
```

![styling-slotted-content-1](../../images/03/06/06/styling-slotted-content-1.png)

##### 2. `::slotted(…)` <sub>(가상 클래스 · 2가지 조건)</sub>
1. `<slot>` 내 렌더링 요소 <sub>(Light DOM)</sub>
    - `slot` 이름 무관
    - 자식 노드 X
2. `(…)` <sub>(CSS 선택자)</sub>

##### `::slotted(div)`
- `<div slot="username">`
  - 자식 노드 X
```html
<user-card>
  <div slot="username">
    <div>John Smith</div>
  </div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <!-- 컴포넌트 (Shadow DOM) 스타일 -->
      <style>
        ::slotted(div) {
          border: 1px solid red;
        }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
```

![styling-slotted-content-2](../../images/03/06/06/styling-slotted-content-2.png)

##### `::slotted` <sub>(가상 클래스)</sub> 한계
- 하위 노드 선택 X
```css
/* 무효 CSS 선택자 */
::slotted(div span) { … }
::slotted(div) p { … }
```
- CSS 에서만 사용 가능
  - `querySelector`<sub>(JS)</sub> X

### CSS hooks with custom properties
How do we style internal elements of a component from the main document?

Selectors like `:host` apply rules to `<custom-dialog>` element or `<user-card>`, but how to style shadow DOM elements inside them?

There's no selector that can directly affect shadow DOM styles from the document. But just as we expose methods to interact with our component, we can expose CSS variables (custom CSS properties) to style it.

Custom CSS properties exist on all levels, both in light and shadow.

For example, in shadow DOM we can use `--user-card-field-color` CSS variable to style fields, and the outer document can set its value:
```html
<style>
  .field {
    color: var(--user-card-field-color, black);
    /* if --user-card-field-color is not defined, use black color */
  }
</style>
<div class="field">Name: <slot name="username"></slot></div>
<div class="field">Birthday: <slot name="birthday"></slot></div>
```

Then, we can declare this property in the outer document for `<user-card>`:
```css
user-card {
  --user-card-field-color: green;
}
```

Custom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner `.field` rule will make use of it.

Here's the full example:
```html
<style>
  user-card {
    --user-card-field-color: green;
  }
</style>

<template id="tmpl">
  <style>
    .field {
      color: var(--user-card-field-color, black);
    }
  </style>
  <div class="field">Name: <slot name="username"></slot></div>
  <div class="field">Birthday: <slot name="birthday"></slot></div>
</template>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));
  }
});
</script>

<user-card>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
```

![css-hooks-with-custom-properties](../../images/03/06/06/css-hooks-with-custom-properties.png)

<br />

## 요약
Shadow DOM can include styles, such as `<style>` or `<link rel="stylesheet">`.

Local styles can affect:
- shadow tree,
- shadow host with `:host`-family pseudoclasses,
- slotted elements (coming from light DOM), `::slotted(selector)` allows to select slotted elements themselves, but not their children.

Document styles can affect:
- shadow host (as it lives in the outer document)
- slotted elements and their contents (as that's also in the outer document)

When CSS properties conflict, normally document styles have precedence, unless the property is labelled as `!important`. Then local styles have precedence.

CSS custom properties pierce through shadow DOM. They are used as "hooks" to style the component:
1. The component uses a custom CSS property to style key elements, such as `var(--component-name-title, <default value>)`.
2. Component author publishes these properties for developers, they are same important as other public component methods.
3. When a developer wants to style a title, they assign `--component-name-title` CSS property for the shadow host or above.
4. Profit!
