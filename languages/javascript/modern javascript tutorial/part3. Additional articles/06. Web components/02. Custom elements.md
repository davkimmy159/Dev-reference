커스텀 요소
=========

##### 커스텀 HTML 요소
- 커스텀 클래스 사용해 정의
- 자체 API
  - 메서드
  - 프로퍼티
  - 이벤트
  - 기타 등등
- 내장 HTML 요소처럼 사용 가능
  - `<easy-tabs>`
  - `<sliding-carousel>`
  - `<beautiful-upload>`
  - 기타 등등

#### 종류 <sub>(2가지)</sub>

##### 1. 자체 커스텀 요소
- 완전 새로운 요소
- `HTMLElement` <sub>(추상 클래스)</sub> 상속

##### 2. 내장 커스텀 요소
- 기존 내장 요소 커스터마이징
- 내장 요소 상속
  - ex\) 버튼 <sub>(`HTMLButtonElement` 상속)</sub>

### 자체 커스텀 요소

##### 다양한 상세 정보 필요 <sub>(클래스 작성)</sub>
- 표시 방법
- 요소 추가 · 제거 시 동작
- 기타 등등

##### 커스텀 요소 클래스 작성
- 일부 선택 메서드 구현
```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
    /* 요소 생성 완료 */
  }

  connectedCallback() {
    // 문서 내 추가 · 제거 후 재추가 시 호출
  }

  disconnectedCallback() {
    // 문서 내 제거 · 재추가 후 제거 시 호출
  }

  static get observedAttributes() {
    // 변화 추적할 속성명 배열
    return [ … ];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // 변화 추적중인 속성값 변화 시 호출
  }

  adoptedCallback() {
    // 새 문서로 이동 시 호출
    // - document.adoptNode (드물게 사용)
  }

  /* 기타 메서드 · 프로퍼티 */
}
```

##### 커스텀 요소 등록
```javascript
customElements.define("my-element", MyElement);
```

##### 커스텁 요소 사용
- `<my-element>` <sub>(태그)</sub> 사용 시
  - `MyElement` <sub>(객체)</sub> 생성
    - 객체 내 해당 특수 메서드 호출
- JS 사용해 직접 생성 가능
```javascript
document.createElement('my-element');
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **커스텀 요소명 내 `-` <sub>(하이픈)</sub> 필수**

##### 내장 · 커스텀 요소명 충돌 방지 목적
- 유효 예
  - `my-element`
  - `super-button`
- 무효 예
  - `myelement`
  - `superbutton`

<br />

#### `<time-formatted>`

##### `<time>` <sub>(내장 요소)</sub>
- 일자 · 시간 정보
- 자체 형식 설정 X

##### 커스텀 날짜 요소 <sub>(`<time-formatted>`)</sub> 작성
- 자동 형식 · 언어 설정
```html
<script>
class TimeFormatted extends HTMLElement {

  /* (1) 단일 메서드 (connectedCallback) 구현
   호출 시점
   - 문서 내 추가
   - HTML 파서 감지
   내장 형식 설정자 사용 (범용 지원)
   - Intl.DateTimeFormat
   */
  connectedCallback() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

}

// (2) 커스텀 요소 등록
customElements.define("time-formatted", TimeFormatted);
</script>

<!-- (3) 커스텀 요소 사용 -->
<time-formatted datetime="2019-12-01"
  year="numeric" month="long" day="numeric"
  hour="numeric" minute="numeric" second="numeric"
  time-zone-name="short"
></time-formatted>
```

![example-time-formatted](../../images/03/06/02/example-time-formatted.png)

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **커스텀 요소 업그레이드**

##### 커스텀 요소 등록 전 등장
- 에러 X
- 미정의 태그
  - `:not(:defined)` <sub>(CSS)</sub>

##### `customElement.define` 호출
- 커스텀 요소 "업그레이드"
  - 각 요소 별 새 인스턴스 생성
  - `connectedCallback` <sub>(메서드)</sub> 호출
  - `:defined` <sub>(CSS)</sub>

##### 커스텀 요소 정보 메서드
- `customElements.get(name)`
  - 해당 클래스 반환
- `customElements.whenDefined(name)`
  - `Promise` 반환
    - 내부 값 X
    - 요소 정의 <sub>(등록)</sub> 완료 시 진행

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **요소 랜더링 : `connectedCallback` <sub>(생성자 X)</sub>**

##### 너무 이른 생성자 호출 시점
- 요소 생성 완료
- 속성값 처리 · 할당 X <sub>(브라우저)</sub>
  - `getAttribute` <sub>(메서드)</sub> 호출 시
    - `null` 반환 <sub>(렌더링 X)</sub>

##### 성능 이점
- 실제 필요 시점 전까지 렌더링 지연

##### `connectedCallback` <sub>(메서드)</sub>
- 문서 내 추가 시 호출
  - 실제 페이지 구성 요소
- 타 요소 내 추가 시 호출 X
  - 실제 페이지 구성 요소 X
- 분리된 별도 DOM 구성 가능
  - 요소 생성
  - 렌더링 X

<br />

### 속성 감지

##### 현재 `<time-formatted>` <sub>(태그)</sub> 구현체
- 렌더링 후 속성 변화 시 반영 X

##### 속성 감지
- `observedAttributes()` <sub>(정적 getter)</sub> 구현
  - 감지 대상 속성 리스트 반환
- `attributeChangedCallback` <sub>(메서드)</sub>
  - 해당 속성 변화 시 호출
  - 단일 속성 대상 호출 X <sub>(성능 이슈)</sub>
```html
<script>
class TimeFormatted extends HTMLElement {

  // (1) 렌더링 로직 분리 (별도 헬퍼 메서드)
  render() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

  // (2) 페이지 내 추가 시 호출 (렌더링)
  connectedCallback() {
    if (!this.rendered) {
      this.render();
      this.rendered = true;
    }
  }

  // (3) 감지할 속성 설정 (반환)
  static get observedAttributes() {
    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];
  }

  // (4) 감지중인 속성 변화 시 호출 (렌더링)
  attributeChangedCallback(name, oldValue, newValue) {
    this.render();
  }

}

customElements.define("time-formatted", TimeFormatted);
</script>

<time-formatted id="elem" hour="numeric" minute="numeric" second="numeric"></time-formatted>

<script>
// (5) 주기적으로 새 속성값 할당
setInterval(() => elem.setAttribute('datetime', new Date()), 1000);
</script>
```

![observing-attributes](../../images/03/06/02/observing-attributes.png)

### 렌더링 순서

##### DOM 생성 · 연결 순서 <sub>(HTML 파서)</sub>
- 부모 → 자식
- `<outer>` → `<inner>`
```javascript
<outer>
  <inner></inner>
</outer>
```

##### 커스텀 요소 생성 시 자식 정보 접근 X
- ex\) `innerHTML`
```html
<script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {

    // '' (빈 내용)
    alert(this.innerHTML);
  }

});
</script>

<user-info>John</user-info>
```

##### 커스텀 요소 생성 시점
- 자식 노드 생성 · 연결 X
  - DOM 준비 완료 X
- 자식 정보 접근
  - 속성 사용
  - 접근 지연
    - 지연 시간 0 `setTimeout`
```html
<script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {
    setTimeout(() => alert(this.innerHTML)); // John (*)
  }

});
</script>

<user-info>John</user-info>
```

Now the `alert` in line `(*)` shows "John", as we run it asynchronously, after the HTML parsing is complete. We can process children if needed and finish the initialization.

On the other hand, this solution is also not perfect. If nested custom elements also use `setTimeout to initialize themselves, then they queue up: the outer `setTimeout` triggers first, and then the inner one.

So the outer element finishes the initialization before the inner one.

Let's demonstrate that on example:
```html
<script>
customElements.define('user-info', class extends HTMLElement {
  connectedCallback() {
    alert(`${this.id} connected.`);
    setTimeout(() => alert(`${this.id} initialized.`));
  }
});
</script>

<user-info id="outer">
  <user-info id="inner"></user-info>
</user-info>
```

Output order:
1. outer connected.
2. inner connected.
3. outer initialized.
4. inner initialized.

We can clearly see that the outer element finishes initialization `(3)` before the inner one `(4)`.

There's no built-in callback that triggers after nested elements are ready. If needed, we can implement such thing on our own. For instance, inner elements can dispatch events like `initialized`, and outer ones can listen and react on them.

### Customized built-in elements
New elements that we create, such as `<time-formatted>`, don't have any associated semantics. They are unknown to search engines, and accessibility devices can't handle them.

But such things can be important. E.g, a search engine would be interested to know that we actually show a time. And if we're making a special kind of button, why not reuse the existing `<button>` functionality?

We can extend and customize built-in HTML elements by inheriting from their classes.

For example, buttons are instances of `HTMLButtonElement`, let's build upon it.

1. Extend `HTMLButtonElement` with our class:
```javascript
class HelloButton extends HTMLButtonElement { /* custom element methods */ }
```

2. Provide an third argument to `customElements.define`, that specifies the tag:
```javascript
customElements.define('hello-button', HelloButton, {extends: 'button'});
```

There may be different tags that share the same DOM-class, that's why specifying `extends` is needed.

3. At the end, to use our custom element, insert a regular `<button>` tag, but add `is="hello-button"` to it:
```html
<button is="hello-button">...</button>
```

Here's a full example:
```html
<script>
// The button that says "hello" on click
class HelloButton extends HTMLButtonElement {
  constructor() {
    super();
    this.addEventListener('click', () => alert("Hello!"));
  }
}

customElements.define('hello-button', HelloButton, {extends: 'button'});
</script>

<button is="hello-button">Click me</button>

<button is="hello-button" disabled>Disabled</button>
```

![customized-built-in-elements](../../images/03/06/02/customized-built-in-elements.png)

Our new button extends the built-in one. So it keeps the same styles and standard features like `disabled` attribute.

### References
- [HTML Living Standard](https://html.spec.whatwg.org/#custom-elements)
- [Compatiblity](https://caniuse.com/#feat=custom-elements)

<br />

## 요약
Custom elements can be of two types:

1. "Autonomous" – new tags, extending `HTMLElement`.

Definition scheme:
```javascript
class MyElement extends HTMLElement {
  constructor() { super(); /* ... */ }
  connectedCallback() { /* ... */ }
  disconnectedCallback() { /* ... */  }
  static get observedAttributes() { return [/* ... */]; }
  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
  adoptedCallback() { /* ... */ }
 }
customElements.define('my-element', MyElement);
/* <my-element> */
```

2. "Customized built-in elements" – extensions of existing elements.

Requires one more `.define` argument, and `is="..."` in HTML:
```javascript
class MyButton extends HTMLButtonElement { /*...*/ }
customElements.define('my-button', MyElement, {extends: 'button'});
/* <button is="my-button"> */
```

<br />

Custom elements are well-supported among browsers. Edge is a bit behind, but there's a [polyfill](https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs)

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 라이브 타이머 요소
잘 구성된 시각을 표시하는 `<time-formatted>` 요소가 이미 있습니다.

현재 시간을 표기하기 위해 `<live-timer>`요소를 작성하세요.
1. 내부적으로 `<time-formatted>`를 사용해야 하며 `<time-formatted>`의 기능을 똑같이 사용하지 않아야 합니다.
2. 매초 tick을 업데이트하십시오.
3. 모든 tick에 대해 `event.detail`에 현재 날짜와 함께 `tick`이라는 이름을 가진 사용자 정의 이벤트가 생성되어야 합니다(챕터 커스텀 이벤트 디스패치 참조).

사용법:
```html
<live-timer id="elem"></live-timer>

<script>
  elem.addEventListener('tick', event => console.log(event.detail));
</script>
```

데모:
![assignment-live-timer-element](../../images/03/06/02/assignment-live-timer-element.png)

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

두 가지 참고 사항이 있습니다.
1. 요소가 문서에서 제거되면 `setInterval` 타이머도 지웁니다. 그러지 않으면 더 필요하지 않더라도 계속 tick 하므로 타이머를 지우는 것은 중요합니다. 그리고 `setInterval` 타이머를 지우지 않으면 브라우저는 요소의 메모리와 요소에 의해 참조된 메모리를 지우고 참조할 수 없습니다.
2. 현재 날짜는 `elem.date` 프로퍼티로 접근할 수 있습니다. 당연히 모든 클래스 메서드와 프로퍼티는 요소 메서드와 프로퍼티입니다.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/6811D6dLLQHBeW1z?p=preview)
