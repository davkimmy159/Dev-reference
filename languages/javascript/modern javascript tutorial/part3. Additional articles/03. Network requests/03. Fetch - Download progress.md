`Fetch` <sub>(다운로드 진행)</sub>
============================

##### `fetch` <sub>(메서드)</sub>
- 다운로드 진행과정 추적 가능
- 업로드 진행과정 추적 X
  - `XMLHttpRequest` 사용

##### `response.body` <sub>(프로퍼티)</sub>
- `ReadableStream` <sub>(특수 객체)</sub>
  - 청크 단위 본문 접근 <sub>(다운로드 도중)</sub>
  - [Streams API](https://streams.spec.whatwg.org/#rs-class) <sub>(명세)</sub>
- 타 메서드 차이 <sub>(`text()` · `json()` 등)</sub>
  - 읽기 프로세스 전반 조작 가능
  - 읽은 양 카운트 가능

##### `response.body` 읽기
```javascript
const reader = response.body.getReader();

while(true) {
  /*
   done (boolean)
   - 읽기 완료 여부
   value
   - Uint8Array (청크 바이트)
     - 바이트 배열 (타입 有)
   */
  const { done, value } = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### 비동기 반복문 지원 <sub>(명세 · [범용 지원 불충분 X](https://github.com/whatwg/streams/issues/778#issuecomment-461341033))</sub>
- `for await … of`
```javascript
// ReadableStream (객체)
for await (const value of response.body) { … }
```
- [범용 지원 불충분 X](https://github.com/whatwg/streams/issues/778#issuecomment-461341033)

<br />

We receive response chunks in the loop, until the loading finishes, that is: until `done` becomes `true`.

To log the progress, we just need for every received fragment `value` to add its length to the counter.

Here's the full working example that gets the response and logs the progress in console, more explanations to follow:
```javascript
// Step 1: start the fetch and obtain a reader
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Step 2: get total length
const contentLength = +response.headers.get('Content-Length');

// Step 3: read the data
let receivedLength = 0; // received that many bytes at the moment
let chunks = []; // array of received binary chunks (comprises the body)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Received ${receivedLength} of ${contentLength}`)
}

// Step 4: concatenate chunks into single Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Step 5: decode into a string
let result = new TextDecoder("utf-8").decode(chunksAll);

// We're done!
let commits = JSON.parse(result);
alert(commits[0].author.login);
```

Let's explain that step-by-step:
1. We perform `fetch` as usual, but instead of calling `response.json()`, we obtain a stream reader `response.body.getReader()`.

    Please note, we can't use both these methods to read the same response: either use a reader or a response method to get the result.

2. Prior to reading, we can figure out the full response length from the `Content-Length` header.

    It may be absent for cross-origin requests (see chapter CORS) and, well, technically a server doesn't have to set it. But usually it's at place.

3. Call `await reader.read()` until it's done.

    We gather response chunks in the array `chunks`. That's important, because after the response is consumed, we won't be able to "re-read" it using `response.json()` or another way (you can try, there'll be an error).

4. At the end, we have `chunks` – an array of `Uint8Array` byte chunks. We need to join them into a single result. Unfortunately, there's no single method that concatenates those, so there's some code to do that:

    1. We create `chunksAll = new Uint8Array(receivedLength)` – a same-typed array with the combined length.
    2. Then use `.set(chunk, position)` method to copy each `chunk` one after another in it.

5. We have the result in `chunksAll`. It's a byte array though, not a string.

    To create a string, we need to interpret these bytes. The built-in TextDecoder does exactly that. Then we can `JSON.parse` it, if necessary.

    What if we need binary content instead of a string? That's even simpler. Replace steps 4 and 5 with a single line that creates a `Blob` from all chunks:
```javascript
let blob = new Blob(chunks);
```

At the end we have the result (as a string or a blob, whatever is convenient), and progress-tracking in the process.

Once again, please note, that's not for upload progress (no way now with `fetch`), only for download progress.
