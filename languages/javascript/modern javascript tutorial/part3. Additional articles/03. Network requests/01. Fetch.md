`fetch`
=======

##### 네트워크 요청
- 주문 전송
- 사용자 정보 읽기
- 서버 최신 변경 정보 가져오기
- 등등

##### AJAX <sub>(Asynchronous JavaScript And XML)</sub>
- 포괄적 기술 표현 용어
  - 서버 정보 비동기적 요청

##### `fetch` <sub>(메서드)</sub>
- 모던 · 다재다능
- 대다수 모던 브라우저 지원
- 구식 브라우저 미지원
  - 폴리필 사용

#### 기본 문법
```javascript
let promise = fetch(url, [options]);
```

##### `url`
- URL

##### `options` <sub>(선택)</sub>
- 메서드 · 헤더 등 지정
- 미전달 시
  - `GET` <sub>(메서드)</sub> 요청 진행
      - `url` 콘텐츠 다운로드

##### 메서드 호출
- 네트워크 요청 전송
- 프라미스 반환
  - 메서드 호출 코드 내 사용

### 응답 <sub>(보통 2단계)</sub>

#### 1. 서버 응답 헤더 도착

##### 이행 상태
- 프라미스 <sub>(`fetch` 메서드 반환값)</sub>
- [`Response`](https://fetch.spec.whatwg.org/#response-class) <sub>(내장 클래스)</sub> 인스턴스

##### 본문 <sub>(body)</sub> 도착 전 상태
- 응답 헤더 확인
  - 요청 처리 성공 · 실패

##### HTTP 요청 전송 불가 상태 <sub>(네트워크 문제 · 부재 사이트 접속 등)</sub>
- 거부 상태 프라미스 <sub>(`fetch` 메서드 반환값)</sub>

#### 응답 프로퍼티 <sub>(HTTP 상태)</sub>

##### `status`
- HTTP 상태 코드
  - ex\) `200` 등

##### `ok` <sub>(`boolean`)</sub>
- `true`
  - `200` ~ `299` <sub>(HTTP 상태 코드)</sub>
```javascript
let response = await fetch(url);

// 요청 성공
// - 200 ~ 299 (HTTP 상태 코드)
if (response.ok) {

  // 응답 몬문 받기
  let json = await response.json();

// 요청 실패
} else {
  alert("HTTP-Error: " + response.status);
}
```

#### 2. 응답 본문 받기 <sub>(추가 메서드 호출)</sub>

##### `response` <sub>([`Response`](https://fetch.spec.whatwg.org/#response-class) 내장 클래스 인스턴스)</sub> 메서드
- `text()`
  - 응답 읽고 텍스트 반환
- `json()`
  - 응답 파싱 <sub>(JSON 형태)</sub>
- `formData()`
  - 응답 반환 <sub>(`FormData` 객체 형태)</sub>
- `blob()`
  - 응답 반환 <sub>(`Blob` 형태)</sub>
    - 타입 있는 바이너리 데이터
- `arrayBuffer()`
  - 응답 반환 <sub>(`ArrayBuffer` 형태)</sub>
    - 바이너리 데이터 <sub>(로우 레벨 형식)</sub>
- `response.body` <sub>(프로퍼티)</sub>
  - [`ReadableStream`](https://streams.spec.whatwg.org/#rs-class) <sub>(객체)</sub>
  - 응답 본문 읽기 <sub>(청크 단위)</sub>

##### GitHub 마지막 커밋 받기 <sub>(JSON 객체 형태)</sub>
- `await` 사용
```javascript
let url = 'https://api.github.com/repos/javascript-tutorial/ko.javascript.info/commits';
let response = await fetch(url);

// 응답 본문 읽고 파싱 (JSON 형태)
let commits = await response.json();

alert(commits[0].author.login);
```
- 프라미스만 사용 <sub>(`await` X)</sub>
```javascript
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```
- 텍스트 형태 응답 받기
  - `.json()` X
  - `.text()`
```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// 응답 본문 읽기 (텍스트 형태)
let text = await response.text();

alert(text.slice(0, 80) + '...');
```

##### `fetch` [명세서](https://fetch.spec.whatwg.org/) 우상단 로고 <sub>(바이너리 데이터)</sub> 가져오기
```javascript
let response = await fetch('/article/fetch/logo-fetch.svg');

// 응답 다운로드 (Blob 객체 형태)
let blob = await response.blob();

// <img> (요소) 생성
// - 다운로드받은 Blob (객체) 설정
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// 이미지 표시
img.src = URL.createObjectURL(blob);

// 3초 후 이미지 제거
setTimeout(() => {
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **중요**

##### 본문 읽기 메서드
- 단 하나만 사용 가능

##### 응답 얻은 후
- 본문 콘텐츠 처리 완료 상태
```javascript
// 응답 본문 소비
let text = await response.text();

// 실패
let parsed = await response.json();
```

<br />

### 응답 헤더

##### `response.headers` 저장
- 맵 유사 <sub>(맵 X)</sub>
  - 유사 메서드 지원
    - 헤더 일부 추출
    - 헤더 전체 순회
    - 기타 등등
```javascript
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// 헤더 일부 추출
// - application/json; charset=utf-8
alert(response.headers.get('Content-Type'));

// 헤더 전체 순회
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
```

### 요청 헤더

##### `headers` 옵션
- 헤더 정보 객체
- `fetch` 요청 헤더 설정
```javascript
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
```

##### `headers` 설정 불가능 헤더 <sub>([전체 목록](https://fetch.spec.whatwg.org/#forbidden-header-name))</sub>
- `Accept-[Charset·Encoding]`
- `Access-Control-Request-[Headers·Method]`
- `Connection`
- `Content-Length`
- `Cookie[2]`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-[*]`
- `Sec-[*]`

##### 헤더 설정 제약 이유
- 올바른 · 안전한 HTTP 사용
- 금지 목록 헤더
  - 브라우저만 설정 · 관리 가능

### `POST` 요청
`GET` 이 외의 요청을 보내려면 추가 옵션을 사용해야 합니다.
- `method` – HTTP 메서드(예: `POST`)
- `body` – 요청 본문으로 다음 항목 중 하나이어야 합니다.
  - 문자열(예: JSON 문자열)
  - `FormData`객체 – `form/multipart` 형태로 데이터를 전송하기 위해 쓰입니다.
  - `Blob`나 `BufferSource` – 바이너리 데이터 전송을 위해 쓰입니다.
  - `URLSearchParams` – 데이터를 `x-www-form-urlencoded` 형태로 보내기 위해 쓰이는데, 요즘엔 잘 사용하지 않습니다.

대부분은 JSON을 요청 본문에 실어 보내게 됩니다.

`user` 객체를 본문에 실어 보내는 예시를 살펴봅시다.
```javascript
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);
```

`POST` 요청을 보낼 때 주의할 점은 요청 본문이 문자열일 때 `Content-Type` 헤더가 `text/plain;charset=UTF-8`로 기본 설정된다는 점입니다.

하지만 위 예시에선 JSON을 전송하고 있기 때문에 `headers`에 제대로 된 `Content-Type`인 `application/json`을 설정해 주었습니다.

### 이미지 전송하기
`Blob`이나 `BufferSource` 객체를 사용하면 `fetch`로 바이너리 데이터를 전송할 수 있습니다.

예시를 살펴봅시다. `<canvas>`에 마우스를 움직여 이미지를 만들고 '전송' 버튼을 눌러 이미지를 서버에 전송해보겠습니다.
```javascript
<body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="전송" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });

      // 전송이 잘 되었다는 응답이 오고 이미지 사이즈가 얼럿창에 출력됩니다.
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
```

![sending-image](../../images/03/03/01/sending-image.png)

이번엔 `Content-Type` 헤더를 명시적으로 설정하지 않은 점에 주목해주시기 바랍니다. `Blob` 객체는 내장 타입을 갖기 때문에 특별히 `Content-Type`를 설정하지 않아도 됩니다. 예시는 이미지를 전송하기 때문에 `toBlob`에 의해 `image/png`가 자동 설정되었습니다. 이렇게 `Blob` 객체의 경우 해당 객체의 타입이 `Content-Type` 헤더의 값이 됩니다.

위 예시의 함수 `submit()`을 `async`/`await` 없이 작성하면 아래와 같습니다.
```javascript
function submit() {
  canvasElem.toBlob(function(blob) {
    fetch('/article/fetch/post/image', {
      method: 'POST',
      body: blob
    })
      .then(response => response.json())
      .then(result => alert(JSON.stringify(result, null, 2)))
  }, 'image/png');
}
```

<br />

## 요약
일반적인 `fetch` 요청은 두 개의 `await` 호출로 구성됩니다.
```javascript
let response = await fetch(url, options); // 응답 헤더와 함께 이행됨
let result = await response.json(); // json 본문을 읽음
```

물론 `await` 없이도 요청을 보낼 수 있습니다.
```javascript
fetch(url, options)
  .then(response => response.json())
  .then(result => /* 결과 처리 */)
```

응답 객체의 프로퍼티는 다음과 같습니다.
- `response.status` – 응답의 HTTP 코드
- `response.ok` – 응답 상태가 `200`과 `299` 사이에 있는 경우 `true`
- `response.headers` – 맵과 유사한 형태의 HTTP 헤더

응답 본문을 얻으려면 다음과 같은 메서드를 사용하면 됩니다.
- `response.text()` – 응답을 텍스트 형태로 반환함
- `response.json()` – 응답을 파싱해 JSON 객체로 변경함
- `response.formData()` – 응답을 `FormData` 객체 형태로 반환(`form/multipart` 인코딩에 대한 내용은 다음 챕터에서 다룸)
- `response.blob()` – 응답을 `Blob`(타입이 있는 바이너리 데이터) 형태로 반환
- `response.arrayBuffer()` – 응답을 `ArrayBuffer`(바이너리 데이터를 로우 레벨로 표현한 것) 형태로 반환

지금까지 배운 `fetch` 옵션은 다음과 같습니다.
- `method` – HTTP 메서드
- `headers` – 요청 헤드가 담긴 객체(제약 사항이 있음)
- `body` – 보내려는 데이터(요청 본문)로 `string`이나 `FormData`, `BufferSource`, `Blob`, `UrlSearchParams` 객체 형태

이어지는 챕터에선 이 외의 옵션과 다양한 `fetch` 유스 케이스를 살펴보겠습니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### fetch를 사용해 Github에서 사용자 정보 가져오기
GitHub 사용자 이름이 담긴 배열을 인자로 받는 비동기 함수 `getUsers(names)`를 만든 후, GitHub에서 fetch한 사용자 정보들이 담긴 배열을 반환하는 함수를 만들어 보세요.

사용자명에 해당하는 사용자 정보를 가져오려면 GitHub API `https://api.github.com/users/사용자명`에 요청을 보내면 됩니다.

샌드박스에 테스트 코드가 준비되어 있습니다.

아래 조건들을 지켜 과제를 완수해 보세요.
1. 사용자당 `fetch` 요청은 한 번만 수행해야 합니다.
2. 데이터가 최대한 일찍 도착할 수 있도록 각 요청은 다른 요청의 결과를 기다려서는 안 됩니다.
3. 요청에 실패하거나 존재하지 않는 사용자에 대한 요청을 보냈다면 `null`을 리턴하고 배열 요소에 담아야 합니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

`fetch`를 통해 사용자 정보를 가져오려면 `fetch('https://api.github.com/users/사용자명')`를 사용해야 합니다.

응답 상태 코드가 `200`이면 `.json()`을 호출해 객체를 읽습니다.

반면 `fetch`가 실패하거나 응답 상태 코드가 `200`이 아니라면 `null`을 리턴하고 배열에 담아야 합니다.

답안은 아래와 같습니다.
```javascript
async function getUsers(names) {
  let jobs = [];

  for(let name of names) {
    let job = fetch(`https://api.github.com/users/${name}`).then(
      successResponse => {
        if (successResponse.status != 200) {
          return null;
        } else {
          return successResponse.json();
        }
      },
      failResponse => {
        return null;
      }
    );
    jobs.push(job);
  }

  let results = await Promise.all(jobs);

  return results;
}
```

`.then`은 `fetch` 직후 호출되므로 응답이 도착하면 다른 `fetch`를 기다리는 대신 곧바로 `.json()`으로 응답을 읽기 시작한다는 것을 기억하세요.

`await Promise.all(names.map(name => fetch(...)))`의 반환 값을 대상으로 `.json()`을 호출한다면 모든 `fetch` 응답이 완료되기 전까지 기다려야 합니다. 대신 각 `fetch`마다 `.json()`을 호출하면 다른 `fetch` 응답을 기다리지 않으면서 JSON 형식으로 데이터를 읽을 수 있습니다.

이 예제를 통해 비록 `async`/`await`을 주로 사용하더라도 여전히 하위 수준의 프라미스(Promise) API가 유용하게 사용될 수 있음을 알 수 있습니다.

[테스트 코드가 담긴 샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/XQkmX15fNwq5kz0F?p=preview)
