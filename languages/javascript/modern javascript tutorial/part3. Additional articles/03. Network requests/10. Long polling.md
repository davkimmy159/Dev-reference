롱 폴링
=======

##### 간단히 서버와 지속적인 연결 유지
- 특정 프로토콜 의존 X
  - 웹소켓
  - server-sent event
  - 기타 등등
- 쉬운 구현
- 다양한 사용처

### 폴링 <sub>(Regular Polling)</sub>

##### 아주 간단히 서버에서 새 정보 수신 가능
- 클라이언트
  - ex) 10초마다 새 정보 요청
- 서버
  1. 클라이언트 온라인 알림 받음
  2. 메시지 패킷 전송

#### 단점

##### 1. 메시지 전송 시 지연 발생
- 최대 10초
- 요청 사이

##### 2. 서버측 매 10초마다 요청 수신
- 서버 내 메시지 존재 여부 무관
- 사용자 타 작업 중 · 잠든 상태 가능
- 성능 측면 큰 부담

##### 작은 서비스 규모 유용
- 보통 개선 필요

### 롱 폴링 <sub>(Long polling)</sub>

##### 일반 폴링 개선 버전
- 쉬운 구현
- 메시지 전송 시 지연 미발생

##### 진행 흐름
1. 요청 서버 전송
2. 서버측 연결 지속
    - 전송할 메시지 생길때까지
3. 서버측 전송할 메시지 등장
    - 메시제 함께 응답 전송
4. 즉시 새 요청 서버 전송 <sub>(브라우저)</sub>

##### 일반적인 사용 상황
- 요청 전송 후 서버 연결 유지 <sub>(브라우저)</sub>
- 메시지 수신 시 재연결 실행

![long-polling](../../images/03/03/10/long-polling.svg)

##### 문제 <sub>(네트워크 에러 등)</sub> 발생해 연결 종료 시
- 즉시 새 요청 전송 <sub>(브라우저)</sub>

##### 클라이언트측 구독 함수 <sub>(`subscribe`)</sub>
- 롱 요청 기능 동작
```javascript
async function subscribe() {
  let response = await fetch("/subscribe");

  /* 502 (상태 코드)
   - 연결 시간 종료 에러
   - 발생 경우
     - 너무 긴 시간 연결 유지
     - 서버 · 프락시측 연결 종료
   */
  if (response.status == 502) {

    // 재연결 실행
    await subscribe();

  // 에러 발생
  } else if (response.status != 200) {

    // 에러 출력
    showMessage(response.statusText);

    // 1초 내로 재연결 실행
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();

  } else {

    // 메시지 수신 · 출력
    let message = await response.text();
    showMessage(message);

    // 다음 메시지 위해 재연결 실행
    await subscribe();
  }
}

subscribe();
```

##### `subscribe` <sub>(롱 폴링 구현 함수)</sub>
- 요청 전송 <sub>(`fetch` 메서드)</sub> 후
  - 응답 대기
- 응답 처리 후
  - 다시 요청 전송

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **서버측 다수 연결 유지 처리 필수**

##### 서버 아키텍쳐
- 다수 연결 유지 처리
  - 문제없이 동작 필수

##### 특정 서버 아키텍쳐
- 연결 1개 당 프로세스 1개 실행
  - 연결↑ → 프로세스↑
  - 각 프로세스 메모리 일정 부분 사용
    - 자원 소모 多
- 특정 언어 벡엔드 문제 자주 발생
  - PHP
  - Ruby
  - 기타 등등
- Node.js 백엔드
  - 해당 문제 X

##### 특정 언어 문제 X
- 대다수 모던 언어 <sub>(PHP · Ruby 포함)</sub>
  - 올바른 백엔드 구현 기능 제공
- 적절한 서버 아키텍쳐 설계 권장
  - 다수 동시 연결 유지 처리 가능

<br />

### 채팅 프로그램 데모

##### 결과

![demo-a-chat](../../images/03/03/10/demo-a-chat.png)

```html
<!-- index.html -->
<!DOCTYPE html>
<script src="browser.js"></script>

All visitors of this page will see messages of each other.

<form name="publish">
  <input type="text" name="message" />
  <input type="submit" value="Send" />
</form>

<div id="subscribe">
</div>

<script>
  new PublishForm(document.forms.publish, 'publish');

  // 임의 url 매개면수 전달
  // - 캐싱 이슈 방지
  new SubscribePane(document.getElementById('subscribe'), 'subscribe?random=' + Math.random());
</script>
```
```javascript
/* server.js */
let http = require('http');
let url = require('url');
let querystring = require('querystring');
let static = require('node-static');

let fileServer = new static.Server('.');

let subscribers = Object.create(null);

function onSubscribe(req, res) {
  let id = Math.random();

  res.setHeader('Content-Type', 'text/plain;charset=utf-8');
  res.setHeader("Cache-Control", "no-cache, must-revalidate");

  subscribers[id] = res;

  req.on('close', function() {
    delete subscribers[id];
  });

}

function publish(message) {

  for (let id in subscribers) {
    let res = subscribers[id];
    res.end(message);
  }

  subscribers = Object.create(null);
}

function accept(req, res) {
  let urlParsed = url.parse(req.url, true);

  // 새 클라이언트 메시지 요청
  if (urlParsed.pathname == '/subscribe') {
    onSubscribe(req, res);
    return;
  }

  // 메시지 전송
  // - POST 메서드
  if (urlParsed.pathname == '/publish' && req.method == 'POST') {
    req.setEncoding('utf8');
    let message = '';
    req.on('data', function(chunk) {
      message += chunk;
    }).on('end', function() {
      publish(message); // publish it to everyone
      res.end("ok");
    });

    return;
  }

  fileServer.serve(req, res);

}

function close() {
  for (let id in subscribers) {
    let res = subscribers[id];
    res.end();
  }
}

// -----------------------------------

if (!module.parent) {
  http.createServer(accept).listen(8080);
  console.log('Server running on port 8080');
} else {
  exports.accept = accept;

  if (process.send) {
     process.on('message', (msg) => {
       if (msg === 'shutdown') {
         close();
       }
     });
  }

  process.on('SIGINT', close);
}
```
```javascript
/* browser.js */
// 메시지 전송
// - 간단한 POST 요청
function PublishForm(form, url) {

  function sendMessage(message) {
    fetch(url, {
      method: 'POST',
      body: message
    });
  }

  form.onsubmit = function() {
    let message = form.message.value;
    if (message) {
      form.message.value = '';
      sendMessage(message);
    }
    return false;
  };
}

// 메시지 수신
// - 롱 폴링 사용
function SubscribePane(elem, url) {

  function showMessage(message) {
    let messageElem = document.createElement('div');
    messageElem.append(message);
    elem.append(messageElem);
  }

  async function subscribe() {
    let response = await fetch(url);

    // 연결 대기 시간 초과
    // - 너무 길게 연결 유지 시 발생
    if (response.status == 502) {

      // 재연결 실행
      await subscribe();

    // 에러 발생
    } else if (response.status != 200) {

      // 에러 출력
      showMessage(response.statusText);

      // 1초 내로 재연결 실행
      await new Promise(resolve => setTimeout(resolve, 1000));
      await subscribe();

    } else {

      // 메시지 수신
      let message = await response.text();
      showMessage(message);

      // 다음 메시지 위해 재연결 실핼
      await subscribe();
    }
  }

  subscribe();

}
```

### 사용처

##### 유용한 경우
- 메시지 송 · 수신 드물게 발생

##### 메시지 송 · 수신 자주 발생 시
- 부하 증가
  - 요청 수 <sub>(개별 메시지)</sub>
  - 포함 헤더
  - 인증 정보 오버헤드
  - 기타 등등
- 타 방법 사용
  - 웹소켓
  - Server Sent Events
