`fetch` API
=========

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### 챕터 내용
- 드물게 사용

<br />

##### `fetch` <sub>(메서드)</sub> 설정 일부

… 설정 내용 테이블 …

### `referrer[Policy]`

##### `fetch` <sub>(메서드)</sub> 내 `Referer` <sub>(헤더)</sub> 설정 방식 결정
- 보통 자동 설정
- 요청 페이지 url 포함
- 대다수 경우 중요 X
- 가끔 제거 · 축약 <sub>(보안 목적)</sub>

##### `referrer` <sub>(옵션)</sub>
- `Referer` <sub>(헤더)</sub> 허용 값 설정
  - 현재 오리진 내 타 url
  - 헤더 제거
```javascript
// 현재 오리진 내 타 url
// https://javascript.info (현재 오리진)
fetch('/page', {
  referrer: "https://javascript.info/anotherpage"
});
```
```javascript
// 헤더 제거
fetch('/page', {
  referrer: ""
});
```

##### `referrerPolicy` <sub>(옵션)</sub>
- `Referer` <sub>(헤더)</sub> 일반적인 규칙 설정
- 요청 구분 <sub>(3종류)</sub>
  1. 동일 오리진 대상 요청
  2. 타 오리진 대상 요청
  3. 타 프로토콜 대상 요청
      - HTTPS → HTTP

##### 설정 값 <sub>([Referrer 정책 명세](https://w3c.github.io/webappsec-referrer-policy/))</sub>

|값|설명|
|---|---|
|`"no-referrer-when-downgrade"` <sub>(기본값)</sub>|항상 전체 `Referer` <sub>(헤더)</sub> 전송<br />- HTTPS → HTTP 제외|
|`"no-referrer"`|`Referer` <sub>(헤더)</sub> 미전송|
|`"origin"`|`Referer` <sub>(헤더)</sub> 내 오리진만 전송 <sub>(전체 페이지 url X)</sub><br />- ex\) `http://site.com` <sub>(`http://site.com/path` X)</sub>|
|`"origin-when-cross-origin"`|send full `Referer` <sub>(헤더)</sub> to the same origin, but only the origin part for cross-origin requests (as above)|
|`"same-origin"`|send full `Referer` <sub>(헤더)</sub> to the same origin, but no `Referer` <sub>(헤더)</sub> for cross-origin requests|
|`"strict-origin"`|send only origin, don't send `Referer` <sub>(헤더)</sub> for HTTPS→HTTP requests|
|`"strict-origin-when-cross-origin"`|for same-origin send full `Referer` <sub>(헤더)</sub>, for cross-origin send only origin, unless it's HTTPS→HTTP request, then send nothing|
|`"unsafe-url"`|always send full url in `Referer` <sub>(헤더)</sub>, even for HTTPS→HTTP requests|

Here's a table with all combinations:

|Value|To same origin|To another origin|HTTPS→HTTP|
|---|---|---|---|
|`"no-referrer"`|-|-|-|
|`"no-referrer-when-downgrade"` or `""` (default)|full|full|-|
|`"origin"`|origin|origin|origin|
|`"origin-when-cross-origin"`|full|origin|origin|
|`"same-origin"`|full|-|-|
|`"strict-origin"`|origin|origin|-|
|`"strict-origin-when-cross-origin"`|full|origin|-|
|`"unsafe-url"`|full|full|full|

Let's say we have an admin zone with URL structure that shouldn't be known from outside of the site.

If we send a `fetch`, then by default it always sends the `Referer` header with the full url of our page (except when we request from HTTPS to HTTP, then no `Referer`).

E.g. `Referer: https://javascript.info/admin/secret/paths`.

If we'd like other websites know only the origin part, not URL-path, we can set the option:
```javascript
fetch('https://another.com/page', {
  …
  referrerPolicy: "origin-when-cross-origin" // Referer: https://javascript.info
});
```

We can put it to all `fetch` calls, maybe integrate into JavaScript library of our project that does all requests and uses `fetch` inside.

Its only difference compared to the default behavior is that for requests to another origin `fetch` sends only the origin part of the URL (e.g. `https://javascript.info`, without path). For requests to our origin we still get the full `Referer` (maybe useful for debugging purposes).

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **Referrer policy is not only for `fetch`**

Referrer policy, described in the [specification](https://w3c.github.io/webappsec-referrer-policy/), is not just for `fetch`, but more global.

In particular, it's possible to set the default policy for the whole page using `Referrer-Policy` HTTP header, or per-link, with `<a rel="noreferrer">`.

<br />

### `mode`
The `mode` option is a safe-guard that prevents occasional cross-origin requests:
- `"cors"` – the default, cross-origin requests are allowed, as described in CORS,
- "`same-origin"` – cross-origin requests are forbidden,
- `"no-cors"` – only simple cross-origin requests are allowed.

This option may be useful when the URL for `fetch` comes from a 3rd-party, and we want a "power off switch" to limit cross-origin capabilities.

### `credentials`
The `credentials` option specifies whether `fetch` should send cookies and HTTP-Authorization headers with the request.
- `"same-origin"` – the default, don't send for cross-origin requests,
- `"include"` – always send, requires `Accept-Control-Allow-Credentials` from cross-origin server in order for JavaScript to access the response, that was covered in the chapter CORS,
- `"omit"` – never send, even for same-origin requests.

### `cache`
By default, `fetch` requests make use of standard HTTP-caching. That is, it honors `Expires`, `Cache-Control` headers, sends `If-Modified-Since`, and so on. Just like regular HTTP-requests do.

The `cache` options allows to ignore HTTP-cache or fine-tune its usage:
- `"default"` – `fetch` uses standard HTTP-cache rules and headers,
- `"no-store"` – totally ignore HTTP-cache, this mode becomes the default if we set a header `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`,
- `"reload"` – don't take the result from HTTP-cache (if any), but populate cache with the response (if response headers allow),
- `"no-cache"` – create a conditional request if there is a cached response, and a normal request otherwise. Populate HTTP-cache with the response,
- `"force-cache"` – use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, make a regular HTTP-request, behave normally,
- `"only-if-cached"` – use a response from HTTP-cache, even if it's stale. If there's no response in HTTP-cache, then error. Only works when `mode` is `"same-origin"`.

### `redirect`
Normally, `fetch` transparently follows HTTP-redirects, like 301, 302 etc.

The `redirect` option allows to change that:
- `"follow"` – the default, follow HTTP-redirects,
- `"error"` – error in case of HTTP-redirect,
- `"manual"` – don't follow HTTP-redirect, but `response.url` will be the new URL, and `response.redirected` will be `true`, so that we can perform the redirect manually to the new URL (if needed).

### `integrity`
The `integrity` option allows to check if the response matches the known-ahead checksum.

As described in the [specification](https://w3c.github.io/webappsec-subresource-integrity/), supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on a browser.

For example, we're downloading a file, and we know that it's SHA-256 checksum is "abcdef" (a real checksum is longer, of course).

We can put it in the `integrity` option, like this:
```javascript
fetch('http://site.com/file', {
  integrity: 'sha256-abcdef'
});
```

Then `fetch` will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.

### `keepalive`
The `keepalive` option indicates that the request may "outlive" the webpage that initiated it.

For example, we gather statistics about how the current visitor uses our page (mouse clicks, page fragments he views), to analyze and improve user experience.

When the visitor leaves our page – we'd like to save the data at our server.

We can use `window.onunload` event for that:
```javascript
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
    keepalive: true
  });
};
```

Normally, when a document is unloaded, all associated network requests are aborted. But `keepalive` option tells the browser to perform the request in background, even after it leaves the page. So this option is essential for our request to succeed.

It has a few limitations:
- We can't send megabytes: the body limit for `keepalive` requests is 64kb.
  - If we need to gather a lot of statistics about the visit, we should send it out regularly in packets, so that there won't be a lot left for the last `onunload` request.
  - This limit applies to all `keepalive` requests together. In other words, we can perform multiple `keepalive` requests in parallel, but the sum of their body lengths should not exceed 64kb.
- We can't handle the server response if the document is unloaded. So in our example `fetch` will succeed due to `keepalive`, but subsequent functions won't work.
  - In most cases, such as sending out statistics, it's not a problem, as server just accepts the data and usually sends an empty response to such requests.
