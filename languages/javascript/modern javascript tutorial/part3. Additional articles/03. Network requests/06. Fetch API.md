`fetch` API
=========

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### 챕터 내용
- 드물게 사용

<br />

##### `fetch` <sub>(메서드)</sub> 설정 일부

… 설정 내용 테이블 …

### `referrer[Policy]`

##### `fetch` <sub>(메서드)</sub> 내 `Referer` <sub>(헤더)</sub> 설정 방식 결정
- 보통 자동 설정
- 요청 페이지 url 포함
- 대다수 경우 중요 X
- 가끔 제거 · 축약 <sub>(보안 목적)</sub>

##### `referrer` <sub>(옵션)</sub>
- `Referer` <sub>(헤더)</sub> 허용 값 설정
  - 현재 오리진 내 타 url
  - 헤더 제거
```javascript
// 현재 오리진 내 타 url
// https://javascript.info (현재 오리진)
fetch('/page', {
  referrer: "https://javascript.info/anotherpage"
});
```
```javascript
// 헤더 제거
fetch('/page', {
  referrer: ""
});
```

##### `referrerPolicy` <sub>(옵션)</sub>
- `Referer` <sub>(헤더)</sub> 일반적인 규칙 설정
- 요청 구분 <sub>(3종류)</sub>
  1. 동일 오리진 대상 요청
  2. 타 오리진 대상 요청
  3. 타 프로토콜 대상 요청
      - HTTPS → HTTP

##### 설정 값 <sub>([Referrer 정책 명세](https://w3c.github.io/webappsec-referrer-policy/))</sub>

|값|설명|
|---|---|
|`"no-referrer-when-downgrade"` <sub>(기본값)</sub>|항상 전체 `Referer` <sub>(헤더)</sub> 전송<br />- HTTPS → HTTP 제외|
|`"no-referrer"`|`Referer` <sub>(헤더)</sub> 미전송|
|`"origin"`|`Referer` <sub>(헤더)</sub> 내 오리진만 전송 <sub>(전체 페이지 url X)</sub><br />- ex\) `http://site.com` <sub>(`http://site.com/path` X)</sub>|
|`"origin-when-cross-origin"`|동일 오리진 요청<br />- 전체 `Referer` <sub>(헤더)</sub> 전송<br />|
||크로스 오리진 요청<br />- `Referer` <sub>(헤더)</sub> 내 오리진만 전송|
|`"same-origin"`|동일 오리진 요청<br />- 전체 `Referer` <sub>(헤더)</sub> 전송<br />|
||크로스 오리진 요청<br />- `Referer` <sub>(헤더)</sub> 미전송|
|`"strict-origin"`|`Referer` <sub>(헤더)</sub> 내 오리진만 전송|
||HTTPS → HTTP 요청<br />- `Referer` <sub>(헤더)</sub> 미전송|
|`"strict-origin-when-cross-origin"`|동일 오리진 요청<br />- 전체 `Referer` <sub>(헤더)</sub> 전송<br />|
||크로스 오리진 요청<br />- `Referer` <sub>(헤더)</sub> 내 오리진만 전송|
||HTTPS → HTTP 요청<br />- `Referer` <sub>(헤더)</sub> 미전송|
|`"unsafe-url"`|항상 전체 `Referer` <sub>(헤더)</sub> 전송<br />- HTTPS → HTTP 포함|

##### 전체 조합

|값|동일 오리진|크로스 오리진|HTTPS → HTTP|
|---|---|---|---|
|`"no-referrer"`|-|-|-|
|`"no-referrer-when-downgrade"` · `""` <sub>(기본값)</sub>|전체|전체|-|
|`"origin"`|오리진|오리진|오리진|
|`"origin-when-cross-origin"`|전체|오리진|오리진|
|`"same-origin"`|전체|-|-|
|`"strict-origin"`|오리진|오리진|-|
|`"strict-origin-when-cross-origin"`|전체|오리진|-|
|`"unsafe-url"`|전체|전체|전체|

##### 관리자 전용 페이지
- 외부 접근 X
- `fetch` 요청 시
  - 항상 전체 `Referer` <sub>(헤더)</sub> 전송 <sub>(기본값)</sub>
  - HTTPS → HTTP 요청 제외
- ex\)
```javascript
Referer: https://javascript.info/admin/secret/paths
```
- 크로스 오리진 요청 시
  - 오리진만 전송 설정 <sub>(url 경로 X)</sub>
```javascript
fetch('https://another.com/page', {
  …

  // Referer: https://javascript.info
  referrerPolicy: "origin-when-cross-origin"
});
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`Referrer` 정책 : `fetch` <sub>(메서드)</sub> 전용 X**

##### [`Referrer` 정책](https://w3c.github.io/webappsec-referrer-policy/)
- `fetch` <sub>(메서드)</sub> 전용 X
- 전반적 설정 가능
  - 전체 페이지 기본 설정
    - `Referrer-Policy` <sub>(헤더)</sub>
  - 링크별 설정
    - `<a rel="noreferrer">`

<br />

### `mode` <sub>(옵션)</sub>

##### 크로스 오리진 요청 대상 안전장치

|값|설명 <sub>(크로스 오리진)</sub>|
|---|---|
|`"cors"` <sub>(기본값)</sub>|요청 허용|
|`"same-origin"`|요청 금지|
|`"no-cors"`|단순 요청만 허용|

##### 서드파티 내 `fetch` <sub>(메서드)</sub> 전용 url
- 크로스 오리진 요청만 제한 가능

### `credentials` <sub>(옵션)</sub>

##### 쿠키 · HTTP 인증 헤더 포함 여부

|값|설명|
|---|---|
|`"same-origin"` <sub>(기본값)</sub>|크로스 오리진 요청 내 포함 X|
|`"include"`|항상 포함<br />|
||`Accept-Control-Allow-Credentials` <sub>(헤더)</sub> 필요<br />- 크로스 오리진 서버 응답<br />- JS 응답 접근 가능|
|`"omit"`|항상 미포함|

### `cache` <sub>(옵션)</sub>

##### `fetch` <sub>(메서드)</sub> 요청
- 표준 HTTP 캐싱 사용 <sub>(일반 HTTP 요청 동일)</sub>
  - `Expires`
  - `Cache-Control` <sub>(헤더)</sub>
  - `If-Modified-Since` 전송
  - 기타 등등

##### `cache` <sub>(옵션)</sub>
- HTTP 캐싱 기능 조정

|값|설명|
|---|---|
|`"default"`|표준 HTTP 캐시 규칙 · 헤더 사용|
|`"no-store"`|HTTP 캐시 완전 무시|
||특정 헤더 설정 시 기본값<br />- `If-Modified-Since`<br />- `If-None-Match`<br />- `If-Unmodified-Since`<br />- `If-Match`<br />- `If-Range`|
|`"reload"`|HTTP 캐시 결과 무시|
||캐시 내 응답 삽입 <sub>(응답 헤더 허용 시)</sub>|
|`"no-cache"`|캐시된 응답 유무 따라 상이 요청 생성<br />- 존재 시 조건부 요청 생성 <br />- 부재 시 일반 요청 생성|
|`"force-cache"`|HTTP 캐시 내 응답 사용 <sub>(최신 · 구식 무관)</sub>|
||HTTP 캐시 내 응답 부재 시<br />- 일반 HTTP 요청 생성|
|`"only-if-cached"`|HTTP 캐시 내 응답 사용 <sub>(최신 · 구식 무관)</sub>|
||HTTP 캐시 내 응답 부재 시 에러 발생<br />- `mode: "same-origin"` <sub>(옵션)</sub> 설정 시 정상 동작|

### `redirect` <sub>(옵션)</sub>

##### `fetch` <sub>(메서드)</sub>
- 보통 HTTP redirect 준수
  - 301
  - 302
  - 기타 등등

##### `redirect` <sub>(옵션)</sub>
- redirect 행동 변경

|값|설정|
|---|---|
|`"follow"` <sub>(기본값)</sub>|HTTP redirect 준수|
|`"error"`|HTTP redirect 동작 시 에러 발생|
|`"manual"`|HTTP redirect 미준수|
||redirect 수동 조작<br />- `response.url` : 새 url<br />- `response.redirected` : `true`|

### `integrity`
The `integrity` option allows to check if the response matches the known-ahead checksum.

As described in the [specification](https://w3c.github.io/webappsec-subresource-integrity/), supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on a browser.

For example, we're downloading a file, and we know that it's SHA-256 checksum is "abcdef" (a real checksum is longer, of course).

We can put it in the `integrity` option, like this:
```javascript
fetch('http://site.com/file', {
  integrity: 'sha256-abcdef'
});
```

Then `fetch` will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.

### `keepalive`
The `keepalive` option indicates that the request may "outlive" the webpage that initiated it.

For example, we gather statistics about how the current visitor uses our page (mouse clicks, page fragments he views), to analyze and improve user experience.

When the visitor leaves our page – we'd like to save the data at our server.

We can use `window.onunload` event for that:
```javascript
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
    keepalive: true
  });
};
```

Normally, when a document is unloaded, all associated network requests are aborted. But `keepalive` option tells the browser to perform the request in background, even after it leaves the page. So this option is essential for our request to succeed.

It has a few limitations:
- We can't send megabytes: the body limit for `keepalive` requests is 64kb.
  - If we need to gather a lot of statistics about the visit, we should send it out regularly in packets, so that there won't be a lot left for the last `onunload` request.
  - This limit applies to all `keepalive` requests together. In other words, we can perform multiple `keepalive` requests in parallel, but the sum of their body lengths should not exceed 64kb.
- We can't handle the server response if the document is unloaded. So in our example `fetch` will succeed due to `keepalive`, but subsequent functions won't work.
  - In most cases, such as sending out statistics, it's not a problem, as server just accepts the data and usually sends an empty response to such requests.
