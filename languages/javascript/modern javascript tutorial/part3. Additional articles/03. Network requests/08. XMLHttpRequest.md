`XMLHttpRequest` <sub>(객체)</sub>
==============

##### 내장 브라우저 객체
- JS 사용해 HTTP 요청 생성

##### 모든 데이터 동작
- 파일 업 · 다운로드
- 과정 추적
- 가타 등등

##### `fetch` <sub>(메서드)</sub>
- 모던 메서드
- 더 많이 사용

##### 현대 웹 개발 시 `XMLHttpRequest` 사용 이유 <sub>(3가지)</sub>
1. 기존 스크립트 지원
2. 구식 브라우저 지원 · 폴리필 미사용 <sub>(용량 ↓)</sub>
3. `fetch` <sub>(메서드)</sub> 미지원 기능 사용
    - ex\) 업로드 과정 추적 등

### 기본

##### 동작 모드 <sub>(2가지)</sub>
1. 비동기
2. 동기

#### 비동기 동작 모드 <sub>(자주 사용)</sub>

##### 1. `XMLHttpRequest` <sub>(객체)</sub> 생성
- 생성자 인수 X
```javascript
let xhr = new XMLHttpRequest();
```

##### 2. 객체 초기화
- 보통 생성 직후 수행
- `open` <sub>(메서드)</sub>
  - 요청 내 주요 매개변수 설정
  - 연결 생성 X
    - 요청 정보 설정
```javascript
xhr.open(method, URL, [async, user, password]);
```
- `method` <sub>(HTTP 메서드)</sub>
  - 보통 `"GET"` · `"POST"`
- `URL` <sub>(요청 전송 주소)</sub>
  - 문자열
  - `URL` <sub>(객체)</sub>
- `async` <sub>(비동기 여부)</sub>
  - `true`
    - 기본값
  - `false`
    - 동기 동작
- `user` · `password` <sub>(로그인 · 비밀번호)</sub>
  - 기초 HTTP 인증 설정

##### 3. 요청 전송
- `send` <sub>(메서드)</sub>
  - 연결 생성
  - 요청 서버 전송
```javascript
xhr.send([body]);
```
- `body` <sub>(요청 본문)</sub>
  - 일부 요청 메서드 <sub>(`GET` 등)</sub>
    - 부재
  - 일부 요청 메서드 <sub>(`POST` 등)</sub>
    - 데이터 전송 시 사용

##### 4. `xhr` <sub>(이벤트)</sub> 반응 <sub>(응답 수신)</sub>
- 일부 이벤트 자주 사용 <sub>(3가지)</sub>
- `load`
  - 요청 동작 완료 <sub>(성공 여부 무관)</sub>
  - 응답 다운로드 완료
- `error`
  - 요청 생성 불가능
    - 네트워크 고장
    - 무효 url
    - 기타 등등
- `progress`
  - 응답 다운로드 중 주기적 발생
  - 다운로드 진행률 정보 제공
```javascript
xhr.onload = function() {
  alert(`Loaded: ${xhr.status} ${xhr.response}`);
};

// 요청 불가능 시 발생
xhr.onerror = function() {
  alert(`Network Error`);
};

// 주기적 발생
xhr.onprogress = function(event) {
  /*
   event.loaded
   - 다운받은 바이트 양
   event.lengthComputable
   - Content-Length (응답 헤더) 유무 여부
   event.total
   - 총 바이트 수
     - lengthComputable = true 필요
   */
  alert(`Received ${event.loaded} of ${event.total}`);
};
```

##### url 로드 후 화면 표시
- url <sub>(서버)</sub>
  - `/article/xmlhttprequest/example/load`
- 진행률 화면 출력
```javascript
// (1)
// 새 XMLHttpRequest (객체) 생성
let xhr = new XMLHttpRequest();

// (2)
// 객체 초기화
// - GET 요청 (/article/…/load)
xhr.open('GET', '/article/xmlhttprequest/example/load');

// (3)
// 요청 전송
xhr.send();

// (4)
// 응답 도착 시 실행
xhr.onload = function() {

  /* HTTP 응답 상태 분석 */
  // 응답 실패
  // - 404 (Not Found) 등
  if (xhr.status != 200) {
    alert(`Error ${xhr.status}: ${xhr.statusText}`);

  // 응답 성공
  } else {
    // 결과 출력
    // - response (서버 응답 내용)
    alert(`Done, got ${xhr.response.length} bytes`);
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Received ${event.loaded} of ${event.total} bytes`);

  // Content-Length (헤더) X
  } else {
    alert(`Received ${event.loaded} bytes`);
  }

};

xhr.onerror = function() {
  alert("Request failed");
};
```

#### 서버 응답 프로퍼티

##### `status` <sub>(숫자)</sub>
- HTTP 상태 코드
  - `200`
  - `404`
  - `403`
  - `0` <sub>(非HTTP 실패)</sub>
  - 기타 등등

##### `statusText` <sub>(문자열)</sub>
- HTTP 상태 메시지
  - `"OK"` <sub>(`200`)</sub>
  - `"Not Found"` <sub>(`404`)</sub>
  - `"Forbidden"` <sub>(`403`)</sub>
  - 기타 등등

##### `response` <sub>(구식 : `responseText`)</sub>
- 서버 응답 본문

##### `timeout`
- 응답 대기 시간 지정
- 시간 초과 시
  - 요청 취소 · `timeout`<sub>(이벤트)</sub> 발생
```javascript
xhr.timeout = 10000; // timeout in ms, 10 seconds
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **URL 검색 매개변수**

##### `URL`<sub>(객체)</sub>
- 검색 매개변수 추가 · 자동 인코딩
```javascript
let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!');

// 'q' (매개변수) 자동 인코딩
// - https://google.com/search?q=test+me%21
xhr.open('GET', url);
```

<br />

### 응답 타입

##### `responseType` <sub>(프로퍼티)</sub>
- 응답 포맷 설정

|값|포맷|
|---|---|
|`""` <sub>(기본값)</sub>|문자열|
|`"text"`|문자열|
|`"arraybuffer"`|`ArrayBuffer` <sub>(객체)</sub>|
|`"blob"`|`Blob` <sub>(객체)</sub>|
|`"document"`|XML 문서<br />- XPath<br />- XML 메서드|
|`"json"`|JSON <sub>(자동 파싱)</sub>

##### JSON 포맷
```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/example/json');

xhr.responseType = 'json';

xhr.send();

// 응답
// - { "message": "Hello, world!" }
xhr.onload = function() {
  let responseObj = xhr.response;
  alert(responseObj.message); // Hello, world!
};
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### 구식 프로퍼티 <sub>(역사적 이유 · 현대 사용 X)</sub>
- `responseText` <sub>(문자열)</sub>
- `responseXML` <sub>(XML 문서)</sub>

<br />

### Ready states
`XMLHttpRequest` changes between states as it progresses. The current state is accessible as `xhr.readyState`.

All states, as in [the specification](https://xhr.spec.whatwg.org/#states):

```javascript
UNSENT = 0; // initial state
OPENED = 1; // open called
HEADERS_RECEIVED = 2; // response headers received
LOADING = 3; // response is loading (a data packed is received)
DONE = 4; // request complete
```

An `XMLHttpRequest` object travels them in the order `0` → `1` → `2` → `3` → … → `3` → `4`. State `3` repeats every time a data packet is received over the network.

We can track them using `readystatechange` event:

```javascript
xhr.onreadystatechange = function() {
  if (xhr.readyState == 3) {
    // loading
  }
  if (xhr.readyState == 4) {
    // request finished
  }
};
```

You can find `readystatechange` listeners in really old code, it's there for historical reasons, as there was a time when there were no `load` and other events. Nowadays, `load`/`error`/`progress` handlers deprecate it.

### Aborting request
We can terminate the request at any time. The call to `xhr.abort()` does that:
```javascript
xhr.abort(); // terminate the request
```

That triggers `abort` event, and `xhr.status` becomes `0`.

### Synchronous requests
If in the `open` method the third parameter `async` is set to `false`, the request is made synchronously.

In other words, JavaScript execution pauses at `send()` and resumes when the response is received. Somewhat like `alert` or `prompt` commands.

Here's the rewritten example, the 3rd parameter of `open` is `false`:
```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
  xhr.send();
  if (xhr.status != 200) {
    alert(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    alert(xhr.response);
  }
} catch(err) { // instead of onerror
  alert("Request failed");
}
```

It might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the "hanging" webpage.

Many advanced capabilities of `XMLHttpRequest`, like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.

Because of all that, synchronous requests are used very sparingly, almost never. We won't talk about them any more.

### HTTP-headers
`XMLHttpRequest` allows both to send custom headers and read headers from the response.

There are 3 methods for HTTP-headers:

`setRequestHeader(name, value)`
Sets the request header with the given `name` and `value`.

For instance:
```javascript
xhr.setRequestHeader('Content-Type', 'application/json');
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Headers limitations**

Several headers are managed exclusively by the browser, e.g. `Referer` and `Host`. The full list is [in the specification](https://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method).

`XMLHttpRequest` is not allowed to change them, for the sake of user safety and correctness of the request.

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Can't remove a header
**

Another peculiarity of `XMLHttpRequest` is that one can't undo `setRequestHeader`.

Once the header is set, it's set. Additional calls add information to the header, don't overwrite it.

For instance:
```javascript
xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// the header will be:
// X-Auth: 123, 456
```

<br />

`getResponseHeader(name)`
Gets the response header with the given `name` (except `Set-Cookie` and `Set-Cookie2`).

For instance:
```javascript
xhr.getResponseHeader('Content-Type')
```

getAl`lResponseHeaders()`
Returns all response headers, except `Set-Cookie` and `Set-Cookie2`.

Headers are returned as a single line, e.g.:
```javascript
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
```

The line break between headers is always `"\r\n"` (doesn't depend on OS), so we can easily split it into individual headers. The separator between the name and the value is always a colon followed by a space `": "`. That's fixed in the specification.

So, if we want to get an object with name/value pairs, we need to throw in a bit JS.

Like this (assuming that if two headers have the same name, then the latter one overwrites the former one):
```javascript
let headers = xhr
  .getAllResponseHeaders()
  .split('\r\n')
  .reduce((result, current) => {
    let [name, value] = current.split(': ');
    result[name] = value;
    return result;
  }, {});

// headers['Content-Type'] = 'image/png'
```

### `POST`, `FormData`
To make a `POST` request, we can use the built-in [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.

The syntax:
```javascript
let formData = new FormData([form]); // creates an object, optionally fill from <form>
formData.append(name, value); // appends a field
```

We create it, optionally fill from a form, `append` more fields if needed, and then:
1. `xhr.open('POST', ...)` – use `POST` method.
2. `xhr.send(formData)` to submit the form to the server.

For instance:
```html
<form name="person">
  <input name="name" value="John">
  <input name="surname" value="Smith">
</form>

<script>
  // pre-fill FormData from the form
  let formData = new FormData(document.forms.person);

  // add one more field
  formData.append("middle", "Lee");

  // send it out
  let xhr = new XMLHttpRequest();
  xhr.open("POST", "/article/xmlhttprequest/post/user");
  xhr.send(formData);

  xhr.onload = () => alert(xhr.response);
</script>
```

The form is sent with `multipart/form-data` encoding.

Or, if we like JSON more, then `JSON.stringify` and send as a string.

Just don't forget to set the header `Content-Type: application/json`, many server-side frameworks automatically decode JSON with it:
```javascript
let xhr = new XMLHttpRequest();

let json = JSON.stringify({
  name: "John",
  surname: "Smith"
});

xhr.open("POST", '/submit')
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.send(json);
```

The `.send(body)` method is pretty omnivore. It can send almost any `body`, including `Blob` and `BufferSource` objects.

### Upload progress
The `progress` event triggers only on the downloading stage.

That is: if we `POST` something, `XMLHttpRequest` first uploads our data (the request body), then downloads the response.

If we're uploading something big, then we're surely more interested in tracking the upload progress. But `xhr.onprogress` doesn't help here.

There's another object, without methods, exclusively to track upload events: `xhr.upload`.

It generates events, similar to `xhr`, but `xhr.upload` triggers them solely on uploading:
- `loadstart` – upload started.
- `progress` – triggers periodically during the upload.
- `abort` – upload aborted.
- `error` – non-HTTP error.
- `load` – upload finished successfully.
- `timeout` – upload timed out (if `timeout` property is set).
- `loadend` – upload finished with either success or error.

Example of handlers:
```javascript
xhr.upload.onprogress = function(event) {
  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
};

xhr.upload.onload = function() {
  alert(`Upload finished successfully.`);
};

xhr.upload.onerror = function() {
  alert(`Error during the upload: ${xhr.status}`);
};
```

Here's a real-life example: file upload with progress indication:
```html
<input type="file" onchange="upload(this.files[0])">

<script>
function upload(file) {
  let xhr = new XMLHttpRequest();

  // track upload progress
  xhr.upload.onprogress = function(event) {
    console.log(`Uploaded ${event.loaded} of ${event.total}`);
  };

  // track completion: both successful or not
  xhr.onloadend = function() {
    if (xhr.status == 200) {
      console.log("success");
    } else {
      console.log("error " + this.status);
    }
  };

  xhr.open("POST", "/article/xmlhttprequest/post/upload");
  xhr.send(file);
}
</script>
```

### Cross-origin requests
`XMLHttpRequest` can make cross-origin requests, using the same CORS policy as fetch.

Just like `fetch`, it doesn't send cookies and HTTP-authorization to another origin by default. To enable them, set `xhr.withCredentials` to `true`:
```javascript
let xhr = new XMLHttpRequest();
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request');
...
```

See the chapter CORS for details about cross-origin headers.

<br />

## 요약
Typical code of the GET-request with `XMLHttpRequest`:
```javascript
let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // HTTP error?
    // handle error
    alert( 'Error: ' + xhr.status);
    return;
  }

  // get the response from xhr.response
};

xhr.onprogress = function(event) {
  // report progress
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // handle non-HTTP error (e.g. network down)
};
```

There are actually more events, the [modern specification](https://www.w3.org/TR/XMLHttpRequest/#events) lists them (in the lifecycle order):
- `loadstart` – the request has started.
- `progress` – a data packet of the response has arrived, the whole response body at the moment is in `response`.
- `abort` – the request was canceled by the call `xhr.abort()`.
- `error` – connection error has occurred, e.g. wrong domain name. Doesn't happen for HTTP-errors like `404`.
- `load` – the request has finished successfully.
- `timeout` – the request was canceled due to timeout (only happens if it was set).
- `loadend` – triggers after `load`, `error`, `timeout` or `abort`.

The `error`, `abort`, `timeout`, and `load` events are mutually exclusive. Only one of them may happen.

The most used events are load completion (`load`), load failure (`error`), or we can use a single `loadend` handler and check the properties of the request object xhr to see what happened.

We've already seen another event: `readystatechange`. Historically, it appeared long ago, before the specification settled. Nowadays, there's no need to use it, we can replace it with newer events, but it can often be found in older scripts.

If we need to track uploading specifically, then we should listen to same events on `xhr.upload` object.
