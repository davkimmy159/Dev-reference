Server-Sent Events
==================

##### [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) 명세
- `EventSource` <sub>(내장 클래스)</sub> 기술
  - 서버 연결 유지
  - 서버 이벤트 수신

##### 지속적인 연결
- 웹소켓 유사

##### 웹소켓 vs `EventSource` <sub>(내장 클래스)</sub>
||웹소켓|`EventSource`<br /><sub>(내장 클래스)</sub>|
|---|---|---|
|방향|양방향<br /><sub>(서버 ↔ 클라이언트)</sub>|단방향<br /><sub>(서버 → 클라이언트)</sub>|
|데이터|- 텍스트<br />- 이진 데이터|텍스트|
|프로토콜|웹소켓 프로토콜|일반 HTTP|

##### `EventSource` <sub>(내장 클래스)</sub>
- 웹소켓 대비 기능 부족
  - 중 · 소규모 앱 적용 시 기능 충분
- 간단한 사용법

##### 특징
- 데이터 스트림 수신
  - 채팅 메시지
  - 가격
  - 기타 등등
- 자동 재연결 지원
  - 직접 구현 X
- 일반 HTTP <sub>(프로토콜)</sub>
  - 별도 프로토콜 X

### 메시지 수신

##### 객체 생성 <sub>(`new EventSource(url)`)</sub>
- `url` 연결 · 유지 <sub>(이벤트 대기)</sub>

##### 서버 응답
- `200` <sub>(코드)</sub>
- `Content-Type: text/event-stream` <sub>(헤더)</sub>

##### 서버측 연결 지속 · 특수 포멧 메시지 전송
```javascript
data: Message 1

data: Message 2

data: Message 3
data: of two lines
```

- A message text goes after `data:`, the space after the colon is optional.
- Messages are delimited with double line breaks `\n\n`.
- To send a line break `\n`, we can immediately send one more `data:` (3rd message above).

In practice, complex messages are usually sent JSON-encoded. Line-breaks are encoded as `\n` within them, so multiline `data:` messages are not necessary.

For instance:
```javascript
data: {"user":"John","message":"First line\n Second line"}
```

…So we can assume that one `data:` holds exactly one message.

For each such message, the `message` event is generated:
```javascript
let eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = function(event) {
  console.log("New message", event.data);
  // will log 3 times for the data stream above
};

// or eventSource.addEventListener('message', ...)
```

#### Cross-origin requests
`EventSource` supports cross-origin requests, like `fetch` any other networking methods. We can use any URL:
```javascript
let source = new EventSource("https://another-site.com/events");
```

The remote server will get the `Origin` header and must respond with `Access-Control-Allow-Origin` to proceed.

To pass credentials, we should set the additional option `withCredentials`, like this:
```javascript
let source = new EventSource("https://another-site.com/events", {
  withCredentials: true
});
```

Please see the chapter CORS for more details about cross-origin headers.

### Reconnection
Upon creation, `new EventSource` connects to the server, and if the connection is broken – reconnects.

That's very convenient, as we don't have to care about it.

There's a small delay between reconnections, a few seconds by default.

The server can set the recommended delay using `retry:` in response (in milliseconds):
```javascript
retry: 15000
data: Hello, I set the reconnection delay to 15 seconds
```

The `retry:` may come both together with some data, or as a standalone message.

The browser should wait that many milliseconds before reconnecting. Or longer, e.g. if the browser knows (from OS) that there's no network connection at the moment, it may wait until the connection appears, and then retry.
- If the server wants the browser to stop reconnecting, it should respond with HTTP status 204.
- If the browser wants to close the connection, it should call `eventSource.close()`:
```javascript
let eventSource = new EventSource(...);

eventSource.close();
```

Also, there will be no reconnection if the response has an incorrect `Content-Type` or its HTTP status differs from `301`, `307`, `200` and `204`. In such cases the `"error"` event will be emitted, and the browser won't reconnect.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

When a connection is finally closed, there's no way to "reopen" it. If we'd like to connect again, just create a new `EventSource`.

<br />

### Message id
When a connection breaks due to network problems, either side can't be sure which messages were received, and which weren't.

To correctly resume the connection, each message should have an `id` field, like this:
```javascript
data: Message 1
id: 1

data: Message 2
id: 2

data: Message 3
data: of two lines
id: 3
```

When a message with `id:` is received, the browser:
- Sets the property `eventSource.lastEventId` to its value.
- Upon reconnection sends the header `Last-Event-ID` with that `id`, so that the server may re-send following messages.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **Put `id:` after `data:`**

Please note: the `id` is appended below message `data` by the server, to ensure that `lastEventId` is updated after the message is received.

<br />

### Connection status: readyState
The `EventSource` object has `readyState` property, that has one of three values:
```javascript
EventSource.CONNECTING = 0; // connecting or reconnecting
EventSource.OPEN = 1;       // connected
EventSource.CLOSED = 2;     // connection closed
```

When an object is created, or the connection is down, it's always `EventSource.CONNECTING` (equals `0`).

We can query this property to know the state of `EventSource`.

### Event types
By default `EventSource` object generates three events:
- `message` – a message received, available as `event.data`.
- `open` – the connection is open.
- `error` – the connection could not be established, e.g. the server returned HTTP 500 status.

The server may specify another type of event with `event: ...` at the event start.

For example:
```javascript
event: join
data: Bob

data: Hello

event: leave
data: Bob
```

To handle custom events, we must use `addEventListener`, not `onmessage`:
```javascript
eventSource.addEventListener('join', event => {
  alert(`Joined ${event.data}`);
});

eventSource.addEventListener('message', event => {
  alert(`Said: ${event.data}`);
});

eventSource.addEventListener('leave', event => {
  alert(`Left ${event.data}`);
});
```

### Full example
Here's the server that sends messages with `1`, `2`, `3`, then `bye` and breaks the connection.

Then the browser automatically reconnects.

##### 결과

![full-example](../../images/03/03/12/full-example.png)

```html
<!-- index.html -->
<!DOCTYPE html>
<script>
let eventSource;

function start() { // when "Start" button pressed
  if (!window.EventSource) {
    // IE or an old browser
    alert("The browser doesn't support EventSource.");
    return;
  }

  eventSource = new EventSource('digits');

  eventSource.onopen = function(e) {
    log("Event: open");
  };

  eventSource.onerror = function(e) {
    log("Event: error");
    if (this.readyState == EventSource.CONNECTING) {
      log(`Reconnecting (readyState=${this.readyState})...`);
    } else {
      log("Error has occured.");
    }
  };

  eventSource.addEventListener('bye', function(e) {
    log("Event: bye, data: " + e.data);
  });

  eventSource.onmessage = function(e) {
    log("Event: message, data: " + e.data);
  };
}

function stop() { // when "Stop" button pressed
  eventSource.close();
  log("eventSource.close()");
}

function log(msg) {
  logElem.innerHTML += msg + "<br>";
  document.documentElement.scrollTop = 99999999;
}
</script>

<button onclick="start()">Start</button> Press the "Start" to begin.
<div id="logElem" style="margin: 6px 0"></div>

<button onclick="stop()">Stop</button> "Stop" to finish.
```
```javascript
/* server.js */
let http = require('http');
let url = require('url');
let querystring = require('querystring');

function onDigits(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream; charset=utf-8',
    'Cache-Control': 'no-cache'
  });

  let i = 0;

  let timer = setInterval(write, 1000);
  write();

  function write() {
    i++;

    if (i == 4) {
      res.write('event: bye\ndata: bye-bye\n\n');
      clearInterval(timer);
      res.end();
      return;
    }

    res.write('data: ' + i + '\n\n');

  }
}

function accept(req, res) {

  if (req.url == '/digits') {
    onDigits(req, res);
    return;
  }

  fileServer.serve(req, res);

}

if (!module.parent) {
  http.createServer(accept).listen(8080);
} else {
  exports.accept = accept;
}
```

<br />

## 요약
`EventSource` object automatically establishes a persistent connection and allows the server to send messages over it.

It offers:
- Automatic reconnect, with tunable `retry` timeout.
- Message ids to resume events, the last received identifier is sent in `Last-Event-ID` header upon reconnection.
- The current state is in the `readyState` property.

That makes `EventSource` a viable alternative to `WebSocket`, as it's more low-level and lacks such built-in features (though they can be implemented).

In many real-life applications, the power of `EventSource` is just enough.

Supported in all modern browsers (not IE).

The syntax is:
```javascript
let source = new EventSource(url, [credentials]);
```

The second argument has only one possible option: `{ withCredentials: true }`, it allows sending cross-origin credentials.

Overall cross-origin security is same as for `fetch` and other network methods.

#### Properties of an EventSource object
- `readyState`
  - The current connection state: either `EventSource.CONNECTING (=0)`, `EventSource.OPEN (=1)` or `EventSource.CLOSED (=2)`.
- `lastEventId`
  - The last received `id`. Upon reconnection the browser sends it in the header `Last-Event-ID`.

#### Methods
- `close()`
  - Closes the connection.

#### Events
- `message`
  - Message received, the data is in `event.data`.
- `open`
  - The connection is established.
- `error`
  - In case of an error, including both lost connection (will auto-reconnect) and fatal errors. We can check `readyState` to see if the reconnection is being attempted.

The server may set a custom event name in `event:`. Such events should be handled using `addEventListener`, not `on<event>`.

#### Server response format
The server sends messages, delimited by `\n\n`.

A message may have following fields:
- `data:` – message body, a sequence of multiple `data` is interpreted as a single message, with `\n` between the parts.
- `id:` – renews `lastEventId`, sent in `Last-Event-ID` on reconnect.
- `retry:` – recommends a retry delay for reconnections in ms. There's no way to set it from JavaScript.
- `event:` – event name, must precede `data:`.

A message may include one or more fields in any order, but `id:` usually goes the last.
