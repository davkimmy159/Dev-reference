파일 업로드 재개
===================

##### `fetch` <sub>(메서드)</sub>
- 파일 업로드 용이

##### 업로드 재개
- 내장 기능 X
- 부분적 구현 가능 기능 多

##### 용량 큰 파일 업로드 재개 작업
- 업로드 진행률 표시 필요
  - `fetch` <sub>(메서드)</sub> X
  - `XMLHttpRequest` <sub>(객체)</sub> 사용

### 도움 안 되는 진행률 이벤트


#### `upload.onprogress`

##### 업로드 진행률 추적
- 데이터 전송 시 작동

##### 서버측 데이터 수신 여부 인지 X <sub>(브라우저)</sub>
- 다양한 문제 발생 가능
  - 지역 네트워크 프락시 지연
  - 원격 서버 프로세스 문제 발생
  - 전송 중 손실 발생 · 리시버 도달 X
  - 기타 등등

##### 업로드 재개 시 필요 정보
- 정확한 바이트 숫자 수신 <sub>(서버 → 브라우저)</sub>
  - 추가 요청 필요

### 알고리즘

#### 1. 파일 아이디 생성 <sub>(고윳값 구분)</sub>
- 서버에 업로드 재개 대상 파일 통보
- 이름 · 크기 · 최종 수정 날짜 변경 시
  - 별도 `fileId` 생성
```javascript
let fileId =
    file.name
  + '-'
  + file.size
  + '-'
  + +file.lastModifiedDate;
```

#### 2. 서버 요청 전송
- 이전 바이트 전송량 질의
- 서버측 파일 업로드 추적 가정
  - `X-File-Id` <sub>(헤더)</sub>
  - 서버측 추적 작업 구현
- 서버 내 파일 부재 시
  - `0` 응답
```javascript
let response = await fetch('status', {
  headers: {
    'X-File-Id': fileId
  }
});

// 서버측 파일 바이트 수신량 확인
let startByte = +await response.text();
```

#### 3. 파일 전송 <sub>(`startByte` 위치)</sub>
- `slice` <sub>(`Blob` 객체 메서드)</sub> 사용
```javascript
xhr.open("POST", "upload", true);

// 파일 아이디
// - 서버에 업로드 대상 파일 통보
xhr.setRequestHeader('X-File-Id', fileId);

// 시작 바이트 (업로드 재개 대생 파일)
// - 서버측 파일 업로드 재개 인지
xhr.setRequestHeader('X-Start-Byte', startByte);

xhr.upload.onprogress = (e) => {
  console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
};

// 업로드 대상 파일
// - ex) input.files[0] 등
xhr.send(file.slice(startByte));
```

##### `X-File-Id` <sub>(헤더 · 파일 아이디)</sub> 서버 전송
- 업로드 대상 파일 통보 <sub>(서버 전송)</sub>

##### `X-Start-Byte` <sub>(헤더 · 시작 바이트)</sub> 서버 전송
- 업로드 초기화 X · 재개 통보 <sub>(서버 전송)</sub>

##### 서버 기록 확인
- 파일 업로드 여부
- 현재 서버 업로드 된 파일 크기 확인
  - `X-Start-Byte` <sub>(헤더)</sub> 값 일치 여부

#### 서버 기록 확인 후
- 파일 데이터 추가
  - 서버 업로드 된 파일 크기 시점 ~

##### 동작 테스트 구현 코드
- 서버 <sub>(Node.js)</sub>
- 클라이언트

##### 서버
- 파일 업로드 저장
  - Nginx 서버 완충 기억 장치
- 파일 업로드 완료 후
  - Nginx 서버 → Node.js <sub>(전달)</sub>

##### 결과

![resumable-file-upload](../../images/03/03/09/resumable-file-upload.png)

```html
<!-- index.html -->
<!DOCTYPE HTML>

<script src="uploader.js"></script>

<form name="upload" method="POST" enctype="multipart/form-data" action="/upload">
  <input type="file" name="myfile">
  <input type="submit" name="submit" value="Upload (Resumes automatically)">
</form>

<button onclick="uploader.stop()">Stop upload</button>

<div id="log">Progress indication</div>

<script>
  function log(html) {
    document.getElementById('log').innerHTML = html;
    console.log(html);
  }

  function onProgress(loaded, total) {
    log("progress " + loaded + ' / ' + total);
  }

  let uploader;

  document.forms.upload.onsubmit = async function(e) {
    e.preventDefault();

    let file = this.elements.myfile.files[0];
    if (!file) return;

    uploader = new Uploader({file, onProgress});

    try {
      let uploaded = await uploader.upload();

      if (uploaded) {
        log('success');
      } else {
        log('stopped');
      }

    } catch(err) {
      console.error(err);
      log('error');
    }
  };

</script>
```
```javascript
/* server.js */
let http = require('http');
let static = require('node-static');
let fileServer = new static.Server('.');
let path = require('path');
let fs = require('fs');
let debug = require('debug')('example:resume-upload');

let uploads = Object.create(null);

function onUpload(req, res) {

  let fileId = req.headers['x-file-id'];
  let startByte = +req.headers['x-start-byte'];

  if (!fileId) {
    res.writeHead(400, "No file id");
    res.end();
  }

  // 파일 저장 위치 지정
//let filePath = path.join('/tmp', fileId);
  let filePath = '/dev/null';

  debug("onUpload fileId: ", fileId);

  // 새 업로드 초기화
  if (!uploads[fileId]) {
    uploads[fileId] = {};
  }
  let upload = uploads[fileId];

  debug("bytesReceived:" + upload.bytesReceived + " startByte:" + startByte)

  let fileStream;

  /* startByte 값
   0 · 미설정 시
   - 새 파일 생성
   有
   - 크기 체크 · 기존 파일 이어 진행
   */
  if (!startByte) {
    upload.bytesReceived = 0;
    fileStream = fs.createWriteStream(filePath, {
      flags: 'w'
    });
    debug("New file created: " + filePath);
  } else {

    // 디스크 내 파일 크기 추가 확인 가능
    if (upload.bytesReceived != startByte) {
      res.writeHead(400, "Wrong start byte");
      res.end(upload.bytesReceived);
      return;
    }

    // 기존 파일 이어 진행
    fileStream = fs.createWriteStream(filePath, {
      flags: 'a'
    });
    debug("File reopened: " + filePath);
  }

  req.on('data', function(data) {
    debug("bytes received", upload.bytesReceived);
    upload.bytesReceived += data.length;
  });

  // 요청 본문 → 파일
  req.pipe(fileStream);

  // 요청 작업 · 요청 데이터 쓰기 완료
  fileStream.on('close', function() {
    if (upload.bytesReceived == req.headers['x-file-size']) {
      debug("Upload finished");
      delete uploads[fileId];

      /* 업로드 완료 파일 대상 추가 작업 진행 */

      res.end("Success " + upload.bytesReceived);
    } else {

      // 연결 종료 · 업로드 미완료 파일 방치
      debug("File unfinished, stopped at " + upload.bytesReceived);
      res.end();
    }
  });

  // I/O 에러 발생 시
  // - 요청 작업 종료
  fileStream.on('error', function(err) {
    debug("fileStream error");
    res.writeHead(500, "File error");
    res.end();
  });

}

function onStatus(req, res) {
  let fileId = req.headers['x-file-id'];
  let upload = uploads[fileId];
  debug("onStatus fileId:", fileId, " upload:", upload);
  if (!upload) {
    res.end("0")
  } else {
    res.end(String(upload.bytesReceived));
  }
}

function accept(req, res) {
  if (req.url == '/status') {
    onStatus(req, res);
  } else if (req.url == '/upload' && req.method == 'POST') {
    onUpload(req, res);
  } else {
    fileServer.serve(req, res);
  }
}

// -----------------------------------

if (!module.parent) {
  http.createServer(accept).listen(8080);
  console.log('Server listening at port 8080');
} else {
  exports.accept = accept;
}
```
```javascript
/* uploader.js */
class Uploader {

  constructor({file, onProgress}) {
    this.file = file;
    this.onProgress = onProgress;

    // create fileId that uniquely identifies the file
    // we could also add user session identifier (if had one), to make it even more unique
    this.fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;
  }

  async getUploadedBytes() {
    let response = await fetch('status', {
      headers: {
        'X-File-Id': this.fileId
      }
    });

    if (response.status != 200) {
      throw new Error("Can't get uploaded bytes: " + response.statusText);
    }

    let text = await response.text();

    return +text;
  }

  async upload() {
    this.startByte = await this.getUploadedBytes();

    let xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", "upload", true);

    // send file id, so that the server knows which file to resume
    xhr.setRequestHeader('X-File-Id', this.fileId);
    // send the byte we're resuming from, so the server knows we're resuming
    xhr.setRequestHeader('X-Start-Byte', this.startByte);

    xhr.upload.onprogress = (e) => {
      this.onProgress(this.startByte + e.loaded, this.startByte + e.total);
    };

    console.log("send the file, starting from", this.startByte);
    xhr.send(this.file.slice(this.startByte));

    // return
    //   true if upload was successful,
    //   false if aborted
    // throw in case of an error
    return await new Promise((resolve, reject) => {

      xhr.onload = xhr.onerror = () => {
        console.log("upload end status:" + xhr.status + " text:" + xhr.statusText);

        if (xhr.status == 200) {
          resolve(true);
        } else {
          reject(new Error("Upload failed: " + xhr.statusText));
        }
      };

      // onabort triggers only when xhr.abort() is called
      xhr.onabort = () => resolve(false);

    });

  }

  stop() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }

}
```

아시다시피 여러 최신 네트워킹 메서드는 기능 면에서 파일 매니저에 가깝습니다 – 오버 헤더 통제, 진행률 표시, 파일을 부분적으로 보냄 등.

이제 파일 업로드 재개를 구현할 수 있습니다.
