창 사이 상호작용
===========================

##### 동일 오리진 정책
- 각 창 · 프레임 접근 방지
  - 사용자 보호 <sub>(정보 절도)</sub>

### 동일 오리진

##### 주소 상 특정 구성 동일 
- 프로토콜
- 도메인
- 포트

##### 동일 오리진 url 예시
- `http://site.com`
- `http://site.com/`
- `http://site.com/my/page.html`

##### 상이 오리진 url 예시 <sub>(`http://site.com`)</sub>
- `http://www.site.com`
  - `www.` <sub>(도메인)</sub>
- `http://site.org`
  - `.org` <sub>(도메인)</sub>
- `https://site.com`
  - `https` <sub>(프로토콜)</sub>
- `http://site.com:8080`
  -  `8080` <sub>(포트)</sub>

#### 동일 오리진 정책 의미

##### The "Same Origin" policy states that:
- if we have a reference to another window, e.g. a popup created by `window.open` or a window inside `<iframe>`, and that window comes from the same origin, then we have full access to that window.
- otherwise, if it comes from another origin, then we can't access the content of that window: variables, document, anything. The only exception is `location`: we can change it (thus redirecting the user). But we cannot read location (so we can't see where the user is now, no information leak).

#### `iframe`
- `<iframe>` <sub>(태그)</sub>
  - 별도로 삽입된 창
- 고유 JS 환경 보유
  - `window` <sub>(전역 객체)</sub>
  - `document` <sub>(객체)</sub>

#### 접근 프로퍼티

##### `contentWindow`
- `iframe` 내 `window` <sub>(전역 객체)</sub>

##### `contentDocument`
- `iframe` 내 `document` <sub>(객체)</sub>
- `contentWindow.document` 축약형

##### 삽입창 접근 시 오리진 체크 <sub>(브라우저)</sub>
- 동일 시
  - 자유롭게 접근
- 상이 시
  - 접근 X <sub>(`location` 예외)</sub>

##### 타 오리진 `iframe` 읽기 · 쓰기
```html
<iframe src="https://example.com" id="iframe"></iframe>

<script>
  iframe.onload = function() {

    // iframe 내 window (전역 객체) 참조 얻기
    // - 정상 동작
    let iframeWindow = iframe.contentWindow;
    try {

      // iframe 내 document (객체) 참조 얻기
      // - 에러 발생
      let doc = iframe.contentDocument;
    } catch(e) {

      // Security Error (another origin)
      alert(e);
    }

    try {
      // iframe 내 페이지 url 얻기
      // - 에러 발생
      let href = iframe.contentWindow.location.href;
    } catch(e) {

      // Security Error
      alert(e);
    }

    // iframe 내 페이지 주소 (window.location) 값 수정
    // - 해당 url 내용 로드
    //   - 정상 동작
    iframe.contentWindow.location = '/';

    // 핸들러 제거
    // - window.location (주소 프로퍼티) 값 수정 후 실행 X
    iframe.onload = null;
  };
</script>
```

##### 타 오리진 창 접근 시 에러 예외 <sub>(2가지)</sub>
1. 창 내 `window` <sub>(전역 객체)</sub> 참조 얻기
    - `iframe.contentWindow`
2. `window.location` <sub>(주소 프로퍼티)</sub> 수정

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`iframe.onload` vs `iframe.contentWindow.onload`**

##### 본질적으로 동일
- `iframe.onload` <sub>(이벤트)</sub>
  - `<iframe>` <sub>(태그)</sub>
- `iframe.contentWindow.onload`
  - 삽입창 객체

##### 발생 시점 <sub>(둘 다)</sub>
- 삽입창 로드 완료 <sub>(모든 자원 포함)</sub>

##### 차이점
- `iframe.onload`
  - 타 오리진 접근 가능
- `iframe.contentWindow.onload`
  - 타 오리진 접근 X

<br />

### 서브도메인 창 <sub>(`document.domain`)</sub>

##### 정의
- 도메인 다른 두 url
  - 상이 오리진

##### 공통 서브도메인 공유
- 전체 도메인 차이 무시 가능 <sub>(동일 오리진 취급)</sub>
  - 창 사이 상호작용 목적
- ex\) `site.com`
  - `john.site.com`
  - `peter.site.com`

##### 양쪽 창 특정 코드 실행 필요
- 코드 실행 후 제한 없이 상호작용 가능
```javascript
document.domain = 'site.com';
```

### `iframe` 내 `document` 함정

##### `iframe` <sub>(동일 오리진)</sub> 내 `document` 접근 시 주의
- 크로스 오리진 무관
- `iframe` <sub>(요소)</sub> 생성 후 즉시 `document` 보유
  - 로드 완료 후의 `document` 와 상이

##### `document`<sub>(생성 직후)</sub>  ≠ `document` <sub>(로드 완료 후)</sub>
- 생성 직후 `document` 관련 작업 시
  - 정상 동작 X
  - ex\) 설정 이벤트 핸들러 미작동 등
```html
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;

  iframe.onload = function() {
    let newDoc = iframe.contentDocument;

    // 두 document 상이
    alert(oldDoc == newDoc); // false
  };
</script>
```

##### 실제 `document`
- `iframe.onload` 발생 시 접근 가능
  - 모든 자원 로드 완료 이후 <sub>(대기 시간 ↑)</sub>

##### `setInterval` <sub>(함수)</sub> 내 체크
- `iframe.onload` 보다 빨리 접근 가능
```html
<iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;

  // 매 100ms 마다 체크
  let timer = setInterval(() => {
    let newDoc = iframe.contentDocument;
    if (newDoc == oldDoc) return;

    alert("New document is here!");

    clearInterval(timer);
  }, 100);
</script>
```

### `window.frames` <sub>(컬렉션)</sub>
- `iframe` 내 창 <sub>(`window`)</sub> 객체 컬렉션

##### 접근 방법
- 인덱스
  - `window.frames[0]`
- 이름 <sub>(`name` 속성값)</sub>
  - `window.frames.iframeName`
```html
<iframe src="/" style="height:80px" name="win" id="iframe"></iframe>

<script>
  // true
  alert(iframe.contentWindow == frames[0]);

  // true
  alert(iframe.contentWindow == frames.win);
</script>
```

##### 중첩 `iframe`
- `window` <sub>(창 객체)</sub> 계층 형성

##### 중첩 관련 프로퍼티 <sub>(`window` 객체)</sub>
- `frames` <sub>(중첩 `iframe`)</sub>
  - 자식 창 <sub>(`window`)</sub> 객체 컬렉션
- `parent`
  - 부모 <sub>(바깥)</sub> 창 <sub>(`window`)</sub> 객체 참조
- `top`
  - 최상위 부모 창 <sub>(`window`)</sub> 객체 참조
```javascript
// true
window.frames[0].parent === window;
```

##### 현재 `document` 위치 확인 <sub>(`iframe` 안 여부)</sub>
- `top` <sub>(프로퍼티)</sub> 체크
```javascript
if (window == top) {
  alert('The script is in the topmost window, not in a frame');
} else {
  alert('The script runs in a frame!');
}
```

### `sandbox` <sub>(`iframe` 속성)</sub>

##### `iframe` 내 특정 동작 실행 방지
- 신뢰할 수 없는 코드 실행 X
- `iframe` 샌드박스화
  - 타 오리진 취급
  - 기타 제한 적용


##### `sandbox` <sub>(속성)</sub> 적용 제한
- 기본값 有
- 완화 가능
  - 문자열 <sub>(공백 구분 리스트)</sub> 할당
- 빈 속성값
  - 가장 엄격한 제한 적용
```html
<iframe sandbox="allow-forms allow-popups">…</iframe>
<iframe sandbox>…</iframe>

```

#### 제한 리스트 [<sub>(메뉴얼)</sub>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) 

##### `allow-same-origin`
- 동일 오리진 정책 허용
  - 크로스-오리진 상호작용 가능
- 기본 적용 제한 <sub>(빈 속성값)</sub>
  - 타 오리진 정책 <sub>(타 오리진 취급)</sub>
    - `src` <sub>(속성)</sub> 내 동일 오리진 무시
    - 
- By default `"sandbox"` forces the "different origin" policy for the iframe. In other words, it makes the browser to treat the `iframe` as coming from another origin, even if its `src` points to the same site. With all implied restrictions for scripts. This option removes that feature.

##### `allow-top-navigation`
- `parent.location` 수정

##### `allow-forms`
- `iframe` 내 폼 제출

##### `allow-scripts`
- `iframe` 내 스크립트 실행

##### `allow-popups`
- `iframe` 내 `window.open` <sub>(팝업창)</sub> 실행

##### 빈 `sandbox` <sub>(속성)</sub> 적용 <sub>(기본 제한)</sub>
- `iframe` 내 JS 코드 · 폼
  - 미작동
```html
<iframe sandbox src="…">
```

##### 결과

![the-sandbox-iframe-attribute](../../images/03/01/02/the-sandbox-iframe-attribute.png)

```html
<!-- index.html -->
<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>
  <div>The iframe below has the <code>sandbox</code> attribute.</div>
  <iframe sandbox src="sandboxed.html" style="height:60px;width:90%"></iframe>
</body>
</html>
```
```html
<!-- sandboxed.html -->
<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <button onclick="alert(123)">Click to run a script (doesn't work)</button>

  <form action="http://google.com">
    <input type="text">
    <input type="submit" value="Submit (doesn't work)">
  </form>

</body>
</html>
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

The purpose of the "`sandbox"` attribute is only to add more restrictions. It cannot remove them. In particular, it can't relax same-origin restrictions if the iframe comes from another origin.

<br />

### Cross-window messaging
The `postMessage` interface allows windows to talk to each other no matter which origin they are from.

So, it's a way around the "Same Origin" policy. It allows a window from `john-smith.com` to talk to `gmail.com` and exchange information, but only if they both agree and call corresponding JavaScript functions. That makes it safe for users.

The interface has two parts.

#### postMessage
The window that wants to send a message calls [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) method of the receiving window. In other words, if we want to send the message to `win`, we should call `win.postMessage(data, targetOrigin)`.

Arguments:
- `data`
  - The data to send. Can be any object, the data is cloned using the "structured cloning algorithm". IE supports only strings, so we should `JSON.stringify` complex objects to support that browser.
- `targetOrigin`
  - Specifies the origin for the target window, so that only a window from the given origin will get the message.

The `targetOrigin` is a safety measure. Remember, if the target window comes from another origin, we can't read it's `location` in the sender window. So we can't be sure which site is open in the intended window right now: the user could navigate away, and the sender window has no idea about it.

Specifying `targetOrigin` ensures that the window only receives the data if it's still at the right site. Important when the data is sensitive.

For instance, here `win` will only receive the message if it has a document from the origin `http://example.com`:
```html
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("message", "http://example.com");
</script>
```

If we don't want that check, we can set `targetOrigin` to `*`.
```html
<iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("message", "*");
</script>
```

#### `onmessage`
To receive a message, the target window should have a handler on the `message` event. It triggers when `postMessage` is called (and `targetOrigin` check is successful).

The event object has special properties:
- `data`
  - The data from `postMessage`.
- `origin`
  - The origin of the sender, for instance `http://javascript.info`.
- `source`
  - The reference to the sender window. We can immediately `source.postMessage(...)` back if we want.

To assign that handler, we should use `addEventListener`, a short syntax `window.onmessage` does not work.

Here's an example:
```javascript
window.addEventListener("message", function(event) {
  if (event.origin != 'http://javascript.info') {
    // something from an unknown domain, let's ignore it
    return;
  }

  alert( "received: " + event.data );

  // can message back using event.source.postMessage(...)
});
```

The full example:

##### 결과

![cross-window-messaging](../../images/03/01/02/cross-window-messaging.png)

```html
<!-- index.html -->
<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <form id="form">
    <input type="text" placeholder="Enter message" name="message">
    <input type="submit" value="Click to send">
  </form>

  <iframe src="iframe.html" id="iframe" style="display:block;height:60px"></iframe>

  <script>
    form.onsubmit = function() {
      iframe.contentWindow.postMessage(this.message.value, '*');
      return false;
    };
  </script>

</body>
</html>
```
```html
<!-- iframe.html -->
<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  Receiving iframe.
  <script>
    window.addEventListener('message', function(event) {
      alert(`Received ${event.data} from ${event.origin}`);
    });
  </script>

</body>
</html>
```

<br />

## 요약
To call methods and access the content of another window, we should first have a reference to it.

For popups we have these references:
- From the opener window: `window.open` – opens a new window and returns a reference to it,
- From the popup: `window.opener` – is a reference to the opener window from a popup.

For iframes, we can access parent/children windows using:
- `window.frames` – a collection of nested window objects,
- `window.parent`, `window.top` are the references to parent and top windows,
- `iframe.contentWindow` is the window inside an `<iframe>` tag.

If windows share the same origin (host, port, protocol), then windows can do whatever they want with each other.

Otherwise, only possible actions are:
- Change the `location` of another window (write-only access).
- Post a message to it.

Exceptions are:
- Windows that share the same second-level domain: `a.site.com` and `b.site.com`. Then setting `document.domain='site.com'` in both of them puts them into the "same origin" state.
- If an iframe has a `sandbox` attribute, it is forcefully put into the "different origin" state, unless the `allow-same-origin` is specified in the attribute value. That can be used to run untrusted code in iframes from the same site.

The `postMessage` interface allows two windows with any origins to talk:
1. The sender calls `targetWin.postMessage(data, targetOrigin)`.
2. If `targetOrigin` is not `'*'`, then the browser checks if window `targetWin` has the origin `targetOrigin`.
3. If it is so, then `targetWin` triggers the `message` event with special properties:
    - `origin` – the origin of the sender window (like `http://my.site.com`)
    - `source` – the reference to the sender window.
    - `data` – the data, any object in everywhere except IE that supports only strings.

We should use `addEventListener` to set the handler for this event inside the target window.
