### `cursor`

##### 검색 메서드 <sub>(`getAll[Keys]` 등)</sub>
- 키 · 값 쌍 배열 반환
- 객체 저장소 크기
  - (초)대량 가능
  - 사용 가능 메모리 초과 가능
    - 모든 데이터 반환 X

##### `cursor` <sub>(특수 객체)</sub>
- 질의 따라 객체 저장소 탐색
- 키 · 값 쌍 1개 반환
  - 메모리 절약

##### 객체 저장소 내 정렬 내부적 자동 실행
- `cursor` 탐색
  - 키 정렬 순 <sub>(오름차순 · 기본값)</sub>

##### 문법
```javascript
// 값
let request = store.openCursor(query, [direction]);

// 키
let requestKey = store.openKeyCursor(…); 
```

##### `query`
- 키 · 키 범위

##### `direction`<sub>(순서 · 선택)</sub>
- `"next"` <sub>(기본값)</sub>
  - 오름차순
- `"prev"`
  - 내림차순
- `"[next·prev]unique"`
  - 오름 · 내림차순
  - 동일 키 생략
  - 인덱스 전용 옵션

##### `onsuccess` <sub>(핸들러)</sub> 다수 발생
- 각 결과 <sub>(키 · 값 쌍)</sub> 당 1번

##### `cursor` 사용하기
```javascript
let transaction = db.transaction("books");
let books = transaction.objectStore("books");

let request = books.openCursor();

// cursor 탐색 결과 (book 1개) 마다 발생
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {

    // 다음 키 (id 필드)
    let key = cursor.key;

    // 다음 값 (book 객체)
    let value = cursor.value;

    console.log(key, value);
    cursor.continue();
  } else {
    console.log("No more books");
  }
};
```

#### 주요 메서드

##### `advance(count)`
- `count` 번 `cursor` 이동 <sub>(결과 스킵)</sub>

##### `continue([key])`
- 다음 값 `cursor` 이동
- `key` 전달 시
  - 해당 값 바로 다음 위치 이동

##### 현재 `cursor` 위치 다음 값 존재 여부 무관
- `onsuccess` <sub>(핸들러)</sub> 무조건 실행
- `result` 값
  - 다음 값
  - `undefined`

##### 인덱스 대상 `cursor`
- 일반 `cursor` <sub>(객체 저장소 대상)</sub> 동일
- `key` <sub>(프로퍼티)</sub>
  - 인덱스 키 <sub>(인덱스 설정 필드)</sub>
    - ex\) `price`
- `primaryKey` <sub>(프로퍼티)</sub>
  - 원래 키
```javascript
let request = priceIdx.openCursor(IDBKeyRange.upperBound(5));

// 각 결과마다 호출
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {

    // 다음 인덱스 키 (price 필드)
    let key = cursor.key;

    // 다음 객체 키 (id 필드)
    let primaryKey = cursor.primaryKey;

    // 다음 결과 (객체 · book)
    let value = cursor.value;

    console.log(key, value);
    cursor.continue();
  } else {
    console.log("No more books");
  }
};
```

### `Promise` 래퍼

##### 각 요청 핸들러 <sub>(`on[success·error]`)</sub> 추가 작업
- 귀찮은 일
- 이벤트 위임 사용
  - 비동기 <sub>(`async` · `await`)</sub> 사용 <sub>(편의성 ↑)</sub>

##### [`jakearchibald` <sub>(가벼운 `Promise` 래퍼 라이브러리)</sub>](https://github.com/jakearchibald/idb)
- `idb` <sub>(전역 객체)</sub> 생성
  - `Promise` 적용 `indexedDB` 메서드 구현
  - 핸들러 <sub>(`on[success·error]`)</sub> X
```javascript
let db = await idb.openDB('store', 1, db => {
  if (db.oldVersion == 0) {

    // 초기화 수행
    db.createObjectStore('books', {keyPath: 'id'});
  }
});

let transaction = db.transaction('books', 'readwrite');
let books = transaction.objectStore('books');

try {
  await books.add(…);
  await books.add(…);

  await transaction.complete;

  console.log('jsbook saved');
} catch(err) {
  console.log('error', err.message);
}
```

#### 에러 처리

##### 에러 미처리 시
- 최근접 외부 `try…catch` <sub>(문)</sub> 까지 진행

##### 미처리 에러
- "unhandled promise rejection" 이벤트
  - `window` <sub>(전역 객체)</sub> 대상
```javascript
window.addEventListener('unhandledrejection', event => {
  let request = event.target; // IndexedDB native request object
  let error = event.reason; //  Unhandled error object, same as request.error
  ...report about the error...
});
```

#### "Inactive transaction" pitfall
As we already know, a transaction auto-commits as soon as the browser is done with the current code and microtasks. So if we put a macrotask like `fetch` in the middle of a transaction, then the transaction won't wait for it to finish. It just auto-commits. So the next request in it would fail.

For a promise wrapper and `async`/`await` the situation is the same.

Here's an example of `fetch` in the middle of the transaction:
```javascript
let transaction = db.transaction("inventory", "readwrite");
let inventory = transaction.objectStore("inventory");

await inventory.add({ id: 'js', price: 10, created: new Date() });

await fetch(...); // (*)

await inventory.add({ id: 'js', price: 10, created: new Date() }); // Error
```

The next `inventory.add` after `fetch (*)` fails with an "inactive transaction" error, because the transaction is already committed and closed at that time.

The workaround is same as when working with native IndexedDB: either make a new transaction or just split things apart.
1. Prepare the data and fetch all that's needed first.
2. Then save in the database.

#### Getting native objects
Internally, the wrapper performs a native IndexedDB request, adding `onerror`/`onsuccess` to it, and returns a promise that rejects/resolves with the result.

That works fine most of the time. The examples are at the lib page https://github.com/jakearchibald/idb.

In few rare cases, when we need the original `request` object, we can access it as `promise.request` property of the promise:
```javascript
let promise = books.add(book); // get a promise (don't await for its result)

let request = promise.request; // native request object
let transaction = request.transaction; // native transaction object

// ...do some native IndexedDB voodoo...

let result = await promise; // if still needed
```

<br />

## 요약
Summary
IndexedDB can be thought of as a "localStorage on steroids". It's a simple key-value database, powerful enough for offline apps, yet simple to use.

The best manual is the specification, [the current one](https://w3c.github.io/IndexedDB/) is 2.0, but few methods from [3.0](https://w3c.github.io/IndexedDB/) (it's not much different) are partially supported.

The basic usage can be described with a few phrases:
1. Get a promise wrapper like [idb](https://github.com/jakearchibald/idb).
2. Open a database: `idb.openDb(name, version, onupgradeneeded)`
    - Create object storages and indexes in `onupgradeneeded` handler or perform version update if needed.
3. For requests:
    - Create transaction `db.transaction('books')` (readwrite if needed).
    - Get the object store `transaction.objectStore('books')`.
4. Then, to search by a key, call methods on the object store directly.
    - To search by an object field, create an index.
5. If the data does not fit in memory, use a cursor.

Here's a small demo app:

##### 결과

![summary](../../images/03/04/03/summary.png)

```html
<!-- index.html -->
<!doctype html>
<script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script>

<button onclick="addBook()">Add a book</button>
<button onclick="clearBooks()">Clear books</button>

<p>Books list:</p>

<ul id="listElem"></ul>

<script>
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db => {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book => `<li>
        name: ${book.name}, price: ${book.price}
      </li>`).join('');
  } else {
    listElem.innerHTML = '<li>No books yet. Please add books.</li>'
  }

}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt("Book name?");
  let price = +prompt("Book price?");

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert("Such book exists already");
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event => {
  alert("Error: " + event.reason.message);
});

</script>
```
