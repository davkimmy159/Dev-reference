### 트랜잭션

##### 동작 그룹
- 그룹 내 모든 동작
  - 함께 성공 · 실패

##### 물건 구매 동작
1. 손님 계좌 내 구매가 차감
2. 손님 구매 목록 내 상품 추가
- 1번째 동작 성공 후 문제 발생 시
  - 2번째 동작 실패
- 모든 동작
  - 전부 성공 · 전부 실패 필요
    - 트랜잭션 사용

##### 모든 데이터 동작
- `indexedDB` 내 한 트랜잭션 내 실행 필수

#### 트랜잭션 생성
```javascript
db.transaction(store[, type]);
```

##### `store` <sub>(문자열 · 배열)</sub>
- 트랜잭션 접근 대상 저장소명
- 다수 객체 저장소 접근 가능

##### `type` <sub>(문자열 · 트랜잭션 타입 · 둘 중 하나)</sub>
- `readonly` <sub>(기본값)</sub>
  - 읽기 전용
- `readwrite`
  - 읽기 · 쓰기
  - 객체 저장소 생성 · 제거 · 수정 X
- `versionchange` <sub>(사용 X · 내부 전용)</sub>
  - 모든 동작 수행 가능
  - DB 연결 시 자동 생성
    - `updateneeded` <sub>(핸들러)</sub> 전용
      - 저장소 조작 가능 위치
        - 갱신
        - 생성
        - 제거

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **다양한 트랜잭션 타입 존재 이유**

##### 성능 이슈
- `readonly` 트랜잭션
  - 동일 저장소 동시 접근 가능
- `readwrite` 트랜잭션
  - 동일 저장소 동시 접근 X
  - 쓰기 동작 시 저장소 잠금
    - 다음 트랜잭션 대기

<br />

##### 트랜잭션 생성 후 작업 수행
- 저정소 내 값 저장
```javascript
// (1)
// 트랜잭션 생성
// - 트랜잭션 접근 대상 저장소 설정
let transaction = db.transaction("books", "readwrite");

// (2)
// 트랜잭션 적용 저장소 얻기
// - objectStore(name)
let books = transaction.objectStore("books");

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

// (3)
// 요청 수행
let request = books.add(book);

// (4)
// 요청 성공 · 실패 처리
// 이후 타 요청 생성 가능
request.onsuccess = function() {
  console.log("Book added to the store", request.result);
};

request.onerror = function() {
  console.log("Error", request.error);
};
```

#### 데이터 저장 메서드

##### `put(value, [key])`
- 저장소 내 데이터 추가
- 저장소 키 설정 <sub>(`keyPath` · `autoIncrement`)</sub> 부재 시
  - `key`
  -  is supplied only if the object store did not have `keyPath` or `autoIncrement` option. If there's already a value with the same key, it will be replaced.

##### `add(value, [key])`
- 저장소 내 데이터 추가
- if there's already a value with the same key, then the request fails, and an error with the name `"ConstraintError"` is generated.

Similar to opening a database, we can send a request: `books.add(book)`, and then wait for `success`/`error` events.
- The `request.result` for `add` is the key of the new object.
- The error is in `request.error` (if any).

### Transactions' autocommit
In the example above we started the transaction and made `add` request. But as we stated previously, a transaction may have multiple associated requests, that must either all succeed or all fail. How do we mark the transaction as finished, with no more requests to come?

The short answer is: we don't.

In the next version 3.0 of the specification, there will probably be a manual way to finish the transaction, but right now in 2.0 there isn't.

**When all transaction requests are finished, and the microtasks queue is empty, it is committed automatically.**

Usually, we can assume that a transaction commits when all its requests are complete, and the current code finishes.

So, in the example above no special call is needed to finish the transaction.

Transactions auto-commit principle has an important side effect. We can't insert an async operation like `fetch`, `setTimeout` in the middle of transaction. IndexedDB will not keep the transaction waiting till these are done.

In the code below, `request2` in line `(*)` fails, because the transaction is already committed, and can't make any request in it:
```javascript
let request1 = books.add(book);

request1.onsuccess = function() {
  fetch('/').then(response => {
    let request2 = books.add(anotherBook); // (*)
    request2.onerror = function() {
      console.log(request2.error.name); // TransactionInactiveError
    };
  });
};
```

That's because `fetch` is an asynchronous operation, a macrotask. Transactions are closed before the browser starts doing macrotasks.

Authors of IndexedDB spec believe that transactions should be short-lived. Mostly for performance reasons.

Notably, `readwrite` transactions "lock" the stores for writing. So if one part of application initiated `readwrite` on `books` object store, then another part that wants to do the same has to wait: the new transaction "hangs" till the first one is done. That can lead to strange delays if transactions take a long time.

So, what to do?

In the example above we could make a new `db.transaction` right before the new request `(*)`.

But it will be even better, if we'd like to keep the operations together, in one transaction, to split apart IndexedDB transactions and "other" async stuff.

First, make `fetch`, prepare the data if needed, afterwards create a transaction and perform all the database requests, it'll work then.

To detect the moment of successful completion, we can listen to `transaction.oncomplete` event:
```javascript
let transaction = db.transaction("books", "readwrite");

// ...perform operations...

transaction.oncomplete = function() {
  console.log("Transaction is complete");
};
```

Only `complete` guarantees that the transaction is saved as a whole. Individual requests may succeed, but the final write operation may go wrong (e.g. I/O error or something).

To manually abort the transaction, call:
```javascript
transaction.abort();
```

That cancels all modification made by the requests in it and triggers `transaction.onabort` event.
