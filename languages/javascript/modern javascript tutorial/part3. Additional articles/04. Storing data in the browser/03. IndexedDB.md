`IndexedDB`
=========

##### 브라우저 내장 DB
- `localStorage` 보다 강력

##### 기능
- 거의 모든 값 저장 가능
  - 다양한 키 타입 가능
- 트랜잭션 지원
  - 신뢰성 ↑
- 키 범위 질의 · 인덱스 지원
- `localStorage` 보다 큰 용량 저장 가능

##### 용도
- 일반적인 클라이언트 · 서버 X <sub>(과분)</sub>
- 오프라인 앱
  - 타 기술 함께 사용 <sub>(`ServiceWorkers` 등)</sub>

##### [네이티브 `IndexedDB` 인터페이스](https://www.w3.org/TR/IndexedDB)
- 이벤트 기반

##### `async` · `await` 사용 가능 <sub>(`Promise` 기반 래퍼 이용)</sub>
- ex\) https://github.com/jakearchibald/idb
- 편의성 ↑
  - 모든 부분 대체 X

### DB 열기

##### `open` <sub>(메서드)</sub>
- DB 연결

##### 문법
```javascript
let openRequest = indexedDB.open(name, version);
```
- `name` <sub>(문자열)</sub>
  - DB명
- `version` <sub>(양의 정수)</sub>
  - 기본값
    - `1`

##### 다수 DB 연결 가능 <sub>(다수 DB명 사용)</sub>
- 동일 오리진 <sub>(도메인 · 프로토콜 · 포트)</sub> 종속
- 상이 오리진 접근 X

#### `openRequest` <sub>(`open` 메서드 반환 객체)</sub> 이벤트

##### `success`
- DB 준비 완료
- `openRequest.result`
  - DB 객체 <sub>(작업 대상)</sub>

##### `error`
- DB 연결 실패

##### `upgradeneeded`
- DB 준비 완료
- 구식 버전

##### 내장 스키마 버전 관리 기능
- 서버측 DB 부재 기능

##### 클라이언트측 DB
- 브라우저 내 위치
  - 개발자 항상 접근 X
- 새 앱 출시 후 사용자 방문 시
  - DB 갱신 필요

#### `upgradeneeded` <sub>(이벤트)</sub>

##### 발생 조건
- 로컬 DB 버전 \< `open` <sub>(메서드)</sub> 명시 버전
  - 버전 비교 후 DB 갱신
- DB 부재 <sub>(버전 == `0`)</sub>
  - 초기화 실행

##### 앱 1번째 출시
- DB 버전
  - `1`
1. `upgradeneeded` <sub>(핸들러)</sub>
    - 초기화 수행
2. 성공 · 실패 핸들러 실행
    - `onsuccess`
    - `onerror`
```javascript
let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {

  // 클라이언트 내 DB 부재 시 실행
  // … 초기화 수행 …
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;

  // … DB 작업 수행 …
};
```

##### 앱 2번째 출시
- DB 버전
  - `2`
1. `upgradeneeded` <sub>(핸들러)</sub>
    - 업데이트 수행
2. 성공 · 실패 핸들러 실행
    - `onsuccess`
    - `onerror`
```javascript
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function(event) {

  // 기존 DB 부재 · 버전 < 2
  let db = openRequest.result;

  // 기존 DB 버전
  switch(event.oldVersion) {

    // DB 부재
    case 0:
      // … 초기화 수행 …

    // 구식 DB
    case 1:
      // … 업데이트 수행 …
  }
};
```

##### DB 삭제
```javascript
// onsuccess · onerror <sub>(핸들러)</sub>
// - DB 삭제 결과 추적
let deleteRequest = indexedDB.deleteDatabase(name);
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **구식 DB 연결 X**

##### 기존 DB 버전 \> `open` <sub>(메서드)</sub> 내 명시 버전
- 에러
  - `onerror` <sub>(핸들러)</sub> 실행

##### 드물게 발생
- ex\) 사용자측 구식 JS 코드 로드 <sub>(프락시 캐시 등)</sub>
  - 구식 코드 · 최신 DB
- 버전 체크 후 페이지 재로드 안내
- 적절한 HTTP 캐싱 해더 사용
  - 구삭 코드 로드 방지

<br />

#### 병렬 업데이트 문제

##### 문제 상황 가정
1. 사용자 사이트 방문 <sub>(브라우저 탭)</sub>
    - DB 버전
      - `1`
2. 새 버전 앱 출시
    - 코드 최신화
3. 동 사용자 사이트 방문 <sub>(브라우저 타 탭)</sub>
    - DB 버전
      - `2`

##### 두 탭 DB 공유 <sub>(동일 사이트 · 오리진)</sub>
- 버전 2개 존재 X
  - 구식 버전 DB 연결 종료 필요

##### `versionchange` <sub>(이벤트)</sub>
- 구식 DB 객체 대상 발생
- 핸들러 설정
  - 구식 DB 연결 종료
  - 페이지 재로드 안내 <sub>(최신 코드 로드)</sub>
- 핸들러 미설정 시 <sub>(구식 DB 연결 유지)</sub>
  - 최신 DB 연결 X
  - `blocked` <sub>(이벤트)</sub> 발생
```javascript
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = …;
openRequest.onerror = …;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  // 핸들러 설정
  db.onversionchange = function() {

    // 구식 DB 연결 종료
    db.close();
    alert("Database is outdated, please reload the page.")
  };

  // … DB 작업 수행 …
};

openRequest.onblocked = function() {

  // onversionchange (핸들러) 적절히 처리 시 실행 X
  // 동일 DB 대상 기존 연결 존재 시 실행
  // - onversionchange (핸들러) 실행 후 해당 연결 종료 X
};
```

##### 과정
1. 연결 성공
    - `onversionchange` <sub>(핸들러)</sub> 설정
    - 후 설정 설정listener after a successful opening, to be informed about a parallel update attempt.
2. Add `openRequest.onblocked` listener to handle the case when an old connection wasn't closed. This doesn't happen if we close it in `db.onversionchange`.

There are other variants. For example, we can take the time to close things gracefully in `db.onversionchange`, and prompt the visitor to save the data before the connection is closed. The new updating connection will be blocked immediately after `db.onversionchange` has finished without closing, and we can ask the visitor in the new tab to close other tabs for the update.

These update collisions happen rarely, but we should at least have some handling for them, e.g. `onblocked` handler, so that our script doesn't surprise the user by dying silently.

### Object store
To store something in IndexedDB, we need an object store.

An object store is a core concept of IndexedDB. Counterparts in other databases are called "tables" or "collections". It's where the data is stored. A database may have multiple stores: one for users, another one for goods, etc.

Despite being named an "object store", primitives can be stored too.

**We can store almost any value, including complex objects.**

IndexedDB uses the [standard serialization algorithm](https://html.spec.whatwg.org/multipage/infrastructure.html#section-structuredserializeforstorage) to clone-and-store an object. It's like `JSON.stringify`, but more powerful, capable of storing much more datatypes.

An example of an object that can't be stored: an object with circular references. Such objects are not serializable. JSON.stringify also fails for such objects.

**There must be a unique `key` for every value in the store.**

A key must be one of the these types – number, date, string, binary, or array. It's a unique identifier, so we can search/remove/update values by the key.

![indexeddb-structure](../../images/03/04/03/indexeddb-structure.svg)

As we'll see very soon, we can provide a key when we add a value to the store, similar to `localStorage`. But when we store objects, IndexedDB allows setting up an object property as the key, which is much more convenient. Or we can auto-generate keys.

But we need to create an object store first.

The syntax to create an object store:
```jakearchibald
db.createObjectStore(name[, keyOptions]);
```

Please note, the operation is synchronous, no `await` needed.
- `name` is the store name, e.g. `"books"` for books,
- `keyOptions` is an optional object with one of two properties:
  - `keyPath` – a path to an object property that IndexedDB will use as the key, e.g. `id`.
  - `autoIncrement` – if `true`, then the key for a newly stored object is generated automatically, as an ever-incrementing number.

If we don't supply `keyOptions`, then we'll need to provide a key explicitly later, when storing an object.

For instance, this object store uses `id` property as the key:
```jakearchibald
db.createObjectStore('books', {keyPath: 'id'});
```

**An object store can only be created/modified while updating the DB version, in `upgradeneeded` handler.**

That's a technical limitation. Outside of the handler we'll be able to add/remove/update the data, but object stores can only be created/removed/altered during a version update.

To perform a database version upgrade, there are two main approaches:
1. We can implement per-version upgrade functions: from 1 to 2, from 2 to 3, from 3 to 4 etc. Then, in `upgradeneeded` we can compare versions (e.g. old 2, now 4) and run per-version upgrades step by step, for every intermediate version (2 to 3, then 3 to 4).
2. Or we can just examine the database: get a list of existing object stores as `db.objectStoreNames`. That object is a [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist) that provides `contains(name)` method to check for existance. And then we can do updates depending on what exists and what doesn't.

For small databases the second variant may be simpler.

Here's the demo of the second approach:
```javascript
let openRequest = indexedDB.open("db", 2);

// create/upgrade the database without version checks
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // if there's no "books" store
    db.createObjectStore('books', {keyPath: 'id'}); // create it
  }
};
```

To delete an object store:
```javascript
db.deleteObjectStore('books')
```
