### 에러 처리

##### 쓰기 요청 실패 가능성 有
- 트랜잭션 관련 에러
- 트랜잭션 외 에러
  - 저장 용량 초과
  - 네트워크 에러
  - 기타 등등

##### 요청 실패 발생 시
- 트랜잭션 자동 취소
  - 모든 변경사항 취소

##### 요청 실패 처리
- ex\) 요청 재전송 등 <sub>(트랜잭션 취소 X)</sub>
- `request.onerror` <sub>(핸들러)</sub> 내
  - `event.preventDefault()` 호출
    - 트랜잭션 취소 방지

##### `""ConstraintError"` <sub>(에러)</sub> 처리
- `store.add(…)`
  - 키 중복 시 에러 발생
```javascript
let transaction = db.transaction("books", "readwrite");

let book = { id: 'js', price: 10 };

let request = transaction.objectStore("books").add(book);

request.onerror = function(event) {

  // 키 중복 시 "ConstraintError" (에러) 발생
  if (request.error.name == "ConstraintError") {

    // 에러 처리
    console.log("Book with such id already exists");

    // 트랜잭션 취소 X
    event.preventDefault();

    /* … 타 키 사용해 저장 … */

  } else {

    // 처리 불가 에러
    // - 트랜잭션 취소
  }
};

transaction.onabort = function() {
  console.log("Error", transaction.error);
};
```

### 이벤트 위임

##### 요청별 성공 · 실패 이벤트 처리
- 이벤트 위임 사용

##### `indexedDB` 이벤트
- DOM 이벤트
  - 버블링 · 캡쳐링 발생
  - 보통 버블링만 사용
- 버블링 순서
  - 요청 → 트랜잭션 → DB

##### DB `onerror` <sub>(핸들러)</sub>
- 모든 에러 이벤트 처리
```javascript
db.onerror = function(event) {

  // 에러 발생 요청
  let request = event.target;

  console.log("Error", request.error);
};
```

##### 버블링 중단
- 요청 에러 핸들러 <sub>(`request.onerror`)</sub>
  - `event.stopPropagation()` 호출
    - 자체 에러 처리
```javascript
request.onerror = function(event) {
  if (request.error.name == "ConstraintError") {

    // 에러 처리
    console.log("Book with such id already exists");

    // 트랜잭션 취소 X
    event.preventDefault();

    // 에러 이벤트 버블링 X
    event.stopPropagation();
  } else {

    /*
     처리 불가 에러
     - 트랜잭션 취소
     트랜잭션 onabort (핸들러)
     - 내 해당 에러 처리
     */
  }
};

…

transaction.onabort = function() {
  console.log("Error", transaction.error);
};
```

### 검색

##### 객체 저장소 주 검색 방법 <sub>(2가지)</sub>
1. 키 · 키 범위 사용
    - ex\) `book.id` <sub>(`"books"` 저장소)</sub>
2. 객체 필드
    - ex\) `book.price`

### 키로 검색하기

##### 검색 관련 메서드 검색 방식 <sub>(2가지)</sub>
1. 단일 키
2. 키 범위
    - [`IDBKeyRange`](https://www.w3.org/TR/IndexedDB/#keyrange) <sub>(객체)</sub>

#### 키 범위 생성 메서드 <sub>(`IDBKeyRange`)</sub>

##### `lowerBound(lower, [open])`
- `lower` 이상
- `open` <sub>(`boolean`)</sub>
  - 경계값 <sub>(`lower`)</sub> 제외 여부

##### `upperBound(upper, [open])`
- `upper` 이하
- `open` <sub>(`boolean`)</sub>
  - 경계값 <sub>(`upper`)</sub> 제외 여부

##### `bound(lower, upper, [lowerOpen], [upperOpen])`
- `lower` ~ `upper`
- `[lower·upper]Open` <sub>(`boolean`)</sub>
  - 경계값 <sub>(`[lower·upper]Open`)</sub> 제외 여부

##### `only(key)`
- 단일값 <sub>(`key`)</sub> 범위
- 드물게 사용

#### 검색 메서드 <sub>(객체 저장소)</sub>
- 인수 <sub>(`query`)</sub>
  - 단일 키
  - 키 범위

##### `get(query)`
- 질의 만족 처음 값 검색

##### `getAll([query], [count])`
- 질의 만족 전체 값 검색
- `count`
  - 개수 제한

##### `getKey(query)`
- 질의 만족 처음 키 검색
  - 주로 키 범위

##### `getAllKeys([query], [count])`
- 질의 만족 전체 키 검색
  - 주로 키 범위
- `count`
  - 개수 제한

##### `count([query])`
- 질의 만족 전체 키 개수 반환
  - 주로 키 범위

##### `books` <sub>(객체 저장소)</sub>
- 키
  - `id` <sub>(필드)</sub>
```javascript
// 책 1개 얻기
// - id == 'js'
books.get('js');

// 다수 책 얻기
// - 'css' ≤ id ≤ 'html'
books.getAll(IDBKeyRange.bound('css', 'html'));

// 다수 책 얻기
// - id < 'html'
books.getAll(IDBKeyRange.upperBound('html', true));

// 전체 책 얻기
books.getAll();

// 전체 키 얻기
// - id > 'js'
books.getAllKeys(IDBKeyRange.lowerBound('js', true));
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **Object store is always sorted**

Object store sorts values by key internally.

So requests that return many values always return them in sorted by key order.

<br />

### Searching by any field with an index
To search by other object fields, we need to create an additional data structure named "index".

An index is an "add-on" to the store that tracks a given object field. For each value of that field, it stores a list of keys for objects that have that value. There will be a more detailed picture below.

The syntax:
```javascript
objectStore.createIndex(name, keyPath, [options]);
```

- `name` – index name,
- `keyPath` – path to the object field that the index should track (we're going to search by that field),
- `option` – an optional object with properties:
  - `unique` – if true, then there may be only one object in the store with the given value at the `keyPath`. The index will enforce that by generating an error if we try to add a duplicate.
  - `multiEntry` – only used if the value on `keyPath` is an array. In that case, by default, the index will treat the whole array as the key. But if `multiEntry` is true, then the index will keep a list of store objects for each value in that array. So array members become index keys.

In our example, we store books keyed by `id`.

Let's say we want to search by `price`.

First, we need to create an index. It must be done in `upgradeneeded`, just like an object store:
```javascript
openRequest.onupgradeneeded = function() {
  // we must create the index here, in versionchange transaction
  let books = db.createObjectStore('books', {keyPath: 'id'});
  let index = books.createIndex('price_idx', 'price');
};
```

- The index will track `price` field.
- The price is not unique, there may be multiple books with the same price, so we don't set `unique` option.
- The price is not an array, so `multiEntry` flag is not applicable.

Imagine that our `inventory` has 4 books. Here's the picture that shows exactly what the `index` is:

![indexeddb-index](../../images/03/04/03/indexeddb-index.svg)

As said, the index for each value of `price` (second argument) keeps the list of keys that have that price.

The index keeps itself up to date automatically, we don't have to care about it.

Now, when we want to search for a given price, we simply apply the same search methods to the index:
```javascript
let transaction = db.transaction("books"); // readonly
let books = transaction.objectStore("books");
let priceIndex = books.index("price_idx");

let request = priceIndex.getAll(10);

request.onsuccess = function() {
  if (request.result !== undefined) {
    console.log("Books", request.result); // array of books with price=10
  } else {
    console.log("No such books");
  }
};
```

We can also use `IDBKeyRange` to create ranges and looks for cheap/expensive books:
```javascript
// find books where price <= 5
let request = priceIndex.getAll(IDBKeyRange.upperBound(5));
```

Indexes are internally sorted by the tracked object field, `price` in our case. So when we do the search, the results are also sorted by `price`.

### Deleting from store
The `delete` method looks up values to delete by a query, the call format is similar to `getAll`:
- `delete(query)` – delete matching values by query.

For instance:
```javascript
// delete the book with id='js'
books.delete('js');
```

If we'd like to delete books based on a price or another object field, then we should first find the key in the index, and then call `delete`:
```javascript
// find the key where price = 5
let request = priceIndex.getKey(5);

request.onsuccess = function() {
  let id = request.result;
  let deleteRequest = books.delete(id);
};
```

To delete everything:
```javascript
books.clear(); // clear the storage.
```
