`Blob` <sub>(객체)</sub>
======

##### ECMA 표준
- `ArrayBuffer` <sub>(객체)</sub>
- `TypedArray` <sub>(뷰 객체)</sub>

##### `Blob` <sub>([File API](https://www.w3.org/TR/FileAPI/))</sub>
- 브라우저 전용 고차원 객체
- `type` <sub>(문자열 · 추가 옵션)</sub>
  - 대개 MIME-type
- `blobParts` <sub>(배열)</sub>
  - 타 `Blob` <sub>(객체)</sub>
  - 문자열
  - `BufferSource`

![blob](../../images/03/02/03/blob.svg)

##### 생성자 문법
```javascript
new Blob(blobParts, options);
```

##### `blobParts` <sub>(배열)</sub>
- 타 `Blob` <sub>(객체)</sub>
- 문자열
- `BufferSource`

##### `options` <sub>(객체)</sub>
- `type` <sub>(문자열)</sub>
  - `Blob` <sub>(객체)</sub> 타입
  - 대개 MIME-type <sub>(`'image/png'` 등)</sub>
- `endings` <sub>(문자열)</sub>
  - end-of-line 변형 여부 <sub>(OS 상이)</sub>
    - `\r\n`
    - `\n`
  - `'transparent'` <sub>(기본값)</sub>
    - 미변형
  - `'native'`
    - 변형
```javascript
// Blob (객체) 생성
// - 문자열
let blob = new Blob(["<html>…</html>"], { type: 'text/html' });
```
```javascript
// Blob (객체) 생성
// - TypedArray(뷰 객체) · 문자열
let hello = new Uint8Array([72, 101, 108, 108, 111]);
let blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});
```

##### `Blob` <sub>(객체)</sub> 추출
```javascript
// array.slice 유사
// 음수 가능
blob.slice([byteStart], [byteEnd], [contentType]);
```
- `byteStart`
  - 시작 바이트
  - `0` <sub>(기본값)</sub>
- `byteEnd`
  - 끝 바이트 <sub>(미포함)</sub>
  - 마지막 요소 <sub>(기본값)</sub>
- `contentType`
  - 추출 `Blob` <sub>(객체)</sub> 타입
  - 기존 타입 <sub>(기본값)</sub>

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`Blob` <sub>(객체)</sub> 수정 불가**

##### 내용 수정 X
- 부분 추출
- 새 객체 생성 후 결합

##### JS 문자열 동작 유사
- 문자 변경 X
- 새 문자열 생성

<br />

### URL 용도 `Blob`

##### 태그 내 url
- `<a>`
- `<img>`
- 기타 등등

##### `type` <sub>(옵션)</sub>
- `Blob` <sub>(객체)</sub> 다운로드 · 업로드 가능
- 네트워크 요청 시
  - `Content-Type` <sub>(헤더)</sub>

##### `Blob` <sub>(객체)</sub> 다운로드
- 링크 클릭 시 `Blob` <sub>(동적 생성 객체)</sub> 다운로드
  - `hello world` <sub>(파일 콘텐츠)</sub>
```html
<!-- 
download (속성)
- 탐색 대신 다운로드 실행
-->
<a download="hello.txt" href='#' id="link">Download</a>

<script>
let blob = new Blob(["Hello, world!"], { type: 'text/plain' });
link.href = URL.createObjectURL(blob);
</script>
```

##### `Blob` <sub>(객체)</sub> 다운로드
- 링크 동적 생성
- 코드 내 링크 클릭 실행
- `Blob` <sub>(동적 생성 객체)</sub> 다운로드
  - `hello world` <sub>(파일 콘텐츠)</sub>
```javascript
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});
link.href = URL.createObjectURL(blob);
link.click();

URL.revokeObjectURL(link.href);
```

#### `URL.createObjectURL`

##### 고유 URL 생성 <sub>(`Blob` 인수 대상)</sub>
- `blob:<origin>/<uuid>` <sub>(형태)</sub>
```
blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273
```
- 브라우저 내 매핑 <sub>(url → `Blob`)</sub> 저장
  - `Blob` 접근
- 현재 문서 내에서만 유효
  - 문서 열려있는동안
- url 사용 요소 <sub>(`<img>` ·  `<a>` 등)</sub>
  - `Blob` 참조 가능

##### 부작용
- 브라우저 내 매핑 <sub>(url → `Blob`)</sub> 저장 시
  - 해당 `Blob` 메모리 내 상주
    - 브라우저 자체 삭제 X

##### 내부 매핑 자동 제거
- 문서 떠날 때 <sub>(`unload` 이벤트)</sub> 발생
  - 해당 `Blob` <sub>(객체)</sub>
    - 도달 불가능 상태
- 장시간 구동 앱
  - 매핑 유지 문제 발생

#### `URL.revokeObjectURL(url)`

##### 내부 매핑 참조 제거
- 해당 `Blob` <sub>(객체)</sub>
  - 도달 불가능 상태 <sub>(이외 참조 부재 시)</sub>

### `Blob` <sub>(객체)</sub> → base64 인코딩 문자열
- 이진 데이터 → 문자열

##### `Blob` <sub>(객체)</sub> → base64 인코딩 문자열
- `URL.createObjectURL` 대안
- 이진 데이터 → ASCII 코드 <sub>(0 ~ 64)</sub>
  - 매우 안전하게 읽기 가능한 문자
  - 'data-url' 내 사용 가능

##### ['data-url'](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)
- `data:[<mediatype>][;base64],<data>` <sub>(형태)</sub>
- 어느 곳에나 사용 가능
  - 일반 url 동일

##### 웃는 얼굴 기호
- 문자열 디코딩 · 이미지 표시 <sub>(브라우저)</sub>
```html
<img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">
```

##### 변환 <sub>(`Blob` → base64)</sub> 작업
- `FileReader` <sub>(내장 객체)</sub> 사용
  - 다양한 포맷으로 `Blob` <sub>(객체)</sub> 읽기

##### `Blob` <sub>(객체)</sub> 다운로드
- base64 인코딩 사용
```javascript
let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], { type: 'text/plain' });

let reader = new FileReader();

// Blob(객체) → base64 인코딩 문자열
reader.readAsDataURL(blob);

reader.onload = function() {

  // data url
  link.href = reader.result;
  link.click();
};
```

Both ways of making an URL of a `Blob` are usable. But usually `URL.createObjectURL(blob)` is simpler and faster.

##### `URL.createObjectURL(blob)`
- We need to revoke them if care about memory.
- Direct access to blob, no "encoding/decoding"

##### `Blob` to data url
- No need to revoke anything.
- Performance and memory losses on big `Blob` objects for encoding.

### Image to `blob`
We can create a `Blob` of an image, an image part, or even make a page screenshot. That's handy to upload it somewhere.

Image operations are done via <`canvas>` element:

1. Draw an image (or its part) on canvas using [canvas.drawImage](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage).
2. Call canvas method [`.toBlob(callback, format, quality)`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob) that creates a `Blob` and runs `callback` with it when done.

In the example below, an image is just copied, but we could cut from it, or transform it on canvas prior to making a blob:
```javascript
// take any image
let img = document.querySelector('img');

// make <canvas> of the same size
let canvas = document.createElement('canvas');
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

let context = canvas.getContext('2d');

// copy image to it (this method allows to cut image)
context.drawImage(img, 0, 0);
// we can context.rotate(), and do many other things on canvas

// toBlob is async opereation, callback is called when done
canvas.toBlob(function(blob) {
  // blob ready, download it
  let link = document.createElement('a');
  link.download = 'example.png';

  link.href = URL.createObjectURL(blob);
  link.click();

  // delete the internal blob reference, to let the browser clear memory from it
  URL.revokeObjectURL(link.href);
}, 'image/png');
```

If we prefer `async`/`await` instead of callbacks:
```javascript
let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
```

For screenshotting a page, we can use a library such as https://github.com/niklasvh/html2canvas. What it does is just walks the page and draws it on `<canvas>`. Then we can get a `Blob` of it the same way as above.

### From `Blob` to `ArrayBuffer`
The `Blob` constructor allows to create a blob from almost anything, including any `BufferSource`.

But if we need to perform low-level processing, we can get the lowest-level `ArrayBuffer` from it using `FileReader`:
```javascript
// get arrayBuffer from blob
let fileReader = new FileReader();

fileReader.readAsArrayBuffer(blob);

fileReader.onload = function(event) {
  let arrayBuffer = fileReader.result;
};
```

<br />

## 요약
While `ArrayBuffer`, `Uint8Array` and other `BufferSource` are "binary data", a [`Blob`](https://www.w3.org/TR/FileAPI/#dfn-Blob) represents "binary data with type".

That makes Blobs convenient for upload/download operations, that are so common in the browser.

Methods that perform web-requests, such as `XMLHttpRequest`, `fetch` and so on, can work with `Blob` natively, as well as with other binary types.

We can easily convert betweeen Blob and low-level binary data types:
- We can make a Blob from a typed array using `new Blob(...)` constructor.
- We can get back `ArrayBuffer` from a Blob using `FileReader`, and then create a view over it for low-level binary processing.
