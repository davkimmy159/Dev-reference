클래스 상속
==========

### `extends` <sub>(키워드)</sub>
```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} 은/는 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} 이/가 멈췄습니다.`);
  }
}

let animal = new Animal("동물");
```

![rabbit-animal-independent-animal](../../images/09/02/rabbit-animal-independent-animal.svg)

```javascript
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} 이/가 숨었습니다!`);
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼 은/는 속도 5로 달립니다.
rabbit.hide(); // 흰 토끼 이/가 숨었습니다!
```

![animal-rabbit-extends](../../images/09/02/animal-rabbit-extends.svg)

##### `extends` <sub>(키워드)</sub>
- 프로토타입 기반 동작
- `Rabbit.prototype.[[Prototype]]`
  - → `Animal.prototype` 참조 설정
- `Rabbit.prototype` 내 메서드 부재 시
  - `Animal.prototype` 에서 가져옴

##### 엔진 : `rabbit.run` <sub>(메서드)</sub> 존재 확인 순서
1. `rabbit` <sub>(객체)</sub>
2. `Rabbit.prototype`
    - `rabbit` <sub>(객체)</sub> 의 프로토타입
3. `Rabbit.prototype.[[Prototype]]`
    - `rabbit` <sub>(객체)</sub> 의 프로토타입의 프로토타입
    - `Animal.prototype`
      - `extends` 통해 관계 생성

- 클래스 표현 → 함수 표현
```javascript
class Parent {
  constructor(pp) {
    this.pp = pp;
  }
  pm() {
    console.log('pm');
  }
}
class Child extends Parent {
  constructor(pp, cp) {
    super(pp);
    this.cp = cp;
  }
  cm() {
    console.log('cm');
  }
}
let child = new Child('pp', 'cp');

↓↓↓

function Parent(pp) {
  this.pp = pp;
}
Parent.prototype.pm = function() {
  console.log('pm');
}
function Child(pp, cp) {
  Parent.apply(this, arguments);
  this.cp = cp;
}
Child.prototype.cm = function() {
  console.log('cm');
}

// 정적 메서드 · 프로퍼티 상속
Object.setPrototypeOf(Child, Parent);

// 프로토타입 체인 설정
Object.setPrototypeOf(Child.prototype, Parent.prototype);

let child = new Child('pp', 'cp');
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **extends 뒤 : 표현식 가능**

```javascript
function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}

// `f("Hello")` (함수) 반환 값 상속
// - 익명 클래스 상속
class User extends f("Hello") {}

new User().sayHi(); // Hello
```

##### 조건 따라 다른 클래스 상속
- 조건 따라 다른 클래스 반환 함수 생성 후
  - 함수 호출 결과 상속

### 메서드 오버라이딩

##### 자식 클래스 : 부모 클래스 메서드 자체 정의 시
- 상속받은 메서드 사용 X
  - 자체 메서드 사용
- 자체 메서드 실행 시 컨텍스트
  - 자식 클래스 객체
```javascript
class Animal {
  stop() {
    alert("animal 이 멈췄습니다.");
  }
}

class Rabbit extends Animal {

  /*
   rabbit.stop() 호출 시
   - Animal stop() 사용 X
   - 클래스 자체 메서드 사용
   */
  stop() {
    alert("rabbit 이 멈췄습니다.");
  }
}

let rabbit = new Rabbit("토끼");
rabbit.stop(); // rabbit 이 멈췄습니다.
```

##### `super` <sub>(키워드)</sub>
- 자체 정의 메서드 내 부모 클래스 메서드 호출
- `super.method( … )`
  - `method` <sub>(부모 클래스 메서드)</sub> 호출
- `super( … )`
  - 부모 생성자 호출
  - 자식 생성자 내부에서만 사용 가능
```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name}가 멈췄습니다.`);
  }
}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }
  stop() {
    super.stop(); // 부모 클래스 stop (메서드) 호출
    this.hide();
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼가 속도 5로 달립니다.
rabbit.stop(); // 흰 토끼가 멈췄습니다. 흰 토끼가 숨었습니다!
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **화살표 함수 : `super` X <sub>(미지원)</sub>**

- `super` 접근 시
  - 외부 함수에서 `super` 가져옴
```javascript
class Rabbit extends Animal {
  stop() {

    /*
     화살표 함수 내 super 사용 시
     - stop (외부 함수 ·메서드) super 사용
       - 부모 stop (메서드) 호출
     1초 후 부모 stop (메서드) 호출
     */
    setTimeout(() => super.stop(), 1000);
  }
}
```
- `setTimeout` 내 일반 함수 사용 시
  - 에러 발생
```javascript
// Unexpected super
setTimeout(function() { super.stop() }, 1000);
```

### 생성자 오버라이딩

##### 명세서 정의
- 다른 클래스 상속 · `constructor` 부재 시
  - 비어있는 `constructor` 생성

##### 생성자
- 부모 `constructor` 
  - 기본적으로 호출
  - 인수 모두 전달

##### 부모 · 자식 클래스 생성자 모두 부재 시
- 모두 자동 생성
```javascript
class Rabbit extends Animal {

  // 자체 생성자 부재 클래스 상속 시
  // - 자동 생성
  /*
  constructor(...args) {
    super(...args);
  }
   */
}
```
- 커스텀 생성자
```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // …
}

class Rabbit extends Animal {

  // 부모 생성자 호출 X
  // - super( … ) X
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // …
}

// 정상 동작 X
// ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
let rabbit = new Rabbit("흰 토끼", 10); 
```

##### 자식 클래스 생성자
- `this` 사용 전
  - `super( … )` 호출 필수
    - 부모 생성자 실행

##### 생성자 호출 시 생성자 함수 구분
- 일반 클래스 생성자 함수
- 상속 클래스 생성자 함수
  - `[[ConstructorKind]]: "derived"`
    - 특수 내부 프로퍼티

#### 일반 · 상속 클래스 생성자 함수 차이

##### 일반 클래스 생성자 함수 실행 <sub>(`new`)</sub> 시
1. 빈 객체 생성
2. `this` 에 객체 할당

##### 상속 클래스 생성자 함수 실행 <sub>(`new`)</sub> 시
1. 빈 객체 생성
2. 부모 클래스 생성자가 `this` 에 객체 할당
- 상속 클래스 생성자 내 `super()` 미호출 시
  - `this` 에 객체 할당 X
```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // …
}

class Rabbit extends Animal {

  constructor(name, earLength) {

    // 부모 생성자 실행
    // - this 에 객체 할당
    super(name);

    this.earLength = earLength;
  }

  // …
}

let rabbit = new Rabbit("흰 토끼", 10);
alert(rabbit.name);      // 흰 토끼
alert(rabbit.earLength); // 10
```

### 클래스 필드 오버라이딩

##### 부모 생성자 내 오버라이딩 필드
- 부모 클래스 필드 값
- 자식 클래스 오버라이딩 값 X

##### 부모 생성자 내 오버라이딩 메서드
- 부모 클래스 메서드 X
- 자식 클래스 오버라이딩 메서드
```javascript
/* 필드 오버라이딩 */
class Animal {
  name = 'animal';

  constructor() {
    alert(this.name);
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal
```

```javascript
/* 메서드 오버라이딩 */
class Animal {
  showName() {
    alert('animal');
  }

  constructor() {
    this.showName();
  }
}

class Rabbit extends Animal {
  showName() {
    alert('rabbit');
  }
}

new Animal(); // animal
new Rabbit(); // rabbit
```

##### 클래스 초기화 순서
1. 부모 클래스 필드
2. 부모 생성자
3. 자식 클래스 필드
4. 자식 생성자

##### 필드 오버라이딩 문제 발생 시
- 필드 대신 다른 방법 사용
  - 메서드
  - getter
  - setter

### `super` · `[[HomeObject]]`
```javascript
let animal = {
  name: "동물",
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "토끼",
  eat() {
 // super.eat()                    // 컨텍스트 : rabbit (현재 객체)
 // this.__proto__.eat()           // 컨텍스트 : animal (프로토타입 · 부모)
    this.__proto__.eat.call(this); // 컨텍스트 : rabbit (현재 객체)
  }
};

rabbit.eat(); // 토끼 이/가 먹이를 먹습니다.
```

##### `rabbit.eat()`
- `this.__proto__` 통해
  - `animal.eat()` 호출
- `.` <sub>(점)</sub> 앞 객체
  - `animal` <sub>(== `rabbit.__proto__`)</sub>
- 체인에 객체 하나 더 추가
```javascript
let animal = {
  name: "동물",
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  eat() {
    /*
     call 사용
     - 컨텍스트 옮겨가며 animal (부모) 메서드 호출
     this == longEar (현재 객체)
     this.__proto__ == rabbit
     */
    this.__proto__.eat.call(this); // 무한 루프 발생
  }
};

let longEar = {
  __proto__: rabbit,
  eat() {
    /*
     longEar 가지고 무언가 하면서 rabbit (부모) 메서드 호출
     this == longEar (현재 객체)
     this.__proto__ == rabbit
     */
    this.__proto__.eat.call(this);
  }
};

longEar.eat(); // RangeError: Maximum call stack size exceeded
```

##### `longEar.eat()`
- `this` == `longEar` <sub>(객체)</sub>
- `this.__proto__.eat.call(this)`
  - `this` → `longEar` 고정
  - `this.__proto__` == `rabbit`

##### `rabbit.eat()`
- `this` == `longEar` <sub>(객체)</sub>
  - `longEar.eat()` 에 의해
- `this.__proto__.eat.call(this)`
  - `this` → `longEar` 고정
  - `this.__proto__` == `rabbit`
- 체인 위로 진행 X
  - 무한 루프

![this-super-loop](../../images/09/02/this-super-loop.svg)

1. `longEar.eat()`
    - `this` == `longEar`
```javascript
      this.__proto__
== longEar.__proto__
==  rabbit
```
```javascript
// longEar.eat()
// - this == longEar
   this.__proto__.eat.call(this); //    this.__proto__
longEar.__proto__.eat.call(this); // longEar.__proto__
           rabbit.eat.call(this); //  rabbit
```
2. `rabbit.eat()`
    - `this` == `longEar`
    - 다시 `rabbit.eat` 호출
```javascript
      this.__proto__
== longEar.__proto__
==  rabbit
```
```javascript
// rabbit.eat()
// - this == longEar
   this.__proto__.eat.call(this); //    this.__proto__
longEar.__proto__.eat.call(this); // longEar.__proto__
           rabbit.eat.call(this); //  rabbit

// longEar.eat() 과 동일
```
3. `rabbit.eat()`
    - `this` == `longEar`
    - 다시 `rabbit.eat` 호출
    - 2번 코드 동일
    - 체인 위로 진행 X
    - 자기 자신 계속 호출 → 무한 루프

### `[[HomeObject]]`
- 특수 내부 프로퍼티 <sub>(함수 전용)</sub>
- 클래스 · 객체 메서드
  - `[[HomeObject]]` <sub>(프로퍼티)</sub> 보유
    - 해당 객체 저장
- `super`
  - `[[HomeObject]]` 이용
    - 부모 프로토타입 · 메서드 찾음
```javascript
let animal = {
  name: "동물",

  // animal.eat.[[HomeObject]] == animal
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "토끼",

  // rabbit.eat.[[HomeObject]] == rabbit
  eat() {
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "귀가 긴 토끼",

  // longEar.eat.[[HomeObject]] == longEar
  eat() {
    super.eat();
  }
};

// 정상 동작
longEar.eat();  // 귀가 긴 토끼 이/가 먹이를 먹습니다.
```
- 객체 메서드
  - `[[HomeObject]]` 알고 있음
  - `this` 없이 프로토타입에서 부모 메서드 가져옴

#### 메서드 자유로움 X

##### JS 함수
- 대개 객체에 묶이지 않음
  - 자유로움
- 객체 간 메서드 복사 가능
  - `this` 상이 상관 X

##### `[[HomeObject]]`
- 존재만으로 함수 자유도 파괴
  - 메서드가 객체 기억
  - `[[HomeObject]]` 변경 불가능
  - 한 번 바인딩 된 함수
    - 더 이상 변경 X
- `super` 내부에서만 유효
  - 메서드 내 `super` 미사용 시
    - 메서드 자유성 보장
    - 객체 간 복사 가능
- 객체 간 메서드 잘못 복사 시
  - `super` 정상 동작 X
```javascript
let animal = {
  sayHi() {
    console.log(`나는 동물입니다.`);
  }
};

// rabbit
// - animal 상속
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    console.log("나는 식물입니다.");
  }
};

// tree
// - plant 상속
let tree = {
  __proto__: plant,

  /*
   rabbit.sayHi (메서드) 복사
   - 중복 코드 방지
   복사해온 rabbit.sayHi (메서드)
   - rabbit (객체) 에서 생성
     - [[HomeObject]] == rabbit
       - 변경 불가능
   tree.sayHi() 안
   - super.sayHi()
     - rabbit 프로토타입 == animal
     - super
       - 체인 위 animal 에서 sayHi 찾음
  */
  sayHi: rabbit.sayHi
};

tree.sayHi();  // 나는 동물입니다.
```

![super-homeobject-wrong](../../images/09/02/super-homeobject-wrong.svg)

#### 함수 프로퍼티 아닌 메서드 사용하기

##### 객체 메서드 `[[HomeObject]]`
- 메서드 문법<sub>(`method()`</sub>
  - 정상 동작
- 함수 프로퍼티 문법 <sub>(`method: function()`)</sub>
  - 정상 동작 X
- 메서드 내
  - `super` 사용 시
    - 메서드 문법 필수
  - `super` 미사용 시
    - 문법 상관 X
```javascript
let animal = {
//eat() { … }
  eat: function() { … } // 함수 프로퍼티 문법
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }

  // super 사용 메서드에서만 메서드 문법
  // - 정상 동작
  /*
   eat() {
     super.eat();
   }
   */

};

rabbit.eat(); // SyntaxError: 'super' keyword unexpected here
              // [[HomeObject]] 부재로 에러 발생
```
