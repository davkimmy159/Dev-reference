화살표 함수 다시 살펴보기
=======================

- 단순히 짧게 쓰기 위한 용도 X

##### 동떨어진 곳에서 실행될 작은 함수 작성 상황 자주 발생
- `arr.forEach(func)` 호출 시
  - `arr` <sub>(배열)</sub> 요소 대상 `func` 실행
  - `setTimeout(func)` 호출 시
    - 내장 스케줄러에 의해 `func` 실행
  - 기타 등등
- JS 함수
  - 생성 후 어딘가 전달
    - 아주 자연스러움
- 어딘가에 함수 전달 시
  - 함수 컨텍스트 잃을 수 있음
- 화살표 함수 사용 시
  - 현재 컨텍스트 잃지 않음

### 화살표 함수 : `this` X
- `this` 접근 시
  - 외부에서 가져옴
```javascript
let group = {
  title: "1모둠",
  students: ["보라", "호진", "지민"],

  /*
    this.title (화살표 함수 본문)
   - showList (화살표 함수 바깥 메서드) 가리키는 대상과 동일
   - this.title == group.title
   */
  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};

group.showList();
```
- 일반 함수 사용 시
  - 함수 `this` == `undefined`
  - `alert` 함수
    - `undefined.title`
- 화살표 함수
  - `this` 없음
  - 에러 발생 X
```javascript
let group = {
  title: "1모둠",
  students: ["보라", "호진", "지민"],

  showList() {
    this.students.forEach(function(student) {
      // TypeError: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
  }
};

group.showList();
```

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **화살표 함수 :  `new` 함께 실행 X**

- `this` 미존재
  - 생성자 함수 사용 X
  - `new` 함께 호출 X

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **화살표 함수 vs bind**

- `.bind(this)`
  - 함수 '한정된 버전' 생성
- 화살표 함수
  - 어떤 것도 바인딩 X
  - 단지 `this` 미존재
  - `this` 사용 시
    - `this` 값 외부 렉시컬 환경 검색
    - 일반 변수 서칭 유사

### 화살표 함수 : `arguments` X
- `arguments` <sub>(유사 배열 객체 · 모든 인수 접근)</sub> 미지원
  - 일반 함수와 차이점
- 포워딩 데코레이터 생성 시 유용
  - 현재 `this` 값 · `arguments` 정보 함께 실어 호출
```javascript
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  };
}

function sayHi(who) {
  alert('안녕, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("철수"); // 2초 후 "안녕, 철수" 출력
```
- 화살표 함수 미사용 시
  - 변수 `ctx` · `args` 필요
    - `setTimeout` 전달 콜백 함수 사용
```javascript
function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() { return f.apply(ctx, args); }, ms);
  };
}
```
