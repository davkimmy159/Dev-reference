Reflect
=======

##### 내장 객체
- 프락시 생성 단순화

##### 내부 메서드
- ex&#41;
  - `[[Get]]`
  - `[[Set]]`
  - 기타 등등
- 명세서에만 정의
  - 직접 호출 X

##### `Reflect`
- 내부 메서드
  - 직접 호출 다소 가능
- 메서드
  - 내부 메서드 감싸는 단순 래퍼

|동작|`Reflect` 메서드|내부 메서드|
|---|---|---|
|`obj[prop]`|`Reflect.get(obj, prop)`|`[[Get]]`|
|`obj[prop] = value`|`Reflect.set(obj, prop, value)`|`[[Set]]`|
|`delete obj[prop]`|`Reflect.deleteProperty(obj, prop)`|`[[Delete]]`|
|`new F(value)`|`Reflect.construct(F, value)`|`[[Construct]]`|
|…|…|…|

```javascript
let user = {};

Reflect.set(user, 'name', 'John');

alert(user.name); // John
```

##### 연산자 : 함수처럼 호출 가능
- `new`
  - `Reflect.construct`
- `delete`
  - `Reflect.deleteProperty`
- 기타 등등

##### 프락시로 가로채는 모든 내부 메서드
- 상응 `Reflect` 메서드 존재
  - 이름 · 인수 동일
  - 동작 : 타겟 <sub>(객체)</sub> 전달

```javascript
let user = {
  name: "John",
};

user = new Proxy(user, {
  get(target, prop, receiver) {
    alert(`GET ${prop}`);

    // 프로퍼티 읽기
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, val, receiver) {
    alert(`SET ${prop}=${val}`);

    // 프로퍼티에 쓰기
    // - 성공 : true 반환
    // - 실패 : false 반환
    return Reflect.set(target, prop, val, receiver);
  }
});

let name = user.name; // shows "GET name"
user.name = "Pete";   // shows "SET name=Pete"
```

##### 트랩 : 단순 전달 역할 시
- `Reflect` 메서드 사용 <sub>(단순한 사용법)</sub>
  - 메서드명 동일
  - 인수 동일

##### 트랩 vs `Reflect`
- 대게 동일
  - 미묘한 차이 존재
```javascript
// 동일
return Reflect.get(target, prop, receiver);
return target[prop];
```

### getter 가로채기
- `user` <sub>(객체)</sub>
  - `_name` <sub>(프로퍼티)</sub>
  - `_name` getter
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {
    return target[prop];
  }
});

alert(userProxy.name); // Guest
```

##### `get` 트랩
- 동작 : 투명 <sub>('transparent')</sub>
  - 기존 프로퍼티 그대로 반환
  - 추가 동작 X

##### 객체 상속
- `admin` <sub>(객체)</sub> → `userProxy` <sub>(프락시)</sub>
  - 비정상 동작 발생
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {

    // 타겟 == user (객체)
    return target[prop];
  }
});

let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

alert(admin.name); // Guest
```
- `admin.name` <sub>(프로퍼티)</sub> 읽기
  - `"Guest"` 반환

##### `"Guest"` 반환 이유
1. `admin` <sub>(자식 객체)</sub>
    - `name` <sub>(프로퍼티)</sub> 부재
2. 프로토타입에서 프로퍼티 찾기
    - `userProxy` <sub>(프락시)</sub>
3. 프로토타입 프로퍼티 읽기
    1. `get` 트랩 트리거
    2. `target[prop]` 반환
        - `user` <sub>(부모 객체)</sub> 프로퍼티

##### `receiver` <sub>(3번째 인수)</sub>
- 원래 `this` 값 보유

##### `this` 값 : getter 전달 시
- `call` · `apply` X
  - 함수 X
  - 프로퍼티 접근
- `Reflect.get` <sub>(메서드)</sub> 사용
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {

  // receiver = admin (자식 객체)
  get(target, prop, receiver) {
    return Reflect.get(target, prop, receiver);
//  return Reflect.get(...arguments);
}
  }
});


let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

alert(admin.name); // Admin
```

##### `Reflect` 메서드
- 트랩 이름 · 인수 동일
  - 의도된 설계
- 단순 동작 제공
  - 포워딩 등

### 프락시 한계

#### 내장 객체 : 내부 공간

##### '내부 공간'
- 대부분의 내장 객체 사용
  - `Map`
  - `Set`
  - `Date`
  - `Promise`
  - 기타 등등
- 프로퍼티 유사
  - 내부 사용 · 명세서 전용
- ex&#41; `Map` 요소 저장 위치
  - `[[MapData]]` <sub>(내부 공간)</sub>
- 내장 메서드
  - 내부 공간 직접 접근
- 내부 메서드 <sub>(`[[Get]]` · `[[Set]]` 등)</sub>
  - 내부 공간 직접 접근 X
  - 프락시로 가로채기 X
##### 내장 객체 : 프락시로 감싸기
- 프락시 <sub>(객체)</sub>
  - 내부 공간 X
  - 내장 메서드 사용 X
```javascript
let map = new Map();
let proxy = new Proxy(map, {});

// 프락시 (객체)
// - `[[MapData]]` (내부 공간) X
//   - 요소 저장 X
proxy.set('test', 1); // 에러 발생
```
##### `[[MapData]]` <sub>(내부 공간)</sub>
- `Map` 요소 저장 위치
- 프락시 (객체)
  - 보유 X

##### `Map.prototype.set` <sub>(내장 메서드)</sub>
- 내부 프로퍼티 접근 시도
  - `this.[[MapData]]`
- `this` == 프락시 (객체)
  - 메서드 작동 X

##### 해결책
```javascript
let map = new Map();

let proxy = new Proxy(map, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});

proxy.set('test', 1);
alert(proxy.get('test')); // 1, 내장 메서드 정상 작동
```

##### `get` <sub>(트랩)</sub>
- 함수 프로퍼티 바인딩
  - → 타겟 <sub>(객체)</sub>

##### 프락시 <sub>(객체)</sub> : 내장 메서드 호출 시 `this` 값
- ex&#41; `proxy.set( … )`
  - 프락시 <sub>(객체)</sub> X
  - 타겟 <sub>(객체)</sub>
- 내장 메서드
  - `this.[[MapData]]` 접근 성공

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **배열 : 내부 공간 X**

##### 특이 예외 <sub>(역사적 이유)</sub>
- 내장 배열
  - 내부 공간 X

### `private` 필드
