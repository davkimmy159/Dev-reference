iterable 객체
=============

- 반복 가능한 객체
  - 배열의 일반화 객체
- 이터러블 개념 사용 시
  - 어떤 객체든 `for…of` <sub>(반복문)</sub> 적용 가능
- 대표적인 이터러블
  - 배열
  - 문자열
  - 다수 내장 객체
- 컬렉션 <sub>(목록 · 집합 등)</sub> 객체 <sub>(배열 X)</sub>
  - `for…of` 문법 사용 시
    - 컬렉션 순회 유용

### `[Symbol.iterator]` <sub>(메서드)</sub>
- 객체 : `[Symbol.iterator]` <sub>(메서드)</sub> 구현
  - `Symbol.iterator` : 특수 내장 심볼

##### 순서
1. 반복 시작 시 `for…of`
    - `[Symbol.iterator]` <sub>(메서드)</sub> 호출
      - 메서드 부재 시
        - 에러 발생
      - 반드시 이터레이터 반환<br /><sub>(`next` <sub>(메서드)</sub> 보유 객체)</sub>
2. 반환된 이터레이터 <sub>(객체)</sub> 대상
    - `for…of` 동작
3. 다음 값 필요 시 `for…of`
    - 이터레이터 내 `next()` <sub>(메서드)</sub> 호출
4. `next()` <sub>(메서드)</sub> 반환 값
    - `{done: Boolean, value: any}`
    - `done: true`
      - 반복 종료
    - `done: false` 
      - `value` 에 다음 값 저장

##### 직접 이터러블 객체 생성해보기
- `for…of` 적용 적합한 객체 생성 <sub>(배열 X)</sub>
- `range` <sub>(객체)</sub>
  - 숫자 간격 표현
```javascript
// for…of 동작 목표
// - for(let num of range) … num=1,2,3,4,5
let range = {
  from: 1,
  to: 5
};

// 1. for…of : 최초 [Symbol.iterator] (메서드) 호출
range[Symbol.iterator] = function() {

  // [Symbol.iterator] (메서드)
  // - 이터레이터 (객체) 반환
  // 2. for…of : 반환된 이터레이터 (객체) 만 대상 동작
  // - 이때 다음 값 정해짐
  return {
    current: this.from,
    last: this.to,

    // 3. for…of 반복마다 next() 호출
    next() {

      // 4. next() 반환 값
      // - 객체 { done: …, value: … }
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 결과
for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- 이터러블 객체 핵심
  - '관심사의 분리' <sub>(Separation of concern, SoC)</sub>
- `range`
  - `next()` <sub>(메서드)</sub> 보유 X
  - `range[Symbol.iterator]()` 호출
    - 이터레이터 객체 반환
      - `next()` <sub>(메서드)</sub> 보유
      - 반복에 사용될 값 생성
  - 이터레이터 객체 · 반복 대상 객체 분리
- 자체 이터레이터
  - 이터레이터 객체 + 반복 대상 객체
  - 더 간단한 코드
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- `range[Symbol.iterator]()`
  - `range` <sub>(객체)</sub> 자체 반환
    - `next()` <sub>(메서드)</sub> 보유
- `this.current`
  - 반복 진행 정도 값 저장
- 코드 더 짧아짐
  - 이런 방식 작성 종종 좋음
- 2개 `for…of` : 하나의 객체 동시 사용 X
  - 이터레이터 <sub>(객체 자신)</sub> 하나뿐
    - 두 반복문 반복 상태 공유
  - 동시 2개 `for…of` 사용
    - 비동기 처리에서도 흔한 케이스 X

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **무한개의 이터레이터**

- 무수히 많은 이터레이터 가능
- `range.to` : `Infinity` 할당 시
  - `range` 무한대
  - 무수히 많은 의사 난수 생성 이터러블 객체
    - 이 방법 종종 유용
- `next` 제약사항 X
  - 값 계속 반환 시 정상 동작
  - 무한개 이터러블 `for…of` 사용 시
    - `break` : 언제든지 반복 중단 가능

### 문자열 == 이터러블 객체
- 배열 · 문자열
  - 가장 많이 쓰이는 내장 이터러블
```javascript
// for…of 문자열 각 글자 순회
for (let char of "test") {
  // 글자 하나당 한 번 실행 (4회 호출)
  alert( char ); // t, e, s, t 차례대로 출력
}

// 서로게이트 쌍 잘 동작
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, 😂 차례대로 출력
}
```

### 이터레이터 명시적 호출
- 이터레이터 명시적 호출하는 경우 거의 無
- `for…of` 보다 반복 과정 더 잘 통제
- 반복 과정 여러 개로 쪼개기 가능
  - 반복 시작 → 잠시 멈춰 다른 작업 → 다시 반복 시작 등
```javascript
/* 직접 호출 순회 */
// 문자열 이터레이터 생성 후 값 '수동으로' 가져옴
let str = "Hello";

// for…of 사용 동일 작업
// for (let char of str) alert(char);
let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자 하나씩 출력
}
```

### 이터러블 vs 유사 배열
- 이터러블 <sub>(iterable)</sub>
  -  `Symbol.iterator` <sub>(메서드)</sub> 구현 객체
- 유사 배열
  - 인덱스 · `length` <sub>(프로퍼티)</sub>
  - 배열처럼 보이는 객체
- 호스트 <sub>(브라우저 등)</sub> 환경 JS 사용 시
  - 각 2가지 · 혼합 객체 종종 사용
  - 혼합 객체 <sub>(이터러블 + 유사 배열)</sub>
    - `for…of` 사용 가능
    - 숫자 인덱스 · `length` <sub>(프로퍼티)</sub>
    - ex&#41; 문자열
- 이터러블 객체 ≠ 유사 배열 객체
```javascript
/* 유사 배열 객체 (이터러블 객체 X) */
// 인덱스 · length 프로퍼티
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

// Symbol.iterator 미존재
// - 에러 발생
for (let item of arrayLike) {}
```
- 이터러블 · 유사 배열 ≠ 배열
  - 배열 메서드 지원 X
    - 불편함 초래

### `Array.from`
- 이터러블 · 유사 배열 → 배열
  - 배열 메서드 사용 가능
  - 유사 배열
    - 이터러블 속성 이용 가능
```javascript
/* 유사 배열 → 배열 */
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

/*
 객체 받아 이터러블 · 유사 배열 여부 조사
 인수 이터러블 · 유사 배열 경우
 - 새 배열 생성 후 객체 모든 요소 새롭게 만든 배열로 복사
 */
let arr = Array.from(arrayLike); // 배열 메서드 정상 동작
alert(arr.pop());
```
```javascript
/* 이터러블 (range 예시 객체) → 배열 */
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5, 배열 문자열 형 변환 정상 동작
```
```javascript
Array.from(obj[, mapFn, thisArg])
```
- 2번째 인수 <sub>(`mapFn` )</sub>
  - 선택적
  - 새 배열 `obj`에 요소 추가 전
    - 각 요소 대상 `mapFn` 적용
- 3번째 인수 <sub>(`thisArg`)</sub>
  - 각 요소 `this` 지정
```javascript
/* range 예시 객체 */
// 각 숫자 제곱
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```
```javascript
/* 문자열 → 배열 */
let str = '𝒳😂';

// str 분해 → 글자 담긴 배열
let chars1 = Array.from(str);

alert(chars1[0]);     // 𝒳
alert(chars1[1]);     // 😂
alert(chars1.length); // 2

// 문자열 자체 이터러블 속성 이용해 동작
// - str.split 과 차이
// - for…of 같이 서로게이트 쌍 정상 적용
let chars2 = [];

// Array.from 내부
// - 동일 반복문 동작
for (let char of str) {
  chars2.push(char);
}

alert(chars2[0]);     // 𝒳
alert(chars2[1]);     // 😂
alert(chars2.length); // 2
```
- 서로게이트 쌍 처리 `slice` 직접 구현
```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 내장 순수 메서드
// - 서로게이트 쌍 미지원
alert( str.slice(1, 3) ); // 쓰레깃값 출력 (영역 다른 특수 값)
```
