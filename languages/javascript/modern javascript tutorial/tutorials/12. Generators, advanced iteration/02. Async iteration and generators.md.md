async 이터레이터와 제너레이터
===========================

### `async` 이터레이터
- 일반 이터레이터 유사
- 약간의 문법적인 차이

##### 일반 이터러블 == 객체
```javascript
/* 일반 이터러블 (객체) */
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,

      next() {
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for(let value of range) {
  alert(value); // 1, 2, 3, 4, 5
}
```

##### 이터러블 (일반 → 비동기)
1. `[Symbol.iterator]`
    - → `[Symbol.asyncIterator]`
2. `next()` <sub>(메서드)</sub>
    - 프라미스 반환
3. `for (let i of it)`
    - → `for await (let i of it)`
```javascript
let range = {
  from: 1,
  to: 5,

  // for await…of 최초 실행 시
  // - [Symbol.asyncIterator] (메서드) 호출
  [Symbol.asyncIterator]() {

    /*
     [Symbol.asyncIterator] (메서드)
     - 이터레이터 (객체) 반환
     for await…of (비동기 반복문)
     - 반환된 이터레이터 객체만 대상 동작
     - 다음 값
       - next() (메서드) 에서 정해짐
     */
    return {
      current: this.from,
      last: this.to,

      // for await…of (비동기 반복문)
      // - 각 이터레이션마다 next() (메서드) 호출
      async next() {

        /*
         next() (메서드)
         - { done: …, value: … } (객체) 반환
           - 자동 프라미스로 감싸짐 (async)
         */

        // await 사용 가능
        // - 비동기 작업
        await new Promise(resolve => setTimeout(resolve, 1000));

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {
  for await (let value of range) {
    alert(value); // 1,2,3,4,5
  }
})()
```
##### `async` 이터레이터
- 일반 이터레이터 구조 유사

##### 차이
1. `[Symbol.asyncIterator]` <sub>(메서드)</sub> 구현
2. `[Symbol.asyncIterator]` <sub>(메서드)</sub>
    - `next()` <sub>(메서드)</sub> 구현 객체 반환
      - 프라미스 반환 메서드
3. `next()` <sub>(메서드)</sub>
    - `async` 메서드
      - 강제 X
      - `await` 사용 가능
    - 일반 메서드
      - 프라미스 반환
4. `for await (let value of range)`
    1. `[Symbol.asyncIterator]` 1회 호출
    2. 각 값 대상 `next()` <sub>(메서드)</sub> 호출


||이터레이터|`async` 이터레이터|
|---|---|---|
|이터레이터 제공 메서드|`[Symbol.iterator]`|`[Symbol.asyncIterator]`|
|`next()` <sub>(메서드)</sub> 반환 값|모든 값|`Promise`|
|사용 반복문|`for…of`|`for await…of`|

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`...` <sub>(전개 구문)</sub> : 비동기적 동작 X**

- 일반적인 동기 이터레이터 필요 기능
  - 비동기 이터레이터 함께 사용 X

##### `...` <sub>(전개 구문)</sub>
- 일반 이터레이터 필요
- == `await` 없는 `for…of` <sub>(반복문)</sub>
  - `[Symbol.asyncIterator]` X
  - `[Symbol.iterator]` 찾음
```javascript
// [Symbol.iterator] (메서드) 부재
// - 에러 발생
alert( [...range] );
```

### `async` 제너레이터
- 제너레이터 == 이터러블 <sub>(객체)</sub>
```javascript
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1, 2, 3, 4, 5
}
```

##### 일반 제너레이터
- `await` X
- 동기적 문법
  - 모든 값 : 동기적으로 생산

##### 비동기 제너레이터
- 문법
  - `async` : 제너레이터 함수 앞
```javascript
async function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {

    // await 사용 가능
    await new Promise(resolve => setTimeout(resolve, 1000));
    yield i;
  }
}

(async () => {

  let generator = generateSequence(1, 5);
  for await (let value of generator) {
    alert(value); // 1, 2, 3, 4, 5
  }

})();
```
##### `async` <sub>(비동기)</sub> 제너레이터
- `for await…of` 반복 가능
- 프라미스 사용 가능
- `await` 사용 가능
- 간단히 생성
  - `async` <sub>(키워드)</sub>
- `next()` <sub>(메서드)</sub>
  - 비동기적
  - 프라미스 반환
  - `await` 필요
```javascript
// 동기 제너레이터 값 반환
result = generator.next();

// 비동기 제너레이터 값 반환
result = await generator.next();
```

### `async` 이터러블 <sub>(객체)</sub>
- 이터러블 <sub>(객체)</sub>
  - `[Symbol.iterator]` <sub>(메서드)</sub> 구현
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    return {
      /* next() (메서드) 구현 객체 */
    }
  }
}
```

##### `[Symbol.iterator]` <sub>(메서드)</sub> 구현 방식 2가지
- `next` <sub>(메서드)</sub> 구현 일반 객체 반환
- 제너레이터 반환
  - 구현 경우 多
```javascript
let range = {
  from: 1,
  to: 5,

// [Symbol.iterator]: function*() {
  *[Symbol.iterator]() {
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1, 2, 3, 4, 5
}
```
- `range` <sub>(커스텀 객체)</sub>
  - 반복 가능
- `*[Symbol.iterator]` <sub>(제너레이터)</sub>
  - 값 나열 로직 구현

##### 제너레이터 : 비동기 동작 추가
- `[Symbol.iterator]`
- → `async [Symbol.asyncIterator]`
```javascript
let range = {
  from: 1,
  to: 5,

//       [Symbol.asyncIterator]: async function*() {
  async *[Symbol.asyncIterator]() {
    for(let value = this.from; value <= this.to; value++) {

      // 값 사이 사이
      // - 약간의 공백 추가
      await new Promise(resolve => setTimeout(resolve, 1000));
      yield value;
    }
  }
};

(async () => {

  for await (let value of range) {
    alert(value); // 1, 2, 3, 4, 5
  }

})();
```
