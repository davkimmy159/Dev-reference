제너레이터
=========

##### 일반 함수
- 0 ~ 1개 값 반환

##### 제너레이터 <sub>(generator)</sub>
- 여러 개의 값
  - 필요에 따라 하나씩 반환 <sub>(yield)</sub>
- 이터러블 <sub>(객체)</sub> 함께 사용 시
  - 데이터 스트림 쉽게 생성

### 제너레이터 함수
- 문법
  - `function*`
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```
##### 제너레이터 함수 호출
- 코드 실행 X
- '제너레이터 객체' 반환
  - 실행 처리 객체
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// 제너레이터 함수
// - 제너레이터 객체 생성
let generator = generateSequence();
alert(generator); // [object Generator]
```
- 함수 본문 코드
  - 아직 실행 X

![generateSequence-1](../../images/12/01/generateSequence-1.svg)

#### `next()` <sub>(메서드)</sub>
- 제너레이터 주요 메서드

##### 가장 가까운 `yield <value>` <sub>(문)</sub>
- 만날 때까지 실행 지속
- `value` 생략 시
  - `undefined`

##### `yield <value>` <sub>(문)</sub> 도달 시
- 실행 중단
- `value` <sub>(산출 목표 값)</sub>
  - 바깥 코드 반환

##### 반환 객체 프로퍼티 <sub>(2개)</sub>
- `value`
  - 산출 값
- `done`
  - `true` &nbsp;&nbsp;: 함수 코드 종료
  - `false` : 함수 코드 실행 중

##### 제너레이터 생성 후
- 첫 번째 산출 값 반환
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

// {value: 1, done: false}
alert(JSON.stringify(one));
```
- 첫 번째 값만 반환
  - 실행 : 2번째 줄 중단

![generateSequence-2](../../images/12/01/generateSequence-2.svg)

- `generator.next()` 다시 호출
  - 실행 재개
    - 다음 `yield` 반환
  - 실행 : 3번째 줄 중단
```javascript
let two = generator.next();

// {value: 2, done: false}
alert(JSON.stringify(two));
```

![generateSequence-3](../../images/12/01/generateSequence-3.svg)

- `generator.next()` 다시 호출
  - 실행 : `return` <sub>(문)</sub> 도달
    - 함수 종료
```javascript
let three = generator.next();

// {value: 3, done: true}
alert(JSON.stringify(three));
```

![generateSequence-4](../../images/12/01/generateSequence-4.svg)

##### 제너레이터 종료
- `generator.next()` 여러 번 호출
  - 소용 X
  - `{ done: true }` <sub>(객체)</sub> 계속 반환

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`function* f( … )` · `function *f( … )`**

- 둘 다 유효

##### 대개 1번째 문법 선호
- `*` : 제너레이터 "함수" 표현
  - 함수 종류 표현
  - 함수 이름 표현 X

### 제너레이터 · 이터러블 <sub>(객체)</sub>
- 제너레이터 == 이터러블 <sub>(객체)</sub>
  - `for…of` <sub>(반복문)</sub> 사용 가능
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, 2
                // 3 : 미출력
}
```

##### `3` 미출력 이유
- `for…of` <sub>(이터레이션)</sub>
  - `{ done: true }`
    - 마지막 `value` 무시
- 마지막 값
  - `yield` 사용
  - `return` X
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, 2, 3
}
```
- `...` <sub>(전개 구문)</sub> 사용 가능
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let sequence = [0, ...generateSequence()];

alert(sequence); // 0, 1, 2, 3
```

### 이터러블 <sub>(객체)</sub> 대신 제너레이터 사용하기
- `range` 예시 <sub>(이터러블 챕터)</sub>
```javascript
let range = {
  from: 1,
  to: 5,

  // for…of 최초 호출 시
  // - [Symbol.iterator] (메서드) 호출
  [Symbol.iterator]() {

    /*
     [Symbol.iterator] (메서드)
     - 이터레이터 (객체) 반환
     for…of (반복문)
     - 반환된 이터레이터 (객체) 만 대상 동작
       - 이때 다음 값 정해짐
     */
    return {
      current: this.from,
      last: this.to,

      // for…of (반복문)
      // - 각 이터레이션마다 next() (메서드) 호출
      next() {

        // next() (메서드)
        // - { done: …, value : … } 반환
        //   - 객체 형태
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

alert([...range]); // 1,2,3,4,5
```
- 제너레이터 함수 버전
```javascript
let range = {
  from: 1,
  to: 5,

// [Symbol.iterator]: function*()
  *[Symbol.iterator]() {
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

alert( [...range] ); // 1, 2, 3, 4, 5
```

##### `range[Symbol.iterator]()`
- 제너레이터 반환
- 제너레이터 메서드
  - `for…of` 동작 조건 충족

##### `for…of` 동작 조건
- `.next()` <sub>(메서드)</sub> 有
- 반환 값 형태
  - `{ value: … , done: boolean }`

##### 제너레이터
- JS 추가 시
  - 이터레이터 구현 용이성 염두
- 이터러블 <sub>(객체)</sub> 대비
  - 간결성 ↑
  - 동일 기능 제공

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **제너레이터 : 무한한 값 생성 가능**

- ex&#41; 끊임없는 의사 난수 생성 등

##### `for…of` 안
- `break` · `return` 필요
  - 무한 반복문 중단

### 제너레이터 컴포지션
- 제너레이터 안 제너레이터 임베딩 <sub>(삽입)</sub> 기능

##### 제너레이터 함수
- 연속된 숫자 생성
```javascript
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}
```
- 좀 더 복잡한 값 연속 생성
  - 위 함수 기반

##### 값 생성 규칙
1. 0 ~ 9 <sub>(숫자)</sub>
    - 48 ~ 57 &nbsp;<sub>(문자 코드)</sub>
2. A ~ Z <sub>(알파벳 대문자)</sub>
    - 65 ~ 90 &nbsp;<sub>(문자 코드)</sub>
3. a ~ z <sub>(알파벳 소문자)</sub>
    - 97 ~ 122 <sub>(문자 코드)</sub>
- 응용
  - 특수 문자 추가
  - 비밀번호 생성
  - 기타 등등

##### 일반 함수 사용 시
1. 함수 여러 개 생성
2. 호출 결과
    - 어딘가에 저장
3. 다시 그 결과들 조합

##### `yield*` <sub>(제너레이터 특수 문법)</sub>
- 한 제너레이터
  - 다른 제너레이터에 '끼워 넣기'
```javascript
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {

  // 0 ~ 9
  yield* generateSequence(48, 57);

  // A ~ Z
  yield* generateSequence(65, 90);

  // a ~ z
  yield* generateSequence(97, 122);

}

let str = '';

for(let code of generatePasswordCodes()) {
  str += String.fromCharCode(code);
}

alert(str); // 0 ~ 9
            // A ~ Z
            // a ~ z
```

##### `yield*` <sub>(지시자)</sub>
- 다른 제너레이터에 실행 위임

##### ex&#41; `yield* gen`
1. `gen` <sub>(제너레이터)</sub> 대상 반복 수행
2. 산출 값들
    - 바깥으로 전달
- 외부 제너레이터 의한 값 산출처럼 보임

##### 중첩 제너레이터 코드 직접 삽입
- 동일 결과
```javascript
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;

  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;

  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0 ~ 9
            // A ~ Z
            // a ~ z
```
##### 제너레이터 컴포지션 사용 시
- 한 제너레이터 흐름
  - 자연스럽게 다른 제너레이터에 삽입
- 추가 메모리 필요 X
  - 중간 결과 저장 용도
