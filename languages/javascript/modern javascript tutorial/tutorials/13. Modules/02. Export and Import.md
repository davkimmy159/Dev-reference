모듈 내보내고 가져오기
====================

### 선언부 앞 `export`
- 변수 · 함수 · 클래스 내보내기
```javascript
// 배열 내보내기
export let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 상수 내보내기
export const MODULES_BECAME_STANDARD_YEAR = 2015;

// 클래스 내보내기
export class User {
  constructor(name) {
    this.name = name;
  }
}
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **클래스 · 함수 내보내기 : `;` <sub>(세미콜론)</sub> X**

##### 선언부 앞 `export` <sub>(클래스 · 함수)</sub>
- 함수 선언 방식 변화 X
  - 함수 선언문 → 함수 표현식 X
  - 여전히 함수 선언문

##### 대부분의 JS 스타일 가이드
- 함수 · 클래스 선언 끝
  - `;` <sub>(세미콜론)</sub> X
  - `export` 동일
```javascript
// 끝에 ; (세미콜론) X
export function sayHi(user) {
  alert(`Hello, ${user}!`);
} // ;
```

### 선언부 외 `export`
- 함수 먼저 선언
  - 나중에 내보내기
- 함수 선언부 위 가능
```javascript
// 📁 say.js
function sayHi(user) {
  alert(`Hello, ${user}!`);
}

function sayBye(user) {
  alert(`Bye, ${user}!`);
}

export {sayHi, sayBye}; // 두 함수 내보내기
```

### `import *`
- `import { … 가져올 목록 … }`
  - 가져오기
```javascript
// 📁 main.js
import {sayHi, sayBye} from './say.js';

sayHi('John');  // Hello, John!
sayBye('John'); // Bye, John!
```
- `import * as <obj>`
  - 한 번에 전부 가져오기
  - 객체 형태
  - 코드량 ↓
```javascript
// 📁 main.js
import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
```

##### 가져오기 대상 : 구체적 명시 권장

##### 1. 모던 빌드 툴 <sub>(웹팩 등)</sub>
- 번들링 <sub>(모듈 한데 모으기)</sub> · 최적화 수행
  - 로딩 속도 ↑
  - 미사용 리소스 삭제
```javascript
// 📁 say.js
// - 많은 함수 구현
export function sayHi() { … }
export function sayBye() { … }
export function becomeSilent() { … }
```
```javascript
// 📁 main.js
// - 많은 함수 중 하나만 가져오기
import {sayHi} from './say.js';
```

##### 빌드 툴
- 실제 사용 함수 파악
- 미사용 함수
  - 최종 번들링 결과물 포함 X
- 가지치기 <sub>(최적화 과정)</sub>
  - 불필요 코드 제거
    - 빌드 결과물 크기 ↓

##### 2. 이름 : 간결하게 작성
- 어떤 걸 가지고 올지 명시
- `say.sayHi()` → `sayHi()`
  - 간결성 ↑

##### 3. 어디서 어떤 게 쓰이는지 명확
- 코드 구조 파악 쉬워짐
- 리팩토링 · 유지보수 도움

### `import as`
- 이름 바꿔 모듈 가져오기
  - `sayHi` → `hi`
  - `sayBye` → `bye`
```javascript
// 📁 main.js
import {sayHi as hi, sayBye as bye} from './say.js';

hi('John');  // Hello, John!
bye('John'); // Bye, John!
```
### `Export as`
- 이름 바꿔 모듈 내보내기
  - `sayHi` → `hi`
  - `sayBye` → `bye`
```javascript
// 📁 say.js
…
export {sayHi as hi, sayBye as bye};
```
```javascript
// 📁 main.js
import * as say from './say.js';

say.hi('John');  // Hello, John!
say.bye('John'); // Bye, John!
```

### `export default`

##### 모듈 구분 <sub>(2종류)</sub>
1. 라이브러리 형태
    - 복수 함수 구현
2. 개체 하나만 선언 <sub>(선호 방식)</sub>
    - 개체 <sub>(함수 · 클래스 · 변수 등)</sub>
      - 전용 모듈 내 구현

##### 자연스레 파일 개수 ↑
- 모듈 이름 잘 작성
- 폴더에 파일 잘 나눠 구성
  - 코드 탐색 문제 X

##### `export default` <sub>(문법)</sub>
- '해당 모듈 : 개체 하나만 존재'
  - 사실 명확히 표시
```javascript
// 📁 user.js
export default class User {
  constructor(name) {
    this.name = name;
  }
}
```
- 파일 하나
  - 대개 `export default` 하나
- `{}` <sub>(중괄호)</sub> 생략
  - 간결성 ↑
```javascript
// 📁 main.js
// - {User} → User
import User from './user.js';

new User('John');
```

|named export|default export|
|---|---|
|`export class User { … }`|`export default class User { … }`|
|`import {User} from …`|`import User from …`|

##### named export · default export 동시 사용
- 문제 X
- 실무 : 사례 흔치 않음
- 둘 중 하나만 사용

##### 파일당 최대 하나의 default export
- 내보낼 개체
  - 이름 생략 가능
- 어떤 개체 가지고 올지 알 수 있음
```javascript
// 클래스명 X
export default class {
  constructor() { ... }
}
```
```javascript
// 함수명 X
export default function(user) {
  alert(`Hello, ${user}!`);
}
```
```javascript
// 배열명 X
export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
```

default를 붙이지 않았다면 개체에 이름이 없는 경우 에러가 발생합니다.
```javascript
// 에러 발생
// - named export
//   - 이름 필요
export class {
  constructor() {}
}
```