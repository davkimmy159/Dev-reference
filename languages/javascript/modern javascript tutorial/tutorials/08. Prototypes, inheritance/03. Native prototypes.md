내장 객체의 프로토타입
====================

- 모든 내장 생성자 함수
  - `prototype` <sub>(프로퍼티)</sub> 사용

### `Object.prototype`
```javascript
let obj = {};
alert( obj ); // "[object Object]"
```

##### `toString` <sub>(메서드)</sub>
  - `"[object Object]"` <sub>(문자열)</sub> 생성

##### `obj = {}` == `obj = new Object()`
- `Object`
  - 내장 객체 생성자 함수
- `Object.prototype`
  - 다양한 메서드 구현된 거대한 객체 참조

![object-prototype](../../images/08/03/object-prototype.svg)

- 객체 생성 시
  - `new Object()` <sub>(생성자 함수)</sub> 호출
  - `{ … }` <sub>(리터럴 문법)</sub>
- 생성된 객체의 `[[Prototype]]`
  - → `Object.prototype` 참조

![object-prototype-1](../../images/08/03/object-prototype-1.svg)

- `obj.toString()` 호출 시
  - `Object.prototype`에서 해당 메서드 가져옴
```javascript
let obj = {};

alert(obj.__proto__ === Object.prototype);          // true
alert(obj.toString  === obj.__proto__.toString);    // true
alert(obj.toString  === Object.prototype.toString); // true
```
- `Object.prototype` 위쪽
  - `[[Prototype]]` 체인 X
```javascript
alert(Object.prototype.__proto__); // null
```
### 내장 객체 : 프로토타입에 메서드 저장

##### 배열 `[1, 2, 3]` 생성 시
- `new Array()` 디폴트 생성자 내부에서 동작
  - `[1, 2, 3]` <sub>(배열)</sub> 의 `[[Prototype]]`
    - → `Array.prototype`
  - `Array.prototype` 통해 배열 메서드 사용
    - 메모리 효율 ↑
```javascript
let arr = [1, 2, 3]
alert(arr); // 1,2,3
```
##### 명세서 규정
- 모든 내장 프로토타입 상속 트리 꼭대기
  - `Object.prototype`
  - "모든 것은 객체를 상속받는다"

![native-prototypes-classes](../../images/08/03/native-prototypes-classes.svg)

```javascript
let arr = [1, 2, 3];

// arr → Array.prototype  상속?
alert( arr.__proto__ === Array.prototype );            // true

// arr → Object.prototype 상속?
alert( arr.__proto__.__proto__ === Object.prototype ); // true

// 체인 맨 위 : null
alert( arr.__proto__.__proto__.__proto__ );            // null
```
- 프로토타입 체인 상 중복 메서드 존재 시
  - 체인 상 가까운 곳 메서드 사용
```javascript
let arr = [1, 2, 3]
alert(arr); // 1,2,3, Array.prototype.toString 결과
```

![native-prototypes-array-tostring](../../images/08/03/native-prototypes-array-tostring.svg)

![console_dir_array](../../images/08/03/console_dir_array.png)

- 타 내장 객체들 · 함수
  - 동일 방법으로 동작
- 함수 생성 시
  - `Function` <sub>(내장 객체 · 생성자)</sub> 사용
    - `Fuction.prototype`
      - 함수 사용 메서드 구현
```javascript
function f() {}

alert(f.__proto__ == Function.prototype);         // true
alert(f.__proto__.__proto__ == Object.prototype); // true, 객체에서 상속받음
```

### 원시값
- 문자열 · 숫자 · 불린값
  - 다루기 엄청 까다로움
  - 객체 X

##### 원시 타입 값 프로퍼티 접근 시
- 임시 래퍼 객체 <sub>(내장 생성자 사용)</sub> 생성
  - 내장 생성자
    - `String`
    - `Number`
    - `Boolean`
  - 메서드 제공 후 제거
- 임시 래퍼 객체
  - 보이지 않는 곳에서 생성
  - 엔진 의해 최적화
  - 각 자료형 해당 래퍼 객체 메서드
    - 프로토타입 내 구현 후 `prototype` 사용
      - 명세서 규정
      - `String.prototype`
      - `Number.prototype`
      - `Boolean.prototype`

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`null` · `undefined` 대응 래퍼 객체 : X**

- 메서드 X
- 프로퍼티 X
- 프로토타입 X

### 네이티브 프로토타입 변경
- 네이티브 프로토타입 수정 가능
  - `String.prototype` 에 메서드 하나 추가 시
    - 모든 문자열 해당 메서드 사용 가능
```javascript
String.prototype.show = function() {
  alert(this);
};

"BOOM!".show(); // BOOM!
```
- 네이티브 프로토타입
  - 새 내장 메서드 추가
    - → 좋지 않은 방법

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **중요:**

##### 프로토타입 전역 영향
- 프로토타입 조작 시
  - 기존 코드 충돌 발생 가능성 ↑
    - ex&#41; 두 라이브러리 동시에 `String.prototype.show` 메서드 추가 시 한 라이브러리 메서드가 다른 라이브러리 메서드 덮어씀
- 네이티브 프로토타입 수정 자제

#### 모던 프로그래밍 : 네이티브 프로토타입 변경 허용 경우 딱 하나
- 폴리필 제작

##### 폴리필
- 메서드 구현체
  - 명세서 정의 메서드 동일 기능
- 특정 JS 엔진
  - 해당 기능 미구현 시 폴리필 사용
- 네이티브 프로토타입 변경
  - 폴리필 직접 구현 후
    - 내장 프로토타입에 추가할 때만
```javascript
/* repeat 메서드 미구현 가정 */
if (!String.prototype.repeat) {

  // 프로토타입 repeat 추가
  String.prototype.repeat = function(n) {

    // string n회 반복
    return new Array(n + 1).join(this);
  };
}

alert( "라".repeat(3) ); // 라라라
```

### 프로토타입에서 메서드 빌려오기
```javascript
// 유사 배열 객체 생성 후 Array 메서드 복사
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

obj.join = Array.prototype.join;

alert( obj.join(',') ); // Hello,world!
```

##### `join` <sub>(내장 메서드)</sub> 내부 알고리즘
- 제대로 된 인덱스 있는지 확인
- `length` <sub>(프로퍼티)</sub> 있는지 확인
  - 확인 후 에러 없이 동작
- 호출 대상
  - 진짜 배열인지 상관 X
- 다수 내장 메서드
  - 이런 식으로 동작

##### `obj.__proto__`
- → `Array.prototype` 설정
  - 배열 메서드 상속
    - 모든 배열 메서드 사용 가능
- JS
  - 단일 상속 허용
  - `obj` 다른 객체 상속 시 X

##### 메서드 빌리기
- 여러 객체에서 필요한 기능 가져와 섞기 가능
  - 유연한 개발
