재귀와 스택
==========

- 큰 목표 작업 하나 → 동일 간단 작업 여러 개 나누기 패턴
- 함수 자기 자신 호출

### 두 가지 사고방식
- x<sup>n</sup> 제곱
```javascript
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```
```javascript
// 1. 반복적인 사고
// - for 루프
function pow(x, n) {
  let result = 1;

  // 반복문 돌면서 x → n번 곱함
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8

// 재귀적인 사고
// - 작업 단순화, 자기 자신 호출
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```
- `pow (x, n)` 호출 시 두 갈래 나뉘어 코드 실행
```javascript
              if n == 1  = x
             /
pow(x, n) =
             \
              else       = x * pow(x, n - 1)
```
1. `n == 1`
    - **재귀 베이스 (base)**
    - 모든 절차 간단해짐
    - 명확한 결괏값 즉시 도출
    - `pow(x, 1) == x`
2. `n != 1`
    - **재귀 단계 (recursive step)**
    - `pow(x, n)` → `x * pow(x, n - 1)`
      - x<sup>n</sup> = x * x<sup>(n-1)</sup>
    - 목표 작업 `pow(x, n)` 분할
      - 간단한 동작 : 　　　　x 곱하기
      - 목표 작업 변형 작업 : &nbsp;&nbsp;`pow(x, n - 1)`
      - `n == 1` 될 때까지 계속 진행

![recursion-pow](./images/5/recursion-pow.svg)

- `pow (2, 4)`
  1. `pow(2, 4)` = `2 * pow(2, 3)`
  2. `pow(2, 3)` = `2 * pow(2, 2)`
  3. `pow(2, 2)` = `2 * pow(2, 1)`
  4. `pow(2, 1)` = `2`

#### 재귀를 사용한 코드는 짧습니다.
- 재귀 사용 코드 반복적 사고 코드보다 대개 짧음
- `if` 문 → 조건부 연산자 `?`
  - 간결성 · 가독성 ↑
```javascript
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```
- 재귀 깊이 (recursion depth)
  - 가장 처음 호출 포함 중첩 호출 최대 개수
  - `pow(x, n)` 재귀 깊이 : `n`
- 자바스크립트 엔진 최대 재귀 깊이 제한
  - 만개 정도까진 확실히 허용
  - 엔진 따라 더 많은 깊이 허용 가능 경우 有
  - 대다수 엔진 십만까지는 허용 X
  - 제한 완화 위해 엔진 내부 자동으로 'tail calls optimization’ 최적화 수행
    - 모든 곳 적용 X
    - 간단한 경우 적용
- 재귀 실제 적용 제약 有
  - 재귀 깊이 제한
  - 그럼에도 광범위하게 사용
    - 간결성 ↑ · 유지보수 난도 ↓

### 실행 컨텍스트와 스택
- 실행 중인 함수 실행 절차
  - 해당 함수의 실행 컨텍스트 (execution context) 에 저장
  - 실행 컨텍스트
    - 함수 실행 세부 정보 보유 내부 데이터 구조
      - 제어 흐름 현재 위치
      - 변수 현재 값
      - `this` 값
      - 등 상세 내부 정보
    - 함수 호출 1회
      - 실행 컨텍스트 1개 생성
- 함수 내부 중첩 호출 절차
  1. 현재 함수 실행 일시 중지
  2. 중지된 함수 연관 실행 컨텍스트
    - 실행 컨텍스트 스택 (execution context stack) 에 저장
  3. 중첩 호출 실행
  4. 중첩 호출 실행 끝난 후 실행 컨텍스트 스택에서 일시 중단 함수 실행 컨텍스트 pop, 중단 함수 실행 재개

#### `pow(2, 3)`
- `pow (2, 3)` 호출 순간
  - 실행 컨텍스트
    - 변수 `x = 2, n = 3` 저장
  - 실행 흐름
    - 함수 첫 번째 줄 위치
```
Context: { x: 2, n: 3, 1번째 줄 } call: pow(2, 3)
```
- 조건 `n == 1` 만족 X
  - 실행 흐름 if문 두 번째 분기 진행
```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) );
```
- 변수 동일, 실행 흐름 위치 변경
  - 실행 컨텍스트 변경
```
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)
```
- `x * pow (x, n - 1)` 계산하려면
  - 새로운 인수 들어가는 `pow` 서브 호출 (subcall), `pow (2, 2)` 만들어야 함

#### `pow(2, 2)`
- 중첩 호출 위해 자바스크립트 실행 컨텍스트 스택에 현재 실행 컨텍스트 저장
- 프로세스
  1. 스택 최상단 현재 컨텍스트 '기록’
  2. 서브 호출 위한 새로운 컨텍스트 생성
  3. 서브 호출 완료 시 기존 컨텍스트 스택에서 꺼내(pop) 실행 재개
- 서브 호출 `pow (2, 2)` 시작될 때 실행 컨텍스트 스택
```
Context: { x: 2, n: 2, 1번째 줄 } call: pow(2, 2) - new context
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3) - old context
```
- 이전 컨텍스트에 변수 정보, 코드 일시 중단된 줄 정보 저장
  - 서브 호출 끝났을 때 이전 컨텍스트 문제없이 다시 시작

#### 주의
- 한 줄에 `pow(…)` + `pow(…)` + `somethingElse(…)` 같이 복수 서브 호출 존재 가능
- 좀 더 정확히 '서브 호출 바로 직후’ 실행 시작

#### pow(2, 1)
- 동일한 과정 다시 반복
- 5번째 줄 인수 `x = 2, n = 1` 함께 새로운 서브 호출 생성
- 새로운 실행 컨텍스트 생성 후 이전 실행 컨텍스트 스택 최상단 push
```
Context: { x: 2, n: 1, 1번째 줄 } call: pow(2, 1) - new
Context: { x: 2, n: 2, 5번째 줄 } call: pow(2, 2) - old
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3) - older
```

#### 실행 종료
- `pow (2, 1)` 실행 시 상황 달라짐
  - 이전과 달리 조건 `n == 1` 만족
    - `if` 문 1번째 분기 실행
```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```
- 이제 호출할 중첩 호출 X
  - 함수 종료, 2 반환
- 함수 종료, 상응 실행 컨텍스트 쓸모 X
  - 해당 실행 컨텍스트 메모리에서 삭제
  - 스택 맨 위 이전 실행 컨텍스 위치
```
Context: { x: 2, n: 2, 5번째 줄 } call: pow(2, 2)
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)
```
- `pow (2, 2)` 실행 다시 시작
- 서브 호출 `pow (2, 1)` 결과 알고 있음
  - `x * pow (x, n - 1)` 계산해 `4` 반환
- 다시 이전 컨텍스트 스택 최상단 위치
```
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)
```
- 마지막 실행 컨텍스트 처리 후 `pow (2, 3) = 8` 결과 도출
- 재귀 깊이 == 스택 들어가는 실행 컨텍스트 수 최댓값
- 재귀 사용 시 메모리 요구사항 유의
  - 실행 컨텍스트 메모리 차지
  - n 증가 → n 내려갈 때마다 생성되는 n개 실행 컨텍스트 저장 메모리 공간 필요
- 반복문 기반 알고리즘 메모리 절약
```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```
- 반복 사용해 만든 함수 컨텍스트 하나만 사용
- 이 컨텍스트에서 `i` · `result` 변경
- 실행 컨텍스트 1개
  - `n` 의존 X
  - 필요한 메모리 ↓
  - 사용 메모리 공간 고정
- 재귀 이용 작성 코드 → 반복문 사용 코드 재작성 가능
  - 반복문 사용 시 대개 함수 호출 비용 (메모리 사용) 절약
- 코드 재작성 후 큰 개선 없는 경우 有
  - 조건 따라 함수 다른 재귀 서브 호출 후 그 결과 합칠 때
  - 분기문 복잡하게 얽혀있을 때 메모리 크게 절약 X
    - 이런 경우 최적화 필요 X
    - 최적화 노력 무용지물 가능
- 재귀 사용 시
  - 코드 양 ↓
  - 코드 이해도 ↑
  - 유지보수 이점
  - 모든 곳 메모리 최적화 신경 써서 코드 작성 X
- 필요한 것 → 좋은 코드

### 재귀적 순회
- 재귀적 순회 (recursive traversal)
```javascript
// 한 회사 임직원
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```
- 모든 임직원 급여 더한 값
  - 반복문
    - `company`
      - 최상위 반복문
    - 1단계 하위 부서
      - 1번째 중첩 반복문
    - n단계 하위 부서
      - n번째 중첩 반복문
  - 재귀
    - 임직원 ‘단순’ 부서 (배열)
      - 간단한 반복문
    - n단계 하위 부서 (객체)
      - N번째 재귀 호출
- 재귀 베이스
  - ‘단순’ 부서 (배열)
- 재귀 단계
  - n단계 하위 부서 (객체)
  - 복잡한 작업
    - 작은 작업 (하위 부서 대상 반복문) 쪼개기
  - 부서 깊이 따라 더 작은 작업으로 쪼개기
    - 결국 마지막엔 첫 번째 경우 (재귀 베이스)
``` javascript
let company = {
  sales:       [{name: 'John', salary: 1000},  {name: 'Alice', salary: 1600 }],
  development: {
    sites:     [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// 급여 합계 함수
function sumSalaries(department) {

  // 재귀 베이스
  // ‘단순’ 부서 (배열)
  if (Array.isArray(department)) {

    // 배열 요소 총합
    return department.reduce((prev, current) => prev + current.salary, 0);

  // 재귀 단계
  // n단계 하위 부서 (객체)
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {

      // 재귀 호출 : 각 하위 부서 임직원 급여 총합
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
```
- 하위 부서 깊이 상관없이 원하는 값 구할 수 있음
- 객체 `{…}` → 서브 호출
- 배열 `[…]` → 서브 호출 X, 결과 계산
![recursive-salaries](./images/5/recursive-salaries.svg)

### 재귀적 구조
- 재귀적으로 정의된 자료구조
  - 자기 자신 일부 복제 자료 구조 형태
- 회사 부서 객체
  - 사람 구성 배열
  - 하위 부서 구성 객체
- HTML · XML
  - 일반 텍스트
  - HTML - 주석
  - 이외 HTML 태그
    - 하위 : 일반 텍스트 · HTML - 주석 · 다른 HTML 태그 등

### 연결 리스트
- 객체 정렬 후 저장
  - 배열
    - 요소 '삭제'와 '삽입' 비용 ↑ 에 들어가는 이 많이 든다는 문제가 있습니다. arr.unshift(obj) 연산을 수행하려면 새로운 obj를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매겨야 하죠. 배열이 커지면 연산 수행 시간이 더 걸리게 됩니다. arr.shift()를 사용할 때도 마찬가지입니다.

요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 arr.push/pop 뿐이죠. 앞쪽 요소에 무언가를 할 때 배열은 이처럼 꽤 느립니다.