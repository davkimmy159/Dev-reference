커스텀 에러 · 에러 확장
=====================

##### 자체 에러 클래스 필요한 경우 多
- 네트워크 관련 작업 중 에러
  - `HttpError`
- 데이터베이스 관련 작업 중 에러
  - `DbError`
- 검색 관련 작업 중 에러
  - `NotFoundError`
- 기타 등등

#### 자체 <sub>(커스텀)</sub> 에러 클래스

##### 권장 프로퍼티
- `message`
- `name`
- `stack`
- 기타 등등
  - ex&#41; `statusCode` <sub>(`HttpError` 클래스)</sub>
    - 숫자 값 <sub>(404 · 403 등)</sub> 지정

##### `Error` <sub>(객체)</sub>
- 상속 X
  - `throw` <sub>(연산자)</sub> 인수 제약 X
- 상속 <sub>(권장)</sub>
  - 에러 객체 식별 가능
    - `obj instanceof Error`

##### 애플리케이션 크기 점점 ↑
- 커스텀 에러 클래스들
  - 자연스레 계층 구조 형성
```javascript
class HttpError {
// …
}

class HttpTimeoutError extends HttpError {
// …
}
```

### 에러 확장하기

##### `readUser(json)` <sub>(함수)</sub>
- 사용자 데이터 JSON 읽음
- 유효 JSON 형태 필요
```javascript
let json = `{ "name": "John", "age": 30 }`;
```
- 함수 내부
  - `JSON.parse` 이용
  - 잘못된 JSON 형식
    - `SyntaxError` 발생
- 인수로 받은 데이터
  - 정상 JSON 형식
  - 필수 정보 누락 가능성 有
    - `name`
    - `age`
- 함수 역할
  - JSON 형식 데이터 읽기
  - 데이터 검증
    - 필수 프로퍼티 유무
    - 데이터 형식
- 함수 발생 에러
  - `SyntaxError` X
  - 전혀 다른 종류 에러
    - JSON 형식 충족
    - 자체 기준 충족 X
- `ValidationError` <sub>(커스텀 에러 클래스)</sub>
  - 전혀 다른 종류 에러
  - 잘못된 필드 정보 저장
  - `Error` <sub>(내장 에러 클래스)</sub> 상속
```javascript
/* Error (내장 에러 클래스) pseudo 코드 */
class Error {
  constructor(message) {
    this.message = message;

     // 내장 에러 클래스마다 이름 상이
    this.name = "Error";

    // 표준 X
    // - 대다수 환경 지원
    this.stack = <call stack>;
  }
}
```
```javascript
/* ValidationError (커스텀 에러 클래스) */
class ValidationError extends Error {
  constructor(message) {

    /*
     부모 생성자 호출
     - message (프로퍼티) 설정
       - 인수
     - name (프로퍼티) 설정
       - "Error"
     */
    super(message);

    // name (프로퍼티)
    // - 원하는 값으로 재설정
    this.name = "ValidationError";
  }
}

// 테스트
function test() {
  throw new ValidationError("에러 발생!");
}

try {
  test();
} catch(err) {
  alert(err.message); // 에러 발생!
  alert(err.name);    // ValidationError
  alert(err.stack);   // 각 행 번호 있는 중첩 호출들 목록
}
```

##### `ValidationError` <sub>(커스텀 에러 클래스)</sub> 사용
- `readUser(json)` <sub>(함수)</sub> 내부
```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// 사용법
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("No field: age");
  }
  if (!user.name) {
    throw new ValidationError("No field: name");
  }

  return user;
}

// try…catch 함께 사용
try {
  let user = readUser('{ "age": 25 }');
} catch (err) {

  // 에러 유형 확인
  // - instanceof (연산자)
  if (err instanceof ValidationError) {

    // Invalid data: No field: name
    alert("Invalid data: " + err.message);

  } else if (err instanceof SyntaxError) {
    alert("JSON Syntax Error: " + err.message);

  } else {

    /*
     catch 블록 처리 에러
     - 유효성 검사
     - 문법 오류 처리
     다른 종류 에러
     - 밖으로 던져야 함
     */
    // 알려지지 않은 에러
    // - 다시 던지기
    throw err;
  }
}
```

##### 에러 유형 확인
- `instanceof` <sub>(연산자)</sub>
- `err.name` <sub>(프로퍼티)</sub>
```javascript
// …
//else if (err instanceof SyntaxError)
} else if (err.name == "SyntaxError") {
// …
```
##### `instanceof` <sub>(연산자)</sub> 권장
- 커스텀 에러 클래스 확장 시
  - 상속 클래스에도 동작

### 더 깊게 상속하기

##### `ValidationError` <sub>(커스텀 에러 클래스)</sub>
- 너무 포괄적
- 미처리 에러들
  - 필수 프로퍼티 누락
  - `age` : 문자열 값 할당
  - 기타 등등

##### `PropertyRequiredError` <sub>(커스텀 에러 클래스)</sub>
- 좀 더 구체적인 클래스
- 필수 프로퍼티 부재 대응
- 누락 프로퍼티 추가 정보 보유
```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
    this.name = "PropertyRequiredError";

    // 자체 프로퍼티
    this.property = property;
  }
}

// 사용법
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new PropertyRequiredError("age");
  }
  if (!user.name) {
    throw new PropertyRequiredError("name");
  }

  return user;
}

// try…catch 함께 사용
try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {

    // Invalid data: No property: name
    alert("Invalid data: " + err.message);

    // PropertyRequiredError
    alert(err.name);
    alert(err.property); // name

  } else if (err instanceof SyntaxError) {
    alert("JSON Syntax Error: " + err.message);

  } else {

    // 알려지지 않은 에러
    // - 다시 던지기
    throw err;
  }
}
```

##### `PropertyRequiredError` <sub>(커스텀 에러 클래스)</sub>
- 새롭게 만든 클래스
- 사용 쉬움
- 프로퍼티명만 전달하면 끝
- 사람 읽을 수 있는 `message` <sub>(프로퍼티)</sub>
  - 생성자가 알아서 생성
```javascript
new PropertyRequiredError(property);
```
- `this.name` 수동 할당 <sub>(생성자 내부)</sub>
  - 귀찮은 작업
- 기본 커스텀 에러 클래스
  - 커스텀 에러들 상속
  - `this.name` 값 할당 <sub>(생성자 내부)</sub>
```javascript
this.name = this.constructor.name;
```
```javascript
class MyError extends Error {
  constructor(message) {
    super(message);

    // this.name 값 설정
    this.name = this.constructor.name;
  }
}

class ValidationError extends MyError { }

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("No property: " + property);
 // this.name = "PropertyRequiredError";
    this.property = property;
  }
}

// 제대로 된 이름 출력
// - "PropertyRequiredError"
alert( new PropertyRequiredError("field").name );
```

### 예외 감싸기

##### `readUser` <sub>(함수)</sub>
- '사용자 데이터 읽기' 용도
- 함수 더 커질 시
  - 다른 오류 발생 가능
  - 다른 커스텀 에러 클래스 생성 필요
- 함수 호출하는 곳
  - 새롭게 생성될 커스텀 에러들 처리 필요
- `catch` 블록 안 여러 `if` <sub>(문)</sub>
  - 알 수 있는 에러
    - 처리
  - 알 수 없는 에러
    - 다시 던지기

##### 현재 에러 처리 스키마
```javascript
try {
  …
  readUser() // 잠재적 에러 발생처
  …
} catch (err) {

  if (err instanceof ValidationError) {

    // validation 에러 처리

  } else if (err instanceof SyntaxError) {

    // SyntaxError (문법) 에러 처리

  } else {

    // 알 수 없는 에러
    // - 다시 던지기
    throw err;
  }
}
```
- 기존 스키마
  - 두 종류의 에러만 처리
  - 에러 종류
    - 추가 가능성 ↑
- 실제 필요 정보
  - '데이터 읽을 때' 에러 발생 여부
- 불필요 정보 <sub>(대부분의 경우)</sub>
  - 에러 발생 이유
  - 자세한 설명

#### 예외 감싸기 진행 순서

##### 1. 포괄적인 에러 클래스 <sub>(`ReadError`)</sub> 작성
- 데이터 읽기 에러 등

##### 2. `readUser` <sub>(함수)</sub> 발생 에러
- ex&#41;
  - `ValidationError`
  - `SyntaxError`
  - 기타 등등
- 함수 내부에서 잡음
  - `ReadError` <sub>(포괄 에러 객체)</sub> 생성

##### 3. `ReadError` <sub>(포괄 에러 객체)</sub>
- `cause` <sub>(프로퍼티)</sub>
  - 실제 에러 참조 저장

##### 예외 감싸기로 스키마 변경
- `readUser` <sub>(함수)</sub> 호출 코드
  - `ReadError` <sub>(포괄 에러 객체)</sub> 만 확인
  - 전체 에러 종류 확인 X
- 추가 정보 필요 시
  - `cause` <sub>(프로퍼티)</sub> 확인
```javascript
class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}

class ValidationError extends Error { /* … */ }
class PropertyRequiredError extends ValidationError { /* … */ }

function validateUser(user) {
  if (!user.age) {
    throw new PropertyRequiredError("age");
  }

  if (!user.name) {
    throw new PropertyRequiredError("name");
  }
}

function readUser(json) {
  let user;

  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new ReadError("Syntax Error", err);
    } else {
      throw err;
    }
  }

  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ReadError("Validation Error", err);
    } else {
      throw err;
    }
  }

}

try {
  readUser('{ 잘못된 형식의 json }');
} catch (e) {
  if (e instanceof ReadError) {
    alert(e);

    // Original error: SyntaxError: Unexpected token b in JSON at position 1
    alert("Original error: " + e.cause);
  } else {
    throw e;
  }
}
```

##### `readUser` <sub>(함수)</sub>
- `SyntaxError` · `ValidationError`
  - 다시 던지기 X
  - `ReadError` <sub>(포괄 에러 객체)</sub> 던짐

##### `readUser` <sub>(함수)</sub> 호출 바깥 코드
- `instanceof ReadError` 만 확인
- 분기문 여러 개 X

##### 예외 감싸기
- 종류별 에러
  - 좀 더 추상적인 하나의 에러로 모아 처리
- 객체 지향 프로그래밍
  - 널리 쓰이는 패턴

<br />

## 요약
- 커스텀 클래스는 `Error`나 다른 내장 에러 클래스를 상속받아 만들 수 있습니다. 이때 `super`를 호출해야 한다는 점과 `name` 프로퍼티를 신경 써야 한다는 점을 잊지 마세요.
- `instanceof`를 사용하면 에러 종류를 판별할 수 있습니다. 상속된 클래스에도 마찬가지죠. 그런데 서드파티 라이브러리에서 온 에러 객체는 클래스를 알아내는 것이 쉽지 않습니다. 이럴 땐 `name` 프로퍼티를 사용해 오류 종류를 확인할 수 있습니다.
- 예외 감싸기는 널리 알려진 예외 처리 기술입니다. 예외 감싸기를 적용한 함수에선 모든 에러를 종류별로 처리하지 않습니다. 대신 모든 에러를 포함할 수 있는 추상 에러를 하나 만들고, 에러가 발생하면 이 추상 에러를 던지도록 합니다. 추상 에러를 던질 때 실제 발생한 에러를 추상 에러의 프로퍼티(`err.cause`)로 넘기면 구체적인 에러 정보를 함께 넘겨줄 수 있는데, 반드시 이 프로퍼티가 있어야 하는 것은 아닙니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### SyntaxError 상속
내장된 `SyntaxError` 클래스를 상속하는 `FormatError` 클래스를 만들어 봅시다.

만들어진 클래스에서 `message`, `name`, `stack를` 참조할 수 있어야 합니다.

참고 예시입니다.
```javascript
let err = new FormatError("formatting error");

alert( err.message ); // formatting error
alert( err.name ); // FormatError
alert( err.stack ); // stack

alert( err instanceof FormatError ); // true
alert( err instanceof SyntaxError ); // true (SyntaxError 클래스를 상속받았기 때문입니다.)
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
class FormatError extends SyntaxError {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

let err = new FormatError("formatting error");

alert( err.message ); // formatting error
alert( err.name ); // FormatError
alert( err.stack ); // stack

alert( err instanceof SyntaxError ); // true
```
