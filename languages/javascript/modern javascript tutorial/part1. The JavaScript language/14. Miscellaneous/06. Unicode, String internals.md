ìœ ë‹ˆì½”ë“œ, ë¬¸ìì—´ ë‚´ë¶€
=========================

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **ì‹¬í™”**

- ë¬¸ìì—´ ë‚´ë¶€ í•™ìŠµ
- ìœ ìš©í•œ ìƒí™©
   - ì´ëª¨ì§€
   - ìˆ˜í•™ ê¸°í˜¸
   - ìƒí˜• ë¬¸ì
   - ê¸°íƒ€ ë“±ë“±

#### JS ë¬¸ìì—´

##### ìœ ë‹ˆì½”ë“œ ê¸°ë°˜
- ê° ê¸€ì : ì¼ë ¨ì˜ byte í‘œí˜„
  - 1 - 4 byte

##### 16ì§„ìˆ˜ ìœ ë‹ˆì½”ë“œ í‘œí˜„
- ë¬¸ìì—´ ë‚´ ë¬¸ì ì‚½ì… ê°€ëŠ¥
  - `\xXX`
  - `\uXXXX XXXX`
  - `\u{Xâ€¦XXXXXX}`

#### `\xXX`

##### êµ¬ì„±
- 16ì§„ìˆ˜ ìˆ«ì 2ê°œ
  - `00` ~ `FF`

##### ì²« 256ê°œ ìœ ë‹ˆì½”ë“œ ë¬¸ì í‘œí˜„
- ë¼í‹´ ì•ŒíŒŒë²³
- ê¸°ë³¸ ë¬¸ë²• ê¸€ì
- ê¸°íƒ€ ë“±ë“±
- ex&#41; `"\x7A"` == `"z"` <sub>(ìœ ë‹ˆì½”ë“œ `U+007A`)</sub>

```javaScript
alert( "\x7A" ); // z
alert( "\xA9" ); // Â©, ì €ì‘ê¶Œ ë¬¸ì
```

#### `\uXXXX XXXX`

##### êµ¬ì„±
- 16ì§„ìˆ˜ ìˆ«ì 4ê°œ
  - `0000` ~ `FFFF`

##### `U+FFFF` ì´ˆê³¼ ìœ ë‹ˆì½”ë“œ ë¬¸ì í‘œí˜„ ì‹œ
- ì„œë¡œê²Œì´íŠ¸ ìŒ í•„ìš”

```javaScript
alert( "\u00A9" ); // Â©, ì €ì‘ê¶Œ ë¬¸ì
alert( "\u044F" ); // Ñ, í‚¤ë¦´ ë¬¸ì
alert( "\u2191" ); // â†‘, ìœ„í™”ì‚´í‘œ ë¬¸ì
```

#### `\u{Xâ€¦XXXXXX}`

##### êµ¬ì„±
- 16ì§„ìˆ˜ ìˆ«ì <sub>(1 ~ 6 bytes)</sub>
  - `0` ~ `10FFFF` <sub>(ê°€ì¥ ë†’ì€ ìœ ë‹ˆì½”ë“œ)</sub>

##### ëª¨ë“  ìœ ë‹ˆì½”ë“œ ë¬¸ì í‘œí˜„

```javaScript
alert( "\u{20331}" ); // ä½«, ë“œë¬¸ í•œì ë¬¸ì (ê¸´ ìœ ë‹ˆì½”ë“œ)
alert( "\u{1F60D}" ); // ğŸ˜, ì›ƒëŠ” ì–¼êµ´ ë¬¸ì (ê¸´ ìœ ë‹ˆì½”ë“œ)
```

### ì„œë¡œê²Œì´íŠ¸ ìŒ
All frequently used characters have 2-byte codes (4 hex digits). Letters in most European languages, numbers, and the basic unified CJK ideographic sets (CJK â€“ from Chinese, Japanese, and Korean writing systems), have a 2-byte representation.

Initially, javaScript was based on UTF-16 encoding that only allowed 2 bytes per character. But 2 bytes only allow 65536 combinations and thatâ€™s not enough for every possible symbol of Unicode.

So rare symbols that require more than 2 bytes are encoded with a pair of 2-byte characters called â€œa surrogate pairâ€.

As a side effect, the length of such symbols is 2:
```javaScript
alert( 'ğ’³'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( 'ğŸ˜‚'.length ); // 2, FACE WITH TEARS OF JOY
alert( 'ğ©·¶'.length ); // 2, a rare Chinese character
```
Thatâ€™s because surrogate pairs did not exist at the time when javaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the length property shows a length of 2.

Getting a symbol can also be tricky, because most language features treat surrogate pairs as two characters.

For example, here we can see two odd characters in the output:
```javaScript
alert( 'ğ’³'[0] ); // shows strange symbols...
alert( 'ğ’³'[1] ); // ...pieces of the surrogate pair
```
Pieces of a surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of 0xd800..0xdbff, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval 0xdc00..0xdfff. These intervals are reserved exclusively for surrogate pairs by the standard.

So the methods String.fromCodePoint and str.codePointAt were added in javaScript to deal with surrogate pairs.

They are essentially the same as String.fromCharCode and str.charCodeAt, but they treat surrogate pairs correctly.

One can see the difference here:
```javaScript
// charCodeAt is not surrogate-pair aware, so it gives codes for the 1st part of ğ’³:

alert( 'ğ’³'.charCodeAt(0).toString(16) ); // d835

// codePointAt is surrogate-pair aware
alert( 'ğ’³'.codePointAt(0).toString(16) ); // 1d4b3, reads both parts of the surrogate pair
```
That said, if we take from position 1 (and thatâ€™s rather incorrect here), then they both return only the 2nd part of the pair:
```javaScript
alert( 'ğ’³'.charCodeAt(1).toString(16) ); // dcb3
alert( 'ğ’³'.codePointAt(1).toString(16) ); // dcb3
// meaningless 2nd half of the pair
```
You will find more ways to deal with surrogate pairs later in the chapter Iterables. There are probably special libraries for that too, but nothing famous enough to suggest here.

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Takeaway: splitting strings at an arbitrary point is dangerous**

We canâ€™t just split a string at an arbitrary position, e.g. take str.slice(0, 4) and expect it to be a valid string, e.g.:

alert( 'hi ğŸ˜‚'.slice(0, 4) ); //  hi [?]
Here we can see a garbage character (first half of the smile surrogate pair) in the output.

Just be aware of it if you intend to reliably work with surrogate pairs. May not be a big problem, but at least you should understand what happens.

### Diacritical marks and normalization