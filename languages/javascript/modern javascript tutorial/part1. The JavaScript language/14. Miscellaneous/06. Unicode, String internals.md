유니코드, 문자열 내부
=========================

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **심화**

- 문자열 내부 학습
- 유용한 상황
   - 이모지
   - 수학 기호
   - 상형 문자
   - 기타 등등

#### JS 문자열

##### 유니코드 기반
- 각 글자 : 일련의 byte 표현
  - 1 - 4 byte

##### 16진수 유니코드 표현
- 문자열 내 문자 삽입 가능
  - `\xXX`
  - `\uXXXX XXXX`
  - `\u{X…XXXXXX}`

#### `\xXX`

##### 구성
- 16진수 숫자 2개
  - `00` ~ `FF`

##### 첫 256개 유니코드 문자 표현
- 라틴 알파벳
- 기본 문법 글자
- 기타 등등
- ex&#41; `"\x7A"` == `"z"` <sub>(유니코드 `U+007A`)</sub>

```javaScript
alert( "\x7A" ); // z
alert( "\xA9" ); // ©, 저작권 문자
```

#### `\uXXXX XXXX`

##### 구성
- 16진수 숫자 4개
  - `0000` ~ `FFFF`

##### `U+FFFF` 초과 유니코드 문자 표현 시
- 서로게이트 쌍 필요

```javaScript
alert( "\u00A9" ); // ©, 저작권 문자
alert( "\u044F" ); // я, 키릴 문자
alert( "\u2191" ); // ↑, 위화살표 문자
```

#### `\u{X…XXXXXX}`

##### 구성
- 16진수 숫자 <sub>(1 ~ 6 bytes)</sub>
  - `0` ~ `10FFFF` <sub>(가장 높은 유니코드)</sub>

##### 모든 유니코드 문자 표현

```javaScript
alert( "\u{20331}" ); // 佫, 드문 한자 문자 (긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 문자 (긴 유니코드)
```

### 서로게이트 쌍
All frequently used characters have 2-byte codes (4 hex digits). Letters in most European languages, numbers, and the basic unified CJK ideographic sets (CJK – from Chinese, Japanese, and Korean writing systems), have a 2-byte representation.

Initially, javaScript was based on UTF-16 encoding that only allowed 2 bytes per character. But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol of Unicode.

So rare symbols that require more than 2 bytes are encoded with a pair of 2-byte characters called “a surrogate pair”.

As a side effect, the length of such symbols is 2:
```javaScript
alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, a rare Chinese character
```
That’s because surrogate pairs did not exist at the time when javaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the length property shows a length of 2.

Getting a symbol can also be tricky, because most language features treat surrogate pairs as two characters.

For example, here we can see two odd characters in the output:
```javaScript
alert( '𝒳'[0] ); // shows strange symbols...
alert( '𝒳'[1] ); // ...pieces of the surrogate pair
```
Pieces of a surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of 0xd800..0xdbff, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval 0xdc00..0xdfff. These intervals are reserved exclusively for surrogate pairs by the standard.

So the methods String.fromCodePoint and str.codePointAt were added in javaScript to deal with surrogate pairs.

They are essentially the same as String.fromCharCode and str.charCodeAt, but they treat surrogate pairs correctly.

One can see the difference here:
```javaScript
// charCodeAt is not surrogate-pair aware, so it gives codes for the 1st part of 𝒳:

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835

// codePointAt is surrogate-pair aware
alert( '𝒳'.codePointAt(0).toString(16) ); // 1d4b3, reads both parts of the surrogate pair
```
That said, if we take from position 1 (and that’s rather incorrect here), then they both return only the 2nd part of the pair:
```javaScript
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3
alert( '𝒳'.codePointAt(1).toString(16) ); // dcb3
// meaningless 2nd half of the pair
```
You will find more ways to deal with surrogate pairs later in the chapter Iterables. There are probably special libraries for that too, but nothing famous enough to suggest here.

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Takeaway: splitting strings at an arbitrary point is dangerous**

We can’t just split a string at an arbitrary position, e.g. take str.slice(0, 4) and expect it to be a valid string, e.g.:

alert( 'hi 😂'.slice(0, 4) ); //  hi [?]
Here we can see a garbage character (first half of the smile surrogate pair) in the output.

Just be aware of it if you intend to reliably work with surrogate pairs. May not be a big problem, but at least you should understand what happens.

### Diacritical marks and normalization