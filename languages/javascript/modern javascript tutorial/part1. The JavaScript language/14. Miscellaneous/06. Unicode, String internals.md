유니코드, 문자열 내부
=========================

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **심화**

- 문자열 내부 학습
- 유용한 상황
   - 이모지
   - 수학 기호
   - 상형 문자
   - 기타 등등

#### JS 문자열

##### 유니코드 기반
- 각 글자 : 일련의 byte 표현
  - 1 - 4 byte

##### 16진수 유니코드 표현
- 문자열 내 문자 삽입 가능
  - `\xXX`
  - `\uXXXX XXXX`
  - `\u{X…XXXXXX}`

#### `\xXX`

##### 구성
- 16진수 숫자 2개
  - `00` ~ `FF`

##### 첫 256개 유니코드 문자 표현
- 라틴 알파벳
- 기본 문법 글자
- 기타 등등
- ex&#41; `"\x7A"` == `"z"` <sub>(유니코드 `U+007A`)</sub>

```javaScript
alert( "\x7A" ); // z
alert( "\xA9" ); // ©, 저작권 문자
```

#### `\uXXXX XXXX`

##### 구성
- 16진수 숫자 4개
  - `0000` ~ `FFFF`

##### `U+FFFF` 초과 유니코드 문자 표현 시
- 서로게이트 쌍 필요

```javaScript
alert( "\u00A9" ); // ©, 저작권 문자
alert( "\u044F" ); // я, 키릴 문자
alert( "\u2191" ); // ↑, 위화살표 문자
```

#### `\u{X…XXXXXX}`

##### 구성
- 16진수 숫자 <sub>(1 ~ 6 bytes)</sub>
  - `0` ~ `10FFFF` <sub>(가장 높은 유니코드)</sub>

##### 모든 유니코드 문자 표현

```javaScript
alert( "\u{20331}" ); // 佫, 드문 한자 문자 (긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 문자 (긴 유니코드)
```

### 서로게이트 쌍

##### 자주 사용되는 문자들
- 2byte 코드
  - 16진수 숫자 4개

##### 2byte 코드 표현
- 대다수 유럽권 언어 문자 · 숫자
- 한중일 통합 한자
  - 'CJK Unified Ideographs'

##### 최초 JS : UTF-16 인코딩 기반
- 글자 당 2byte 허용
  - 조합 개수 : 65536개
- 모든 가능한 기호 표시
  -  턱없이 부족

##### 잘 안 쓰이는 · 2byte 이상 요구 기호
- 2byte 문자 쌍 조합해 인코딩
  - 서로게이트 쌍
- 부작용
  - 기호 길이 : 2
```javaScript
alert( '𝒳'.length );  // 2, 수학 기호 대문자 X
alert( '😂'.length ); // 2, 울면서 웃는 얼굴 (이모지)
alert( '𩷶'.length );  // 2, 잘 안 쓰이는 중국어
```

##### JS 초기
- 서로게이트 쌍 부재
  - 제대로 처리 X

##### 하나의 기호 길이
- 2 <sub>(`length` 프로퍼티)</sub>

##### 서로게이트 쌍 기호
- 두 글자로 인식
  - 다루기 까다로움
```javaScript
alert( '𝒳'[0] ); // 이상한 기호 표시
alert( '𝒳'[1] ); // 서로게이트 쌍 일부
```
- 서로 쌍 이루지 않으면 무의미

##### 기호 대신 코드 사용 가능
- 서로게이트 쌍 그룹
  - 1번째
    - `0xd800` ~ `0xdbff`
  - 2번째
    - `0xdc00` ~ `0xdfff`
  - 기타 등등
- 해당 코드 그룹 위치
  - 서로게이트 쌍 위해 비워둠 <sub>(표준)</sub>

##### 서로게이트 쌍 처리 메서드 : 표준 추가
- `String.fromCodePoint`
- `String.codePointAt`

##### 기능 동일 기존 메서드 <sub>(서로게이트 쌍 처리 X)</sub>
- `String.fromCharCode`
- `str.charCodeAt`

One can see the difference here:
```javaScript
// charCodeAt is not surrogate-pair aware, so it gives codes for the 1st part of 𝒳:

alert( '𝒳'.charCodeAt(0).toString(16) ); // d835

// codePointAt is surrogate-pair aware
alert( '𝒳'.codePointAt(0).toString(16) ); // 1d4b3, reads both parts of the surrogate pair
```
That said, if we take from position 1 (and that’s rather incorrect here), then they both return only the 2nd part of the pair:
```javaScript
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3
alert( '𝒳'.codePointAt(1).toString(16) ); // dcb3
// meaningless 2nd half of the pair
```
You will find more ways to deal with surrogate pairs later in the chapter Iterables. There are probably special libraries for that too, but nothing famous enough to suggest here.

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Takeaway: splitting strings at an arbitrary point is dangerous**

We can’t just split a string at an arbitrary position, e.g. take str.slice(0, 4) and expect it to be a valid string, e.g.:

alert( 'hi 😂'.slice(0, 4) ); //  hi [?]
Here we can see a garbage character (first half of the smile surrogate pair) in the output.

Just be aware of it if you intend to reliably work with surrogate pairs. May not be a big problem, but at least you should understand what happens.

### Diacritical marks and normalization