참조 타입
========

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **심화 학습**

- 특정 에지 케이스 <sub>(edge case)</sub>

<br />

##### 복잡한 상황에서 메서드 호출 시
- `this` 값 잃어버리는 경우 발생
```javascript
let user = {
  name: "John",
  hi() { alert(this.name); },
  bye() { alert("Bye"); }
};

user.hi(); // John (간단한 호출)

/*
 name 따라 다른 메서드 호출
 - user.hi
 - user.bye
 에러 발생 (this == undefined)
 - TypeError: Cannot read property 'name' of undefined
 */
(user.name == "John" ? user.hi : user.bye)();
```

### 참조 타입 자세히 알아보기

##### `obj.method()` : 연산 2개
1. `.` <sub>(점 연산자)</sub>
    - `obj.method` <sub>(객체 프로퍼티)</sub> 접근
2. `()` <sub>(괄호 연산자)</sub>
    - 접근한 프로퍼티 <sub>(메서드)</sub> 실행

##### 두 연산 각각 별도 줄 실행
```javascript
let user = {
  name: "John",
  hi() { alert(this.name); }
}

// 1. 객체 프로퍼티 접근
let hi = user.hi;

// 2. 접근한 프로퍼티 실행
//    - 에러 발생 (this == undefined)
hi();
```

##### `hi = user.hi`
- 함수 → 변수 할당
- 마지막 줄과 완전히 독립적으로 동작
  - `this` 값 저장 X

##### `user.hi()` 동작 : 속임수 사용 <sub>(JS)</sub>
- `.` <sub>(점 연산자)</sub> 반환 값
  - 함수 X
  - 참조 타입 <sub>(Reference Type)</sub> 값

##### 참조 타입 <sub>(Reference Type)</sub> 값
- 명세서에서만 사용되는 타입
  - 개발 시 사용 X

##### 참조 타입에 속하는 값 : 조합 형태
- `base`
  - 객체
- `name`
  - 프로퍼티명
- `strict`
  - 엄격 모드에서 `true`

##### `user.hi` <sub>(프로퍼티 접근 - 점 연산자)</sub> 반환 값
- 함수 X
- 참조형 <sub>(참조 타입)</sub> 값

```javascript
// 엄격 모드
// 참조형 값
(user, "hi", true)
(base, name, strict)
```

##### 참조형 값 : `()` <sub>(괄호 연산자)</sub> 사용해 호출 시
1. 객체 · 메서드 연관 모든 정보 받음
2. `this` 값 결정 <sub>(연관 정보 기반)</sub>
    - `this(=user)`

##### 참조 타입 : '중개인' 역할
- `.` <sub>(점 연산자)</sub> 연산에서 알아낸 정보
  - `()` <sub>(괄호 연산자)</sub> 로 전달

##### `.` <sub>(점)</sub> 연산 이외 연산 <sub>(할당 연산 등)</sub>
- 참조 타입 통째로 버림
- `user.hi` 값 <sub>(함수)</sub> 만 받아 전달
  - `this` 정보 사라짐

##### 참조 타입 전달 <sub>(this 값 전달)</sub>
- `.` <sub>(점 연산자)</sub>
  - `obj.method()`
- `[]` <sub>(대괄호 연산자)</sub>
  - `obj[method]()`
- `bind` <sub>(함수 메서드)</sub>
  - `func.bind()`

<br />

## 요약
참조 타입은 자바스크립트 내부에서 사용되는 타입입니다.

`.` <sub>(점 연산자)</sub> 이나 대괄호를 사용해 객체 프로퍼티인 메서드(`obj.method()`)에 접근하려 하면 정확한 프로퍼티 값이 반환되는 것이 아니라 특별한 형태의 값인 '참조 타입' 값이 반한됩니다. 이 참조타입 값엔 프로퍼티 값과 프로퍼티가 정의된 객체 정보가 담겨있습니다.

`()` <sub>(괄호)</sub> 를 사용해 메서드를 호출할 때, 메서드 내에서 사용되는 `this`에 제대로 된 객체 정보를 전달해 줄 수 있는 이유가 바로 '참조 타입' 덕분입니다.

그런데 `.` <sub>(점 연산자)</sub> 이나 `[]` <sub>(대괄호)</sub> 이외의 연산에선 참조 타입이 그냥 프로퍼티 값으로 변해버립니다. 객체 메서드라면 함숫값으로 변해버리죠.

이런 내부 동작은 보이지 않는 곳에서 일어납니다. 참조 타입이 어떻게 동작하는지 알아야 해결할 수 있는 문제는 표현식을 이용해 동적으로 객체에서 메서드를 가져올 때와 같이 자주 발생하지 않습니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 문법 점검하기
아래 코드의 실행 결과를 예측해보세요.
```javascript
let user = {
  name: "John",
  go: function() { alert(this.name) }
}

(user.go)()
```

주의: 함정을 파놓았습니다. (• ◡•)

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

에러가 발생합니다!

코드를 직접 실행해봅시다.
```javascript
let user = {
  name: "John",
  go: function() { alert(this.name) }
}

(user.go)() // error!
```

브라우저에서 출력되는 에러 메시지만 봐서는 무엇이 잘못되었는지 파악하기 어려울 겁니다.

**에러는 `user = {...}` 뒤에 `;` <sub>(세미콜론)</sub>이 없어서 발생했습니다.**

자바스크립트는 괄호(`(us... `) 앞에 `;` <sub>(세미콜론)</sub>을 자동으로 넣어주지 않습니다. 따라서 코드는 아래와 같아집니다.
```javascript
let user = { go:... }(user.go)()
```

이렇게 두 표현식이 합쳐지면서 인수가 `(user.go)`인 객체 형태의 함수를 호출한 것처럼 되었습니다. 여기에 더하여 객체 `user`가 정의되지 않은 상태에서 같은 줄에 `let user`를 사용했기 때문에 에러가 발생합니다.

`user = {...}` 뒤에 `;` <sub>(세미콜론)</sub>을 붙여서 에러를 해결해봅시다.
```javascript
let user = {
  name: "John",
  go: function() { alert(this.name) }
};

(user.go)() // John
```

참고로, `(user.go)`를 감싸는 괄호는 아무런 역할을 하지 않습니다. 괄호는 대개 연산자 우선순위를 바꾸는 데 사용되는데, `(user.go)`에선 `.` <sub>(점 연산자)</sub> 가 먼저 동작하기 때문에 의미가 없습니다. 문제 출제 의도는 `;` <sub>(세미콜론)</sub>여부였습니다.

<hr />

### `this` 값 알아내기
아래 코드에선 다양한 방법으로 `user.go()`를 4번 연속 호출합니다.

그런데 첫 번째((1))와 두 번째 호출((2)) 결과는 세 번째((3))와 네 번째((4)) 호출 결과와 다릅니다. 이유가 뭘까요?
```javascript
let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();               // (1) [object Object]

(obj.go)();             // (2) [object Object]

(method = obj.go)();    // (3) undefined

(obj.go || obj.stop)(); // (4) undefined
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

이유는 다음과 같습니다.

1. 우리가 알고 있는 일반적인 메서드 호출 방법입니다.
2. 역시 일반적인 호출 방법에 속합니다. 괄호가 추가되었긴 하지만 연산 우선순위를 바꾸진 않으므로 점 연산자가 먼저 실행됩니다.
3. 좀 더 복잡한 패턴의 호출(`(expression).method()`)이 등장했네요. 세 번째 호출은 아래와 같은 코드로 쪼갤 수 있습니다.
    ```javascript
    f = obj.go; // 표현식 계산하기
    f();        // 저장된 것 호출하기
    ```

    위 코드에서 `f()`는 (메서드가 아닌) 함수로써 호출되었습니다. `this`에 대한 정보가 전혀 없는 상태에서 말이죠.

4. (3)과 동일한 패턴의 호출입니다. `expression`이 `obj.go || obj.stop`라는 차이점만 있습니다.

(3)과 (4)에서 어떤 일이 일어나는지 알려면 참조 타입을 다시 상기해야 합니다. 점이나 대괄호를 통해 프로퍼티에 접근하려는 경우 참조 타입 값(`(base, name, strict)`)이 반환됩니다.

메서드 호출을 제외하고, 참조 타입 값에 행해지는 모든 연산은 참조 타입 값을 일반 값으로 변환시킵니다. 이 과정에서 `this`에 정보가 누락됩니다.
