`BigInt`
======

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 추가됨**

- 스펙 추가된 지 얼마 안 된 문법
- [브라우저별 지원 여부 확인](https://caniuse.com/#feat=bigint)

<br />

##### 길이 제약 없이 정수 다룰 수 있는 숫자형
- 사용법
  - 정수 리터럴 끝 : `n`
  - `BigInt` <sub>(함수)</sub> 호출
- 문자열 · 숫자 → `BigInt` <sub>(타입)</sub> 값
```javascript
const bigint1 = 1234567890123456789012345678901234567890n;
const bigint2 = BigInt("1234567890123456789012345678901234567890");

// 10n 동일
const bigintFromNumber = BigInt(10);
```

### 수학 연산자
- 대개 일반 숫자와 큰 차이 없이 사용
```javascript
alert(1n + 2n); // 3
alert(5n / 2n); // 2
```
- 나눗셈 연산
  - 소수부 X

##### `BigInt` 형 값 대상 연산
- `BigInt` 형 값 반환
- 일반 숫자 혼합 사용 X
```javascript
// Error: Cannot mix BigInt and other types
alert(1n + 2);
```

##### 일반 숫자 혼합 사용 시
- 명시적으로 형 변환
  - `BigInt()`
  - `Number()`
```javascript
let bigint = 1n;
let number = 2;

// 숫자 → bigint
alert(bigint + BigInt(number)); // 3

// bigint → 숫자
alert(Number(bigint) + number); // 3
```
##### 형 변환 관련 연산
- 항상 조용히 동작
  - 절대 에러 발생 X
- 너무 큰 `Bigint` 형 값 <sub>(숫자형 허용 자릿수 초과)</sub>
  - 나머지 비트 : 자동으로 잘림 <sub>(주의)</sub>

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`+` <sub>(단항 덧셈 연산자)</sub> 사용 불가능**

##### `+` <sub>(단항 덧셈 연산자)</sub>
- 손쉽게 숫자형 변환
  - `+value` → `value` <sub>(숫자형)</sub>
- `Bigint` 대상 연산
  - 미지원 <sub>(혼란 방지)</sub>
  - `Number()` 사용
```javascript
let bigint = 1n;

alert( +bigint ); // 에러
alert( Number(bigint));
```

### 비교 연산자
비교 연산자 `<`, `>`는 `bigint`와 일반 숫자 모두에 사용할 수 있습니다.
```javascript
alert( 2n > 1n ); // true

alert( 2n > 1 ); // true
```

그런데 비교하려는 대상이 다른 타입에 속하면 `==`를 사용할 때는 같을지 모르지만 `===`를 사용할 때는 다르다고 판단됩니다.
```javascript
alert( 1 == 1n ); // true

alert( 1 === 1n ); // false
```

### 논리 연산
`bigint`는 `if` 안이나 다른 논리 연산자와 함께 사용할 때 일반 숫자와 동일하게 행동합니다.

`if`안에서 `0n`은 falsy이고 다른 값들은 truthy로 평가되죠.
```javascript
if (0n) {
  // 절대 실행되지 않습니다.
}
```

`||`, `&&` 등의 논리 연산자를 `bigint`에 적용할 때도 일반 숫자와 유사하게 동작합니다.
```javascript
alert( 1n || 2 ); // 1 (1n은 truthy로 판단됩니다.)

alert( 0n || 2 ); // 2 (0n은 falsy로 판단됩니다.)
```

### 폴리필
`bigint` 폴리필을 만드는 것은 꽤 까다롭습니다. `+`, `-`를 비롯한 다양한 연산자들이 `bigint`와 일반 숫자에서 다른 결과를 보이기 때문입니다.

`bigint`끼리 나누면 항상 `bigint`를 반환한다는 것을 앞서 말씀드린 바 있습니다.

동일한 결과가 나오게 하려면 폴리필에서 기존 코드를 분석하고 내장 연산자 모두를 관련 함수로 대체해 줄 수 있어야 합니다. 그런데 이렇게 하려면 품이 많이 들고 성능 이슈도 생길 수 있습니다.

따라서 아직까진 제대로 된 `bigint` 폴리필이 나오지 않은 상황입니다.

잘 알려진 폴리필은 없지만 [JSBI](https://github.com/GoogleChromeLabs/jsbi) 라이브러리의 개발자들이 대안을 제시하긴 했습니다.

이 라이브러리는 자체적으로 만든 방법을 사용해 큰 숫자를 구현합니다. 순수 `bigint`대신 라이브러리에서 만든 숫자를 사용하는 게 대안이 될 수 있습니다.


|연산|네이티브 `BigInt`|JSBI|
|---|---|---|
|일반 숫자를 사용해 `bigint`만들기|`a = BigInt(789)`|`a = JSBI.BigInt(789)`|
|덧셈|`c = a + b`|`c = JSBI.add(a, b)`|
|뺄셈|`c = a - b`|`c = JSBI.subtract(a, b)`|
|…|…|…|

이렇게 JSBI를 사용해 숫자를 만든 다음 바벨 플러그인에 있는 폴리필을 사용해 JSBI 호출을 네이티브 `bigint`로 변환하면 원하는 브라우저에서 연산을 수행할 수 있습니다.

In other words, this approach suggests that we write code in JSBI instead of native `bigint`. But JSBI works with numbers as with `bigint` internally, emulates them closely following the specification, so the code will be “bigint-ready”.

We can use such JSBI code “as is” for engines that don’t support `bigint` and for those that do support – the polyfill will convert the calls to native `bigint`.

참고 자료
[MDN docs on `BigInt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
[Specification](https://tc39.es/ecma262/#sec-bigint-objects)
