### 실무 : `WeakRef` <sub>(객체)</sub> · FinalizationRegistry

##### 실무 시나리오
- 모바일 · 클라우드 사진 동기화
  - 타 기기에서 사진 보기
  - 기타 추가 기능 제공

##### 추가 기능들
- 사진 편집 · 영상 효과
- 임시 저장 · 앨범 생성
- 일련 사진 → 영상 몽타주 변환
- 기타 등등

##### 예제

![weakref-finalizationregistry-demo-01](../../images/01/14/07/weakref-finalizationregistry-demo-01.png)

##### 좌측
- 클라우드 사진 라이브러리
  - 섬네일로 사진 표시

##### 우측
- "Create collage" 버튼
  - 사진 선택 · 콜라주 생성
    - 다운로드 가능

##### 압축
- 사진 다운로드 · 표시 섬네일
  - 페이지 로딩 속도 ↑

##### 압축 X
- 사진 선택 · 콜라주 생성

![weakref-finalizationregistry-demo-02](../../images/01/14/07/weakref-finalizationregistry-demo-02.png)

##### 사이즈
- 섬네일 고유 사이즈
  - 240 x 240 <sub>(픽셀)</sub>
- 미리보기 모드
  - 전체 사이즈 불필요

##### 콜라주 생성 <sub>(사진 4장)</sub>
1. 사진 선택
2. "Create collage" 버튼 클릭
3. `weakRefCache` <sub>(함수)</sub>
    - 캐시 내 이미지 존재 여부 확인
    - 부재 시
      - 다운로드 <sub>(클라우드)</sub>
      - 캐시 삽입


### 실무 : `WeakRef` <sub>(객체)</sub> · FinalizationRegistry

##### 실무 시나리오
- 모바일 · 클라우드 사진 동기화
  - 타 기기에서 사진 보기
  - 기타 추가 기능 제공

##### 추가 기능들
- 사진 편집 · 영상 효과
- 임시 저장 · 앨범 생성
- 일련 사진 → 영상 몽타주 변환
- 기타 등등

##### 예제

![weakref-finalizationregistry-demo-01](../../images/01/14/07/weakref-finalizationregistry-demo-01.png)

##### 좌측
- 클라우드 사진 라이브러리
  - 섬네일로 사진 표시

##### 우측
- "Create collage" 버튼
  - 사진 선택 · 콜라주 생성
    - 다운로드 가능

##### 압축
- 사진 다운로드 · 표시 섬네일
  - 페이지 로딩 속도 ↑

##### 압축 X
- 사진 선택 · 콜라주 생성

![weakref-finalizationregistry-demo-02](../../images/01/14/07/weakref-finalizationregistry-demo-02.png)

##### 사이즈
- 섬네일 고유 사이즈
  - 240 x 240 <sub>(픽셀)</sub>
- 미리보기 모드
  - 전체 사이즈 불필요

##### 콜라주 생성 <sub>(사진 4장)</sub>
1. 사진 선택
2. "Create collage" 버튼 클릭
3. `weakRefCache` <sub>(함수)</sub>
    - 캐시 내 이미지 존재 여부 확인
    - 부재 시
      1. 클라우드에서 다운로드
      2. 캐시 삽입

-  Let's assume, that we need to create a collage of 4 photos: we select them, and then click the "Create collage" button. At this stage, the already known to us weakRefCache function checks whether the required image is in the cache. If not, it downloads it from the cloud and puts it in the cache for further use. This happens for each selected image:

![weakref-finalizationregistry-demo-03](../../images/01/14/07/weakref-finalizationregistry-demo-03.gif)

Paying attention to the output in the console, you can see, which of the photos were downloaded from the cloud – this is indicated by FETCHED_IMAGE. Since this is the first attempt to create a collage, this means, that at this stage the “weak cache” was still empty, and all the photos were downloaded from the cloud and put in it.

But, along with the process of downloading images, there is also a process of memory cleanup by the garbage collector. This means, that the object stored in the cache, which we refer to, using a weak reference, is deleted by the garbage collector. And our finalizer executes successfully, thereby deleting the key, by which the image was stored in the cache. CLEANED_IMAGE notifies us about it:


![weakref-finalizationregistry-demo-04](../../images/01/14/07/weakref-finalizationregistry-demo-04.jpg)


Next, we realize that we do not like the resulting collage, and decide to change one of the images and create a new one. To do this, just deselect the unnecessary image, select another one, and click the "Create collage" button again:

![weakref-finalizationregistry-demo-05](../../images/01/14/07/weakref-finalizationregistry-demo-05.gif)


But this time not all images were downloaded from the network, and one of them was taken from the weak cache: the CACHED_IMAGE message tells us about it. This means that at the time of collage creation, the garbage collector had not yet deleted our image, and we boldly took it from the cache, thereby reducing the number of network requests and speeding up the overall time of the collage creation process:


![weakref-finalizationregistry-demo-06](../../images/01/14/07/weakref-finalizationregistry-demo-06.jpg)

Let's "play around" a little more, by replacing one of the images again and creating a new collage:

![weakref-finalizationregistry-demo-07](../../images/01/14/07/weakref-finalizationregistry-demo-07.gif)

This time the result is even more impressive. Of the 4 images selected, 3 of them were taken from the weak cache, and only one had to be downloaded from the network. The reduction in network load was about 75%. Impressive, isn't it?

![weakref-finalizationregistry-demo-08](../../images/01/14/07/weakref-finalizationregistry-demo-08.jpg)


Of course, it is important to remember, that such behavior is not guaranteed, and depends on the specific implementation and operation of the garbage collector.

Based on this, a completely logical question immediately arises: why do not we use an ordinary cache, where we can manage its entities ourselves, instead of relying on the garbage collector? That’s right, in the vast majority of cases there is no need to use WeakRef and FinalizationRegistry.

Here, we simply demonstrated an alternative implementation of similar functionality, using a non-trivial approach with interesting language features. Still, we cannot rely on this example, if we need a constant and predictable result.

You can open this example in the sandbox.

