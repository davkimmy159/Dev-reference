WeakRef and FinalizationRegistry
================================

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **언어 내 숨겨진 기능**

- 굉장히 드물게 사용

<br />

##### 도달 가능 원칙 <sub>(가비지 컬렉션)</sub>
- 도달 가능한 · 사용중인 값
```javascript
// user (변수)
// - 객체 참조
let user = { name: "John" };

// user (변수)
// - null 할당
user = null;

// 객체 참조 없어짐
// - 메모리에서 객체 삭제
```
- 참조 2개
```javascript
// user (변수)
// - 객체 참조
let user = { name: "John" };

// 참조 값 복사
// - user (변수) → admin (변수)
let admin = user;

// user (변수)
// - null 할당
user = null;

// 객체
// - 도달 가능 · 참조 유지 (admin 변수)
//   - 메모리에 객체 유지
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **용어 : "강한 참조" · "약한 참조"**

##### 강한 참조
- 가비지 컬렉션 작동 대상 X
  - 참조 메모리 위치에 객체 · 값 저장
- JS
  - 일반적인 객체 참조
```javascript
// user (변수)
// - 강한 참조
let user = { name: "John" };
```

##### 약한 참조
- 가비지 컬렉션 작동 대상
- 약한 참조만 존재 시
  - 메모리에서 삭제

### `WeakRef` <sub>(객체)</sub>

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **주의**

##### 이번 학습에서 사용하는 구조
- 신중한 사용 필요
- 되도록 사용 지양

<br />

##### 어떤 객체에 대한 약한 참조 저장 객체
- 참조하는 어떤 객체
  - "타겟"
  - "지시 대상"

##### 특징
- "타겟" · "지시 대상" 객체
  - 가비지 컬렉터 작동 대상

##### 예제
- `user` <sub>(변수)</sub>
  - 지시 대상
- `admin` <sub>(변수)</sub>
  - `user` <sub>(변수)</sub> 에 대한 약한 참조
- `WeakRef` <sub>(객체)</sub> 생성자
  - 타겟 <sub>(지시 대상)</sub> 객체 인수 전달
```javascript
// user (변수)
// - 객체에 대한 강한 참조
let user = { name: "John" };

// admin (변수)
// - 객체에 대한 약한 참조
let admin = new WeakRef(user);
```
- `user` <sub>(변수)</sub>
  - 강한 참조
- `admin` <sub>(변수)</sub>
  - 약한 참조

![9weakref-finalizationregistry-01](../../images/01/14/07/weakref-finalizationregistry-01.svg)

##### 어느 순간
- `user` <sub>(변수)</sub> 사용 X
  - 값 덮어씌우기
  - 스코프 밖으로 이동
  - 기타 등등 등
- `admin` <sub>(변수)</sub>
  - 약한 참조 유지
```javascript
// user (변수)
// - null 값 할당
user = null;
```
- 객체에 대한 약한 참조
  - 객체 유지 불가능
- 약한 참조만 존재 시
  - 가비지 컬렉터 작동

##### 가비지 컬렉터 작동 전
- 약한 참조 유지 가능
  - 강한 참조 부재 상태
- 객체 상태
  - 슈뢰딩거의 고양이
  - 전혀 알 수 없음

![9weakref-finalizationregistry-02](../../images/01/14/07/weakref-finalizationregistry-02.svg)

##### `deref()` <sub>(메서드)</sub>
- 객체 삭제 전
  - `WeakRef` <sub>(객체)</sub> 참조 객체 반환
- 객체 삭제 후
  - `undefined` 반환
```javascript
let ref = admin.deref();

if (ref) {

  // 객체 아직 삭제 X
  // - 객체 대상 작업 가능

} else {

  // 객체 삭제 완료
  // - 가비지 컬렉터에 의해 제거됨

}
```

### `WeakRef` <sub>(객체)</sub> 유스 케이스

##### 일반적인 사용처
- 캐싱
- 연관 배열
  - 자원 집중적인 객체 저장

##### 기능
- 캐시 · 연관 배열 내 객체 존재 시
  - 가비지 컬렉터 작동하게끔 함

##### ex&#41; 수많은 이진 이미지 객체들
- `ArrayBuffer` · `Blob` 타입
- 각 파일별로 이름 · 경로 설정
- 기존 자료구조
  - 사용 부적합
- `Map`
  - 객체 저장 유지
  - 메모리 사용량 ↑
- `WeakMap`
  - 약한 참조 사용
  - 가비지 컬렉터 작동
- 약한 참조 사용 자료구조
  - 사용 적합

##### `Map` 컬렉션
- 값 : `WeakRef` 인스턴스
  - 용량 큰 객체 약한 참조
    - 오랫동안 저장 X
- '도달 가능한' 상태일 경우
  - 캐시에서 이미지 객체 얻기
- 캐시에서 삭제되었을 경우
  - 객체 재생성 · 재다운로드
- 메모리 사용량 절약

### 유스 케이스 1 : 캐싱

##### `Map`
- `key`
  - 문자열
- `value`
  - `WeakRef` <sub>(객체)</sub>
  - 가비지 컬렉션 대상

##### 가비지 컬렉션
- 동작 전
  - 캐시에서 가져오기
- 동작 후
  - 재다운드 후 캐시에 넣기
```javascript
function fetchImg() {

  // 이미지 다운로드 코드

}

// 고차원 함수
// - 인수 : 함수
// - 반환 : 함수
function weakRefCache(fetchImg) {

    // 캐시 (맵)
    // - key   : 이미지명
    // - value : WeakRef (객체)
    const imgCache = new Map();

    // 함수 반환
    // - 인수 : 이미지명
    //   - 캐시 내 이미지 가져올 때 사용
    return (imgName) => {

        // 캐시 내 이미지 가져오기
        // - key : 함수 인수
        const cachedImg = imgCache.get(imgName);

        // 캐시 내 키 (함수 인수) 해당 이미지
        // - 존재 · 아직 삭제 전
        //   - value 반환
        if (cachedImg?.deref()) {
            return cachedImg?.deref();
        }

        // 캐시 내 키 (함수 인수) 해당 이미지
        // - 부재 · deref() : undefined 반환
        //   - 재다운로드 실행
        const newImg = fetchImg(imgName);

        // 재다운로드된 이미지
        // - 캐시에 삽입 (WeakRef 객체)
        imgCache.set(imgName, new WeakRef(newImg));

        return newImg;
    };
}

const getCachedImg = weakRefCache(fetchImg);
```

##### `Map` 컬렉션
- `key`
  - 이미지명 <sub>(문자열)</sub>
- `value`
  - `WeakRef` <sub>(객체)</sub>
    - 이미지 보유

##### `WeakRef` 캐싱
- 자원 집중적인 객체
  - 너무 많은 메모리 할당 방지
- 캐시 내 객체 재사용
  - 메모리 · 시간 절약

![weakref-finalizationregistry-03](../../images/01/14/07/weakref-finalizationregistry-03.svg)

##### 단점
- `WeakRef` <sub>(객체)</sub> 참조 객체
  - 얼마 후 삭제됨

![weakref-finalizationregistry-04](../../images/01/14/07/weakref-finalizationregistry-04.svg)

##### 해결책
- 주기적으로 캐시 정리
  - 참조 사라진 해당 키 · 값 정리
- 청소 콜백 <sub>(함수)</sub> <sub>(finalizers)</sub> 사용

### 유스 케이스 2 : DOM 객체 추적

##### 서드파티 코드 · 라이브러리
- 개발 페이지 내 요소와 상호작용
  - 요소 존재하는 동안
  - ex&#41; logger

```html
<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="index.css">
  <title>WeakRef DOM Logger</title>
</head>
<body>
  <div class="app">
    <button class="start-messages">Start sending messages</button>
    <div class="window">
      <div class="window__header">
        <p class="window__title">Messages:</p>
        <button class="window__button">Close</button>
      </div>
      <div class="window__body">
        No messages.
      </div>
    </div>
  </div>
  <script type="module" src="index.js"></script>
</body>
</html>
```
```javascript
/* (1)
 DOM 요소 얻기
 - "Start sending messages" 버튼
 */
const startMessagesBtn = document.querySelector('.start-messages');

/* (2)
 DOM 요소 얻기
 - "Close" 버튼
 */
const closeWindowBtn = document.querySelector('.window__button');

/* (3)
 DOM 요소 얻기
 - 로그 표시창
 - new WeakRef() (생성자) 사용
 windowElementRef (변수)
 - 약한 참조 (DOM 요소)
 */
const windowElementRef = new WeakRef(document.querySelector(".window__body"));

/* (4)
 이벤트 리스너 추가
 - "Start sending messages" 버튼
   - 클릭 시 logger 시작 기능 담당
 */
startMessagesBtn.addEventListener('click', () => {
  startMessages(windowElementRef);
    startMessagesBtn.disabled = true;
});

/* (5)
 이벤트 리스너 추가
 - "Close" 버튼
   - 클릭 시 로그 표시창 기능 담당
 */
closeWindowBtn.addEventListener('click', () =>  document.querySelector(".window__body").remove());

const startMessages = (element) => {

    /* (6)
     setInterval (함수) 호출
     - 매초 새 메시지 표시
     */
    const timerId = setInterval(() => {

        /* (7)
         DOM 요소 (로그 표시창 · WeakRef 객체)
         - element.deref() (메서드)
           - 타겟 객체 반환 시
             - 여전히 접근 가능 · 아직 메모리 제거 X
             - 새 메시지 생성 후 보내기
         */
        if (element.deref()) {
          const payload = document.createElement("p");
            payload.textContent = `Message: System status OK: ${new Date().toLocaleTimeString()}`;
            element.deref().append(payload);

        /* (8)
         DOM 요소 (로그 표시창 · WeakRef 객체)
         - element.deref() (메서드)
           - undefined 반환 시
             - 메모리에서 제거
             - logger : 메시지 표시 중단 · 타이머 초기화
         If the deref() method returns undefined, it means that the DOM-element has been deleted from memory. In this case, the logger stops displaying messages and clears the timer.
         */
        } else {

            /* (9)
             alert (함수)
             - DOM 요소 (로그 표시 창 · WeakRef) 메모리에서 제거 후 호출
               - ex) "Close" 버튼 클릭 등
             메모리에서 제거 동작
             - 바로 동작 안 할 수도 있음
               - 가비지 컬렉터 내부 메커니즘이 시점 결정
             */
            alert("The element has been deleted.");
            clearInterval(timerId);
        }
    }, 1000);
};
```

##### `"Start sending messages"` 버튼 클릭 시
- 메시지 표시 시작
  - 로그 표시창 <sub>(`WeakRef` 객체)</sub>
    - `.window__body` <sub>(클래스)</sub> 요소

##### `.window__body` <sub>(클래스)</sub> 요소 삭제 시
- logger
  - 메시지 보내기 중단해야 함
- `"Close"` 버특 클릭 시
  - 해당 요소 삭제

##### 서드파티 코드에 매번 DOM 요소 존재 여부 알리기 X
- 약한 참조 생성
  - `WeakRef` <sub>(객체)</sub>
- 해당 요소 : DOM 에서 삭제 시
  - logger 인지
  - 메시지 보내기 중단

##### 프로세스 직접 조작 X
- 브라우저
  - 가비지 컬렉션 동작 강요 가능

##### Google Chrome
1. developer tools
2. "Performance" tab
3. 쓰레기통 <sub>(아이콘)</sub> 클릭
    - "Collect garbage"
- 작동 후
  - `alert` <sub>(함수)</sub> 바로 호출됨

![google-chrome-developer-tools](../../images/01/14/07/google-chrome-developer-tools.png)

### FinalizationRegistry

##### 청소 콜백 <sub>(함수)</sub> <sub>(finalizer)</sub>
- FinalizationRegistry 등록 객체
  - 가비지 컬렉터 의해 삭제 시 호출

##### 목적
- 객체 : 메모리에서 삭제 후
  - 객체 관련 추가 동작 제공

##### Registry <sub>(FinalizationRegistry)</sub>
- JS 내 특별 객체
  - 객체 등록 · 제외 담당
  - 청소 콜백 <sub>(함수)</sub> 관리

##### 기능
- 객체 등록 · 청소 콜백 <sub>(함수)</sub> 연결
  - 관련 정보 저장
- 객체 : 메모리에서 제거 시
  - 청소 콜백 <sub>(함수)</sub> 자동 호출

##### FinalizationRegistry 인스턴스 생성
- 생성자 호출 <sub>(인수 1개)</sub>
  - 청소 콜백 <sub>(함수)</sub> <sub>(finalizer)</sub> 전달

##### 문법
```javascript
function cleanupCallback(heldValue) {

  // 청소 콜백 (함수) 코드

}

const registry = new FinalizationRegistry(cleanupCallback);
```

##### `cleanupCallback` <sub>(청소 콜백 함수)</sub>
- 등록 객체 : 매모리에서 제거 시
  - 자동 호출

##### `heldValue`
- 청소 콜백 <sub>(함수)</sub> 전달 인수
- 인수 == 객체 경우
  - registry : 강한 참조 유지

##### `registry`
- `FinalizationRegistry` 인스턴스

#### `FinalizationRegistry` 메서드

##### `register(target, heldValue [, unregisterToken])`
- `registry` 에 객체 등록
- `target` <sub>(객체)</sub>
  - 추적 위해 등록되는 객체
  - 가비지 컬렉터 의해 삭제 시
    - 청소 콜백 <sub>(함수)</sub> 호출
      - 인수 : `heldValue`
- `unregisterToken` <sub>(옵션)</sub>
  - 등록 제외 토큰
  - 객체 등록 제외 위해 전달
    - 가비지 컬렉터 의해 삭제 전
  - 대개 `target` <sub>(객체)</sub> 사용
    - 관행

##### unregister(unregisterToken)
- `registry` 에서 객체 제외
- 인수 : 1개 <sub>(`unregisterToken`)</sub>
  - 객체 등록 시 얻어짐

##### `user` <sub>(객체)</sub>
- `FinalizationRegistry` 인스턴스 생성
  - 청소 콜백 <sub>(함수)</sub> 정의
```javascript
let user = { name: "John" };

const registry = new FinalizationRegistry((heldValue) => {
  console.log(`${heldValue} has been collected by the garbage collector.`);
});
```
- `user` <sub>(객체)</sub> 등록
```javascript
registry.register(user, user.name);
```

##### `registry`
- 등록 객체에 강한 참조 X
  - 목적에 반함
- 등록 객체에 강한 참조 시
  - 가비지 컬렉터 대상 X
```javascript
/*
 user (객체)
 - 가비지 컬렉터 의해 제거 시
   - 콘솔에 메시지 출력
 */
"John has been collected by the garbage collector."
```

#### 청소 콜백 <sub>(함수)</sub> 구현 후 미사용 경우 有

##### 프로그램 완전 종료 시
- 브라우저 탭 닫기 등

##### `FinalizationRegistry` 인스턴스
- JS 코드 내 '도달 불가능' 시
- 인스턴스 생성 객체
  - 스코프 밖으로 사라질 시
  - 삭제 시

### `FinalizationRegistry` · 캐싱

##### `WeakRef` <sub>(객체)</sub> 캐싱 예제
- 메모리 누수 : `Map`
  - `key`
    - 계속 유지
  - `value`
    - 가비지 컬렉터 의해 제거

##### `FinalizationRegistry` 사용해 개선
```javascript
function fetchImg() {

  // 이미지 다운로드 코드

}

function weakRefCache(fetchImg) {
  const imgCache = new Map();

  /* (1)
   FinalizationRegistry 인스턴스 생성
   - 죽은 (key 만 남은) 요소 관리
     - value (WeakRef)
       - 가비지 컬렉터 의해 제거
   필수 체크
   - value (WeakRef) : 가비지 컬렉터 의해 제거 후
     - 아직 재추가 안됨
   */
  const registry = new FinalizationRegistry((imgName) => {
    const cachedImg = imgCache.get(imgName);
    if (cachedImg && !cachedImg.deref()) imgCache.delete(imgName);
  });

  return (imgName) => {
    const cachedImg = imgCache.get(imgName);

    if (cachedImg?.deref()) {
      return cachedImg?.deref();
    }

    const newImg = fetchImg(imgName);
    imgCache.set(imgName, new WeakRef(newImg));

    /* (2)
     새 이미지 다운로드 · 캐시에 삽입 후
     - registry 에 WeakRef (객체) 등록
       - WeakRef (객체) 추적
     */
    registry.register(newImg, imgName);

    return newImg;
  };
}

const getCachedImg = weakRefCache(fetchImg);
```

##### '살아있는' `Map` 요소만 유지
- 각 `WeakRef` <sub>(객체)</sub>
  - `FinalizationRegistry` 등록
  - 가비지 컬렉터 의해 제거 시
    - 청소 콜백 <sub>(함수)</sub> 작동
      - '죽은' 요소 제거

![9weakref-finalizationregistry-05](../../images/01/14/07/weakref-finalizationregistry-05.svg)

#### 중요한 사실

##### finalizers
- 병렬 프로세스 작동
  - main 프로그램
  - 청소 콜백 <sub>(함수)</sub>

##### 시간 차 존재
- 가비지 컬렉터 의해 삭제 표시
- 실제 청소 콜백 <sub>(함수)</sub> 작동

##### 시간 차 사이
- main 프로그램
  - 해당 객체에 그 어떤 동작도 가능
    - ex&#41; 메모리로 가져오기 등

##### 예시 : 필수 체크 이유
- 가비지 컬렉터 의해 제거 전
  - 추적 객체에 그 어떤 동작도 가능

##### 특별 상황 <sub>(주의 요구)</sub>
- 키 검색 도중
  - 가비지 컬렉터 의해 제거 경우 有
  - 아직 청소 콜백 <sub>(함수)</sub> 작동 전

### 실무 : `WeakRef` <sub>(객체)</sub> · FinalizationRegistry
