WeakRef and FinalizationRegistry
================================

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **언어 내 숨겨진 기능**

- 굉장히 드물게 사용

<br />

##### 도달 가능 원칙 <sub>(가비지 컬렉션)</sub>
- 도달 가능한 · 사용중인 값
```javascript
// user (변수)
// - 객체 참조
let user = { name: "John" };

// user (변수)
// - null 할당
user = null;

// 객체 참조 없어짐
// - 메모리에서 객체 삭제
```
- 참조 2개
```javascript
// user (변수)
// - 객체 참조
let user = { name: "John" };

// 참조 값 복사
// - user (변수) → admin (변수)
let admin = user;

// user (변수)
// - null 할당
user = null;

// 객체
// - 도달 가능 · 참조 유지 (admin 변수)
//   - 메모리에 객체 유지
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **용어 : "강한 참조" · "약한 참조"**

##### 강한 참조
- 가비지 컬렉션 작동 대상 X
  - 참조 메모리 위치에 객체 · 값 저장
- JS
  - 일반적인 객체 참조
```javascript
// user (변수)
// - 강한 참조
let user = { name: "John" };
```

##### 약한 참조
- 가비지 컬렉션 작동 대상
- 약한 참조만 존재 시
  - 메모리에서 삭제

### `WeakRef` <sub>(객체)</sub>

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **주의**

##### 이번 학습에서 사용하는 구조
- 신중한 사용 필요
- 되도록 사용 지양

<br />

##### 어떤 객체에 대한 약한 참조 저장 객체
- 참조하는 어떤 객체
  - "타겟"
  - "지시 대상"

##### 특징
- "타겟" · "지시 대상" 객체
  - 가비지 컬렉터 작동 대상

##### 예제
- `user` <sub>(변수)</sub>
  - 지시 대상
- `admin` <sub>(변수)</sub>
  - `user` <sub>(변수)</sub> 에 대한 약한 참조
- `WeakRef` <sub>(객체)</sub> 생성자
  - 타겟 <sub>(지시 대상)</sub> 객체 인수 전달
```javascript
// user (변수)
// - 객체에 대한 강한 참조
let user = { name: "John" };

// admin (변수)
// - 객체에 대한 약한 참조
let admin = new WeakRef(user);
```
- `user` <sub>(변수)</sub>
  - 강한 참조
- `admin` <sub>(변수)</sub>
  - 약한 참조

![9weakref-finalizationregistry-01](../../images/01/14/07/weakref-finalizationregistry-01.svg)

##### 어느 순간
- `user` <sub>(변수)</sub> 사용 X
  - 값 덮어씌우기
  - 스코프 밖으로 이동
  - 기타 등등 등
- `admin` <sub>(변수)</sub>
  - 약한 참조 유지
```javascript
// user (변수)
// - null 값 할당
user = null;
```
- 객체에 대한 약한 참조
  - 객체 유지 불가능
- 약한 참조만 존재 시
  - 가비지 컬렉터 작동

##### 가비지 컬렉터 작동 전
- 약한 참조 유지 가능
  - 강한 참조 부재 상태
- 객체 상태
  - 슈뢰딩거의 고양이
  - 전혀 알 수 없음

![9weakref-finalizationregistry-02](../../images/01/14/07/weakref-finalizationregistry-02.svg)

##### `deref()` <sub>(메서드)</sub>
- 객체 삭제 전
  - `WeakRef` <sub>(객체)</sub> 참조 객체 반환
- 객체 삭제 후
  - `undefined` 반환
```javascript
let ref = admin.deref();

if (ref) {

  // 객체 아직 삭제 X
  // - 객체 대상 작업 가능

} else {

  // 객체 삭제 완료
  // - 가비지 컬렉터에 의해 제거됨

}
```

### `WeakRef` <sub>(객체)</sub> 유스 케이스

##### 일반적인 사용처
- 캐싱
- 연관 배열
  - 자원 집중적인 객체 저장

##### 기능
- 캐시 · 연관 배열 내 객체 존재 시
  - 가비지 컬렉터 작동하게끔 함

##### ex&#41; 수많은 이진 이미지 객체들
- `ArrayBuffer` · `Blob` 타입
- 각 파일별로 이름 · 경로 설정
- 기존 자료구조
  - 사용 부적합
- `Map`
  - 객체 저장 유지
  - 메모리 사용량 ↑
- `WeakMap`
  - 약한 참조 사용
  - 가비지 컬렉터 작동
- 약한 참조 사용 자료구조
  - 사용 적합

##### `Map` 컬렉션
- 값 : `WeakRef` 인스턴스
  - 용량 큰 객체 약한 참조
    - 오랫동안 저장 X
- '도달 가능한' 상태일 경우
  - 캐시에서 이미지 객체 얻기
- 캐시에서 삭제되었을 경우
  - 객체 재생성 · 재다운로드
- 메모리 사용량 절약

### 유스 케이스 1 : 캐싱

##### `Map`
- `key`
  - 문자열
- `value`
  - `WeakRef` <sub>(객체)</sub>
  - 가비지 컬렉션 대상

##### 가비지 컬렉션
- 동작 전
  - 캐시에서 가져오기
- 동작 후
  - 재다운드 후 캐시에 넣기
```javascript
function fetchImg() {

  // 이미지 다운로드 코드

}

// 고차원 함수
// - 인수 : 함수
// - 반환 : 함수
function weakRefCache(fetchImg) {

    // 캐시 (맵)
    // - key   : 이미지명
    // - value : WeakRef (객체)
    const imgCache = new Map();

    // 함수 반환
    // - 인수 : 이미지명
    //   - 캐시 내 이미지 가져올 때 사용
    return (imgName) => {

        // 캐시 내 이미지 가져오기
        // - key : 함수 인수
        const cachedImg = imgCache.get(imgName);

        // 캐시 내 키 (함수 인수) 해당 이미지
        // - 존재 · 아직 삭제 전
        //   - value 반환
        if (cachedImg?.deref()) {
            return cachedImg?.deref();
        }

        // 캐시 내 키 (함수 인수) 해당 이미지
        // - 부재 · deref() : undefined 반환
        //   - 재다운로드 실행
        const newImg = fetchImg(imgName);

        // 재다운로드된 이미지
        // - 캐시에 삽입 (WeakRef 객체)
        imgCache.set(imgName, new WeakRef(newImg));

        return newImg;
    };
}

const getCachedImg = weakRefCache(fetchImg);
```

##### `Map` 컬렉션
- `key`
  - 이미지명 <sub>(문자열)</sub>
- `value`
  - `WeakRef` <sub>(객체)</sub>
    - 이미지 보유

##### `WeakRef` 캐싱
- 자원 집중적인 객체
  - 너무 많은 메모리 할당 방지
- 캐시 내 객체 재사용
  - 메모리 · 시간 절약

![weakref-finalizationregistry-03](../../images/01/14/07/weakref-finalizationregistry-03.svg)

##### 단점
- `WeakRef` <sub>(객체)</sub> 참조 객체
  - 얼마 후 삭제됨

![weakref-finalizationregistry-04](../../images/01/14/07/weakref-finalizationregistry-04.svg)

##### 해결책
- 주기적으로 캐시 정리
  - 참조 사라진 해당 키 · 값 정리
- finalizers 사용

### 유스 케이스 2 : DOM 객체 추적

##### 서드파티 코드 · 라이브러리
- 개발 페이지 내 요소와 상호작용
  - 존재하는 동안
  - ex&#41; logger

```html
<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="index.css">
  <title>WeakRef DOM Logger</title>
</head>
<body>
  <div class="app">
    <button class="start-messages">Start sending messages</button>
    <div class="window">
      <div class="window__header">
        <p class="window__title">Messages:</p>
        <button class="window__button">Close</button>
      </div>
      <div class="window__body">
        No messages.
      </div>
    </div>
  </div>
  <script type="module" src="index.js"></script>
</body>
</html>
```
```javascript
// (1)
const startMessagesBtn = document.querySelector('.start-messages');

// (2)
const closeWindowBtn = document.querySelector('.window__button');

// (3)
const windowElementRef = new WeakRef(document.querySelector(".window__body"));

// (4)
startMessagesBtn.addEventListener('click', () => {
    startMessages(windowElementRef);
    startMessagesBtn.disabled = true;
});

// (5)
closeWindowBtn.addEventListener('click', () =>  document.querySelector(".window__body").remove());

const startMessages = (element) => {

    // (6)
    const timerId = setInterval(() => {

        // (7)
        if (element.deref()) {
            const payload = document.createElement("p");
            payload.textContent = `Message: System status OK: ${new Date().toLocaleTimeString()}`;
            element.deref().append(payload);

        // (8)
        } else {

            // (9)
            alert("The element has been deleted.");
            clearInterval(timerId);
        }
    }, 1000);
};
```
```css
.app {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.start-messages {
    width: fit-content;
}

.window {
    width: 100%;
    border: 2px solid #464154;
    overflow: hidden;
}

.window__header {
    position: sticky;
    padding: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #736e7e;
}

.window__title {
    margin: 0;
    font-size: 24px;
    font-weight: 700;
    color: white;
    letter-spacing: 1px;
}

.window__button {
    padding: 4px;
    background: #4f495c;
    outline: none;
    border: 2px solid #464154;
    color: white;
    font-size: 16px;
    cursor: pointer;
}

.window__body {
    height: 250px;
    padding: 16px;
    overflow: scroll;
    background-color: #736e7e33;
}
```
