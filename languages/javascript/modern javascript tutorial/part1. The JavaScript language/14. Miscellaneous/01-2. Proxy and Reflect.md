Reflect
=======

##### 내장 객체
- 프락시 생성 단순화

##### 내부 메서드
- ex&#41;
  - `[[Get]]`
  - `[[Set]]`
  - 기타 등등
- 명세서에만 정의
  - 직접 호출 X

##### `Reflect`
- 내부 메서드
  - 직접 호출 다소 가능
- 메서드
  - 내부 메서드 감싸는 단순 래퍼

|동작|`Reflect` 메서드|내부 메서드|
|---|---|---|
|`obj[prop]`|`Reflect.get(obj, prop)`|`[[Get]]`|
|`obj[prop] = value`|`Reflect.set(obj, prop, value)`|`[[Set]]`|
|`delete obj[prop]`|`Reflect.deleteProperty(obj, prop)`|`[[Delete]]`|
|`new F(value)`|`Reflect.construct(F, value)`|`[[Construct]]`|
|…|…|…|

```javascript
let user = {};

Reflect.set(user, 'name', 'John');

alert(user.name); // John
```

##### 연산자 : 함수처럼 호출 가능
- `new`
  - `Reflect.construct`
- `delete`
  - `Reflect.deleteProperty`
- 기타 등등

##### 프락시로 가로채는 모든 내부 메서드
- 상응 `Reflect` 메서드 존재
  - 이름 · 인수 동일
  - 동작 : 타겟 <sub>(객체)</sub> 전달

```javascript
let user = {
  name: "John",
};

user = new Proxy(user, {
  get(target, prop, receiver) {
    alert(`GET ${prop}`);

    // 프로퍼티 읽기
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, val, receiver) {
    alert(`SET ${prop}=${val}`);

    // 프로퍼티에 쓰기
    // - 성공 : true 반환
    // - 실패 : false 반환
    return Reflect.set(target, prop, val, receiver);
  }
});

let name = user.name; // shows "GET name"
user.name = "Pete";   // shows "SET name=Pete"
```

##### 트랩 : 단순 전달 역할 시
- `Reflect` 메서드 사용 <sub>(단순한 사용법)</sub>
  - 메서드명 동일
  - 인수 동일

##### 트랩 vs `Reflect`
- 대게 동일
  - 미묘한 차이 존재
```javascript
// 동일
return Reflect.get(target, prop, receiver);
return target[prop];
```

### getter 가로채기
- `user` <sub>(객체)</sub>
  - `_name` <sub>(프로퍼티)</sub>
  - `_name` getter
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {
    return target[prop];
  }
});

alert(userProxy.name); // Guest
```

##### `get` 트랩
- 동작 : 투명 <sub>('transparent')</sub>
  - 기존 프로퍼티 그대로 반환
  - 추가 동작 X

##### 객체 상속
- `admin` <sub>(객체)</sub> → `userProxy` <sub>(프락시)</sub>
  - 비정상 동작 발생
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {

    // 타겟 == user (객체)
    return target[prop];
  }
});

let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

alert(admin.name); // Guest
```
- `admin.name` <sub>(프로퍼티)</sub> 읽기
  - `"Guest"` 반환

##### `"Guest"` 반환 이유
1. `admin` <sub>(자식 객체)</sub>
    - `name` <sub>(프로퍼티)</sub> 부재
2. 프로토타입에서 프로퍼티 찾기
    - `userProxy` <sub>(프락시)</sub>
3. 프로토타입 프로퍼티 읽기
    1. `get` 트랩 트리거
    2. `target[prop]` 반환
        - `user` <sub>(부모 객체)</sub> 프로퍼티

##### `receiver` <sub>(3번째 인수)</sub>
- 원래 `this` 값 보유

##### `this` 값 : getter 전달 시
- `call` · `apply` X
  - 함수 X
  - 프로퍼티 접근
- `Reflect.get` <sub>(메서드)</sub> 사용
```javascript
let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {

  // receiver = admin (자식 객체)
  get(target, prop, receiver) {
    return Reflect.get(target, prop, receiver);
//  return Reflect.get(...arguments);
}
  }
});


let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

alert(admin.name); // Admin
```

##### `Reflect` 메서드
- 트랩 이름 · 인수 동일
  - 의도된 설계
- 단순 동작 제공
  - 포워딩 등

### 프락시 한계

#### 내장 객체 내부 공간

##### '내부 공간'
- 대부분의 내장 객체 사용
  - `Map`
  - `Set`
  - `Date`
  - `Promise`
  - 기타 등등
- 프로퍼티 유사
  - 내부 사용 · 명세서 전용
- ex&#41; `Map` 요소 저장 위치
  - `[[MapData]]` <sub>(내부 공간)</sub>
- 내장 메서드
  - 내부 공간 직접 접근
- 내부 메서드 <sub>(`[[Get]]` · `[[Set]]` 등)</sub>
  - 내부 공간 직접 접근 X
- 프락시로 가로채기
  - 정상 동작 X

##### 내장 객체 : 프락시로 감싸기
- 프락시 <sub>(객체)</sub>
  - 내부 공간 X
  - 내장 메서드 정상 동작 X
```javascript
let map = new Map();
let proxy = new Proxy(map, {});

// 프락시 (객체)
// - `[[MapData]]` (내부 공간) X
//   - 요소 저장 X
proxy.set('test', 1); // 에러 발생
```
##### `[[MapData]]` <sub>(내부 공간)</sub>
- `Map` 요소 저장 위치
- 프락시 <sub>(객체)</sub>
  - 보유 X

##### `Map.prototype.set` <sub>(내장 메서드)</sub>
- 내부 프로퍼티 접근 시도
  - `this.[[MapData]]`
- `this` == 프락시 <sub>(객체)</sub>
  - 메서드 정상 작동 X

##### 해결책
- 함수 프로퍼티 바인딩
```javascript
let map = new Map();

let proxy = new Proxy(map, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});

proxy.set('test', 1);
alert(proxy.get('test')); // 1, 내장 메서드 정상 작동
```

##### `get` <sub>(트랩)</sub>
- 함수 프로퍼티 바인딩
  - → 타겟 <sub>(객체)</sub>

##### 프락시 <sub>(객체)</sub> : 내장 메서드 호출 시 `this` 값
- ex&#41; `proxy.set( … )`
  - 프락시 <sub>(객체)</sub> X
  - 타겟 <sub>(객체)</sub>
- 내장 메서드
  - `this.[[MapData]]` 접근 성공

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **배열 : 내부 공간 X**

##### 특이 예외 <sub>(역사적 이유)</sub>
- 내장 배열
  - 내부 공간 X

<br />

### `private` 필드

##### `private` 클래스 필드
- 내장 메서드 유사 상황 발생

##### `getName()` <sub>(메서드)</sub>
- `#name` <sub>(`private` 프로퍼티)</sub> 접근
- 프락시로 감싸기
  - 동작 실패
```javascript
class User {
  #name = "Guest";

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {});

alert(user.getName()); // 에러 발생
```

##### `private` 필드
- 내부 공간 이용해 구현
- 접근 시
  - 내부 메서드 사용 X
    - `[[Get]]`
    - `[[Set]]`

##### `getName()` <sub>(메서드)</sub> 호출 시 `this` 값
- 프락시 <sub>(객체)</sub>
  - 내부 공간 X
  - `private` 필드 X

##### 해결책
- 함수 프로퍼티 바인딩
```javascript
class User {
  #name = "Guest";

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});

alert(user.getName()); // Guest
```

##### 바인딩 단점
- 타겟 <sub>(객체)</sub> : 메서드에 노출
  - 다른 곳에 전달 가능성 ↑
  - 프락시 기능 고장 가능성 ↑

### 프락시 <sub>(객체)</sub> ≠ 타겟 <sub>(객체)</sub>

##### 키 객체 : 프락시로 감싸기
- 키 객체 사라짐
```javascript
let allUsers = new Set();

class User {
  constructor(name) {
    this.name = name;
    allUsers.add(this);
  }
}

let user = new User("John");

alert(allUsers.has(user)); // true

user = new Proxy(user, {});

alert(allUsers.has(user)); // false
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **프락시 <sub>(객체)</sub> : 객체 일치 연산 <sub>(`===`)</sub> 가로채기 X**

##### 대부분의 연산자
- 가로채기 가능
  - `new` <sub>(`construct`)</sub>
  - `in` <sub>(`has`)</sub>
  - `delete` <sub>(`deleteProperty`)</sub>
  - 기타 등등

##### 객체 일치 연산 <sub>(`===`)</sub>
- 가로채기 X
- 객체
  - 엄밀히 자기자신 외에 불일치

##### 객체 비교하는 모든 연산자 · 내장 클래스
- 객체 · 프락시 <sub>(객체)</sub> 구분
  - 투명한 대체 X

<br />

### 취소 가능 프락시 <sub>(객체)</sub>
- 비활성화 가능 프락시 <sub>(객체)</sub>
- 언제든지 비활성화 가능 <sub>(트랩 X)</sub>
  - ex&#41; 리소스 액세스 닫기 등

##### 문법
```javascript
let { proxy, revoke } = Proxy.revocable(target, handler)
```

##### 반환 값
- `proxy`
  - 프락시 <sub>(객체)</sub>
- `revoke`
  - 취소 함수 <sub>(프락시 비활성화)</sub>
```javascript
let object = {
  data: "Valuable data"
};

let {proxy, revoke} = Proxy.revocable(object, {});

// 원본 (객체) 대신 프락시 (객체) 전달
alert(proxy.data); // "Valuable data"

// 프락시 비활성화
revoke();

// 프락시 작동 X
// - revoked
alert(proxy.data); // 에러 발생
```

##### `revoke()` 호출 시
- 내부 참조 제거
  - 프락시 <sub>(객체)</sub> → 타겟 <sub>(객체)</sub>
  - 두 객체 연결 X
- 타겟 <sub>(객체)</sub>
  - 이후 가비지 컬렉터에 의해 제거

##### `WeakMap`
- `revoke` <sub>(함수)</sub> 저장
  - 키 : 프락시 <sub>(객체)</sub>
```javascript
let revokes = new WeakMap();

let object = {
  data: "Valuable data"
};

let {proxy, revoke} = Proxy.revocable(object, {});

revokes.set(proxy, revoke);

// WeakMap
// - revoke (함수) 찾은 후 호출
// - 키 : proxy (객체)
revoke = revokes.get(proxy);
revoke();

alert(proxy.data); // 에러 발생 (revoked)
```

#### `WeakMap` · `reovke` <sub>(함수)</sub>

##### `reovke` <sub>(함수)</sub> 신경 X
- `WeakMap` 저장
- 필요할 때 프락시 <sub>(객체)</sub> 로 찾기

##### 프락시 <sub>(객체)</sub> : '도달 불가능' 상태
- `Map`
  - 가비지 컬렉션 작동 X
- `WeakMap`
  - 가비지 컬렉션 작동
    - 프락시 <sub>(객체)</sub> 제거
    - `revoke` <sub>(함수)</sub> 제거

### 참조 <sub>(Proxy)</sub>
- [명세](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots)
- [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

<br />

## 요약
The [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) API is designed to complement [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). For any `Proxy` trap, there’s a `Reflect` call with same arguments. We should use those to forward calls to target objects.

Proxies have some limitations:
- Built-in objects have “internal slots”, access to those can’t be proxied. See the workaround above.
- The same holds true for private class fields, as they are internally implemented using slots. So proxied method calls must have the target object as `this` to access them.
- Object equality tests `===` can’t be intercepted.
- Performance: benchmarks depend on an engine, but generally accessing a property using a simplest proxy takes a few times longer. In practice that only matters for some “bottleneck” objects though.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 존재하지 않는 프로퍼티를 읽으려고 할 때 에러 던지기
존재하지 않는 프로퍼티 값을 읽으려고 하면 보통은 `undefined`가 반환됩니다.

`undefined` 대신 에러를 던지는 프락시를 만들어봅시다.

이렇게 해 놓으면 프로그래밍 중에 저지르는 실수를 미연에 방지할 수 있을 겁니다.

객체 `target`을 받는 함수 `wrap(target)`를 만들고 위에서 언급한 기능을 구현하여 함수 `wrap(target)`이 프락시를 반환하도록 해보세요.

함수는 아래와 같이 동작해야 합니다.
```javascript
let user = {
  name: "John"
};

function wrap(target) {
  return new Proxy(target, {
      /* 여기에 코드를 작성하세요. */
  });
}

user = wrap(user);

alert(user.name); // John
alert(user.age); // ReferenceError: Property doesn't exist "age"
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
let user = {
  name: "John"
};

function wrap(target) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      } else {
        throw new ReferenceError(`Property doesn't exist: "${prop}"`)
      }
    }
  });
}

user = wrap(user);

alert(user.name); // John
alert(user.age); // ReferenceError: Property doesn't exist "age"
```

<hr />

### 음수 인덱스를 사용해 배열 요소에 접근하기
몇몇 프로그래밍 언어는 음수 인덱스를 사용해 배열 끝을 기준으로 요소에 접근할 수 있게 해줍니다.

아래와 같이 말이죠.
```javascript
let array = [1, 2, 3];

array[-1]; // 3, 마지막 요소
array[-2]; // 2, 뒤에서 두 번째 요소
array[-3]; // 1, 뒤에서 세 번째 요소
```

위 예시에서 `array[-N]`는 `array[array.length - N]`와 동일합니다.

이렇게 음수 인덱스를 사용해 배열 요소에 접근할 수 있도록 해주는 프락시를 만들어봅시다.

최종 결과는 아래 조건을 만족해야 합니다.
```javascript
let array = [1, 2, 3];

array = new Proxy(array, {
  /* 여기에 코드를 작성하세요. */
});

alert( array[-1] ); // 3
alert( array[-2] ); // 2

// 배열 기능은 "변함없이 그대로" 동작해야 합니다.
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
let array = [1, 2, 3];

array = new Proxy(array, {
  get(target, prop, receiver) {
    if (prop < 0) {
      // arr[1] 같은 형태로 배열 요소에 접근하는 경우에도
      // prop은 문자열이기 때문에 숫자로 바꿔줘야 합니다.
      prop = +prop + target.length;
    }
    return Reflect.get(target, prop, receiver);
  }
});

alert(array[-1]); // 3
alert(array[-2]); // 2
```

<hr />

### `Observable` 만들기
프락시를 반환해 ‘객체를 observable 하게 만들어주는’ 함수 `makeObservable(target)`를 만들어보세요.

최종 결과는 아래 조건을 만족해야 합니다.
```javascript
function makeObservable(target) {
  /* 여기에 코드를 작성하세요. */
}

let user = {};
user = makeObservable(user);

user.observe((key, value) => {
  alert(`SET ${key}=${value}`);
});

user.name = "John"; // alerts: SET name=John
```

`makeObservable`가 반환하는 객체는 기존 객체와 동일하지만 프로퍼티가 변경될 때 호출되는 함수인 `handler`를 설정해주는 메서드 `observe(handler)`가 있어야 합니다.

프로퍼티가 변경될 때마다 프로퍼티 키와 값을 인수로 받는 메서드 `handler(key, value)`가 호출되어야 하죠.

참고: 이 문제에선 프로퍼티에 값을 쓰려는 경우만 고려해서 답을 작성해보세요. 읽기 등의 동작은 유사한 방법을 사용해 구현할 수 있습니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

해답은 크게 두 부분으로 구성됩니다.

1. `.observe(handler)`이 호출될 때마다 핸들러를 어딘가에 보관해두고 나중에 호출될 수 있도록 해야 하는데, 심볼을 프로퍼티 키로 사용해 핸들러를 객체에 저장할 수 있게 해 보았습니다.
2. 변경이 있을 때마다 핸들러가 호출되도록 `set` 트랩이 있는 프락시를 만들어 보았습니다.
```javascript
let handlers = Symbol('handlers');

function makeObservable(target) {
  // 1. 핸들러를 저장할 곳을 초기화합니다.
  target[handlers] = [];

  // 나중에 호출될 것을 대비하여 핸들러 함수를 배열에 저장합니다.
  target.observe = function(handler) {
    this[handlers].push(handler);
  };

  // 2. 변경을 처리할 프락시를 만듭니다.
  return new Proxy(target, {
    set(target, property, value, receiver) {
      let success = Reflect.set(...arguments); // 동작을 객체에 전달합니다.
      if (success) { // 에러 없이 프로퍼티를 제대로 설정했으면
        // 모든 핸들러를 호출합니다.
        target[handlers].forEach(handler => handler(property, value));
      }
      return success;
    }
  });
}

let user = {};

user = makeObservable(user);

user.observe((key, value) => {
  alert(`SET ${key}=${value}`);
});

user.name = "John";
```
