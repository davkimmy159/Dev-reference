객체로서의 함수 · 기명 함수 표현식
===============================

##### 함수
- 호출 가능한 <sub>(callable)</sub> '행동 객체'
- 프로퍼티 추가 · 제거 · 참조 통해 전달

### `name` <sub>(프로퍼티)</sub>
- 함수 이름
```javascript
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
```
- 익명 함수
  - 자동 이름 할당
```javascript
let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi
```
- 기본값 사용
  - 자동 이름 할당
```javascript
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi
}

f();
```

##### 'contextual name'
- 익명 함수
  - 컨텍스트에서 이름 가져옴
- JS 명세서 정의 기능

##### 객체 메서드 이름
```javascript
let user = {

  sayHi() {
    // …
  },

  sayBye: function() {
    // …
  }

}

alert(user.sayHi.name);  // sayHi
alert(user.sayBye.name); // sayBye
```

##### 객체 메서드
- 이름 자동 할당 X
  - 적절한 이름 추론 불가능한 상황 有
- 이름 추론 불가능 시
  - `name` <sub>(프로퍼티)</sub>
    - `""` <sub>(빈 문자열)</sub> 할당

##### 실무
- 대부분의 함수
  - 이름 존재
- 빈 메서드 이름 발생 빈도 ↓
```javascript
// 배열 내 함수 생성
let arr = [function() {}];

// 엔진 : 함수명 설정 불가능
// name (프로퍼티) 값
// - "" (빈 문자열)
alert( arr[0].name ); // "" (빈 문자열)
```

### `length` <sub>(프로퍼티)</sub>
- 함수 매개변수 개수
```javascript
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length);   // 1
alert(f2.length);   // 2
alert(many.length); // 2
```
- 나머지 매개변수
  - 개수 포함 X
- 함수 내 동작 함수 타입 검사에 종종 사용
```javascript
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

/*
 OK 클릭
 - 핸들러 2개 모두 호출
 Cancel 클릭
 - 2번째 핸들러만 호출
 */
ask("질문 있으신가요?", () => alert('OK를 선택하셨습니다.'), result => alert(result));
```

##### 다형성 <sub>(polymorphism)</sub>
- 인수 종류 따라 인수 다르게 처리

### 커스텀 프로퍼티
- 함수에 자체 프로퍼티 추가
```javascript
function sayHi() {
  alert("Hi");

  // 함수 호출 수 카운트
  sayHi.counter++;
}
sayHi.counter = 0; // 초깃값

sayHi(); // Hi
sayHi(); // Hi

alert( `호출 횟수: ${sayHi.counter}회` ); // 호출 횟수: 2회
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **함수 프로퍼티 ≠ 변수**

##### 함수 프로퍼티 할당
- `sayHi.counter = 0`
- 함수 내 `let counter` <sub>(지역 변수)</sub> X
- `.counter` <sub>(프로퍼티)</sub> ≠ `let counter` <sub>(변수)</sub>
- 함수 == 객체
  - 실행에 아무 영향 X

<br />

- 함수 프로퍼티
  - 클로저 대체
```javascript
function makeCounter() {

  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
/*
 count (프로퍼티)
 - 외부 렉시컬 환경 X
 - 함수 프로퍼티에 값 저장
 */
```

##### 클로저 vs 함수 프로퍼티
- 클로저
  - 외부 코드 : 접근 · 값 수정 X
  - 중첩 함수 내에서만 가능
- 함수 프로퍼티
  - 외부 코드 : 접근 · 값 수정 가능
- 목적 따라 구현 방법 선택
```javascript
function makeCounter() {

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

// 외부 코드 접근 · 값 수정
counter.count = 10;

alert( counter() ); // 10
```

### 기명 함수 표현식
- Named Function Expression <sub>(NFE)</sub>
- 이름 있는 함수 표현식
```javascript
// 일반 함수 표현식
let sayHi1 = function(who) {
  alert(`Hello, ${who}`);
};

sayHi1("John"); // Hello, John

// 기명 함수 표현식
let sayHi2 = function func(who) {
  alert(`Hello, ${who}`);
};

sayHi2("John"); // Hello, John
```

##### 이름 붙여도 여전히 함수 표현식
- 표현식 할당 형태 유지
- 함수 선언문 형태 X

##### 2가지 변화
- 함수 표현식 내부
  - 자기 자신 참조 가능 <sub>(이름 사용)</sub>
- 함수 표현식 외부
  - 참조 불가능 <sub>(이름 사용 X)</sub>
```javascript
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {

    // 'func' (이름) 사용해 자신 호출
    func("Guest");
  }
};

sayHi(); // Hello, Guest

// 함수 표현식 외부
// - 함수 이름 접근 X
func(); // Error, func is not defined
```
- 기명 함수 표현식 미사용 시
  - 외부 코드 의해 코드 변경 가능
```javascript
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // TypeError: sayHi is not a function
  }
};

/* 함수 표현식 할당 직후
 1. 함수 표현식 : 새로운 변수에 할당
 2. 기존 변수 : null 할당
  - 에러 발셍
 */
let welcome = sayHi;
sayHi = null;

welcome(); // 중첩 sayHi 호출 : 더 이상 불가능
```

##### `sayHi` 찾는 과정
1. 지역 렉시컬 환경 검색
    - `sayHi` 부재
2. 외부 렉시컬 환경 검색
    - `sayHi` 부재
      - `null` 할당 <sub>(함수 호출 시점)</sub>

##### 문제 해결
- 기명 함수 표현식
```javascript
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // 값 제대로 출력
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (중첩 호출 제대로 동작)
```

##### `func` <sub>(함수 이름)</sub>
- 함수 지역 수준 <sub>(function-local)</sub> 존재
- 외부 렉시컬 환경
  - 검색 불필요
  - 보이지도 않음

##### 함수 표현식 이름
- 현재 함수만 참조 가능 <sub>(명세서 정의)</sub>

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **함수 선언문 : 내부 이름 지정 <sub>(사용)</sub> X**

##### 함수 선언문
- 내부 이름 지정 문법 X
- 믿을만한 내부 이름 필요 시
  - 기명 함수 표현식 사용

<br />

## 요약
함수는 객체입니다.

이번 챕터에선 객체로서의 함수에서 사용 할 수 있는 프로퍼티 두 가지를 다뤄보았습니다.
- `name` – 함수의 이름이 저장됩니다. 대개는 함수 선언부에서 이름을 가져오는데, 선언부에 이름이 없는 경우엔 자바스크립트 엔진이 컨텍스트(할당 등)를 이용해 이름을 추론합니다.
- `length` – 함수 선언부에 있는 인수의 수로 나머지 매개변수는 포함되지 않습니다.

함수 표현식으로 함수를 정의하였는데 이름이 있다면 이를 기명 함수 표현식이라 부릅니다. 기명 함수 표현식의 이름은 재귀 호출과 같이 함수 내부에서 자기 자신을 호출하고자 할 때 사용할 수 있습니다.

함수엔 다양한 프로퍼티를 추가할 수 있습니다. 널리 쓰이는 자바스크립트 라이브러리 상당수에서 이런 커스텀 프로퍼티를 잘 활용하고 있습니다.

이런 라이브러리들은 '주요' 함수 하나를 만들고 여기에 다양한 '헬퍼' 함수를 붙이는 식으로 구성됩니다. [`jQuery`]는 이름이 `$`인 주요 함수로 이루어져 있습니다. [`lodash`]는 주요 함수 `_`에 `_.clone`, `_.keyBy`등의 프로퍼티를 추가하는 식으로 구성되죠. 자세한 정보는 [lodash 공식 문서](https://lodash.com/docs/4.17.15)에서 찾아볼 수 있습니다. 이렇게 함수 하나에 다양한 헬퍼 함수를 붙여 라이브러리를 만들면 라이브러리 하나가 전역 변수 하나만 사용하므로 전역 공간을 더럽히지 않는다는 장점이 있습니다. 이름 충돌도 방지할 수 있죠.

이렇게 객체로서의 함수 특징을 이용해 커스텀 프로퍼티를 만들면 함수는 자기 자신을 이용해 원하는 일을 수행할 수 있고, 함수 자기 자신에 딸린 프로퍼티의 기능도 사용할 수 있다는 장점이 있습니다.

과제

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 숫자 설정과 감소가 가능한 counter 만들기
다음 `makeCounter()`코드를 수정해서 카운터가 감소하고 숫자를 설정하게 해보세요.
- `counter()`는 다음 숫자를 반환해야 합니다.
- `counter.set(value)`는 `counter`를 `value`로 설정해야 합니다.
- `counter.decrease()`는 `counter`를 `1` 감소시켜야 합니다.

아래 링크를 클릭해 sandbox에 작성된 코드를 보고, 사용법을 살펴보세요.

참고: 클로저 또는 함수 프로퍼티를 사용해 `counter` 값을 저장할 수 있습니다. 두 가지 방법을 모두 사용해 답안을 두 개 만드셔도 됩니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

아래 답안은 지역변수 `count`를 사용하고 있는데, 추가 메서드는 함수 `counter`에 정의하고 있습니다. 함수 `counter`에 할당한 메서드들은 동일한 외부 렉시컬 환경을 공유하고 동일한 `count`에 접근할 수 있습니다.
```javascript
function makeCounter() {
  let count = 0;

  function counter() {
    return count++;
  }

  counter.set = value => count = value;

  counter.decrease = () => count--;

  return counter;
}
```

[정답](https://plnkr.co/edit/Db8grLifp3NXpxCr?p=preview)

<hr />

### 임의의 수만큼 있는 괄호를 이용해 합계 구하기
다음과 같이 작동하는 함수 `sum`을 만들어보세요.
```javascript
sum(1)(2) == 3; // 1 + 2
sum(1)(2)(3) == 6; // 1 + 2 + 3
sum(5)(-1)(2) == 6
sum(6)(-1)(-2)(-3) == 0
sum(0)(1)(2)(3)(4)(5) == 15
```

힌트: 해당 함수 내부에서 쓸 수 있는 객체-원시형으로의 형 변환을 직접 구현해야 할 수도 있습니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

1. `sum`은 함수를 반환해야만 이 모든 것이 _의도한 대로_ 동작합니다.
2. `sum`이 반환하는 함수는 호출될 때마다 현재 값을 메모리에 저장하고 있어야 합니다.
3. 함수는 `==` 를 만났을 때 숫자가 되어야 합니다. 함수는 객체이므로 객체를 원시형으로 변환하기 챕터에서 설명한 것처럼, 객체-원시형으로의 형 변환이 일어날 텐데, 이때 메서드를 직접 구현해 원하는 대로 객체-원시형으로의 형 변환이 일어나게 할 수 있습니다.

답안은 아래와 같습니다.
```javascript
function sum(a) {

  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15
```

함수 `sum`은 실제로 한 번만 동작한다는 사실에 주목하시기 바랍니다. 함수 `sum`은 함수 `f`를 반환합니다.

이어지는 호출에서 함수 `f`는 매개변수를 `currentSum`에 추가하고 자신을 반환합니다.

**`f`의 마지막 줄에는 재귀가 없습니다.**

재귀가 있었다면 아래와 같이 생겼을 겁니다.
```javascript
function f(b) {
  currentSum += b;
  return f(); // <-- 재귀 호출
}
```

위 함수 `f`는 호출 없이 자기 자신을 그대로 반환합니다.
```javascript
function f(b) {
  currentSum += b;
  return f; // <-- 자신을 호출하지 않고 반환만 합니다.
}
```

이렇게 자기 자신을 호출하지 않고 반환만 하면 다음 호출에서 함수 `f`를 사용할 수 있고, 자기 자신을 또다시 반환해 원하는 만큼 이 과정을 반복할 수 있습니다. `toString` 은 `currentSum` 을 반환해주므로 반환된 함수(객체)를 숫자 혹은 문자열로도 사용할 수 있죠. `Symbol.toPrimitive`나 `valueOf`를 사용해 객체를 숫자나 문자열로 변환할 수도 있습니다.
```javascript
function sum(a) {

  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}
```

[정답](https://plnkr.co/edit/iZJ5mjNcyV8wsJsP?p=preview)
