변수 유효범위 · 클로저
======================

##### JS : 함수 지향 언어
- 많은 자유
- 함수 동적 생성
- 생성한 함수
  - 다른 함수 인수 전달
- 생성된 곳 아닌 다른 곳에서 함수 호출

### `{ … }` <sub>(코드 블록)</sub>

##### `{ … }` <sub>(코드 블록)</sub> 내 선언 변수
- 블록 안에서만 사용 가능
```javascript
// 지역 변수 선언 후 몇 가지 조작
// - 그 결과 밖에서 볼 수 없음
{
  let message = "안녕하세요."; // 블록 내에서만 접근 가능

  alert(message); // 안녕하세요.
}

alert(message);   // ReferenceError: message is not defined
```

##### 블록 특징
- 특정 작업 수행 코드 묶는 용도
- 블록 내 작업 수행 전용 변수 생성
```javascript
{
  // 메시지 출력
  let message = "안녕하세요.";
  alert(message);
}

{
  // 또 다른 메시지 출력
  let message = "안녕히 가세요.";
  alert(message);
}
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **블록 없으면 에러 발생**

##### 기존 선언 변수 동명 변수
- `{ … }` <sub>(블록)</sub> 없이 선언 시
  - 에러 발생
```javascript
// 메시지 출력
let message = "안녕하세요.";
alert(message);

// 또 다른 메시지 출력
// 에러 발생
// - SyntaxError: Identifier 'message' has already been declared
let message = "안녕히 가세요.";
alert(message);
```

<br />

##### 블록 내 선언 변수
- 블록 안에서만 접근 가능
- `if` · `for` · `while` <sub>(문)</sub>
```javascript
if (true) {
  let phrase = "안녕하세요!";

  alert(phrase); // 안녕하세요!
}

// if (문) 블록 밖 alert (함수)
// - phrase (변수) 접근 X
alert(phrase); // ReferenceError: phrase is not defined
```

##### 변수 유효 범위
- 블록 범위 한정
  - `if` · `for` · `while` <sub>(문)</sub> 유용
```javascript
for (let i = 0; i < 3; i++) {
  // i (변수)
  // - for (문) 안에서만 유효
  alert(i); // 0, 1, 2
}

alert(i); // ReferenceError: i is not defined
```

### 중첩 함수

##### 함수 내부 선언 함수
- 코드 정돈 시 사용
```javascript
function sayHiBye(firstName, lastName) {

  // helper (헬퍼 중첩 함수)
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );

}
```

##### 객체 프로퍼티 형태 · 중첩 함수 자체
- 반환 가능한 값

##### 반환된 중첩 함수
- 어디서든 호출해 사용 가능
- 외부 변수 여전히 접근 가능
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

### 렉시컬 환경

#### 단계 1. 변수

##### 렉시컬 환경 <sub>(내부 숨김 연관 객체)</sub> 내 구성 요소
- 실행 중인 함수
- `{ … }` <sub>(코드 블록)</sub>
- 스크립트 전체

##### 렉시컬 환경 <sub>(객체)</sub> 구성 <sub>(2가지)</sub>
- **환경 레코드 <sub>(특수 내부 객체)</sub>**
  - 모든 지역 변수 저장
    - 레코드 객체 프로퍼티
  - 기타 정보 저장
    - `this` 값
    - 기타 등등
- **외부 렉시컬 환경 참조**
  - 외부 코드 연관

##### 변수 == 환경 레코드 프로퍼티
- 변수 읽기 · 변경
  - 환경 레코드 프로퍼티 읽기 · 변경

##### 스크립트 전체 관련 렉시컬 환경
- 전역 렉시컬 환경
- 외부 참조
  - `null`

![lexical-environment-global](../../images/01/06/03/lexical-environment-global.svg)

##### 실행 흐름 진행 시
- 렉시컬 환경 변화

#### 스크립트 시작 시

##### 1. 스크립트 내 선언 변수
- 전역 렉시컬 환경 올라감 <sub>(pre-populated)</sub>
- uninitialized <sub>(특수 내부 상태)</sub>

##### JS 엔진
- uninitialized <sub>(상태)</sub> 변수 인지
- `let` 등장 전까지 변수 참조 X

##### 2. `let phrase` 등장 <sub>(값 할당 전)</sub>
- 값 : `undefined`
- `phrase`
  - 이 시점 이후 사용 가능

##### 3. `phrase` 값 할당

##### 4. `phrase` 값 변경

![closure-variable-phrase](../../images/01/06/03/closure-variable-phrase.svg)

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **렉시컬 환경 : 명세서에만 존재**

##### 명세서 내 동작 방식 설명 위한 이론상 객체
- 직접 렉시컬 환경 얻기 · 조작 불가능

##### JS 엔진들 : 렉시컬 환경 최적화 노력
- 명세서 언급 사항 준수
- 엔진 고유 방법 사용
- 메모리 절약
  - 미사용 변수 버기기
- 다양한 내부 트릭
- 기타 등등

<br />

#### 단계 2. 함수 선언문
- 함수 == 값 <sub>(== 변수)</sub>

##### 차이
- 함수 선언문 선언 함수
  - 바로 초기화
  - 렉시컬 환경 생성 즉시 사용 가능
    - 선언 전 함수 사용 가능 이유
- 일반 변수
  - `let` 등장 · 선언 전 사용 X

##### 전역 렉시컬 환경 초기 상태 변화
- 스크립트에 함수 추가 시

![closure-function-declaration](../../images/01/06/03/closure-function-declaration.svg)


##### 함수 선언문 정의 함수에만 적용
- 함수 표현식 <sub>(함수 → 변수 할당)</sub> 해당 X
  - ex&#41; `let say = function(name) …`

#### 단계 3. 내부 · 외부 렉시컬 환경

##### 함수 호출 · 실행 시
- 새 렉시컬 환경 자동 생성
  - 전달 받은 매개변수 저장
  - 함수 지역 변수 저장

##### 함수 호출 중 내부 상태
- <sub>(호출 중인)</sub> 함수 내부 렉시컬 환경
- 함수 외부 렉시컬 환경
  - 내부 렉시컬 환경이 참조

##### `say("John")` <sub>(함수)</sub> 호출 시 내부 변화

![lexical-environment-simple](../../images/01/06/03/lexical-environment-simple.svg)

##### 내부 렉시컬 환경
- `say` <sub>(현재 실행 중 함수)</sub> 상응
- 프로퍼티 1개 보유
  - `name` <sub>(함수 인자)</sub> 유래
  - 값 : `"John"` <sub>(`say("John")` 호출)</sub>
- 외부 렉시컬 환경 참조 보유

##### 외부 렉시컬 환경
- == 전역 렉시컬 환경
- 프로퍼티 2개 보유
  - `phrase` <sub>(변수)</sub>
  - `say` <sub>(함수)</sub>

#### 코드에서 변수 접근 과정

##### 1. 검색 범위 설정
1. 내부 렉시컬 환경
2. 외부 렉시컬 환경 확장
    - 내부 렉시컬 환경 참조
3. 전역 렉시컬 환경 확장 때까지 반복

##### 2. 전역 렉시컬 환경 도달 후 변수 부재 시
- 엄격 모드
  - 에러 발생
- 비 엄격 모드
  - 새 전역 변수 생성 <sub>(에러 발생 X)</sub>
    - 하위 호환성

#### 예시 정리 : `alert` <sub>(`say` 내부)</sub>

##### `name` <sub>(변수)</sub>
1. 내부 렉시컬 환경 검색
    - 찾음
    - 상응 프로퍼티 <sub>(`name` )</sub> 존재

##### `phrase` <sub>(변수)</sub>
1. 내부 렉시컬 환경 검색
    - 못 찾음
    - 상응 프로퍼티 <sub>(`phrase` )</sub> 부재
2. 외부 렉시컬 환경 검색 <sub>(범위 확장)</sub>
    - 찾음

![lexical-environment-simple-lookup](../../images/01/06/03/lexical-environment-simple-lookup.svg)

#### 단계 4. 함수 반환하는 함수

##### 모든 함수
- 렉시컬 환경 <sub>(생성 위치)</sub> 기억
  - 호출 장소 상관 X

##### `[[Environment]]` <sub>(숨김 프로퍼티)</sub>
- 렉시컬 환경 <sub>(함수 생성 위치)</sub> 참조 저장
- 함수 생성 시 값 설정
  - 이후 변경 X
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

##### `makeCounter` 호출 시
- 매번 새 렉시컬 환경 객체 생성
  - 함수 실행 필요 변수들 저장
- 렉시컬 환경 2개 생성

![closure-makecounter](../../images/01/06/03/closure-makecounter.svg)

##### `makeCounter` 실행 중
- 중첩 함수 생성 <sub>(실행 X)</sub>
- `counter.[[Environment]]` <sub>(중첩 함수)</sub>
  - 외부 렉시컬 환경 참조 저장
  - `{count: 0}` <sub>(`makeCounter` 함수)</sub>

![closure-makecounter-environment](../../images/01/06/03/closure-makecounter-environment.svg)

##### `counter` 호출 시
- 매번 새 렉시컬 환경 생성
- 새 렉시컬 환경 → 외부 렉시컬 환경 참조
  - `counter.[[Environment]]`
  - `{count: 0}` <sub>(`makeCounter` 함수)</sub>

![closure-makecounter-nested-call](../../images/01/06/03/closure-makecounter-nested-call.svg)

##### 실행 흐름 : 중첩 함수 본문 도달
- `count` <sub>(변수)</sub> 필요
1. 자체 렉시컬 환경 검색
    - 비어있음
- 익명 중첩 함수
  - 지역 변수 X
2. 외부 렉시컬 환경 <sub>(← 자체 렉시컬 환경 참조)</sub> 검색
    - `counter.[[Environment]]`
    - `{ count: 0 }` <sub>(`makeCounter` 함수)</sub>
      - `count` <sub>(변수)</sub> 발견
3. `count++` 실행 · `count` 값 1 증가
    - 변숫값 갱신
    - 변수 저장된 렉시컬 환경에서 실행

![closure-makecounter-nested-call-2](../../images/01/06/03/closure-makecounter-nested-call-2.svg)

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **클로저**

##### 외부 변수 기억 · 접근 가능 함수
- JS 모든 함수
  - 자연스럽게 클로저
- 예외 하나 존재
  - `new Function` 문법

<br />

### 가비지 컬렉션

##### 함수 호출 종료 시
- 제거 대상
  - 함수 대응 렉시컬 환경
  - 모든 함수 관련 변수
- 관련 변수 참조 불가능

##### 호출 종료 후 여전히 '도달 가능한' 중첩 함수
- 중첩 함수 `[[Environment]]` <sub>(숨김 프로퍼티)</sub>
  - 외부 함수 렉시컬 환경 정보 저장
    - '도달 가능한' 상태
- 함수 호출 종료 후
  - 렉시컬 환경 : 메모리에 유지
```javascript
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

// g.[[Environment]]
// - f (함수) 호출 시 생성되는 렉시컬 환경 정보 저장
let g = f();
```

##### 중첩 함수 사용 시 주의사항
- `f` <sub>(함수)</sub> 다수 호출 후 결과 저장 시
  - 호출 시 생성된 각 렉시컬 환경
    - 모두 메모리에 유지
```javascript
function f() {
  let value = Math.random();

  return function() { alert(value); };
}

// 배열 내 세 함수
// - 각각 f (함수) 호출 시 생성된 환경과 연관 관계 맺음
let arr = [f(), f(), f()];
```

##### 렉시컬 환경 객체
- 도달 불가능 시
  - 메모리에서 삭제
- 참조 중첩 함수 하나라도 존재 시
  - 메모리에서 삭제 X
```javascript
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g (함수) 살아있는 동안
             // - 연관 렉시컬 환경 : 메모리에 유지
g = null;    // 참조 사라짐 (null 할당)
             // - 도달할 수 없는 상태
             // - 메모리에서 삭제
```

#### 최적화 프로세스

##### 이론
- 모든 외부 변수
  - 함수 살아있는 동안 메모리에 유지

##### 실제
- JS 엔진 : 계속 최적화
  - 변수 사용 분석
  - 외부 변수 미사용 판단 시
    - 메모리에서 제거

##### 디버깅 시
- 최적화 과정 중 제거된 변수
  - 사용 불가능
- V8 엔진 주요 부작용
  - Chrome
  - Opera
```javascript
function f() {
  let value = Math.random();

  function g() {

    // 이론상 value 접근 가능
    // 최적화 대상 되어 에러 발생
    debugger; // Uncaught ReferenceError: value is not defined
  }

  return g;
}

let g = f();
g();
```
- 외부 변수 최적화
  - 흥미로운 디버깅 이슈 유발
```javascript
// 의도한 변수 대신 동명의 다른 외부 변수 출력
let value = "이름 같은 다른 변수";

function f() {
  let value = "가장 가까운 변수";

  function g() {

     // 콘솔 'alert(value);' 입력 시
     // - '이름이 같은 다른 변수' 출력
    debugger;
  }

  return g;
}

let g = f();
g();
```

##### V8 부작용 미리 인지 시 유용
- Chrome · Opera 디버깅 시
  - 언젠가 이슈 접할 수 있음

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### Does a function pickup latest changes?
The function sayHi uses an external variable name. When the function runs, which value is it going to use?
```javascript
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // what will it show: "John" or "Pete"?
```

Such situations are common both in browser and server-side development. A function may be scheduled to execute later than it is created, for instance after a user action or a network request.

So, the question is: does it pick up the latest changes?

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The answer is: `"Pete"`

A function gets outer variables as they are now, it uses the most recent values.

Old variable values are not saved anywhere. When a function wants a variable, it takes the current value from its own Lexical Environment or the outer one.

<hr />

### Which variables are available?
The function `makeWorker` below makes another function and returns it. That new function can be called from somewhere else.

Will it have access to the outer variables from its creation place, or the invocation place, or both?
```javascript
function makeWorker() {
  let name = "Pete";

  return function() {
    alert(name);
  };
}

let name = "John";

// create a function
let work = makeWorker();

// call it
work(); // what will it show?
```

Which value it will show? `“Pete”` or `“John”`?

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The answer is: `"Pete"`

The `work()` function in the code below gets `name` from the place of its origin through the outer lexical environment reference:

![lexenv-nested-work](../../images/01/06/03/lexenv-nested-work.svg)

So, the result is `"Pete"` here.

But if there were no `let name` in `makeWorker()`, then the search would go outside and take the global variable as we can see from the chain above. In that case the result would be `"John"`.

<hr />

### counter는 독립적일까요?
`makeCounter`를 사용해 두 개의 conuter `counter`와 `counter2`를 만들었습니다.

두 `counter`는 독립적일까요? 두 번째 카운터는 `0, 1`이나 `2, 3`중 어떤 숫자를 얼럿창에 띄워줄까요? 다른 결과가 출력될까요?
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
let counter2 = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1

alert( counter2() ); // ?
alert( counter2() ); // ?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

얼럿창엔 `0`과 `1` 이 출력됩니다.

함수 `counter`와 `counter2`는 각각 다른 `makeCounter` 호출에 의해 만들어졌습니다.

두 함수는 독립적인 렉시컬 환경을 갖게 되므로 각 함수는 자신만의 `count`를 갖게 됩니다.

<hr />

### counter 객체
생성자 함수를 이용해 `counter` 객체를 만들어보았습니다.

아래 예시는 잘 작동할까요? 결과는 어떨까요?
```javascript
function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}

let counter = new Counter();

alert( counter.up() ); // ?
alert( counter.up() ); // ?
alert( counter.down() ); // ?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

잘 동작합니다.

생성자 함수의 두 중첩 함수는 동일한 외부 렉시컬 환경에서 만들어졌기 때문에 같은 `count` 변수를 공유합니다.
```javascript
function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };

  this.down = function() {
    return --count;
  };
}

let counter = new Counter();

alert( counter.up() ); // 1
alert( counter.up() ); // 2
alert( counter.down() ); // 1
```

<hr />

### if 문 안의 함수
아래 예시의 실행 결과를 예측해보세요.
```javascript
let phrase = "Hello";

if (true) {
  let user = "John";

  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}

sayHi();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

에러가 발생합니다.

`sayHi`는 `if`문 안에서 정의했기 때문에, 오직 `if`문 안에서만 접근할 수 있습니다. `if`문 밖엔 `sayHi`가 없습니다.

<hr />

### 클로저를 이용하여 합 구하기
`sum(a)(b) = a+b`와 같은 연산을 해주는 함수 `sum`을 만들어보세요.

두 개의 괄호를 사용해서 말이죠.

예시:
```javascript
sum(1)(2) = 3
sum(5)(-1) = 4
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

두 번째 괄호가 제대로 동작하려면 첫 번째 괄호는 반드시 함수를 반환해야 합니다.

아래와 같이 말이죠.
```javascript
function sum(a) {

  return function(b) {
    return a + b; // 'a'는 외부 렉시컬 환경에서 가져옵니다.
  };

}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1) ); // 4
```

<hr />

### Is variable visible?
What will be the result of this code?
```javascript
let x = 1;

function func() {
  console.log(x); // ?

  let x = 2;
}

func();
```

P.S. There's a pitfall in this task. The solution is not obvious.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The result is: **error**.

Try running it:
```javascript
let x = 1;

function func() {
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 2;
}

func();
```

In this example we can observe the peculiar difference between a “non-existing” and “uninitialized” variable.

As you may have read in the article 변수의 유효범위와 클로저, a variable starts in the “uninitialized” state from the moment when the execution enters a code block (or a function). And it stays uninitalized until the corresponding `let` statement.

In other words, a variable technically exists, but can't be used before `let`.

The code above demonstrates it.
```javascript
function func() {
  // the local variable x is known to the engine from the beginning of the function,
  // but "unitialized" (unusable) until let ("dead zone")
  // hence the error

  console.log(x); // ReferenceError: Cannot access 'x' before initialization

  let x = 2;
}
```

This zone of temporary unusability of a variable (from the beginning of the code block till `let`) is sometimes called the “dead zone”.

<hr />

### 함수를 이용해 원하는 값만 걸러내기
배열에 사용할 수 있는 내장 메서드 `arr.filter(f)`는 함수 `f`의 반환 값을 `true`로 만드는 모든 요소를 배열로 반환해줍니다.

`filter`에 넘겨서 사용할 수 있는 함수 두 가지를 만들어봅시다.
- `inBetween(a, b)` – `a` 이상 `b` 이하
- `inArray([...])` – 배열 안에 있는 값인가

위 함수를 활용하면 다음과 같은 결과가 나와야 합니다.
- `arr.filter(inBetween(3,6))` – `3`과 `6` 사이에 있는 값만 반환함
- `arr.filter(inArray([1,2,3]))` – `[1,2,3]` 안에 있는 값과 일치하는 값만 반환함
예시:
```javascript
/* ... 여기에 두 함수 inBetween과 inArray을 만들어주세요 ...*/
let arr = [1, 2, 3, 4, 5, 6, 7];

alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### Filter inBetween
```javascript
function inBetween(a, b) {
  return function(x) {
    return x >= a && x <= b;
  };
}

let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
```

#### Filter inArray
```javascript
function inArray(arr) {
  return function(x) {
    return arr.includes(x);
  };
}

let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
```

[정답](https://plnkr.co/edit/EzBBfjjhTTbOX3WG?p=preview)

<hr />

### 필드를 기준으로 정렬하기
객체가 담긴 배열을 정렬해야 한다고 가정해봅시다.
```javascript
let users = [
  { name: "John", age: 20, surname: "Johnson" },
  { name: "Pete", age: 18, surname: "Peterson" },
  { name: "Ann", age: 19, surname: "Hathaway" }
];
```

아래와 같은 방법을 사용해 정렬할 수 있을 겁니다.
```javascript
// 이름을 기준으로 정렬(Ann, John, Pete)
users.sort((a, b) => a.name > b.name ? 1 : -1);

// 나이를 기준으로 정렬(Pete, Ann, John)
users.sort((a, b) => a.age > b.age ? 1 : -1);
```

그런데, 아래와 같이 함수를 하나 만들어서 정렬하면 더 깔끔해질 것 같네요.
```javascript
users.sort(byField('name'));
users.sort(byField('age'));
```

함수를 직접 만들어 `sort`에 넘기는 것보다 `byField(fieldName)`를 넘기는 것처럼 말이죠.

필드를 기준으로 정렬을 도와주는 함수 `byField`를 만들어봅시다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
function byField(fieldName){
  return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
}
```

[정답](https://plnkr.co/edit/dzWCOinTV321PrUr?p=preview)

<hr />

### 함수를 사용해 군대 만들기
중요도: 5
아래 코드는 `shooters`가 요소인 배열을 만들어줍니다.

모든 함수는 몇 번째 `shooter`인지 출력해줘야 하는데 뭔가 잘못되었습니다.
```javascript
function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let shooter = function() { // shooter 함수
      alert( i ); // 몇 번째 shooter인지 출력해줘야 함
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0번째 shooter가 10을 출력함
army[5](); // 5번째 shooter 역시 10을 출력함
// 모든 shooter가 자신의 번호 대신 10을 출력하고 있음
```

왜 모든 `shooter`가 동일한 숫자를 출력하는 걸까요? 제대로 된 번호가 출력될 수 있게 코드를 수정해 보세요.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

Let's examine what's done inside `makeArmy`, and the solution will become obvious.

1. It creates an empty array `shooters`:
```javascript
let shooters = [];
```

2. Fills it in the loop via `shooters.push(function...)`.

    Every element is a function, so the resulting array looks like this:
```javascript
shooters = [
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); }
];
```

3. The array is returned from the function.

Then, later, the call to `army[5]()` will get the element `army[5]` from the array (it will be a function) and call it.

Now why all such functions show the same?

That's because there's no local variable `i` inside `shooter` functions. When such a function is called, it takes `i` from its outer lexical environment.

What will be the value of `i`?

If we look at the source:
```javascript
function makeArmy() {
  ...
  let i = 0;
  while (i < 10) {
    let shooter = function() { // shooter function
      alert( i ); // should show its number
    };
    ...
  }
  ...
}
```

…We can see that it lives in the lexical environment associated with the current `makeArmy()` run. But when `army[5]()` is called, `makeArmy` has already finished its job, and `i` has the last value: `10` (the end of `while`).

As a result, all `shooter` functions get from the outer lexical envrironment the same, last value `i=10`.

We can fix it by moving the variable definition into the loop:
```javascript
function makeArmy() {

  let shooters = [];

  for(let i = 0; i < 10; i++) {
    let shooter = function() { // shooter function
      alert( i ); // should show its number
    };
    shooters.push(shooter);
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5
```

Now it works correctly, because every time the code block in for (`let i=0...) {...}` is executed, a new Lexical Environment is created for it, with the corresponding variable `i`.

So, the value of `i` now lives a little bit closer. Not in `makeArmy()` Lexical Environment, but in the Lexical Environment that corresponds the current loop iteration. That's why now it works.

![lexenv-makearmy](../../images/01/06/03/lexenv-makearmy.svg)

Here we rewrote `while` into `for`.

Another trick could be possible, let's see it for better understanding of the subject:
```javascript
function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let j = i;
    let shooter = function() { // shooter function
      alert( j ); // should show its number
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5
```

The `while` loop, just like `for`, makes a new Lexical Environment for each run. So here we make sure that it gets the right value for a `shooter`.

We copy `let j = i`. This makes a loop body local `j` and copies the value of `i` to it. Primitives are copied “by value”, so we actually get a complete independent copy of `i`, belonging to the current loop iteration.

[정답](https://plnkr.co/edit/BOHSGwHNGbptajR2?p=preview)
