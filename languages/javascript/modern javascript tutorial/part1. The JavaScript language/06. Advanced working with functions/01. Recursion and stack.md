재귀 · 스택
==========

- 큰 목표 작업 → 동일 목표 간단 작업들
- 함수 자기 자신 호출

### 두 가지 사고방식
- 반복 vs 재귀
```javascript
// 거듭제곱
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```
```javascript
/* 반복적인 사고 */
// for (반복문)
function pow(x, n) {
  let result = 1;

  // 반복문 돌면서 x를 n번 곱함
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8

/* 재귀적인 사고 */
// - 작업 단순화
// - 자기 자신 호출
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```

##### `pow (x, n)` <sub>(함수)</sub> 호출 시
- 두 갈래 나뉘어 코드 실행
```javascript
              if   n == 1 = x
             /
pow(x, n) =
             \
              else         = x * pow(x, n - 1)
```

##### `n == 1`
- 재귀 베이스 <sub>(base)</sub>
- 모든 절차 간단해짐
- 명확한 결괏값 즉시 도출
- `pow(x, 1) == x`

##### `n != 1`
- 재귀 단계 <sub>(recursive step)</sub>
- `pow(x, n)` → `x * pow(x, n - 1)`
  - x<sup>n</sup> = x * x<sup>(n-1)</sup>
- 목표 작업 <sub>(`pow(x, n)`)</sub> 분할
  - 간단한 동작 <sub>(x 곱하기)</sub>
  - 목표 작업 변형 <sub>(`pow(x, n - 1)`)</sub>
  - `n == 1` 될 때까지 계속 진행

![recursion-pow](../../images/01/06/01/recursion-pow.svg)

##### `pow (2, 4)`
1. `pow(2, 4)` = `2 * pow(2, 3)`
2. `pow(2, 3)` = `2 * pow(2, 2)`
3. `pow(2, 2)` = `2 * pow(2, 1)`
4. `pow(2, 1)` = `2`

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **재귀 사용 코드 : 짧음**

- 반복적 사고 코드보다 대개 짧음
- `if` <sub>(문)</sub> → `?` <sub>(조건부 연산자)</sub>
  - 간결성 · 가독성 ↑
```javascript
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```

<br />

##### 재귀 깊이
- 중첩 호출 최대 개수 <sub>(첫 호출 포함)</sub>
- `pow(x, n)` <sub>(함수)</sub> 재귀 깊이
  - `n`

##### 최대 재귀 깊이 제한 <sub>(JS 엔진)</sub>
- 만개 정도까지 확실히 허용
- 엔진 따라 더 많은 깊이 가능
  - 대다수 엔진 : 십만까지는 X

##### tail calls optimization
- 엔진 내부
  - 자동 최적화 수행 <sub>(제한 완화)</sub>
- 모든 경우 X
  - 간단한 경우만 적용

##### 재귀 깊이 제한
- 재귀 사용 시 부담
- 그럼에도 광범위하게 사용
  - 간결성 ↑
  - 유지보수 난이도 ↓

### 실행 컨텍스트 · 스택

##### 실행 중인 함수 실행 절차 정보
- 해당 함수 실행 컨텍스트에 저장

##### 실행 컨텍스트
- 함수 실행 세부 정보 보유 <sub>(내부 데이터 구조)</sub>
  - 제어 흐름 현재 위치
  - 변수 현재 값
  - `this` 값
  - 기타 등등
- 함수 호출 1회
  - 실행 컨텍스트 1개 생성

#### 함수 내부 중첩 호출 절차

##### 1. 현재 함수 실행 일시 중지

##### 2. 실행 컨텍스트 스택에 저장
- 실행 컨텍스트 <sub>(일시 중지 함수)</sub> push

##### 3. 중첩 호출 실행

##### 4. 중첩 호출 실행 종료
1. 실행 컨텍스트 스택에서 제거
    - 실행 컨텍스트 <sub>(일시 중지 함수)</sub> pop
2. 일시 중지 함수 실행 재개

#### `pow(2, 3)`

##### 실행 컨텍스트에 정보 저장
- 변수
  - `x = 2`
  - `n = 3`
- 실행 흐름
  - 함수 1번째 줄 위치
```javascript
Context: { x: 2, n: 3, 1번째 줄 } call: pow(2, 3)
```

##### `n == 1` <sub>(조건)</sub> 만족 X
- 실행 흐름
  - `if` <sub>(문)</sub> 2번째 분기 진행
```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {      // ←
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) );
```

##### 변수 동일 · 실행 흐름 위치 변경
- 실행 컨텍스트 정보 변경
```javascript
// 줄 정보 변경
// 1 → 5번째 줄
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)
```

##### `x * pow (x, n - 1)` 계산 시
- `pow (2, 2)` <sub>(서브 호출)</sub> 생성

#### `pow(2, 2)`

##### 중첩 호출 발생 시
- 현재 실행 컨텍스트
  - 실행 컨텍스트 스택에 저장 <sub>(push)</sub>

##### 프로세스
1. 스택 최상단
    - 현재 컨텍스트
2. 새 컨텍스트 <sub>(서브 호출)</sub> 생성
    - 스택에 서브 호출 컨텍스트 push
3. 서브 호출 완료 시
    - 스택에서 서브 호출 컨텍스트 pop
    - 기존 컨텍스트 실행 재개
      - 스택 pop

##### `pow (2, 2)` <sub>(서브 호출)</sub> 시작 시 스택
```javascript
Context: { x: 2, n: 2, 1번째 줄 } call: pow(2, 2) // new context
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3) // old context
```

##### 이전 컨텍스트 저장 정보
- 변수 정보
- 코드 일시 중단된 줄

##### 서브 호출 종료 후
- 이전 컨텍스트
  - 문제없이 다시 시작

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### 한 줄에 복수 서브 호출 가능
- `pow( … ) + pow( … ) + some( … )`
- 서브 호출 바로 직후 실행 시작

<br />

#### `pow(2, 1)`
- 동일한 과정 다시 반복
- 5번째 줄
  - 새 서브 호출 생성
  - 변수
    - `x = 2`
    - `n = 1`
- 새 실행 컨텍스트 생성 후
  - 스택에 실행 컨텍스트 push <sub>(스택 최상단)</sub>
```javascript
Context: { x: 2, n: 1, 1번째 줄 } call: pow(2, 1) // new
Context: { x: 2, n: 2, 5번째 줄 } call: pow(2, 2) // old
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3) // older
```

#### 실행 종료

##### `pow (2, 1)` 실행 시
- `n == 1` <sub>(조건)</sub> 만족
  - `if` <sub>(문)</sub> 1번째 분기 실행
```javascript
function pow(x, n) {
  if (n == 1) {      // ←
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```

##### 호출할 중첩 호출 X
- 함수 종료
- `2` 반환

##### 해당 실행 컨텍스트
- 쓸모 X
- 메모리에서 삭제

##### 스택 최상단
- 이전 실행 컨텍스트
```javascript
// Context: { x: 2, n: 1, 1번째 줄 } call: pow(2, 1) // new (X)
Context: { x: 2, n: 2, 5번째 줄 } call: pow(2, 2)    // old
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)    // older
```

##### `pow (2, 2)` 실행 다시 시작
- 서브 호출 <sub>(`pow (2, 1)`)</sub> 결과
  - 알고 있음
- `x * pow (x, n - 1)` 계산 후
  - `4` 반환
- 스택 최상단
  - 이전 실행 컨텍스
```javascript
// Context: { x: 2, n: 1, 1번째 줄 } call: pow(2, 1) // new (X)
// Context: { x: 2, n: 2, 5번째 줄 } call: pow(2, 2) // old (X)
Context: { x: 2, n: 3, 5번째 줄 } call: pow(2, 3)    // older
```

##### 마지막 실행 컨텍스트 처리 후
- 결과 <sub>(`pow (2, 3) = 8`)</sub> 도출

##### 재귀 깊이
- 실행 컨텍스트 수 <sub>(스택)</sub> 최댓값

##### 메모리 요구사항 유의
- 실행 컨텍스트
  - 메모리 차지
- 메모리 저장 공간 필요
  1. n 증가
  2. n번 내려감
  3. n개 실행 컨텍스트 생성

##### 반복문 기반 알고리즘
- 메모리 절약
```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

##### 컨텍스트 1개만 사용
- 변수 <sub>(`i` · `result`)</sub>
  - 컨택스트 내 변경
- `n` 의존 X
- 필요 메모리 공간 ↓
- 사용 메모리 공간 고정
- 대개 함수 호출 비용 <sub>(메모리 사용)</sub> 절약

##### 코드 재작성 후 큰 개선 없는 경우 有
- 메모리 크게 절약 X
- 최적화 필요 X
  - 최적화 노력 무용지물
- ex&#41;
  - 조건 따라 다른 재귀 서브 호출 후 결과 합칠 때
  - 분기문 복잡하게 얽혀있을 때

##### 재귀 코드
- 코드 양 ↓
- 코드 이해도 ↑
- 유지보수 이점

##### 모든 곳에 메모리 최적화 신경 X
- 필요한 것
  - 좋은 코드
  - 최적화 코드 X

### 재귀적 순회
```javascript
/* 한 회사 내 부서 · 임직원 */
let company = {

  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```

#### 모든 임직원 급여 더하기

##### 반복문
- `company` <sub>(객체)</sub>
  - 최상위 반복문
- 1단계 하위 부서
  - 1번째 중첩 반복문
- n단계 하위 부서
  - n번째 중첩 반복문

##### 재귀
- 단순 부서 <sub>(임직원 배열)</sub>
  - 반복문
  - 재귀 베이스
- n단계 하위 부서 <sub>(하위 부서 객체)</sub>
  - n번째 재귀 호출
  - 재귀 단계

##### 복잡한 작업 분해
- 작은 작업들
  - 하위 부서 대상 반복문
- 부서 깊이 따라 더 작은 작업들로 쪼개기
  - 마지막 == 재귀 베이스
``` javascript
let company = {

  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};

// 급여 합계 함수
function sumSalaries(department) {

  // 재귀 베이스
  // - 단순 부서 (임직원 배열)
  if (Array.isArray(department)) {

    // 배열 요소 총합
    return department.reduce((prev, current) => prev + current.salary, 0);

  // 재귀 단계
  // - n단계 하위 부서 (하위 부서 객체)
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {

      // 재귀 호출
      // - 각 하위 부서 임직원 급여 총합
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
```

##### `[ … ]` <sub>(배열)</sub>
- 서브 호출 X
- 결과 계산

##### `{ … }` <sub>(객체)</sub>
- 서브 호출

![recursive-salaries](../../images/01/06/01/recursive-salaries.svg)

### 재귀적 구조
- 재귀적으로 정의된 자료구조
  - 자기 자신 일부 복제 형태

##### 예시
- 회사 부서
  - 사람 <sub>(배열)</sub>
  - 하위 부서 <sub>(객체)</sub>
- HTML · XML
  - 일반 텍스트
  - HTML 주석
  - HTML 태그
    - 일반 텍스트
    - HTML 주석
    - 다른 HTML 태그
    - …

### 연결 리스트

#### 배열

##### 앞 요소 연산
- 요소 삭제 · 삽입 비용 ↑

##### `unshift( … )` · `shift()`
- 배열 앞 새 요소 공간 생성 · 제거
- 모든 요소 번호 다시 매김
- 배열 크기 ↑
  - 연산 수행 시간 ↑

##### 끝 요소 연산
- 요소 삭제 · 삽입 비용 ↓
- `push` · `pop`

#### 연결 리스트 <sub>(linked list)</sub>
- 삽입 · 삭제 속도 ↑

##### 프로퍼티
- `value`
  - 요소
- `next`
  - 다음 요소 참조
  - `null` <sub>(다음 요소 부재 시)</sub>
```javascript
let list1 = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

↓↓↓

let list2 = { value: 1 };
list2.next = { value: 2 };
list2.next.next = { value: 3 };
list2.next.next.next = { value: 4 };
list2.next.next.next.next = null;
```
![linked-list](../../images/01/06/01/linked-list.svg)

##### 전체 리스트
- 여러 부분으로 나누기
- 다시 합치기
```javascript
// 여러 부분으로 나누기
let secondList = list.next.next;
list.next.next = null;

// 다시 합치기
list.next.next = secondList;
```

![linked-list-split](../../images/01/06/01/linked-list-split.svg)


##### 쉽게 요소 추가 · 삭제
- 리스트 앞에 요소 추가
```javascript
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// 맨 앞 새 요소 추가
list = { value: "new item", next: list };

// 중간 요소 제거
// - 이전 요소 next (프로퍼티) 변경
list.next = list.next.next;
```

![linked-list-0](../../images/01/06/01/linked-list-0.svg)

![linked-list-remove-1](../../images/01/06/01/linked-list-remove-1.svg)

##### `list.next` <sub>(참조)</sub> 변경 <sub>(`value 1` → `value 2`)</sub>
- `value 1` 요소 <sub>(객체)</sub>
  - 체인에서 제외
  - 따로 저장 X
    - 메모리에서 자동 제거

#### 연결 리스트 단점

##### 번호 <sub>(인덱스)</sub> 사용해 요소 쉽게 접근 X
- n번째 값 접근 시
  - `list[n]` X
  - 첫 항목에서 n번 이동 <sub>(`next` 프로퍼티)</sub>

##### 중간 요소 삽입 · 삭제 연산 덜 중요 시 고려 자료구조
- 큐 <sub>(queue)</sub>
- 데크 <sub>(deque)</sub>
  - 양 끝 삽입 · 삭제 빠르게 수행

##### 예시 연결 리스트 개선 <sub>(기능 추가)</sub>
- `prev` <sub>(프로퍼티)</sub>
  - 이전 요소 참조 <sub>(쉽게 이동)</sub>
- `tail` <sub>(변수)</sub>
  - 마지막 요소 참조
  - 마지막 요소 추가 · 삭제 시
    - 참조 값 갱신
- 요구사항 따라 구조 변경

<br />

## 요약
지금까지 나온 용어를 정리해봅시다.

- 재귀(recursion) – 함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 용어입니다. 재귀 함수는 우아하게 원하는 문제를 해결할 때 자주 쓰이곤 합니다.

  함수가 자신을 호출하는 단계를 재귀 단계(recursion step) 라고 부릅니다. basis라고도 불리는 재귀의 베이스(base) 는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수입니다.

  [재귀적으로 정의된](https://en.wikipedia.org/wiki/Recursive_data_type) 자료 구조는 자기 자신을 이용해 자료 구조를 정의합니다.

  재귀적으로 정의된 자료구조에 속하는 연결 리스트는 리스트 혹은 `null`을 참조하는 객체로 이루어진 데이터 구조를 사용해 정의됩니다.
  ```javascript
  list = {value, next -> list}
  ```

  HTML 문서의 HTML 요소 트리나 위에서 다룬 부서를 나타내는 트리 역시 재귀적인 자료 구조로 만들었습니다. 이렇게 재귀적인 자료 구조를 사용하면 가지가 여러 개인데 각 가지가 여러 가지로 뻗쳐 나가는 형태로 자료 구조를 만들 수 있습니다.

  예시에서 구현한 `sumSalary`같은 재귀 함수를 사용하면 각 분기(가지)를 순회할 수 있습니다.

모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있습니다. 최적화를 위해 반복문으로 다시 작성해야 할 수도 있죠. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작합니다. 재귀를 사용하면 구현과 유지보수가 쉽다는 장점도 있습니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 주어진 숫자까지의 모든 숫자 더하기
숫자 `1 + 2 + ... + n`을 계산하는 함수 `sumTo (n)`을 만들어보세요.

예시:
```javascript
sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
```

아래 방법을 사용해 세 가지 답안을 만들어보세요.

1. `for` 반복문 사용하기
2. 재귀 사용하기(`n > 1`일 때 `sumTo(n) = n + sumTo(n-1)`)
3. [등차수열](https://en.wikipedia.org/wiki/Arithmetic_progression) 공식 사용하기
예시:
```javascript
function sumTo(n) { /*... 답안은 여기에 작성 ... */ }

alert( sumTo(100) ); // 5050
```

더 생각해보기 1
- 세 가지 방법 중 어떤 방법이 가장 빠른가요?
- 어떤 방법이 가장 느린가요?
- 이유도 함께 제시해주세요.

더 생각해보기 2
- 재귀를 사용해 `sumTo (100000)`를 계산할 수 있을까요?

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

반복문 사용하기:
```javascript
function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
```

재귀 사용하기:
```javascript
function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
```

등차수열의 합공식 sumTo(n) = n*(n+1)/2 사용하기:
```javascript
function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
```

더 생각해보기 1
- 등차수열의 합공식을 사용하는 방법이 가장 빠릅니다. `n`에 관계없이 오직 세 개의 연산만 수행하면 되니까요. 수학은 항상 뭔가에 도움을 줍니다!

  반복을 사용하는 방법은 두 번째로 빠릅니다. 재귀를 사용하는 방법과 반복문을 사용하는 방법 모두 같은 수의 숫자를 더하는 것에서 같지만, 재귀를 사용하는 방법은 중첩 호출과 실행 스택 관리가 추가로 필요하기 때문에 더 많은 자원을 소비합니다. 따라서 속도가 더 느리죠.

더 생각해보기 2
- 몇몇 자바스크립트 엔진은 'tail call' 최적화를 지원합니다. 위 함수 `sumTo`처럼 함수가 가장 마지막으로 수행하는 연산이 재귀 호출이라면 외부 함수는 실행을 다시 시작할 필요가 없기 때문에 엔진은 실행 컨텍스트를 기억할 필요가 없어집니다. 메모리 부담이 사라지는 거죠. 그렇기 때문에 `sumTo(100000)`같은 계산이 가능한 것입니다. 그런데 자바스크립트 엔진이 tail call 최적화를 지원하지 않는다면(대부분의 엔진이 이를 지원하지 않습니다) 엔진에 설정된 스택 사이즈 제한을 넘었기 때문에 최대 스택 사이즈 초과 에러가 발생합니다.

<hr />

### 팩토리얼 계산하기
[팩토리얼(factorial)](https://en.wikipedia.org/wiki/Factorial)은 `n`이 자연수일 때, `1`부터 `n`까지의 모든 자연수의 곱을 의미합니다. `n` 팩토리얼은 `n!`으로 표시합니다.

팩토리얼은 아래와 같이 정의할 수도 있습니다.
```javascript
n! = n * (n - 1) * (n - 2) * ...*1
```

자연수 `n`에 대한 `n` 팩토리얼:
```javascript
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
```

재귀를 사용하여 `n!`을 계산하는 함수, `factorial(n)`을 만들어보세요.
```javascript
alert( factorial(5) ); // 120
```

힌트: `n!`은 `n * (n-1)!`입니다. `3! = 3 * 2! = 3 * 2 * 1! = 6` 같이 말이죠.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

팩토리얼은 그 정의에 따라 `n!`을 `n * (n-1)!`로 바꿔쓸 수 있습니다.

따라서 `factorial(n)`의 결과는 `n`과 `factorial(n-1)`의 결과를 곱한 값이 되겠죠. 함수의 인수는 `n-1`에서 `1`이 될 때까지 점점 줄어들 겁니다.
```javascript
function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
```

재귀의 베이스는 `1`로 잡았는데, `0`이어도 상관은 없습니다. `0`일 경우 재귀 단계가 하나 더 늘어난다는 것만 다릅니다.
```javascript
function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
```

<hr />

### 피보나치 수 계산하기
[피보나치 수](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98)는 첫째와 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열로, F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>라는 공식으로 표현할 수 있습니다.

처음 두 항은 `1`이고, 그다음 항들은 `2(1+1),3(1+2),5(2+3)`이므로 전체 수열은 `1, 1, 2, 3, 5 , 8, 13, 21 ...` 형태를 띱니다.

피보나치 수는 [황금 비율](https://en.wikipedia.org/wiki/Golden_ratio) 등 우리 주변을 둘러싼 수많은 자연 현상과 관련이 있습니다.

`n` 번째 피보나치 수를 반환하는 함수 `fib(n)`을 작성해보세요.

예시:
```javascript
function fib(n) { /* 답안은 여기에 작성 */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
```

주의: `fib (77)`를 호출했을 때 연산 시간이 1초 이상 되면 안 됩니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

가장 먼저 떠오르는 방법은 재귀입니다.

정의 자체에서 유추할 수 있듯이 피보나치 수열은 재귀를 사용해 구현할 수 있습니다.
```javascript
function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // 연산에 너무 많은 시간이 걸립니다!
```

그런데 이렇게 재귀를 사용해 구현하면 `n`이 커질 경우 속도가 느려집니다. `fib(77)`을 호출하면 CPU 리소스를 다 잡아먹어서 잠시 엔진이 멈출 수도 있습니다.

연산 속도가 느려지는 이유는 함수 호출 도중에 수많은 서브 호출이 일어나기 때문입니다. 같은 값들이 여러 번 평가되면서 이런 일이 발생하죠.

`fib(5)`의 계산 과정을 살펴봅시다.
```javascript
...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...
```
`fib(3)`은 `fib(5)`와 `fib(4)`를 계산할 때 모두 필요합니다. 그렇기 때문에 `fib(3)`은 완전히 다른 두 곳에서 독립적으로 호출되고 평가되죠.

재귀 트리를 직접 살펴봅시다.

![fibonacci-recursion-tree](../../images/01/06/01/fibonacci-recursion-tree.svg)

그림을 보니 `fib(3)`은 두 번 평가된다는 것이 좀 더 명확히 보이네요. `fib(2)`는 세 번이나 평가됩니다. 이렇게 재귀를 사용해 피보나치 수열을 구현하면 `n`이 증가하는 속도보다 전체 연산 횟수가 더 빨리 증가합니다. `77` 자체는 그리 큰 숫자가 아니지만, 피보나치 수열에서 `n=77`일 경우엔 엄청난 수의 연산이 일어나죠.

이런 단점은 이미 평가된 값을 어딘가에 저장해놓는 식으로 최적화 할 수 있습니다. `fib(3)` 계산이 끝나면 이 결과를 어딘가에 저장해 놓았다가 같은 값이 필요할 때 저장된 값을 불러오는 식으로 말이죠.

또 다른 최적화 방법은 재귀가 아닌 반복문을 기반으로 하는 알고리즘을 짜는 것입니다.

`n`부터 시작해 숫자를 하나씩 줄이며 원하는 값을 구하는 대신 `1`과 `2`로 시작하는 반복문으로 `fib(3)`을 구하고, 이를 기반으로 `fib(4)`를 구하고, 또 이를 기반으로 `fib(5)`를 구하는 식으로 알고리즘을 구현할 수 있습니다. 이렇게 구현하면 이전 두 항의 값만 저장하면 되죠.

반복문을 기반으로 하는 알고리즘을 좀 더 자세히 살펴보겠습니다.

시작은 다음과 같습니다.
```javascript
// a = fib(1), b = fib(2), 처음 두 항은 1이라는 정의에 의해 이렇게 값을 할당하였습니다.
let a = 1, b = 1;

// c = fib(3), 세 번째 항은 첫 번째 항과 두 번째 항의 합입니다.
let c = a + b;

/* fib(1), fib(2), fib(3)을 구했습니다.
a  b  c
1, 1, 2
*/
```

이제 `fib(2)`와 `fib(3)`을 더해 `fib(4)`를 구해봅시다.

`a`에 기존 `b`를, `b`에 기존 `c`를 할당하고, `c`는 `a`와 `b`의 합이 되도록 합시다.
```javascript
a = b; // a = fib(2)
b = c; // b = fib(3)
c = a + b; // c = fib(4)

/* 다음과 같은 수열을 얻을 수 있습니다.
   a  b  c
1, 1, 2, 3
*/
```

같은 과정을 반복해 다음 수를 얻어봅시다.
```javascript
a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* 다음과 같은 수열을 얻을 수 있습니다.
      a  b  c
1, 1, 2, 3, 5
*/
```

목표로 하는 값을 얻을 때까지 위와 같은 과정을 반복하면 되겠죠? 이렇게 하면 재귀를 사용하는 방법보다 연산 속도도 빠르고 중복되는 계산도 없다는 장점이 있습니다.

반복문을 사용한 전체 코드는 다음과 같습니다.
```javascript
function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
```

반복문 내 `i`는 `3`부터 시작합니다. 피보나치 수열의 첫 번째 항과 두 번째 항은 `a=1`, `b=1`로 하드코딩 했기 때문입니다.

이런 접근 방법은 [bottom-up 다이내믹 프로그래밍(dynamic programming, 동적 계획법)](https://en.wikipedia.org/wiki/Dynamic_programming)이라 부릅니다.

<hr />

### 단일 연결 리스트 출력하기
재귀와 스택에서 설명한 바 있는, 단일 연결 리스트(single-linked list)가 있다고 가정해 봅시다.
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

리스트 내 항목을 차례대로 하나씩 출력해주는 함수 `printList(list)`를 만들어보세요.

반복문과 재귀를 사용한 답안을 각각 만들어봅시다.

그리고 재귀를 사용한 것과 재귀를 사용하지 않은 것 중 어떤 게 더 좋은 코드인지 생각해봅시다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### 반복문을 기반으로 하는 방법
반복문을 사용한 답안은 다음과 같습니다.
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);
```

여기서 주목해야 할 점은 리스트를 임시 변수 `tmp`에 저장하고 사용했다는 것입니다. 아래처럼 매개변수 `list`를 그대로 사용해도 되는데 말이죠.
```javascript
function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}
```

그런데 매개변수 `list`를 바로 사용하는 건 그다지 현명한 선택은 아닙니다. 나중에 함수를 확장할 때 `list`를 가지고 뭔가 해야 하는 경우가 생길 수 있기 때문이죠. 어떤 일 때문인지는 몰라도 `while`문 앞에서 `list`가 변경되면 우리가 짠 코드는 제대로 동작하지 않을 겁니다.

좋은 변수명이 무엇인가를 생각해 봤을 때도 리스트를 임시 변수 `tmp`에 저장하는 게 좋습니다. `list`에는 리스트 그 자체가 저장되어있는 게 좋죠.

`tmp`는 리스트를 순회하기 위한 용도로 쓰였기 때문에 `tmp`라고 명명하는 게 좋습니다. `for`문의 `i`처럼 말이죠.

#### 재귀를 기반으로 하는 방법
재귀를 사용해 만든 `printList(list)`는 아주 간단한 로직을 기반으로 합니다. "리스트를 출력할 때는 현재 요소 list를 출력하고, 같은 방법을 사용해 `list.next`를 출력한다."라는 로직이죠.
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // 현재 요소를 출력합니다.

  if (list.next) {
    printList(list.next); // 같은 방법을 사용해 나머지 요소를 출력합니다.
  }

}

printList(list);
```

이제 두 방법을 비교해봅시다.

반복문을 사용하면 리소스를 좀 더 효율적으로 사용합니다. 두 방법의 반환 값은 같지만, 반복문을 사용한 방법에선 중첩 함수를 호출하는데 추가적인 리소스를 쓰지 않기 때문입니다.

반면 재귀를 사용한 방법은 코드 길이가 짧고 이해하기 쉽다는 장점이 있습니다.

<hr />

### 단일 연결 리스트를 역순으로 출력하기
위 문제(단일 연결 리스트 출력하기)에 있는 단일 연결 리스트의 항목을 역순으로 출력해주는 함수를 만들어봅시다.

반복문과 재귀를 사용한 답안을 각각 만들어보세요.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### 재귀를 기반으로 하는 방법
재귀를 사용한 방법은 조금 까다롭습니다.

리스트의 나머지 요소들을 출력한 다음에 현재 요소를 출력해야 하죠.
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);
```

#### 반복문을 기반으로 하는 방법
리스트를 원래 순서대로 출력하는 방법보다 역시 까다롭습니다.

`list`의 마지막 값을 바로 구할 수 있는 방법이 없기 때문입니다. 마지막 값을 시작으로 '역행'할 수 없는 상황이죠.

따라서 우리는 원래 순서대로 요소들을 하나씩 거슬러 올라가면서 각 요소를 배열에 저장해 놓고, 마지막 요소에 도달했을 때 배열에 저장된 요소들을 거꾸로 출력하는 방법을 사용할 수 있을 겁니다.
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
```

여기서 주목할 점은 재귀를 사용한 방법과 반복문을 사용한 방법이 완전히 동일한 접근 방식을 취했다는 것입니다. 리스트를 앞에서부터 따라가면서 각 요소를 실행 컨텍스트 스택에 저장해 놓았다가 스택 맨 위에서부터 요소를 차례대로 출력하였습니다.
