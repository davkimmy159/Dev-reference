## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 모든 숫자 더하기

##### `sumTo (n)` <sub>(함수)</sub> 작성
- `1 + 2 + … + n` <sub>(숫자)</sub> 계산
```javascript
sumTo(1);  // 1
sumTo(2);  // 3  (2 + 1)
sumTo(3);  // 6  (3 + 2 + 1)
sumTo(4);  // 10 (4 + 3 + 2 + 1)
…
sumTo(100) // 5050 (100 + 99 + … + 2 + 1)
```

##### 3가지 답안
- a. `for` <sub>(반복문)</sub> 사용
- b. 재귀 사용
  - `sumTo(n) = n + sumTo(n - 1)`
    - `n > 1` <sub>(조건)</sub> 충족 시
- c. [등차수열](https://en.wikipedia.org/wiki/Arithmetic_progression) 공식 사용
```javascript
function sumTo(n) { … }

sumTo(100); // 5050
```

##### 더 생각해보기
- a. 3가지 방법 속도 비교 · 이유 설명
- b. 재귀
  - `sumTo(100000)` 계산 가능 여부

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### a. 반복문 사용
```javascript
function sumTo(n) {
  let sum = 0;

  for (let i = 1; i <= n; i++) {
    sum += i;
  }

  return sum;
}
```

##### b. 재귀 사용
```javascript
function sumTo(n) {
  if (n == 1) {
    return 1;
  } else {
    return n + sumTo(n - 1);
  }
}
```

##### c. 등차수열 합공식 사용
- `sumTo(n) = n * (n + 1) / 2`
```javascript
function sumTo(n) {
  return n * (n + 1) / 2;
}
```

##### 속도 비교
1. 등차수열 합공식
   - 항상 3개 연산만 수행 <sub>(`n` 무관)</sub>
2. 반복문
3. 재귀 <sub>(자원 소비량 ↑)</sub>
   - 중첩 호출
   - 실행 스택 관리

#### `sumTo(100000)` 재귀 적용

##### 꼬리 물기 최적화
- 최대 깊이 제한 완화
- 엔진별 지원 여부 상이

##### 최적화 지원 엔진 <sub>(일부)</sub> 가능
- 함수 내 마지막 수행 연산 == 재귀 호출
  - 외부 함수 재실행 불필요
    - 실행 컨텍스트 저장 X
    - 메모리 부담 ↓

##### 최적화 미지원 엔진 <sub>(대다수)</sub> 불가능
- 엔진 설정 스택 크기 제한 초과
  - 최대 스택 크기 초과 에러

<hr />

### 팩토리얼 계산하기

##### [팩토리얼](https://en.wikipedia.org/wiki/Factorial) <sub>(factorial)</sub>
- 1 ~ n 사이 모든 자연수 곱 <sub>(n!)</sub>
  - n == 자연수
- 정의
```javascript
n! = n * (n - 1) * (n - 2) * … * 1
```
- n!
```javascript
1! = 1
2! = 2   = 2 * 1
3! = 6   = 3 * 2 * 1
4! = 24  = 4 * 3 * 2 * 1
5! = 120 = 5 * 4 * 3 * 2 * 1
…
```

##### `factorial(n)` <sub>(함수)</sub> 작성
- 재귀 사용해 n! <sub>(n 팩토리얼)</sub> 계산
```javascript
factorial(5); // 120
```

##### 힌트
- n!
  - `n * (n - 1)!`
```javascript
3! = 3 * 2!
   = 3 * 2 * 1!
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### `factorial(n)` → `n` * `factorial(n - 1)`
- `n` <sub>(인수)</sub> 값 ↓
  - `n` → `n - 1` → … → `1`
- 재귀 기반
  - `0` · `1` 가능 <sub>(차이 無)</sub>
```javascript
function factorial(n) {

//if (n) {      // 재귀 기반 == 0
  if (n != 1) { // 재귀 기반 == 1
    return n;
  } else {
    return factorial(n - 1) : 1;
  }
}

factorial(5); // 120
```

<hr />

### 피보나치 수 계산하기

##### [피보나치 수](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98) <sub>(수열)</sub>
- 1 · 2번째 항
  - 1
- 3번째 항 ~
  - 바로 앞 두 항 합
- 공식
  - F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
- 2 <sub>(1+1)</sub>, 3 <sub>(1+2)</sub>, 5 <sub>(2+3)</sub>, …
  - 1, 1, 2, 3, 5 , 8, 13, 21, …

##### `fib(n)` <sub>(함수)</sub> 작성
- `n`번째 피보나치 수 반환
```javascript
function fib(n) { … }

fib(3);  // 2
fib(7);  // 13
fib(77); // 5527939700884757
```

##### 주의
- `fib (77)` 호출 시 연산 시간
  - 1초 이하

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 재귀
```javascript
function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

fib(3);  // 2
fib(7);  // 13
fib(77); // 시간 소모량 多
```

##### `n` ↑ → 속도 ↓
- 함수 호출 도중 수많은 서브 호출 발생
  - 동일 값들 다수 평가 수행
- ex\) `fib(5)` · `fib(4)` <sub>(독립된 두 개별 연산)</sub>
  - `fib(3)` 필요
    -  동일 값 중복 계산 발생
```javascript
…
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
…
```
- 전체 연산 횟수 ↑ <sub>(기하급수적)</sub>
  - ex\) `fib(5)`
    - `fib(2)` 3번 평가
    - `fib(3)` 2번 평가
    - …

![fibonacci-recursion-tree](../../images/01/06/01/fibonacci-recursion-tree.svg)

##### 최적화
- a. 평가 값 저장
- b. 재귀 → 반복문 <sub>(재작성)</sub>

#### 반복문 기반 알고리즘

##### 이전 두 항 값만 저장
- 연산 속도 ↑
- 중복 계산 X
```javascript
let a = 1;     // a = fib(1)
let b = 1;     // b = fib(2)
let c = a + b; // c = fib(3)

// a  b  c
// 1, 1, 2

a = b;     // a = fib(2)
b = c;     // b = fib(3)
c = a + b; // c = fib(4)

//    a  b  c
// 1, 1, 2, 3

a = b;     // a = fib(3)
b = c;     // b = fib(4)
c = a + b; // c = fib(5)

//       a  b  c
// 1, 1, 2, 3, 5

…
```

##### 함수 구현
```javascript
function fib(n) {
  let a = 1;
  let b = 1;

  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }

  return b;
}
```

##### 참고
- [_bottom-up dynamic programming_](https://en.wikipedia.org/wiki/Dynamic_programming)

<hr />

### 단일 연결 리스트 출력하기

##### `list` <sub>(단일 연결 리스트)</sub>
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

##### `printList(list)` <sub>(함수)</sub> 작성
- 리스트 내 항목 순차 출력

##### 2가지 답안
- 반복문 · 재귀 각각 사용
  - 둘 중 더 좋은 코드 판단

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 반복문 기반
- `tmp` <sub>(임시 변수)</sub> 사용
  - 순회 용도
```javascript
function printList(list) {
  let tmp = list; // 임시 변수

  while (tmp) {
    alert(tmp.value);

    tmp = tmp.next;
  }
}
```
- `list` <sub>(매개변수)</sub> 사용
  - 타 작업 중 사용 시 문제 발생 가능
```javascript
function printList(list) {
  while(list) { // 매개변수 직접 사용
    alert(list.value);

    list = list.next;
  }
}
  /* 매개변수 (list) 사용
   좋지 않은 방법
   - 추후 함수 확장 시
     - 어딘가에 매개변수 (list) 사용 가능
   while (문) 앞에서 매개변수 (list) 변경 시
   - 코드 정상 동작 X
```

##### 재귀 기반
```javascript
function printList(list) {

  // 현재 요소 출력
  alert(list.value);

  if (list.next) {

    // 동일 방법으로 나머지 요소 출력
    printList(list.next);
  }

}
```

##### 반복문 vs 재귀
- 반복문
  - 자원 좀 더 효율적으로 사용
    - 중첩 함수 호출 X
- 재귀
  - 코드 길이 ↓
  - 이해 쉬움

<hr />

### 단일 연결 리스트 역순 출력하기

##### 함수 작성
- 이전 과제 연결 리스트 항목 역순 출력
- 반복문 · 재귀 각각 사용

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 반복문 기반
- 까다로움
  - 마지막 값 바로 구할 수 없음
1. 기존 순서대로 요소들 하나씩 거슬러 올라감
    - 각 요소 : 배열 저장
2. 마지막 요소 도달 시
    - 배열 요소들 거꾸로 출력
```javascript
function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}
```

##### 재귀 기반
- 약간 까다로움
  - 나머지 요소들 출력 후 현재 요소 출력
```javascript
function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}
```

##### 동일 접근 방식
1. 리스트 앞에서부터 시작
2. 각 요소
    - 실행 컨텍스트 스택 저장
3. 스택 맨 위에서부터 요소 차례대로 출력
