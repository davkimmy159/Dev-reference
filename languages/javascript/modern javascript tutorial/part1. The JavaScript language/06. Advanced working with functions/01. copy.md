## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 모든 숫자 더하기

##### `sumTo (n)` <sub>(함수)</sub> 작성
- `1 + 2 + … + n` <sub>(숫자)</sub> 계산
```javascript
sumTo(1);  // 1
sumTo(2);  // 3  (2 + 1)
sumTo(3);  // 6  (3 + 2 + 1)
sumTo(4);  // 10 (4 + 3 + 2 + 1)
…
sumTo(100) // 5050 (100 + 99 + … + 2 + 1)
```

##### 3가지 답안
- a. `for` <sub>(반복문)</sub> 사용
- b. 재귀 사용
  - `sumTo(n) = n + sumTo(n - 1)`
    - `n > 1` <sub>(조건)</sub>
- c. [등차수열](https://en.wikipedia.org/wiki/Arithmetic_progression) 공식 사용
```javascript
function sumTo(n) { … }

alert( sumTo(100) ); // 5050
```

##### 더 생각해보기 ⓐ
- 3가지 중
  - 가장 빠른 방법 · 이유
  - 가장 느린 방법 · 이유

##### 더 생각해보기 ⓑ
- 재귀
  - `sumTo (100000)` 계산 가능 여부

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 반복문 사용
```javascript
function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
```

##### 재귀 사용
```javascript
function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
```

##### 등차수열 합공식 사용
- `sumTo(n) = n * (n + 1) / 2`
```javascript
function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
```

#### 더 생각해보기 1

##### 가장 빠른 방법
- 등차수열 합공식
  - `n` 관계없이 오직 3개 연산만 수행

##### 2번째 빠른 방법
- 반복문

##### 가장 느린 방법
- 재귀 <sub>(더 많은 자원 소비)</sub>
  - 중첩 호출 · 실행 스택 관리

#### 더 생각해보기 2

##### 일부 JS 엔진 : 'tail call' 최적화 지원
- 함수 가장 마지막 수행 연산 : 재귀 호출
  - 외부 함수 재실행 불필요
    - 실행 컨텍스트 기억 불필요
    - 메모리 부담 X

##### 대다수 JS 엔진 : 'tail call' 최적화 미지원
- 엔진 설정 스택 크기 제한 초과
  - 최대 스택 크기 초과 에러

<hr />

### 팩토리얼 계산하기

##### [팩토리얼(factorial)](https://en.wikipedia.org/wiki/Factorial)
- `1` ~ `n` 모든 자연수 곱
  - `n` : 자연수
- `n` 팩토리얼
  - `n!`
```javascript
n! = n * (n - 1) * (n - 2) * … * 1

1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
```

##### `factorial(n)` <sub>(함수)</sub> 작성
- 재귀 사용해 `n!` 계산
```javascript
alert( factorial(5) ); // 120
```

##### 힌트
- `n!`
  - `n * (n-1)!`
- ex\) `3!`
  - `3 * 2!`
  - `3 * 2 * 1!`

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### `factorial(n)` → `n` * `factorial(n - 1)`
- `n` <sub>(인수)</sub>
  - → `n - 1` → … → `1`
- 재귀 기반
  - `1` · `0` <sub>(둘 중 하나 · 차이 X)</sub>
```javascript
function factorial(n) {

  // 재귀 기반 : 1
  return (n != 1) ? n * factorial(n - 1) : 1;

  // 재귀 기반 : 0
  return  n       ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
```

<hr />

### 피보나치 수 계산하기

##### [피보나치 수](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%EC%88%98)
- 수열
  - 1 · 2번째 항
    - 1
  - 그 뒤 모든 항
    - 바로 앞 두 항의 합
- F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
  - 1, 1, 2, 3, 5 , 8, 13, 21 …

##### `fib(n)` <sub>(함수)</sub> 작성
- `n` 번째 피보나치 수 반환
```javascript
function fib(n) {
  /* 코드 작성 */
}

alert(fib(3));  // 2
alert(fib(7));  // 13
alert(fib(77)); // 5527939700884757
```

##### 주의
- `fib (77)` 호출 시
  - 연산 시간 \< 1초

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 재귀
```javascript
function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77);      // 많은 시간 소모
```

##### `n` 증가 → 속도 ↓
- 함수 호출 도중 수많은 서브 호출 발생
  - 동일 값들 여러 번 평가

##### ex\) `fib(5)` 계산 과정
- `fib(3)`
  - `fib(5)` · `fib(4)` 계산 시 필요
  - 완전히 다른 두 곳
    - 독립적으로 호출 · 평가
```javascript
…
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
…
```

##### 함수 재귀 트리
- `fib(3)`
  - 2번 평가
- `fib(2)`
  - 3번 평가

![fibonacci-recursion-tree](../../images/01/06/01/fibonacci-recursion-tree.svg)

##### 해결 <sub>(최적화)</sub>
1. 평가된 값
    - 어딘가에 저장
2. 재귀 → 반복문

##### 반복문 기반 알고리즘
- 이전 두 항 값만 저장
  - 연산 속도 ↑
  - 중복 계산 X
```javascript
let a = 1;     // a = fib(1)
let b = 1;     // b = fib(2)
let c = a + b; // c = fib(3)

// a  b  c
// 1, 1, 2

a = b;     // a = fib(2)
b = c;     // b = fib(3)
c = a + b; // c = fib(4)

//    a  b  c
// 1, 1, 2, 3

a = b;     // a = fib(3)
b = c;     // b = fib(4)
c = a + b; // c = fib(5)

//       a  b  c
// 1, 1, 2, 3, 5
```

##### 반복문 기반 코드
```javascript
function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) );  // 2
alert( fib(7) );  // 13
alert( fib(77) ); // 5527939700884757
```

##### [bottom-up 다이내믹 프로그래밍](https://en.wikipedia.org/wiki/Dynamic_programming)

<hr />

### 단일 연결 리스트 출력하기

##### 단일 연결 리스트
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

##### `printList(list)` <sub>(함수)</sub> 작성
- 리스트 내 항목 차례대로 하나씩 출력
- 반복문 · 재귀 각각 사용
  - 둘 중 더 좋은 코드 판단

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 반복문 기반
```javascript
function printList(list) {

  /* 임시 변수 (tmp) 사용
   'tmp' (임시 변수)
   - 좋은 변수명
   - 리스트 순회 용도
   'list' (변수)
   - 리스트 그 자체 저장
   */
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

  /* 매개변수 (list) 사용
   좋지 않은 방법
   - 추후 함수 확장 시
     - 어딘가에 매개변수 (list) 사용 가능
   while (문) 앞에서 매개변수 (list) 변경 시
   - 코드 정상 동작 X

  while (list) {
    alert(list.value);
    list = list.next;
  }
   */

}
```

##### 재귀 기반
```javascript
function printList(list) {

  // 현재 요소 출력
  alert(list.value);

  if (list.next) {

    // 동일 방법으로 나머지 요소 출력
    printList(list.next);
  }

}
```

##### 반복문 vs 재귀
- 반복문
  - 자원 좀 더 효율적으로 사용
    - 중첩 함수 호출 X
- 재귀
  - 코드 길이 ↓
  - 이해 쉬움

<hr />

### 단일 연결 리스트 역순 출력하기

##### 함수 작성
- 이전 과제 연결 리스트 항목 역순 출력
- 반복문 · 재귀 각각 사용

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 반복문 기반
- 까다로움
  - 마지막 값 바로 구할 수 없음
1. 기존 순서대로 요소들 하나씩 거슬러 올라감
    - 각 요소 : 배열 저장
2. 마지막 요소 도달 시
    - 배열 요소들 거꾸로 출력
```javascript
function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}
```

##### 재귀 기반
- 약간 까다로움
  - 나머지 요소들 출력 후 현재 요소 출력
```javascript
function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}
```

##### 동일 접근 방식
1. 리스트 앞에서부터 시작
2. 각 요소
    - 실행 컨텍스트 스택 저장
3. 스택 맨 위에서부터 요소 차례대로 출력
