함수 바인딩
==========

##### 객체 메서드
- 콜백 전달 시
  - `this` 정보 사라짐

### 사라진 `this`
```javascript
// setTimeout
// - this 사라짐
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
```
```javascript
setTimeout(user.sayHi, 1000); // Hello, undefined!

↓↓↓

let f = user.sayHi;
setTimeout(f, 1000); // user (객체) 컨텍스트 잃어버림
```

##### 브라우저 환경 `setTimeout` <sub>(메서드)</sub>
- 특별한 방식 동작
- 인수 전달 함수 호출 시
  - `this` → `window` 할당
  - `this.firstName`
    - → `window.firstName`

### 해결 방법 1 : 래퍼 <sub>(함수)</sub>

##### 가장 간단한 해결책
- 외부 렉시컬 환경 내 `user` <sub>(객체)</sub> 받음
  - 보통 때처럼 메서드 호출
- 화살표 함수
  - 코드 축약
```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);
```

#### 취약성 ↑

##### `setTimeout` 트리거 전 <sub>(1초 지나기 전)</sub> `user` 변경 시
- 변경된 객체 메서드 호출
```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

// Hello, 또 다른 사용자!
setTimeout(() => user.sayHi(), 1000);

// 1초 지나기 전 user 값 바뀜
user = {
  sayHi() {
     alert("또 다른 사용자!");
  }
};
```

### 해결 방법 2 : `bind` <sub>(내장 메서드)</sub>

##### JS 내 모든 함수
- `bind` <sub>(`this` 수정 내장 메서드)</sub> 제공
```javascript
let boundFunc = func.bind(context);
```

##### `boundFunc` <sub>(특수 객체)</sub> 반환
- 함수처럼 호출 가능
- `this` → `context` 고정
- `boundFunc` 호출 == `func` <sub>(`this` 고정)</sub> 호출
```javascript
let user = {
  firstName: "John"
};

function func() {
  alert(this.firstName);
}

// func 의 this → user (객체) 바인딩
let funcUser = func.bind(user);
funcUser(); // John
```

##### 원본 함수에 인수 그대로 전달
```javascript
let user = {
  firstName: "John"
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// this → user 바인딩
let funcUser = func.bind(user);

// 인수 : "Hello"
// this → user (객체) 고정
funcUser("Hello"); // Hello, John
```

##### 객체 메서드 `bind`
- 인수 그대로 전달
- `this` 고정
```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

/* user.sayHi (메서드) → user (객체) 바인딩
 sayHi (함수)
 - '묶인 (bound)' 함수
 - 단독 호출 가능
 */
let sayHi = user.sayHi.bind(user);

// 객체 없이 객체 메서드 호출
sayHi(); // Hello, John!

// 지연 호출
setTimeout(sayHi, 1000); // Hello, John!

// 1초 이내 user (객체) 값 변해도 지연 호출 내 기존 값 사용
user = {
  sayHi() { alert("또 다른 사용자!"); }
};
```
```javascript
let user = {
  firstName: "John",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Hello"); // Hello, John
              // - 인수 : "Hello"
say("Bye");   // Bye, John
              // - 인수 : "Bye"
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`bindAll` : 메서드 전체 바인딩**

##### 객체 전체 메서드 `this` 고정 방법
- 반복문 사용
- lodash <sub>(JS)</sub>
  - `_.bindAll(object, methodNames)`
```javascript
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
```

<br />

### 부분 적용

##### 인수 바인딩
- 드물게 사용
- 가끔 유용
```javascript
let bound = func.bind(context, [arg1], [arg2], …);
```

##### `arg1, arg2, …`
- 바인딩 함수 인수
```javascript
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // 6 , mul(2, 3)
alert( double(4) ); // 8 , mul(2, 4)
alert( double(5) ); // 10, mul(2, 5)
```

##### 가독성 좋은 이름 가진 독립 함수 생성 가능
- `double`
- `triple`
- 기타 등등

##### 1번째 인수 고정
- 매번 인수 전달 필요 X

##### 매우 포괄적인 함수 기반
- 덜 포괄적인 <sub>(더 구체적인)</sub> 변형 함수
- ex&#41; `send(from, to, text)`
  - → `sendTo(to, text)`
    - 전송 주체 : `user` <sub>(현재 사용자)</sub>

### 컨텍스트 없는 부분 적용

##### 네이티브 `bind`
- 컨텍스트 <sub>(1번째)</sub> 인수 생략 불가능

##### 인수만 바인딩 시
- `partial` <sub>(헬퍼 함수)</sub> 구현
```javascript
function partial(func, ...argsBound) {

  // 래퍼 함수
  return function(...args) {
    return func.call(this, ...argsBound, ...args);
  }
}

let user = {
  firstName: "John",
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// 시간 고정 부분 메서드 추가
user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

user.sayNow("Hello"); // [10:00] John: Hello!
```

##### `partial(func[, arg1, arg2, … )` 호출 시
- 래퍼 함수 반환

##### 래퍼 호출 시
- 동일한 `this`
- `user.sayNow`
  - `user` <sub>(객체)</sub> 대상 호출
- `...argsBound`
  - `partial` <sub>(헬퍼 함수)</sub> 호출 시 받은 인수
    - `new Date().getHours()`
- `...args`
  - 래퍼 <sub>(함수)</sub> 전달 인수 <sub>(`"Hello"`)</sub>

##### lodash <sub>(JS 라이브러리)</sub>
- `_.partial`

<br />

## 요약
`func.bind(context, ...args)`는 `this`가 `context`로 고정되고 인수도 고정된 함수 `func`을 반환합니다.

`bind`는 보통 객체 메서드의 `this`를 고정해 어딘가에 넘기고자 할 때 사용합니다. `setTimeout`에 넘길 때 같이 말이죠.

기존 함수의 인수 몇 개를 고정한 함수를 부분 적용(partially applied) 함수 또는 부분(partial) 함수라고 부릅니다.

부분 적용은 같은 인수를 여러 번 반복하고 싶지 않을 때 유용합니다. `send(from, to)`라는 함수가 있는데 `from`을 고정하고 싶다면 `send(from, to)`의 부분 함수를 구현해 사용하면 됩니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### bind를 적용한 함수를 메서드에 정의하기
아래 코드를 실행하면 어떤 결과가 나올까요?
```javascript
function f() {
  alert( this ); // ?
}

let user = {
  g: f.bind(null)
};

user.g();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

정답: `null`
```javascript
function f() {
  alert( this ); // null
}

let user = {
  g: f.bind(null)
};

user.g();
```

`bind`를 적용한 함수의 컨텍스트는 완전히 고정됩니다. 한번 고정되면 바꿀 방법이 없습니다.

따라서 `user.g()`를 실행했음에도 불구하고 기존 함수의 컨텍스트는 `null`이 되기 때문에 `null`이 출력됩니다.

<hr />

### bind 두 번 적용하기
함수에 `bind`를 적용하고, 이어서 한 번 더 `bind`를 적용하면 `this`를 바꿀 수 있을까요?

아래 코드를 실행하면 어떤 결과가 나올까요?
```javascript
function f() {
  alert(this.name);
}

f = f.bind( {name: "John"} ).bind( {name: "Ann" } );

f();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

정답: `"John"`
```javascript
function f() {
  alert(this.name);
}

f = f.bind( {name: "John"} ).bind( {name: "Pete"} );

f(); // John
```

`f.bind(...)`가 반환한 특수 객체인 [묶인 함수(bound function)](https://tc39.es/ecma262/#sec-bound-function-exotic-objects)는 함수 생성 시점의 컨텍스트만 기억합니다. 인수가 제공되었다면 그 인수 또한 기억합니다.

한번 `bind`를 적용하면 `bind`를 사용해 컨텍스트를 다시 정의할 수 없습니다.

<hr />

### bind를 적용한 함수의 프로퍼티
함수 프로퍼티에 값을 하나 할당해봅시다. 이 함수에 `bind` 메서드를 적용하면 프로퍼티 값은 바뀔까요? 그렇다면 혹은 그렇지않다면 그 이유는 무엇일까요?
```javascript
function sayHi() {
  alert( this.name );
}
sayHi.test = 5;

let bound = sayHi.bind({
  name: "John"
});

alert( bound.test ); // 얼럿 창엔 어떤 값이 출력될까요? 값이 나온 이유는 무엇일까요?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

정답: `undefined`

`bind`를 적용하면 또 다른 객체가 반환됩니다. 새로운 객체엔 `test` 프로퍼티가 없으므로 `undefined`가 출력됩니다.

<hr />

### this 값이 undefined인 함수 고치기
아래 함수 `askPassword()`는 비밀번호를 먼저 확인하고 그 결과에 따라 `user.loginOk`나 `user.loginFail`을 호출해야 합니다.

그런데 함수를 호출하면 에러가 발생합니다. 에러는 왜 발생했을까요?

에러가 발생하지 않도록 색칠된 줄을 고쳐보세요. 다른 줄은 바꾸지 않아야 합니다.
```javascript
function askPassword(ok, fail) {
  let password = prompt("비밀번호를 입력해주세요.", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  loginOk() {
    alert(`${this.name}님이 로그인하였습니다.`);
  },

  loginFail() {
    alert(`${this.name}님이 로그인에 실패하였습니다.`);
  },

};

askPassword(user.loginOk, user.loginFail);
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

에러는 `ask`가 함수 `loginOk`, `loginFail`을 객체 없이 가지고 오기 때문에 발생합니다.

`ask`는 `loginOk`, `loginFail`을 호출할 때 `this=undefined`라고 자연스레 가정합니다.

`bind` 함수를 사용해 컨텍스트를 고정시켜 봅시다.
```javascript
function askPassword(ok, fail) {
  let password = prompt("비밀번호를 입력해주세요.", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  loginOk() {
    alert(`${this.name}님이 로그인하였습니다.`);
  },

  loginFail() {
    alert(`${this.name}님이 로그인에 실패하였습니다.`);
  },

};

askPassword(user.loginOk.bind(user), user.loginFail.bind(user));
```

이제 잘 동작합니다.

이 외에도 다른 답이 있는데, 아래에서 확인 가능합니다.
```javascript
//...
askPassword(() => user.loginOk(), () => user.loginFail());
```

이렇게 화살표 함수를 사용하는 방법 또한 대개 잘 동작하며 가독성도 좋습니다.

다만 이 방법은 `askPassword`가 호출됐으나 사용자가 프롬프트 대화상자에 값을 제출하고 `() => user.loginOk()`를 호출하기 전에 `user` 변수가 바뀌는 등의 복잡한 상황에서는 오작동할 가능성이 있습니다.

<hr />

### 로그인에 부분 적용하기
중요도: 5
이 과제는 this 값이 undefined인 함수 고치기를 변형한 좀 더 복잡한 과제입니다.

여기서는 `user` 객체를 수정해 `user`가 `loginOk`, `loginFail` 대신에 오직 하나의 함수 `user.login(true·false)`만 가질 수 있게 해놓았습니다.

`user.login(true)`는 `ok`, `user.login(false)`은 `fail`을 호출하게 하려면 `askPassword`에 무엇을 넘겨줘야 할까요?
```javascript
function askPassword(ok, fail) {
  let password = prompt("비밀번호를 입력해주세요.", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  login(result) {
    alert( this.name + (result ? ' 로그인 성공' : ' 로그인 실패') );
  }
};

askPassword(?, ?); // ?
```

색칠된 줄의 물음표 부분만 수정해야 합니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

1. 래퍼 함수나 화살표 함수를 사용하면 간결하게 원하는 기능을 구현할 수 있습니다.
```javascript
askPassword(() => user.login(true), () => user.login(false));
```
이 방법을 사용하면 `askPassword`는 외부 변수에서 `user`를 가져오기 때문에 원하는 결과를 얻을 수 있습니다.

2. 컨텍스트가 `user`이면서 올바른 첫 번째 인수가 있는 부분 적용 함수를 만들면 원하는 기능을 구현할 수 있습니다.
```javascript
askPassword(user.login.bind(user, true), user.login.bind(user, false));
```
