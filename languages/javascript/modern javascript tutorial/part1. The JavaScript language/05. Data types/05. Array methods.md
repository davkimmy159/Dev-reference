배열 메서드

====
### 요소 추가 · 제거 메서드

##### `delete` <sub>(연산자)</sub> 배열 사용 가능 <sub>(배열 == 객체)</sub>
- 특정 요소 1개 삭제
  - 요소 개수 변화 X
- 사용 지양
  - 배열 메서드 사용
```javascript
let arr = ["I", "go", "home"];

// "go" (2번째 요소) 삭제
delete arr[1];
//  arr = ["I",     , "home"];

alert( arr[1] );     // undefined
alert( arr.length ); // 3
```

#### [`splice`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) <sub>(배열 자체 수정)</sub>

##### 요소 추가 · 삭제 · 교체
```javascript
array.splice(index[, deleteCount, elem1, …, elemN])
```
- `index`
  - 조작 시작점 인덱스
- `[deleteCount]`
  - 제거 요소 개수
- `[elem1, …, elemN]`
  - 추가 요소

##### 요소 제거
```javascript
let arr = ["I", "study", "JavaScript"];

// ① 인덱스 1 ("study") 시작점 설정
// ② 요소 1개 제거 ("study")
arr.splice(1, 1);
// ["I", "JavaScript"]
```

##### 요소 교체
```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// ① 인덱스 0 ("I") 시작점 설정
// ② 요소 3개 제거 ("I" · "study" · "JavaScript")
// ③ 새 요소 추가
arr.splice(0, 3, "Let's", "dance");
// ["Let's", "dance", "right", "now"]
```

##### 반환 값
- 제거 요소 구성 배열
```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// ① 인덱스 0 ("I") 시작점 설정
// ② 요소 2개 제거 ("I" · "study")
// ③ 제거 요소 구성 배열 반환 (변수 저장)
let removed = arr3.splice(0, 2);
// arr     = ["JavaScript", "right", "now"];
// removed = ["I", "study"]
```

##### 요소 추가
- `[deleteCount]` <sub>(제거 요소 개수 · 2번째 인수)</sub>
  - `0` 설정 <sub>(요소 제거 X)</sub>
```javascript
let arr = ["I", "study", "JavaScript"];

// ① 인덱스 2 ("JavaScript") 시작점 설정
// ② 새 요소 추가
arr.splice(2, 0, "complex", "language");
// ["I", "study", "complex", "language", "JavaScript"]
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **음수 인덱스 사용 가능**

##### 배열 관련 메서드
- 음수 인덱스 사용 가능
  - 배열 끝 기준 시작점 설정
```javascript
// -1 (배열 끝 1번째 요소) 부터 0개 요소 삭제 후 3, 4 추가
let arr = [1, 2, 5];

// ① 인덱스 -1 (5) 시작점 설정
// ② 새 요소 추가 (3 · 4)
arr.splice(-1, 0, 3, 4);
// [1, 2, 3, 4, 5]
```

<br />

#### [`slice`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)

##### 배열 내 특정 범위 복사
- `String.slice` <sub>(문자열 메서드)</sub> 동작 유사
```javascript
array.slice([start], [end])
```
- `[start]`
  - 범위 시작
- `[end]`
  - 범위 종료 <sub>(`[end]` 제외)</sub>
- 음수 인수 가능
  - 배열 끝 기준
- 인수 無
  - 배열 복사본 생성
```javascript
let arr = ["t", "e", "s", "t"];

//        s         e
// ["t", "e", "s", "t"]
alert( arr.slice(1, 3)); // e,s

//             s
// ["t", "e", "s", "t"]
alert( arr.slice(-2) );  // s,t
```

#### [`concat`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)

##### 배열 병합 <sub>(새 결과 배열 생성)</sub>
```javascript
array.concat(arg1, arg2 …)
```
- `arg1, arg2 …`
  - 배열 · 값
  - 개수 제한 X

##### 새 배열 내 병합 결과 저장 · 반환
- 호출 배열 <sub>(`array`)</sub> 내 모든 요소 복사
- 인수 <sub>(`arg1, arg2 …`)</sub> 복사
  - 배열 전달 시 모든 요소
```javascript
let arr = [1, 2];

// 1,2,3,4
// - [1, 2] + [3, 4]
alert( arr.concat([3, 4]) );

// 1,2,3,4,5,6
// - [1, 2] + [3, 4] + [5, 6]
alert( arr.concat([3, 4], [5, 6]) );

// 1,2,3,4,5,6
// - [1, 2] + [3, 4] + 5 + 6
alert( arr.concat([3, 4], 5, 6) );
```

##### 객체형 인수 <sub>(유사 배열 객체 등)</sub>
- 객체 자체 <sub>(참조 값)</sub> 복사 <sub>(분해 X)</sub>
```javascript
let arr = [1, 2];
let arrayLike = { // 유사 배열 객체 (배열 X)
  0: "something",
  length: 1
};

// 1,2,[object Object]
// - [1, 2] + arrayLike
let result = arr.concat(arrayLike);

// true
alert( result[2] === arrayLike );
```

##### `[Symbol.isConcatSpreadable]` <sub>(프로퍼티)</sub>
- 유사 배열 객체 배열 취급 여부 결정
  - 객체 내 프로퍼티 값 복사 가능
```javascript
let arr = [1, 2];
let arrayLike = { // 유사 배열 객체 (배열 X)
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

// [1, 2] + {0: "something", 1: "else"}
// 1,2,something,else
alert( arr.concat(arrayLike) );
```

### 반복 작업

#### [`forEach`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)

##### 전체 요소 대상 반복 작업 수행
```javascript
array.forEach(function(item, index, array) { … });
```
- 함수형 인수 <sub>(`function(item, index, array)`)</sub>
  - 각 요소 대상 실행
  - 반환 값 무시
```javascript
// 각 요소 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

// 각 요소 alert (특정 문자열 포함) 실행
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

### 배열 탐색

#### `[i·lastI]ndexOf`

##### 배열 내 특정 요소 검색
```javascript
array.[i·lastI]ndexOf(item, [from])
```
- `item`
  - 검색 대상 <sub>(요소)</sub>
- `[from]` <sub>(숫자)</sub>
  - 검색 시작 인덱스
- 반환 값
  - 인덱스 <sub>(검색 성공)</sub>
  - `-1`<sub>(검색 실패)</sub>
- 검색 방향
  - `indexOf`
    - 앞 → 끝
  - `lastIndexOf`
    - 앞 ← 끝
```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) );     //  1
alert( arr.indexOf(false) ); //  2
alert( arr.indexOf(null) );  // -1
```

#### [`includes`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)

##### 배열 내 특정 요소 유무 여부 검사
```javascript
array.includes(item, [from])
```
- `item`
  - 검색 대상 <sub>(요소)</sub>
- `[from]` <sub>(숫자)</sub>
  - 검색 시작 인덱스
- 요소 위치 X
  - 배열 내 유무 여부만 확인
```javascript
let arr = [1, 0, false];

alert( arr.includes(1) ); // true
```

##### `[i·lastI]ndexOf` vs `includes`
- 요소 검색 시 `===` <sub>(일치 연산자)</sub> 사용 <sub>(공통점)</sub>
  - ex\) `false`
    - 정확히 `false` 만 검색
    - `0` <sub>(falsy 값)</sub> 검색 X
- `NaN` 검색 여부 <sub>(차이점)</sub>
  - `[i·lastI]ndexOf` 불가능
  - `includes` 가능
```javascript
const arr = [NaN];

alert( arr.indexOf(NaN) );  // -1
alert( arr.includes(NaN) ); // true
```

#### `find[Index]`

##### 특정 조건 부합 단일 요소 · 인덱스 검색
```javascript
array.find(function(item, index, array) { … })
```
- 함수형 인수 <sub>(`function(item, index, array)`)</sub>
  - 전체 요소 대상 순차 실행
  - 조건 부합 여부 반환
    - `true` <sub>(검색 성공 · 탐색 중단)</sub>
    - `false` <sub>(탐색 진행)</sub>
- 반환 값
  - 요소 · 인덱스 <sub>(검색 성공)</sub>
  - `undefined` · `-1` <sub>(검색 실패)</sub>
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];
let user = users.find(item => item.id == 1);
// {id: 1, name: "John"}

alert(user.name); // John
```

#### [`filter`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

##### 특정 조건 부합 다수 요소 검색
```javascript
array.filter(function(item, index, array) { … })
```
- 함수형 인수 <sub>(`function(item, index, array)`)</sub>
  - 전체 요소 대상 순차 실행
  - 조건 부합 여부 반환
    - `true` <sub>(결과 배열 내 순차 삽입)</sub>
    - `false` <sub>(결과 배열 내 삽입 X)</sub>
- 반환 값
  - 조건 부합 요소 구성 배열 <sub>(검색 성공)</sub>
  - `[]` <sub>(빈 배열 · 검색 실패)</sub>
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];
let someUsers = users.filter(item => item.id < 3);
/*
[
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
]
 */

alert(someUsers.length); // 2
```

##### 함수형 인수 <sub>(`function(item, index, array)`)</sub>
- 주요 패턴
  - `(item => …)`
- `item` <sub>(1번째 매개변수)</sub>
  - 자주 · 단독 사용
- `index` · `array` <sub>(나머지 매개변수)</sub>
  - 드물게 사용

### 배열 변형

#### [`map`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

##### 요소 변환
```javascript
array.map(function(item, index, array) { … })
```
- 함수형 인수 <sub>(`function(item, index, array)`)</sub>
  - 전체 요소 대상 순차 실행
  - 요소 대신 새 값 반환
- 반환 값
  - 변환 <sub>(새 값 구성)</sub> 배열
```javascript
let names = ["Bilbo", "Gandalf", "Nazgul"];
//                      문자열 → 숫자
let lengths = names.map(item => item.length);

alert(lengths); // 5,7,6
```

#### [`sort`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) <sub>(배열 자체 수정)</sub>

##### 요소 정렬
```javascript
array.sort([function(x, y) { … }])
```
- 함수형 인수 <sub>(`[function(x, y)]`)</sub>
  - 전체 요소 대상 순차 실행
  - 인접 요소 간 비교 수행
    - 비교 결과 반환 필수
- 반환 값
  - 재정렬된 <sub>(기존)</sub> 배열
  - 드물게 사용 <sub>(배열 자체 수정)</sub>

재정렬 후 배열 요소가 `1, 15, 2`가 되었습니다. 기대하던 결과(`1, 2, 15`)와는 다르네요. 왜 이런 결과가 나왔을까요?

요소는 문자열로 취급되어 재 정렬되기 때문입니다.

모든 요소는 문자형으로 변환된 이후에 재 정렬됩니다. 앞서 배웠듯이 문자열 비교는 사전편집 순으로 진행되기 때문에 `2`는 `15`보다 큰 값으로 취급됩니다(`"2" > "15"`).

기본 정렬 기준 대신 새로운 정렬 기준을 만들려면 `arr.sort()`에 새로운 함수를 넘겨줘야 합니다.

인수로 넘겨주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 합니다.

##### 재정렬 시 요소 → 문자열 취급
- 모든 요소 → `string` 형 변환 후 재정렬
  - 사전<sub>(편집)</sub> 순 비교 수행
```javascript
let arr = [ 1, 2, 15 ];

arr.sort();

alert( arr ); // 1, 15, 2
```
- 

```javascript
let arr = [ 1, 2, 15 ];

/*
 arr (배열) 내부 재정렬
 인수 X
 - 요소 : 문자열 취급하여 재정렬
 - 사전편집 순 : "15" < "2"
 */

arr.sort();
alert( arr ); // 1, 15, 2

// 새 정렬 기준 함수
// - 값 2개 비교
// - 반환 값 존재
function compareNumeric(a, b) {

  // 1번째 값 > 2번째 값
  if (a >  b) return 1;

  // 두 값 동일
  if (a == b) return 0;

  // 1번째 값 < 2번째 값
  if (a <  b) return -1;
}
arr.sort(compareNumeric);
alert(arr); // 1, 2, 15
```

##### 정렬 과정 확인 트릭
- 어떤 요소끼리 비교 발생했는지 확인
```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **정렬 함수 : 어떤 숫자든 반환 가능**

- 정렬 함수
  - 반환 값 제약 X
- 양수 반환
  - 1번째 인수 \> 2번째 인수
- 음수 반환
  - 1번째 인수 \< 2번째 인수
```javascript
// 간결한 표현
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15

// 화살표 함수 (더 간결)
arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **문자열 : `localeCompare` <sub>(메서드)</sub> 사용**

- `Ö` 같은 문자 언어 대응
```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );
// Andorra,Vietnam,Österreich
// - 제대로 정렬 X

alert( countries.sort( (a, b) => a.localeCompare(b) ) );
// Andorra,Österreich,Vietnam
// - 제대로 정렬
```

<br />

#### `reverse`
- 요소 역순 정렬
- 재정렬된 기존 배열 반환
```javascript
let arr = [1, 2, 3, 4, 5];

arr.reverse();
alert( arr ); // 5,4,3,2,1
```

#### `split`

##### `String.split(delim)` <sub>(문자열)</sub>
- `delim` <sub>(구분자)</sub> 기준 문자열 분리
```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');
for (let name of arr) {

  // Bilbo에게 보내는 메시지
  // Gandalf에게 보내는 메시지
  // Nazgul에게 보내는 메시지
  alert( `${name}에게 보내는 메시지` );
}
```

##### 2번째 인수
- `number`
- 배열 길이 제한
- 길이 초과 요소 무시
- 실무 가끔 사용
```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

// Bilbo, Gandalf
alert(arr);
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **문자열 글자 단위 분리**

##### `String.split(delim)` <sub>(문자열)</sub>
- `delim` <sub>(구분자)</sub> : `""` <sub>(빈 문자열)</sub>
  - 글자 단위 분리
```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

<br />

#### `arr.join(glue)`
- 배열 요소 모두 합침
  - `glue` <sub>(인수)</sub> 기준
  - 하나의 문자열 생성
```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');

// Bilbo;Gandalf;Nazgul
alert( str );
```

#### `reduce(Right)`
- 각 요소 돌면서 반복 작업 수행
  - 하나의 값 도출

##### `arr.reduce`
```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  …
}, [initial]);
```

##### 함수형 인수
- 전체 배열 요소 대상 순차적으로 적용
- 적용 결과
  - 다음 요소 대상 함수 호출 시 사용
- `accumulator`
  - 이전 요소 대상 함수 호출 결과
- `item`
  - 현재 요소
- `index`
  - 요소 인덱스
- `array`
  - 배열
- `[initial]`
  - 최초 호출 시 사용 초깃값
```javascript
/* 전체 배열 요소 더하기 */
let arr = [1, 2, 3, 4, 5];

// 함수형 인수 내 인수 개수
// - 일반적으로 2개 사용
let result = arr.reduce((sum, current) => sum + current, 0);
alert( result ); // 15

// 초깃값 전달 X
let result = arr.reduce((sum, current) => sum + current);
alert( result ); // 15
```

![reduce](../../images/01/05/05/reduce.svg)

||`sum`|`current`|`result`|
|:---:|:---:|:---:|:---:|
|1번째 호출|`0`|`1`|`1`|
|2번째 호출|`1`|`2`|`3`|
|3번째 호출|`3`|`3`|`6`|
|4번째 호출|`6`|`4`|`10`|
|5번째 호출|`10`|`5`|`15`|

##### 초깃값 미전달 시
- 1번소 요소
  - 초깃값으로 사용
- 2번째 요소부터 함수형 인수 호출
- `[]` <sub>(빈 배열)</sub> 메서드 호출 시 에러
- 항상 초깃값 명시 권장
```javascript
let arr = [];

arr.reduce((sum, current) => sum + current)
// TypeError: Reduce of empty array with no initial value
// 초깃값 전달 시
// - 초깃값 반환
// - 에러 X
```

##### `arr.reduceRight`
- `reduce` 동일 기능
- 배열 우측부터 연산 수행

### `Array.isArray`
- 배열 여부 확인

##### 배열
- 독립된 자료형 X
- 객체형 취급

##### `typeof` <sub>(연산자)</sub>
- 일반 객체 · 배열 구분 X
```javascript
alert(typeof {}); // object
alert(typeof []); // object
```

##### `Array.isArray(value)`
- `value` 값
  - 배열
    - `true` 반환
  - 배열 X
    - `false` 반환
```javascript
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

### 배열 메서드 · `thisArg`

##### 함수형 인수 받는 대다수 배열 메서드 <sub>(`sort` 제외)</sub>
- 마지막 인수 존재
  - `thisArg`

##### `thisArg`
- 선택적 매개변수
- 가끔 사용
```javascript
// 선택적으로 사용
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```
- 함수형 인수의 `this`
```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// thisArg == canJoin 컨텍스트 (army 객체) 정보
// 화살표 함수보다 좀 더 이해 쉬움
// - 더 자주 사용
let soldiers1 = users.filter(army.canJoin, army);
//                                        thisArg

// 동일 (화살표 함수)
let soldiers2 = users.filter(user => army.canJoin(user))

alert(soldiers1.length); // 2
alert(soldiers1[0].age); // 20
alert(soldiers1[1].age); // 23
```

##### `thisArgs` : `army` 미지정 시
- `army.canJoin`
  - 단독 함수 취급
- 함수 본문 내
  - `this` → `undefined` <sub>(에러)</sub>

<br />

요약
====

### 배열 메서드

#### 요소 추가 · 삭제

##### `push(...items)`
- 맨 끝에 요소 추가

##### `pop()`
- 맨 끝 요소 추출

##### `shift()`
- 첫 요소 추출

##### `unshift(...items)`
- 맨 앞에 요소 추가

##### `splice(pos, deleteCount, ...items)`
1. `deleteCount` 개 요소 삭제
    - `pos` ~
2. `items` 추가

##### `slice(start, end)`
- 요소 복사해 새 배열 생성
  - `start` ~ (`end` - 1)

##### `concat(...items)`
1. 배열 내 모든 요소 복사 후
    - `items` <sub>(요소 · 배열)</sub> 추가
2. 값 담은 새 배열 생성 후 반환

#### 요소 찾기

##### `[lastI·i]ndexOf(item, pos)`
- `item` 검색 <sub>(`pos` ~)</sub>
  - 성공 시
    - 해당 요소 인덱스 반환
  - 실패 시
    - `-1` 반환

##### `includes(value)`
- 배열 내 `value` <sub>(요소)</sub>
  - 존재 시
    - `true` 반환
  - 부재 시
    - `false` 반환

##### [`find·filter](func)`
- 특정 1번째 · 모든 요소 반환
  - 조건 : `func` 반환 값 == `true`

##### `findIndex(func)`
- `find` 유사
- 인덱스 반환

#### 배열 전체 순회

##### `forEach(func)`
- 전체 요소 대상 `func` 호출
  - 결과 반환 X

#### 배열 변형

##### `map(func)`
- 전체 요소 대상 `func` 호출
  - `func` 반환 결과 → 새 배열에 추가
  - 결과 담은 새 배열 반환

##### `sort(func)`
- 배열 정렬
  - 기존 배열 적용 · 반환

##### `reverse()`
- 배열 뒤집어 반환
  - 기존 배열 적용 · 반환

##### `split` · `join`
- 문자열 ↔ 배열 변환

##### `reduce(func, initial)`
- 각 요소 대상 `func` 호출
  - `func` 반환 값
    - 다음 `func` 호출에 전달
- 최종적으로 하나의 값 도출

#### 기타
- `Array.isArray(arr)`
  - `arr` : 배열 여부 판단

#### 기존 배열 변형 메서드
- `sort`
- `reverse`
- `splice`

#### 이 외 배열 메서드

##### [`some(func)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
- 전체 요소 대상 `func` 호출
- 특정 요소 조건 부합 여부 <sub>(최소 1개)</sub>
  - `func` 반환 값 == `true` <sub>(조건)</sub>
- 하나라도 조건 만족 시
  - `true` 반환
- 전부 조건 불만족 시
  - `false` 반환
##### [`every(func)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)
- 전체 요소 대상 `func` 호출
- 전체 요소 조건 부합 여부
  - `func` 반환 값 == `true` <sub>(조건)</sub>
- 전부 조건 만족 시
  - `true` 반환
- 하나라도 조건 불만족 시
  - `false` 반환

##### [`fill(value, start, end)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)
- `value` 채워넣기
  - `start` ~ `end`

##### [`copyWithin(target, start, end)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)
1. 요소 복사
    - `start` ~ `end`
2. 복사한 요소 → `target` 에 추가
    - 기존 요소 존재 시
      - 덮어씀

##### 배열 관련 메서드 참조
- [`manual`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array)

<br />
