배열 · 메서드
============

### 요소 추가 · 제거 메서드

#### `splice`

##### `delete` <sub>(연산자)</sub>
- 배열 요소 1개 삭제
  - 배열 == 객체
- 원하는 요소 삭제
- 배열 요소 개수 변화 X
```javascript
let arr = ["I", "go", "home"];
delete arr[1];   // "go" 삭제
alert( arr[1] ); // undefined

// delete 요소 삭제 후 배열
// arr = ["I",  , "home"];
alert( arr.length ); // 3
```

##### `splice`
- 요소 추가 · 삭제 · 교체
```javascript
arr.splice(index[, deleteCount, elem1, …, elemN])
```
- `index`
  - 조작 가할 1번째 요소 인덱스 <sub>(index)</sub>
- `deleteCount`
  - 제거 요소 개수
- `elem1, …, elemN`
  - 추가할 요소
```javascript
/* 요소 삭제 */
let arr1 = ["I", "study", "JavaScript"];
arr1.splice(1, 1); // 인덱스 1부터 요소 1개 제거
alert( arr1 );     // ["I", "JavaScript"]

/* 처음 (0) 3개 (3) 요소 삭제 후 다른 요소 대체 */
let arr2 = ["I", "study", "JavaScript", "right", "now"];
arr2.splice(0, 3, "Let's", "dance");
alert( arr2 ) // ["Let's", "dance", "right", "now"]

/* 삭제된 요소 구성 배열 반환 */
let arr3 = ["I", "study", "JavaScript", "right", "now"];
let removed = arr3.splice(0, 2); // 처음 2개 요소 삭제
alert( removed );                // "I", "study"

/*
 삭제 X · 새 요소 추가
 - deleteCount == 0
 인덱스 2부터 0개 요소 삭제 후 "complex", "language" 추가
 */
let arr = ["I", "study", "JavaScript"];
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **음수 인덱스 사용 가능**

##### 배열 관련 메서드
- 음수 인덱스 사용 시
  - 배열 끝 기준
```javascript
// -1 (배열 끝 1번째 요소) 부터 0개 요소 삭제 후 3, 4 추가
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5
```

<br />

#### `slice`
```javascript
arr.slice([start], [end])
```
- 해당 범위 요소 복사한 새 배열 반환
  - 범위 : `start` ~ `end` <sub>(`end` 제외)</sub>
- 음수 인수 <sub>(`start` · `end`)<sub/>
  - 배열 끝 기준
- 인수 X
  - 복사본 생성
- `str.slice` <sub>(문자열 메서드)</sub> 동작 유사
```javascript
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s
alert( arr.slice(-2) );   // s,t
```

#### `concat`
- 기존 배열 요소 사용해 새 배열 생성
- 기존 배열 요소에 추가 후
  - 새 배열 반환
- 인수
  - 배열 · 값
  - 개수 제한 X
```javascript
arr.concat(arg1, arg2 …)
```
- `arr` <sub>(전체 요소)</sub> + `arg1` · `arg2` … <sub>(전체 요소)</sub>
  - 요소 합친 새 배열 반환
- `argN` <sub>(인수)</sub> : 배열
  - 배열 내 모든 요소 복사
```javascript
let arr = [1, 2];
alert( arr.concat([3, 4]) );         // 1,2,3,4
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
alert( arr.concat([3, 4], 5, 6) );   // 1,2,3,4,5,6
```
- 제공받은 배열 요소 <sub>(인수)</sub>
  - 복사해 활용
- 객체 <sub>(유사 배열 객체 포함)</sub> 인자
  - 분해 X
  - 통으로 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

##### 유사 배열 객체 인자
- `[Symbol.isConcatSpreadable]` <sub>(특수 프로퍼티)</sub> 존재 시
  - 배열 취급
    - 객체 전체 복사 X
    - 객체 프로퍼티 값 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

#### `forEach` : 반복 작업
- 함수 인자
  - 배열 요소 각각에 실행
  - 반환 값 무시
```javascript
arr.forEach(function(item, index, array) {
  // …
});
```
```javascript
// 각 요소
// - alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

// 각 요소
// - 인덱스 정보 더해서 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

### 배열 탐색

#### `indexOf` · `lastIndexOf` · `includes`
- 동명 문자열 메서드
  - 문법 · 기능 동일

##### `arr.indexOf(item, from)`
- `from` <sub>(인덱스)</sub> 부터 `item` <sub>(요소)</sub> 검색
- 해당 요소 발견 시
  - 해당 요소 인덱스 반환
- 해당 요소 미발견 시
  - `-1` 반환

##### `arr.lastIndexOf(item, from)`
- `indexOf` 동일 기능
- 끝부터 검색

##### `arr.includes(item, from)`
- `from` <sub>(인덱스)</sub> 부터 시작해 `item` 검색
- 해당 요소 발견 시
  - `true` 반환
- 해당 요소 미발견 시
  - `false` 반환
```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) );     //  1
alert( arr.indexOf(false) ); //  2
alert( arr.indexOf(null) );  // -1
alert( arr.includes(1) );    // true
```

##### 요소 검색 : `===` <sub>(완전 항등 연산자)</sub> 사용
- ex&#41; `false` 검색 시
  - 정확히 `false` 만 검색
  - `0` 검색 X

##### `includes`
- 요소 위치 X
- 배열 내 존재 여부만 확인
- `NaN` : 제대로 처리
  - `indexOf` · `lastIndexOf` 와의 차이
```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) );  // -1
                            // '===' (완전 항등 비교) : NaN 동작 X
alert( arr.includes(NaN) ); // true, NaN 여부 확인
```

#### `find` 와 `findIndex`
- 특정 조건 부합 요소 검색
```javascript
let result = arr.find(function(item, index, array) {
  /*
   조건 해당 요소 존재 시 (함수 인수 내 true 반환)
   - 반복 중단
   - 해당 요소 반환
   조건 해당 요소 부재 시
   - undefined 반환
   */
});
```
##### `find`
- 전체 요소 대상 함수 순차적으로 호출
- `item`
  - 요소
- `index`
  - 요소 인덱스
- `array`
  - 배열 자기 자신
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // John
```

##### 가장 많이 사용되는 패턴
- `(item => item.id == 1)`
  - 1번째 인자만 사용
- 다른 인자들 <sub>(`index` · `array`)</sub>
  - 자주 사용 X

##### `arr.findIndex`
- `find` 동일
- 요소 반환 X
- 요소 인덱스 반환
- 조건 해당 요소 부재 시
  - `-1` 반환

#### `filter`
- 조건 부합 요소들 담은 새 배열 반환
```javascript
let results = arr.filter(function(item, index, array) {
  /*
   조건 충족 요소
   - results 에 순차적으로 추가
   - 하나도 없으면 빈 배열 반환
   */
});
```
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명 반환
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
```
### 배열 변형

#### `map`
- 전체 배열 요소 대상 함수 호출
- 변형된 요소들 담은 새 배열 반환
```javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새 값 반환
});
```
```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

#### `sort(fn)`
- 배열 요소 정렬
- 배열 자체 변경
- 재정렬 된 배열 반환
  - 반환 값 잘 사용 X <sub>(이미 배열 자체 수정됨)</sub>
```javascript
let arr = [ 1, 2, 15 ];

/*
 arr (배열) 내부 재정렬
 인수 X
 - 요소 : 문자열 취급하여 재정렬
 - 사전편집순 : "15" < "2"
 */

arr.sort();
alert( arr );           // 1, 15, 2

// 새 정렬 기준 함수
// - 값 2개 비교
// - 반환 값 존재
function compareNumeric(a, b) {
  if (a >  b) return 1;  // 1번째 값 > 2번째 값
  if (a == b) return 0;  // 두 값 동일
  if (a <  b) return -1; // 1번째 값 < 2번째 값
}
arr.sort(compareNumeric);
alert(arr);             // 1, 2, 15
```

##### 정렬 과정 확인 트릭
- 어떤 요소끼리 비교 발생했는지 확인
```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **정렬 함수 : 어떤 숫자든 반환 가능**

- 정렬 함수
  - 반환 값 제약 X
- 양수 반환
   - 1번째 인수 &#62; 2번째 인수
- 음수 반환
   - 1번째 인수 &#60; 2번째 인수
```javascript
// 간결한 표현
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15

// 화살표 함수 (더 간결)
arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
```

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **문자열 : `localeCompare` <sub>(메서드)</sub> 사용**

- `Ö` 같은 문자 언어 대응
```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );
// Andorra,Vietnam,Österreich
// - 제대로 정렬 X

alert( countries.sort( (a, b) => a.localeCompare(b) ) );
// Andorra,Österreich,Vietnam
// - 제대로 정렬
```

<br />

#### `reverse`
- 요소 역순 정렬
- 재정렬된 기존 배열 반환
```javascript
let arr = [1, 2, 3, 4, 5];

arr.reverse();
alert( arr ); // 5,4,3,2,1
```

#### `split`

##### `str.split(delim)` <sub>(문자열)</sub>
- `delim` <sub>(구분자)</sub> 기준 문자열 분리
```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');
for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
                                    // Gandalf에게 보내는 메시지
                                    // Nazgul에게 보내는 메시지
}
```
- 2번째 인수
  - 숫자형
  - 배열 길이 제한
  - 길이 초과 요소 무시
  - 실무 가끔 사용
```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **문자열 글자 단위 분리**

##### `str.split(delim)` <sub>(문자열)</sub>
- `delim` <sub>(구분자)</sub> : `""` <sub>(빈 문자열)</sub>
  - 글자 단위 분리
```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

<br />

#### `arr.join(glue)`
- `glue` <sub>(인수)</sub> 기준 배열 요소 모두 합침
  - 하나의 문자열 생성
```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');
alert( str ); // Bilbo;Gandalf;Nazgul
```

#### `reduce` · `reduceRight`
- 각 요소 돌면서 반복 작업 수행
  - 하나의 값 도출

##### arr.reduce
```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // …
}, [initial]);
```

##### 함수 인자
- 전체 배열 요소 대상 순차적으로 적용
- 적용 결과
  - 다음 요소 대상 함수 호출 시 사용
- 인수
  - `accumulator`
    - 이전 요소 대상 함수 호출 결과
  - `item`
    - 현재 요소
  - `index`
    - 요소 인덱스
  - `array`
    - 배열
- `initial`
  - 최초 호출 시 사용 초깃값 <sub>(옵션)</sub>
```javascript
/* 전체 배열 요소 더하기 */
let arr = [1, 2, 3, 4, 5];

// 함수 인수
// - 일반적으로 인수 2개 사용
let result = arr.reduce((sum, current) => sum + current, 0);
alert( result ); // 15

// 초깃값 전달 X
let result = arr.reduce((sum, current) => sum + current);
alert( result ); // 15
```

![reduce](../../images/01/05/05/reduce.svg)

||`sum`|`current`|`result`|
|:---:|:---:|:---:|:---:|
|1번째 호출|`0`|`1`|`1`|
|2번째 호출|`1`|`2`|`3`|
|3번째 호출|`3`|`3`|`6`|
|4번째 호출|`6`|`4`|`10`|
|5번째 호출|`10`|`5`|`15`|

##### 초깃값 미전달 시
- 1번소 요소
  - 초깃값으로 사용
- 2번째 요소부터 함수 인수 호출
- 빈 배열 메서드 호출 시
  - 에러 발생
- 항상 초깃값 명시 권장
```javascript
let arr = [];

arr.reduce((sum, current) => sum + current)
// TypeError: Reduce of empty array with no initial value
// 초깃값 전달 시
// - 초깃값 반환
// - 에러 발생 X
```

##### `arr.reduceRight`
- `reduce` 동일 기능
- 배열 오른쪽부터 연산 수행

### `Array.isArray` : 배열 여부 체크

##### 배열
- 독립된 자료형 X
- 객체형 취급

##### `typeof`
- 일반 객체 · 배열 구분 X
```javascript
alert(typeof {}); // object
alert(typeof []); // object
```

##### `Array.isArray(value)`
- `value` 값
  - 배열 &nbsp;&nbsp; : `true` 반환
  - 배열 X : `false` 반환
```javascript
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

### 배열 메서드 · `thisArg`

##### 함수 인수 받는 대부분 배열 메서드 <sub>(`sort` 제외)</sub>
- 함수 인수 마지막 인수 존재
  - `thisArg`

##### `thisArg`
- 선택적 매개변수
- 가끔 사용
```javascript
// 선택적으로 사용할 수 있는 마지막 인수
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```
- 함수 인수 `this`
```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// thisArg == canJoin 컨텍스트 (army 객체) 정보
// 화살표 함수보다 좀 더 이해 쉬움
// - 더 자주 사용
let soldiers1 = users.filter(army.canJoin, army);
//                                        thisArg

// 동일 (화살표 함수)
let soldiers2 = users.filter(user => army.canJoin(user))

alert(soldiers1.length); // 2
alert(soldiers1[0].age); // 20
alert(soldiers1[1].age); // 23
```

##### `thisArgs` : `army` 미지정 시
- `army.canJoin`
  - 단독 함수 취급
- 함수 본문 내
  - `this` → `undefined` <sub>(에러 발생)</sub>

<br />

## 요약
지금까지 살펴본 배열 메서드를 요약해보도록 합시다.

요소를 더하거나 지우기
- `push(...items)` – 맨 끝에 요소 추가하기
- `pop()` – 맨 끝 요소 추출하기
- `shift()` – 첫 요소 추출하기
- `unshift(...items)` – 맨 앞에 요소 추가하기
- `splice(pos, deleteCount, ...items)` – `pos`부터 `deleteCount`개의 요소를 지우고, `items` 추가하기
- `slice(start, end)` – `start`부터 `end` 바로 앞까지의 요소를 복사해 새로운 배열을 만듦
- `concat(...items)` – 배열의 모든 요소를 복사하고 `items`를 추가해 새로운 배열을 만든 후 이를 반환함. `items`가 배열이면 이 배열의 인수를 기존 배열에 더해줌

원하는 요소 찾기
- `indexOf`/`lastIndexOf(item, pos)` – `pos`부터 원하는 `item`을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면 `-1`을 반환함
- `includes(value)` – 배열에 `value`가 있으면 `true`를, 그렇지 않으면 `false`를 반환함
- `find`/`filter(func)` – `func`의 반환 값을 `true`로 만드는 첫 번째/전체 요소를 반환함
- `findIndex`는 `find`와 유사함. 다만 요소 대신 인덱스를 반환함

배열 전체 순회하기
- `forEach(func)` – 모든 요소에 `func`을 호출함. 결과는 반환되지 않음

배열 변형하기
- `map(func)` – 모든 요소에 `func`을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦
- `sort(func)` – 배열을 정렬하고 정렬된 배열을 반환함
- `reverse()` – 배열을 뒤집어 반환함
- `split`/`join` – 문자열을 배열로, 배열을 문자열로 변환함
- `reduce(func, initial)` – 요소를 차례로 돌면서 `func`을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨

기타
- `Array.isArray(arr)` – `arr`이 배열인지 여부를 판단함

`sort`, `reverse`, `splice`는 기존 배열을 변형시킨다는 점에 주의하시기 바랍니다.

지금까지 배운 메서드만으로 배열과 관련된 작업 99%를 해결할 수 있습니다. 이 외의 배열 메서드도 있긴 한데 잠시 언급하고 넘어가겠습니다.

- [`arr.some(fn)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)과 [`arr.every(fn)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)는 배열을 확인합니다.

  두 메서드는 `map`과 유사하게 모든 요소를 대상으로 함수를 호출합니다. `some`은 함수의 반환 값을 `true`로 만드는 요소가 하나라도 있는지 여부를 확인하고 `every`는 모든 요소가 함수의 반환 값을 `true`로 만드는지 여부를 확인합니다. 두 메서드 모두 조건을 충족하면 `true`를, 그렇지 않으면 `false`를 반환합니다.

- [`arr.fill(value, start, end)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)은 `start`부터 `end`까지 `value`를 채워 넣습니다.

- [`arr.copyWithin(target, start, end)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)은 `start`부터 `end`까지 요소를 복사하고, 복사한 요소를 `target`에 붙여넣습니다. 기존 요소가 있다면 덮어씁니다.

배열에 관한 모든 메서드는 [`manual`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array)에서 찾아볼 수 있습니다.

배워야 할 메서드 종류가 너무 많아서 이걸 다 외워야 하나라는 생각이 들 수 있는데, 생각보다 쉬우니 너무 걱정하지 않으셨으면 좋겠습니다.

일단은 요약본을 참고해 자주 사용하는 메서드가 무엇인지 정도만 알아두어도 괜찮습니다. 아래 과제를 풀면서 충분히 연습하다 보면 배열 메서드에 대한 경험치가 쌓일 겁니다.

나중에 배열을 이용해 뭔가를 해야 하는데 방법이 떠오르지 않을 때 이곳으로 돌아와 요약본을 다시 보고 상황에 맞는 메서드를 찾으면 됩니다. 설명에 딸린 예시들이 실제 코드 작성 시 도움이 될 겁니다. 이런 과정을 반복하다 보면 특별한 노력 없이도 메서드를 저절로 외울 수 있습니다.

<br />

## <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `border-left-width`를 `borderLeftWidth`로 변경하기
`"my-short-string"`같이 여러 단어를 대시(`-`)로 구분한 문자열을 카멜 표기법을 사용한 문자열 `"myShortString"`로 변경해주는 함수를 작성해보세요.

대시는 모두 지우고 각 단어의 첫 번째 글자는 대문자로 써주면 됩니다.

예시:
```javascript
camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
```

힌트: `split`을 사용해 문자열을 배열로 바꾼 다음 `join`을 사용해 다시 합치면 됩니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
function camelize(str) {
  return str
    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
    .map(
      // capitalizes first letters of all array items except the first one
      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}
```

[정답](https://plnkr.co/edit/htDT2IV2gucoSwys?p=preview)

<hr />

### 특정 범위에 속하는 요소 찾기
배열 `arr`의 요소 중 `a`이상 `b` 이하 범위에 속하는 요소만 골라 새로운 배열에 집어넣고, 해당 요소를 출력해주는 함수 `filterRange(arr, a, b)`를 작성해봅시다.

새로 작성하는 함수는 기존 배열 `arr`을 변경하면 안 되고, 반환되는 함수는 새로운 배열이어야 합니다.

예시:
```javascript
let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (조건에 맞는 요소)

alert( arr ); // 5,3,8,1 (기존 배열은 변경되지 않았습니다.)
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
function filterRange(arr, a, b) {
  // 가독성을 위해 표현식을 괄호로 감싸주었습니다.
  return arr.filter(item => (a <= item && item <= b));
}

let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (조건에 맞는 요소)

alert( arr ); // 5,3,8,1 (기존 배열은 변경되지 않았습니다.)
```

[정답](https://plnkr.co/edit/vQPP6s9ecysjbLsS?p=preview)

<hr />

### 특정 범위에 속하는 요소 찾기(배열 변경하기)
배열 `arr`의 요소 중 `a`와 `b` 사이에 속하지 않는 요소는 삭제해주는 함수 `filterRangeInPlace(arr, a, b)`를 작성해보세요. 배열의 모든 요소(`i`)는 다음 조건을 만족해야 합니다. `a ≤ arr[i] ≤ b`

작성한 함수는 기존 배열을 변경하기만 하고 아무것도 반환하지 않아야 합니다.

예시:
```javascript
let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // 1과 4 사이에 있지 않은 요소는 모두 제거함

alert( arr ); // [3, 1]
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // 범위 밖의 요소를 제거함
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}

let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // 1과 4 사이에 있지 않은 요소는 모두 제거함

alert( arr ); // [3, 1]
```

[정답](https://plnkr.co/edit/vJqEQRv1TiBL6wL4?p=preview)

<hr />

### 내림차순으로 정렬하기
```javascript
let arr = [5, 2, 1, -10, 8];

// 요소를 내림차순으로 정렬해주는 코드를 여기에 작성해보세요.

alert( arr ); // 8, 5, 2, 1, -10
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );
```

<hr />

### 배열 복사본을 정렬하기
문자열이 담긴 배열 `arr`을 복사한 다음 해당 배열을 정렬해봅시다. 단 이때 `arr`은 변경되면 안 됩니다.

함수 `copySorted(arr)`는 복사 후 정렬된 배열을 반환해야 합니다.
```javascript
let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

`slice()`를 사용해 배열을 복사한 다음 정렬하면 됩니다.
```javascript
function copySorted(arr) {
  return arr.slice().sort();
}

let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted );
alert( arr );
```

<hr />

### 확장 가능한 계산기
기능을 "확장"할 수 있는 계산기 객체를 만들어 주는 생성자 함수 `Calculator`를 작성해봅시다.

`Calculator`는 두 단계를 거쳐 만들 수 있습니다.

##### 1.
첫 번째 단계는 `"1 + 2"`와 같은 문자열을 받아서 “숫자 연산자 숫자” 형태(공백으로 구분)로 바꿔주는 메서드 `calculate(str)`를 구현하는 것입니다. 이 함수는 `+`와 `-`를 처리할 수 있어야 하고, 연산 결과를 반환해야 합니다.

예시:
```javascript
let calc = new Calculator;

alert( calc.calculate("3 + 7") ); // 10
```

##### 2.
두 번째 단계는 계산기가 새로운 연산을 학습할 수 있도록 해주는 메서드 `addMethod(name, func)`를 추가해 주는 것입니다. 연산자 이름을 나타내는 `name`과 인수가 두개인 익명 함수 `func(a,b)`를 받는 새 메서드를 구현해야 하죠.

구현된 메서드를 이용해 곱셈 `*`과 나눗셈 `/`, 거듭제곱 `**`연산자를 추가해주는 예시는 아래와 같습니다.
```javascript
let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) => a * b);
powerCalc.addMethod("/", (a, b) => a / b);
powerCalc.addMethod("**", (a, b) => a ** b);

let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8
```

참고사항:
- 괄호나 복잡한 표현식 없이도 본 과제를 풀 수 있습니다.
- 숫자와 연산자는 공백 하나로 구분합니다.
- 에러 핸들링을 위한 코드를 추가해도 좋습니다(선택 사항).

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

- 메서드는 `this.methods` 프로퍼티를 사용해 추가할 수 있습니다.
- 예외처리와 숫자형으로의 변환은 모두 메서드 `calculate`에서 처리하고 있습니다. 이렇게 해야 추후 좀 더 복잡한 표현식을 추가할 수 있습니다.
```javascript
function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
```

[정답](https://plnkr.co/edit/gMJhWhNZuRVBIp7b?p=preview)

<hr />

### 이름 매핑하기
`name`을 나타내는 프로퍼티를 가진 객체 `user`가 담긴 배열이 있습니다. `name`의 값만 담은 새로운 배열을 만들어주는 코드를 작성해보세요.

예시:
```javascript
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = /* 여기에 코드를 작성하세요. */

alert( names ); // John, Pete, Mary
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = users.map(item => item.name);

alert( names ); // John, Pete, Mary
```

<hr />

### 객체 매핑하기
세 개의 프로퍼티 `name`과 `surname`, `id`를 가진 객체 `user`가 담긴 배열이 있습니다.

`name`과 `surname`을 조합해 `fullName`을 만들고, 이를 이용해 두 개의 프로퍼티 `id`와 `fullName`을 가진 객체를 담은 새로운 배열을 반환해주는 코드를 작성해보세요.

예시:
```javascript
let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = /* 여기에 코드를 작성하세요. */

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith
```

문제를 해결하려면 배열을 새로운 배열로 매핑해야 합니다. 힌트를 하나 드리자면 `=>`를 이용하는 것입니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
```

화살표 함수 우측에 괄호를 썼다는 점에 주목해주시기 바랍니다.

아래와 같이 괄호 없이 코드를 작성할 수 없습니다.
```javascript
let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});
```

앞서 배웠듯이 화살표 함수는 본문이 없는 형태인 `value => expr`와 본문이 있는 형태인 `value => {...}` 두 방법으로 작성할 수 있습니다.

중괄호 `{`를 만나면 자바스크립트는 이를 객체의 시작이라 인식하지 않고 함수 본문이 시작되는 것이라 인식합니다. 소괄호를 사용하면 이를 피할 수 있습니다.
```javascript
let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
```

이제 코드가 의도한 대로 동작합니다.

<hr />

### 나이를 기준으로 객체 정렬하기
프로퍼티 `age`가 있는 객체가 담긴 배열이 있습니다. 이 배열을 `age`를 기준으로 정렬해주는 함수 `sortByAge(users)`를 만들어보세요.

예시:
```javascript
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
function sortByAge(arr) {
  arr.sort((a, b) => a.age - b.age);
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// now sorted is: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
```

<hr />

### 배열 요소 무작위로 섞기
배열의 요소를 무작위로 섞어주는 함수 `shuffle(array)`을 작성해 보세요.

`shuffle`을 여러 번 실행하면 요소의 정렬 순서가 달라야 합니다. 예시를 살펴봅시다.
```javascript
let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
```

문제를 풀 때 주의할 점은 모든 순열이 동일한 확률로 일어나야 한다는 점입니다. 예를 들어 `[1,2,3]` 은 `[1,2,3]`이나 `[1,3,2]`, `[3,1,2]`로 재정렬 될 수 있는데, 이 배열들이 만들어지는 빈도는 같아야 합니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

간단한 해결책은 아래와 같습니다.
```javascript
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
```

`Math.random() - 0.5`의 계산 결과는 양수나 음수 둘 중 하나이기 때문에 정렬 함수는 요소를 무작위로 재 정렬해줍니다.

그런데 `sort`는 이런 용도로 만들어진 메서드가 아니기 때문에 위와 같이 답안을 작성하면 숫자 `1`과 `2`, `3`으로 만들 수 있는 순열이 같은 빈도로 나타나지 않습니다.

예시를 이용해 이를 살펴봅시다. 아래 코드는 함수 `shuffle`을 백만 번 실행시키고 가능한 한 모든 결과의 빈도를 세줍니다.
```javascript
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// 1, 2, 3으로 만들 수 있는 모든 순열의 빈도를 세줍니다.
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// 만들 수 있는 모든 순열의 생성 빈도를 세서 출력해줍니다.
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
```

위 코드를 실행하면 아래와 유사한 결과가 도출됩니다(자바스크립트 엔진마다 다를 수 있습니다).
```javascript
123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
```

`123`과 `213`이 나타나는 빈도가 높은 것으로 보아 기존 코드를 이용하면 결과가 한쪽으로 쏠릴 수 있다는 것을 알 수 있습니다.

실행 결과는 자바스크립트 엔진마다 다르겠지만, 기존 코드는 문제에서 제시한 조건을 만족하지 못한다는 사실을 알게 되었습니다.

왜 위 코드는 의도한 대로 동작하지 않는 걸까요? 그 이유는 `sort`를 실행했을 때 내부 동작이 블랙박스 안에 담겨있기 때문입니다. `sort`를 실행하면 인수로 넘긴 정렬 함수가 배열을 정리해주는데 이 과정에서 배열 요소끼리의 비교가 완전 무작위로 이뤄지기 때문에 블랙박스 안에 무엇이 담겨있을지는 더 예측하기 어려워집니다. 자바스크립트 엔진마다 내부 구현방식이 다르므로 이런 혼돈은 더 커지죠.

이런 문제는 다양한 방법으로 해결할 수 있는데 [`피셔-예이츠 셔플(Fisher-Yates shuffle)`](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) 알고리즘은 이 중 하나입니다. 피셔-예이츠 셔플 알고리즘은 배열 끝 요소부터 시작해 앞으로 하나씩 나아가면서 해당 요소 앞에 있는 임의의 요소와 해당 요소를 바꿔치기하는 알고리즘입니다.
```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // 무작위 인덱스(0 이상 i 미만)

    // array[i]와 array[j]를 바꿔치기합니다.
    // 아래 답안에선 "구조 분해 할당(destructuring assignment)"이라 불리는 문법을 사용하여
    // 원하는 것을 구현하였는데,
    // 이 문법에 대한 자세한 내용은 이후 챕터에서 다룰 예정입니다.
    // 구조 분해 할당을 사용하지 않고 작성한 코드는 아래와 같습니다.
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
```

자 이제 새롭게 작성한 함수를 가지고 실행해 봅시다.
```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// 1, 2, 3으로 만들 수 있는 모든 순열의 빈도를 세줍니다.
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// 만들 수 있는 모든 순열의 생성 빈도를 세서 출력해줍니다.
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
```

실행 결과는 아래와 같습니다.
```javascript
123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
```

모든 순열이 거의 유사한 빈도로 만들어진 것을 확인해 보았습니다.

피셔-예이츠 알고리즘은 “정렬” 연산도 없기 때문에 성능상 이점도 있습니다.

<hr />

### 평균 나이 구하기
`age`를 나타내는 프로퍼티를 가진 객체가 여러 개 담긴 배열이 있습니다. 평균 나이를 반환해주는 함수 `getAverageAge(users)`를 작성해보세요.

평균을 구하는 공식은 `(age1 + age2 + ... + ageN) / N` 입니다.

예시:
```javascript
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```javascript
function getAverageAge(users) {
  return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // 28
```

<hr />

### 중복 없는 요소 찾아내기
`arr`은 배열입니다.

배열 내 유일한 요소를 찾아주는 함수 `unique(arr)`를 작성해보세요.

예시:
```javascript
function unique(arr) {
  /* your code */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

원하는 기능을 구현하려면 배열 요소 각각을 대상으로 아래와 같은 확인작업을 진행해야 합니다.
- 새로운 배열(결과 배열)을 만들고 해당 요소가 결과 배열에 들어가 있는지 확인합니다.
- 위 조건을 만족한다면 해당 요소는 무시하고, 그렇지 않다면 해당 요소를 결과 배열에 더해줍니다.
```javascript
function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
```

위와 같이 작성하면 원하는 답안을 만들 순 있지만, 성능상의 문제가 있습니다.

`result.includes(str)` 메서드는 `result`를 순회하면서 각 요소와 `str`을 비교하며 일치하는 값이 있는지 검색합니다.

`result`의 요소가 `100`개인 상황에서 `str`과 일치하는 요소가 없다면 `result.includes(str)` 메서드는 `result` 전체를 순회하면서 정확히 `100`번의 비교를 진행할 겁니다. `result`의 길이가 `10,000`이라면 만 번의 비교가 일어나겠죠.

자바스크립트 엔진의 속도가 상당히 빠르기 때문에 만 번 정도는 문제가 되진 않습니다.

그런데 `for`문을 사용해 `arr`의 요소마다 테스트를 실행할 경우는 이야기가 달라집니다.

`arr.length`가 `10000`이면 `10000*10000`, 1억 번의 비교가 일어나기 때문이죠. 정말 큰 숫자입니다.

따라서 위 해답은 배열의 길이가 짧을 때만 사용하시기 바랍니다.

위 해답을 어떻게 하면 최적화 할 수 있는지에 대해서는 맵과 셋 챕터에서 다뤄보도록 하겠습니다.

[정답](https://plnkr.co/edit/szVLRehZxasVbqrr?p=preview)

<hr />

### Create keyed object from array
Let’s say we received an array of users in the form `{id:..., name:..., age... }`.

Create a function `groupById(arr)` that creates an object from it, with `id` as the key, and array items as values.

For example:
```javascript
let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// after the call we should have:

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
```

Such function is really handy when working with server data.

In this task we assume that `id` is unique. There may be no two array items with the same `id`.

Please use array `.reduce` method in the solution.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}

[정답](https://plnkr.co/edit/ZFAb7HKwKoWuPwc0?p=preview)
