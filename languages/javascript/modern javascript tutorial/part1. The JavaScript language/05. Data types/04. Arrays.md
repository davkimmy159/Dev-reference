배열
====

- 순서 컬렉션 저장 자료구조

### 배열 선언
```javascript
// 생성자
let arr = new Array();

// 배열 리터럴 (주로 사용)
let arr = [];
```

##### `[]` <sub>(대괄호)</sub> 안 초기 요소 삽입
```javascript
let fruits = ["사과", "오렌지", "자두"];
```

##### 각 배열 요소 숫자 <sub>(인덱스)</sub>
- 0 ~
- 배열 내 순서

##### 배열 내 특정 요소 얻기
- `[]` <sub>(대괄호)</sub> 안 인덱스
```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

// 배열 내 특정 요소 수정
fruits[2] = '배';  // ["사과", "오렌지", "배"]

// 새 요소 추가
fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]

// 배열 요소 개수
alert( fruits.length ); // 4

// 요소 전체 출력
alert( fruits );   // 사과,오렌지,배,레몬
```

##### 배열 요소 자료형 제약 X
```javascript
let arr = [
  '사과',
  { name: '이보라' },
  true,
  function() { alert('안녕하세요.'); }
];

// 1 (인덱스) 요소 (객체) name (프로퍼티)
alert( arr[1].name ); // 이보라

// 3 (인덱스) 요소 (함수) 실행
arr[3](); // 안녕하세요.
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **trailing 쉼표**

##### 배열 마지막 요소
- 쉼표 사용 가능

##### 모든 줄 생김새 유사
- 요소 추가 · 삭제 용이
```javascript
let fruits = [
  "사과",
  "오렌지",
  "자두",
];
```

<br />

### `pop` · `push` vs `shift` · `unshift`

#### 큐 <sub>(queue)</sub>
- 배열 사용해 만드는 대표적인 자료구조
- 선입선출 <sub>(First-In-First-Out, FIFO)</sub>
- 순서 있는 컬렉션 저장

##### 큐 주요 연산
- `push`
  - 맨 끝에 요소 추가
- `shift`
  - 제일 앞 요소 꺼내 제거
  - 남은 요소들 앞으로 밈

#### 스택 <sub>(stack)</sub>
- 배열 사용해 만드는 대표적인 자료구조
- 후입선출 <sub>(Last-In-First-Out, LIFO)</sub>

##### 스택 주요 연산
- `push`
  - 스택 끝에 요소 삽입
- `pop`
  - 스택 끝 요소 추출

#### 배열
- 큐 · 스택 둘다 생성 가능
- 데큐 <sub>(deque, Double Ended Queue)</sub>
  - 여러 연산 가능 자료구조
    - 처음 · 끝 요소 더하기 · 빼기

#### 배열 끝 작업 메서드
- `pop`
  - 배열 끝 요소 제거
  - 제거한 요소 반환
- `push`
  - 배열 끝에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// pop
alert( fruits.pop() ); // 배
alert( fruits );       // 사과,오렌지

// push
// fruits.push( … )
// fruits[fruits.length] = … (동일)
fruits.push("배");
alert( fruits );       // 사과,오렌지,배
```

#### 배열 앞 작업 메서드
- `shift`
  - 배열 앞 요소 제거
  - 제거한 요소 반환
- `unshift`
  - 배열 제일 앞에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// shift
alert( fruits.shift() ); // 사과
alert( fruits );         // 오렌지,배

// unshift
fruits.unshift('사과');
alert( fruits );         // 사과,오렌지,배
```
- `push` · `unshift`
  - 요소 여러 개 한 번에 더하기
```javascript
let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

alert( fruits ); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

### 배열 내부 동작 원리
- 특별한 종류의 객체

##### 숫자형 키 사용
- 객체 기본 기능 보유
- 순서 있는 컬렉션 제어 메서드 보유
- `length` <sub>(프로퍼티)</sub>

#### ※ _배열 본질 == 객체_
```javascript
let fruits = ["바나나"]

let arr = fruits;        // 참조 복사
alert( arr === fruits ); // true

arr.push("배");  // 참조 이용해 배열 수정
alert( fruits ); // 바나나,배
```

#### 배열 특수 내부 표현방식
- 배열 요소
  - 인접한 메모리 공간에 차례로 저장
    - 연산 속도 ↑
- 다양한 배열 관련 연산 최적화 기법 존재

##### 배열 사용처
- 순서 있는 자료 컬렉션
- 일반 객체처럼 작업 시
  - 최적화 기법들 제대로 동작 X
```javascript
let fruits = [];

// 배열 길이보다 훨씬 큰 숫자 사용해 프로퍼티 생성
fruits[99999] = 5;

// 임의의 이름 사용해 프로퍼티 생성
fruits.age = 25;
```

##### 배열에 프로퍼티 추가 시
- JS 엔진 : 일반 객체처럼 다룸
  - 배열 최적화 기법 동작 X

##### 배열 특유 이점 사라지는 사용 방법들
```javascript
// 프로퍼티 키
// - 숫자 아닌 값
arr.test = 1;

// 앞 · 끝에만 요소 추가
arr[0] = 1;
arr[1000] = 2;

// 요소 역순 삽입
arr[1000] = 1;
arr[999] = 2;
```
- 배열 목적 맞게 사용
- 임의 키 사용 시
  - 일반 객체 적합

### 성능

##### `shift` · `unshift` : 속도 느림
1. 0 <sub>(인덱스)</sub> 요소 제거 · 추가
2. 모든 요소 좌 · 우 이동
    - 모든 인덱스 1씩 감소 · 증가
3. `length` <sub>(프로퍼티)</sub> 값 갱신
- 배열 요소 多
  - 요소 이동 시간 ↑
  - 메모리 관련 연산 ↑

##### `push` · `pop` : 속도 빠름
1. 배열 마지막에 요소 추가 · 제거
2. `length` <sub>(프로퍼티)</sub> 값 갱신
- 요소 이동 X
- 기존 인덱스 그대로 유지

### 반복문

#### `for`
- 가장 오래된 배열 순회 방법
- 인덱스 사용
```javascript
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

#### `for…of`
- 요소 값
```javascript
let fruits = ["사과", "오렌지", "자두"];

for (let fruit of fruits) {
  alert( fruit );
}
```

#### `for…in`
- 요소 인덱스
```javascript
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```

#### `for…in` 문제점

##### 모든 프로퍼티 대상 순회
- 숫자 키 외 프로퍼티
  - 순회 대상 포함

##### 유사 배열 객체
- 브라우저 · 기타 호스트 환경 사용 객체
- 배열 모양 비슷한 객체
  - `length` <sub>(프로퍼티)</sub>
  - 요소 인덱스
- 기타 프로퍼티들 존재 가능
  - 숫자형 키 외 프로퍼티 · 메서드
  - 문제 일으킬 가능성 ↑

##### 객체에 최적화
- 배열 사용 시
  - 객체 대비 10 ~ 100배 느림
- 반복문 자체 속도 빠름
  - 병목 지점에서만 문제 발생 가능

##### 배열
- `for…in` 사용 자제

### `length` <sub>(프로퍼티)</sub>

##### `length` <sub>(프로퍼티)</sub> 값
- 배열 조작 시
  - 자동 갱신
- 가장 큰 인덱스 + 1
- ≠ 실제 요소 개수
```javascript
// 잘못된 배열 사용
let fruits = [];
fruits[123] = "사과";

alert( fruits.length ); // 124
```

##### `length` <sub>(프로퍼티)</sub> 수정 가능
- 값 수동 증가
  - 아무 일 X
- 값 수동 감소
  - 배열 잘림
  - 잘린 배열 요소 복구 X

##### 간단하게 배열 비우기
- `arr.length = 0;`
```javascript
let arr = [1, 2, 3, 4, 5];

// 요소 2개만 남기고 자르기
arr.length = 2;
alert( arr ); // [1, 2]

// 본래 길이 수동 증가
// - 삭제된 기존 요소들 복구 X
arr.length = 5;
alert( arr[3] ); // undefined
```

### `new Array()` <sub>(배열 생성자)</sub>
- 잘 사용되지 않는 편
```javascript
let arr = new Array("사과", "배", "기타");
```

##### 까다로운 사용법
- 숫자형 인수 하나 전달 시
  - 배열 요소 없음
  - 배열 길이 == 인수
```javascript
let arr = new Array(2);

alert( arr[0] );     // undefined, 요소 없음
alert( arr.length ); // 길이 : 2
```

### 다차원 배열
- 배열 내 배열

##### 행렬 저장
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5
```

### `toString` <sub>(메서드)</sub>

##### 전체 요소 문자열 <sub>(쉼표 구분)</sub> 반환
```javascript
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```

##### `[Symbol.toPrimitive]` · `valueOf` <sub>(메서드)</sub>
- 미구현
```javascript
alert( [] + 1 );    // "1"
alert( [1] + 1 );   // "11"
alert( [1,2] + 1 ); // "1,21"

alert( "" + 1 );    // "1"
alert( "1" + 1 );   // "11"
alert( "1,2" + 1 ); // "1,21"
```

<br />

## 요약

### 배열
- 특수한 형태의 객체
- 순서 있는 자료 저장 · 관리 최적화 자료구조

##### 선언 방법
```javascript
// [] (대괄호)
// - 자주 사용
let arr = [item1, item2...];

// 배열 생성자 (new Array)
// - 자주 사용 X
let arr = new Array(item1, item2...);
```

##### `new Array(number)` <sub>(배열 생성자)</sub> 호출
- 배열 생성
  - 길이 : `number` <sub>(인수)</sub>
  - 요소 X

##### `length` <sub>(프로퍼티)</sub>
- 배열 길이
- 가징 큰 숫자형 인덱스 값 + 1
- 배열 메서드
  - 값 자동 조정
- 값 수동 감소
  - 배열 끝 잘림

##### 데큐 유사 연산
- `push(...items)`
  - 배열 끝에 `items` <sub>(요소)</sub> 추가
- `pop()`
  - 배열 끝 요소 제거 · 반환
- `shift()`
  - 배열 처음 요소 제거 · 요소
- `unshift(...items)`
  - 배열 앞에 `items` <sub>(요소)</sub> 추가

##### 전체 요소 대상 반복 작업
- `for (let i = 0; i < arr.length; i++)`
  - 가장 빠름
  - 구식 브라우저 호환
- `for (let item of arr)`
  - 배열 요소에만 사용
  - 모던한 문법
- `for (let i in arr)`
  - 배열 사용 X

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 배열은 복사가 될까요?

##### 코드 실행 결과 에측
```javascript
let fruits = ["사과", "배", "오렌지"];

// 배열 '복사' 후
// - 새 값 추가 (push 메서드)
let shoppingCart = fruits;
shoppingCart.push("바나나");

alert( fruits.length ); // ?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 정답 : `4`
- 배열 == 객체
- `shoppingCart` · `fruits`
  - 동일 배열 참조
```javascript
let fruits = ["사과", "배", "오렌지"];

let shoppingCart = fruits;

shoppingCart.push("바나나");

alert( fruits.length ); // 4
```

<hr />

### 배열 관련 연산

##### 배열 관련 다섯 가지 연산 수행
1. `styles` <sub>(배열)</sub> 생성
    - `“Jazz”` <sub>(요소)</sub>
    - `"Blues"` <sub>(요소)</sub>
2. 배열 끝에 요소 추가
    - `"Rock-n-Roll"` <sub>(요소)</sub>
3. 배열 정 중앙 요소 바꾸기
    - `"Classics"` <sub>(요소)</sub>
    - 가운데 요소 찾는 코드
      - 홀수 개 요소 배열에서도 작동 
4. 배열 1번째 요소 꺼내서 출력
5. 배열 앞에 요소 추가
    - `"Rap"` <sub>(요소)</sub>
    - `"Reggae"` <sub>(요소)</sub>

##### 단계 하나씩 거칠 때마다 배열 모습
```javascript
Jazz,     Blues
Jazz,     Blues,      Rock-n-Roll
Jazz,     Classics,   Rock-n-Roll
Classics, Rock-n-Roll
Rap,      Reggae,     Classics,   Rock-n-Roll
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
let styles = ["Jazz", "Blues"];
styles.push("Rock-n-Roll");
styles[Math.floor((styles.length - 1) / 2)] = "Classics";
alert( styles.shift() );
styles.unshift("Rap", "Reggae");
```

<hr />

### 배열 컨텍스트에서 함수 호출하기

##### 코드 실행 결과 예측 · 이유
```javascript
let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // ?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 문법적으로 동일
- `arr[2]()`
- `obj[method]()`
  - `obj` == `arr`
  - `2` &nbsp;&nbsp;&nbsp;== `method`

##### `arr[2]` <sub>(함수)</sub>
- 객체 메서드처럼 호출
  - `this` → `arr` 참조
```javascript
let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){ … }
```

<hr />

### 입력한 숫자의 합 구하기
아래 조건을 만족하는 함수 `sumInput()`을 작성해 봅시다.
- `prompt` 창을 띄워 사용자에게 숫자를 입력해 달라고 요청한 후, 입력받은 값들을 배열에 저장합니다.
- 숫자가 아닌 값, 혹은 빈 문자열을 입력하거나 `'Cancel'` 버튼을 누르면 질문을 멈춥니다.
- 배열 요소의 합을 계산하고 리턴합니다.

주의: 숫자 `0`은 유효한 숫자이므로, 사용자가 `0`을 입력하더라도 질문이 멈추지 말아야 합니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

해답에서 작지만 중요한 역할을 하는 부분에 주의를 기울여 주세요. `+value`로 입력받은 값을 숫자형으로 변경한 이후엔, 빈 문자열(정지 신호)을 `0`(유효한 숫자)과 구분할 수 없기 때문에, `prompt` 직후에 `value`를 숫자로 변환하지 않고 나중에 숫자로 변환하였습니다.
```javascript
function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("숫자를 입력해 주세요.", 0);

    // 입력받는 것을 정지해야 하는 경우
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
```

<hr />

### 최대합 부분 배열
입력값은 `arr = [1, -2, 3, 4, -9, 6]` 같이 숫자로만 구성된 배열이라고 가정해봅시다.

우리가 해야 할 일은 인접한 요소의 총합이 최대인 `arr`의 부분 배열을 찾는 것입니다.

부분 배열 요소들의 합을 리턴하는 함수 `getMaxSubSum(arr)`를 작성해 봅시다.

예시:
```javascript
getMaxSubSum([-1, 2, 3, -9]) == 5 (강조 표시된 요소들의 합)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (모든 요소)
```

요소 전체가 음수라면 아무런 요소도 선택하지 않아야 최댓값이 됩니다(부분 배열은 빈 배열). 그리고 합은 `0`이 됩니다.
```javascript
getMaxSubSum([-1, -2, -3]) = 0;
```

가능하다면 성능을 고려하여 답안을 작성해 봅시다. 답안은 [O(n<sup>2</sup>)](https://en.wikipedia.org/wiki/Big_O_notation) 또는 O(n)까지 가능합니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### 느린 해답
만들 수 있는 모든 부분 배열의 합을 계산하는 방법이 있을 수 있습니다.

이를 구현하는 가장 간단한 방법은 배열의 각 요소를 시작으로 하는 모든 부분 배열의 합을 계산하는 것입니다.

예를 들어 배열 `[-1, 2, 3, -9, 11]`이 있다고 합시다.
```javascript
// -1부터 시작
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// 2부터 시작
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// 3부터 시작
3
3 + (-9)
3 + (-9) + 11

// -9부터 시작
-9
-9 + 11

// 11부터 시작
11
```

위와 같은 알고리즘을 사용하려면 중첩 반복문이 필요합니다. 외부 반복문에선 배열의 각 요소를 순회하고, 내부 반복문에선 각 요소부터 시작하는 부분 배열의 합을 계산하게 됩니다.
```javascript
function getMaxSubSum(arr) {
  let maxSum = 0; // 어떤 요소도 선택하지 않으면 0을 반환합니다.

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
```

이렇게 구현하면 시간 복잡도가 [`O(n2)`](https://en.wikipedia.org/wiki/Big_O_notation)이 됩니다. 이는 배열의 크기를 2배 늘리면 알고리즘은 4배나 더 오래 걸린다는 의미입니다.

크기가 큰 배열(1000, 10000 또는 그 이상의 요소를 가진 배열)에 위와 같은 알고리즘을 적용하면 매우 느릴 수 있습니다.

#### 빠른 해답
배열을 순회하면서 변수 `s`에 현재의 부분합을 저장하는 방법도 가능합니다. `s`가 음수가 된 경우는 `s`에 `0`을 할당하면 됩니다. s의 값 중 최댓값이 정답이 됩니다.

해설이 모호하다고 느껴지면 아래 코드를 참고해주세요.
```javascript
function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) { // 배열의 각 요소를
    partialSum += item; // partialSum에 더합니다.
    maxSum = Math.max(maxSum, partialSum); // 최대값을 기억해 놓습니다.
    if (partialSum < 0) partialSum = 0; // 음수가 되면 0을 대입합니다.
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
```

이 알고리즘은 정확히 한번 배열을 순회하므로 시간 복잡도는 O(n)입니다.

알고리즘에 대한 상세한 정보는 [최대합 부분 배열 문제](https://en.wikipedia.org/wiki/Maximum_subarray_problem)에서 찾을 수 있습니다. 동작원리에 대해 확실히 이해가 되지 않았다면 위 예제의 알고리즘이 어떻게 동작하는지 찬찬히 살펴보세요. 글을 읽는 것보다 코드를 살펴보는게 훨씬 도움이 될 겁니다.

[정답](https://plnkr.co/edit/uAWodoF6mrto3rih?p=preview)
