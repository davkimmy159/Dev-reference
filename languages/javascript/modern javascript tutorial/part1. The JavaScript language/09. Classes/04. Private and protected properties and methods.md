`private` · `protected`
====

##### 객체 지향 프로그래밍
- 내부 · 외부 인터페이스 구분
  - 가장 중요한 원리 중 하나

### 실생활 예제

#### 커피 머신 내 인타페이스 분리

##### 외부 인터페이스
- 단순 · 사용자 전용
  - 버튼 1개
  - 화면 1개
  - 구멍 1 ~ 2개

![coffee](../../images/01/09/04/coffee.jpg)

##### 내부 인터페이스
- 복잡 · 업자 <sub>(생산자 · 수리기사 등)</sub> 전용
  - 필터
  - 물통
  - 파이프
  - 구동 장치
  - 회로 기판
  - 기타 등등

![coffee-inside](../../images/01/09/04/coffee-inside.jpg)

##### 커피 머신 사용
- 단순한 외부 인터페이스 이용
  - 작동 과정 숙지 불필요
  - 물 공급 <sub>(입력)</sub> · 내린 커피 <sub>(결과)</sub> 중요
- 복잡한 내부 인터페이스 이용 불필요
  - 사용법 난이도 ↑
  - 감전 위험
  - 기타 등등

### 내부 · 외부 인터페이스

##### 객체 지향 프로그래밍
- 프로퍼티 · 메서드 분류 <sub>(2가지)</sub>
  - a. 내부 인터페이스
  - b. 외부 인터페이스

##### a. 내부 인터페이스
- 클래스 외부 접근 불가능
  - 동일 클래스 내 타 구성 요소 접근 가능
- 내부 세부사항
  - 각자 정보 이용해 객체 동작
- 외부 인터페이스 통해서만 사용 가능

##### b. 외부 인터페이스
- 클래스 외부 접근 가능
- 작업 시 객체 내부 동작 과정 숙지 불필요 <sub>(장점)</sub>

#### 객체 필드 <sub>(프로퍼티 · 메서드)</sub> 타입 <sub>(2가지)</sub>

##### a. `public`
- 어디서든 접근 가능
  - 외부 인터페이스 구성

##### b. `private`
- 클래스 내부에서만 접근 가능
  - 내부 인터페이스 구성

##### `protected` <sub>(≒ `private`)</sub>
- 자신 · 자손 클래스 내부에서만 접근 가능
  - 내부 인터페이스 구성
- 자손 클래스 내 필드 접근 경우 多
  - `private` 대비 더 많이 사용
- JS 미지원
  - 모방 사용 多

### `protected` <sub>(모방)</sub> 프로퍼티

##### JS 내 `protected` 모방 <sub>(관습)</sub>
- 필드명 앞 `_` <sub>(밑줄)</sub> 추가 <sub>(`field` → `_field`)</sub>
  - 외부 접근 불가능 필드 표현
- 접근자 프로퍼티 사용
  - 데이터 접근 통제

#### 프로퍼티 보호

##### `waterAmount` <sub>(프로퍼티)</sub> 필드 타입 설정
- a. `public`
- b. `protected` <sub>(모방)</sub>

##### a. `public`
- 외부에서 접근 · 값 수정 가능
```javascript
class CoffeeMachine {
  waterAmount = 0; // public

  constructor(power) {
    this.power = power;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 양 설정 (외부에서 직접 수정)
coffeeMachine.waterAmount = 200;
```

##### b. `protected` <sub>(모방)</sub>
- 접근 · 값 수정 통제
  - 물 양 `0` 미만 값 설정 방지
- `waterAmount` → `_waterAmount`
```javascript
class CoffeeMachine {
// waterAmount = 0; // public
  _waterAmount = 0; // protected (모방)

  constructor(power) {
    this.power = power;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  // 물 양 0 미만 값 설정 방지
  set waterAmount(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }

    this._waterAmount = value;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 양 음수 설정 시 에러
coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
```

#### 읽기 전용 프로퍼티

##### `power` <sub>(프로퍼티)</sub> 필드 타입 설정
- a. `public`
- b. `protected` <sub>(모방)</sub>

##### a. `public`
- 외부에서 접근 · 값 수정 가능
```javascript
class CoffeeMachine {
  …

  constructor(power) {
    this.power = power; // public
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 전력량 설정 (외부에서 직접 수정)
coffeeMachine.power = 25;
```

##### b. `protected` <sub>(모방)</sub>
- 접근 · 값 수정 통제
  - 객체 생성 후 값 수정 방지 <sub>(읽기 전용)</sub>
    - getter 有
    - setter 無
- `power` → `_power`
```javascript
class CoffeeMachine {
  …

  constructor(power) {
 // this.power  = power;
    this._power = power;
  }

  …

  // getter 구현
  get power() {
    return this._power;
  }

  /* setter 미구현
  set power(value) {
    this._power = value;
  }
   */
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 전력량: 100 (접근 가능)
alert(`전력량: ${coffeeMachine.power}`);

// 에러 (setter 無)
coffeeMachine.power = 25; // Error
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **\[g·s\]etter 함수**

##### 접근자 프로퍼티 <sub>(문법)</sub> vs \[g·s\]etter 함수 <sub>(일반 메서드)</sub>
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  // 접근자 프로퍼티 (문법)
  get waterAmount() { … }
  set waterAmount(value) { … }

  // [g·s]etter 함수 (일반 메서드)
  getWaterAmount() { … }
  setWaterAmount(value) { … }
}
```

##### 취사선택
- 접근자 프로퍼티 <sub>(문법)</sub>
  - 단일 인수 <sub>(유연성 ↓)</sub>
  - 코드량 ↓
- \[g·s\]etter 함수 <sub>(일반 메서드)</sub>
  - 다수 인수 가능 <sub>(유연성 ↑)</sub>
  - 코드량 ↑

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`protected` 필드 상속**

##### 하위 클래스 내 메서드
- 해당 클래스 내 `protected` 필드 접근 가능
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  constructor(power) {
    this._power = power;
  }
  …
}

class MegaMachine extends CoffeeMachine {
  _syrupAmount = 0;

  constructor(power, cleaner) {
    super(power);
    this._cleaner = cleaner;
  }

  …

  subClassMethod(value) {

    // 상위 클래스 내 protected 필드 접근 가능
    this._waterAmount = 100;
    this._power = 200;
  }
}
```

<br />

### `private` 프로퍼티

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 명세서 추가**

- 부분 지원 · 미지원 엔진 사용 시
  - 폴리필 구현 필요

<br />

##### 필드명 앞 `#` 추가 <sub>(`field` → `#field`)</sub>
- 클래스 내에서만 접근 가능

##### `private` 설정
- `#waterLimit` <sub>(프로퍼티)</sub>
  - 물 용량 한도
- `#checkWater` <sub>(메서드)</sub>
  - 물 잔여량 확인
```javascript
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }

    if (value > this.#waterLimit) {
      throw new Error("물이 용량을 초과합니다.");
    }
  }
}

let coffeeMachine = new CoffeeMachine();

// 클래스 외부
// - private 접근 X

// Error
coffeeMachine.#checkWater();

// Error
coffeeMachine.#waterLimit = 1000;
```

##### `#`
- JS 지원 문법
- `private` 필드 의미
  - 클래스 외부 · 자손 클래스 접근 X

##### `private` · `public` 필드 상충 X
- `private` · `public` 프로퍼티
  - 동시 존재 가능
```javascript
class CoffeeMachine {
  #waterAmount = 10;
  waterAmount = 20;
}
```

##### `waterAmount`
- `#waterAmount` 접근자
```javascript
class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;

// Error
alert(machine.#waterAmount);
```

##### 장점
- 언어 자체에 의해 강제

##### 단점
- 상속 클래스
  - 직접 접근 X
  - \[g·s\]etter 사용
```javascript
class MegaCoffeeMachine extends CoffeeMachine {
  method() {

    // Error
    // - CoffeeMachine 통해서만 접근 가능
    alert( this.#waterAmount );
  }
}
```

##### 제약사항 : 너무 엄격
- 상속 클래스
  - 상위 클래스 내부 접근 시
    - 정당한 사유 존재
- `protected` 필드 더 자주 쓰이는 이유
  - 언어 차원 미지원

<br />

요약
====

##### 객체 지향 프로그래밍
- 내 · 외부 인터페이스 구분
  - 캡슐화

### 캡슐화 이점

#### 1. 사용자 사용 보호

##### 클래스 세부 구현 조작 방지
- 외부 : 의도치 않게 클래스 조작 시
  - 결과 예측 X

#### 2. 지원 가능

##### 클래스 개발자들
- 자유롭게 내부 프로퍼티 · 메서드 수정
  - 사용자 알림 불필요

##### 내부 인터페이스 엄격히 구분 시
- 외부 코드 : 내부 `private` 메서드 의존 X
  - `private` 메서드명 변경 가능
  - 매개변수 변경 · 제거 가능

##### 사용자 입장 <sub>(새 버전 출시 경우)</sub>
- 전면적 내부 정비 · 외부 인터페이스 동일
  - 업그레이드 용이

#### 3. 복잡성 은닉
- 숨겨진 구현 세부 사항
  - 간단 · 편리
- 외부 인터페이스 설명
  - 문서화 용이

#### 내부 인터페이스 숨기기
- `protected` · `private` 프로퍼티

##### `protected` 필드
- `_` 시작 <sub>(관습 · JS 미지원)</sub>
- 상속 클래스에서만 접근 가능

##### `private` 필드
- `#` 시작 <sub>(JS 지원)</sub>
- 해당 필드 정의 클래스 내부에서만 접근 가능
- 일부 브라우저 미지원
  - 폴리필 구현 필요
