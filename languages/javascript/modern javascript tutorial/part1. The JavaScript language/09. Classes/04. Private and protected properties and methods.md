`private` · `protected` 프로퍼티 · 메서드
===================================

##### 객체 지향 프로그래밍
- 내부 · 외부 인터페이스 구분
  - 가장 중요한 원리 중 하나

### 내부 · 외부 인터페이스

##### 객체 지향 프로그래밍
- 프로퍼티 · 메서드
  - 두 그룹 분류

##### 내부 인터페이스
- 동일 클래스 내 다른 메서드 접근 가능
- 클래스 외부에서 접근 X
- 외부 인터페이스 통해서만 사용 가능

##### 외부 인터페이스
- 클래스 외부에서 접근
- 외부 인터페이스만 알아도 작업 가능
  - 객체 내부 몰라도 상관 X <sub>(큰 장점)</sub>

#### 객체 필드 <sub>(프로퍼티 · 메서드)</sub> 타입

##### `public`
- 어디서든지 접근 가능
- 외부 인터페이스 구성

##### `private`
- 클래스 내부에서만 접근 가능
- 내부 인터페이스 구성

#### JS 외 다수 언어

##### `protected` 지원
- 자신 · 자식 클래스 접근 허용
- `private` 유사
  - 자식 클래스에서도 접근 가능 <sub>(차이)</sub>
- 내부 인터페이스 구성 시 유용
- `private` 보다 조금 더 광범위하게 사용

##### JS
- `protected` 미지원
- 모방 사용 多

### 프로퍼티 보호하기
```javascript
class CoffeeMachine {

  // protected 프로퍼티
  _waterAmount = 0;

  constructor(power) {

    // public 프로퍼티
    this._power = power;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 추가
coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
```
- `public` 프로퍼티
  - `power`
- `protected` 프로퍼티
  - `waterAmount`

##### `protected` 프로퍼티
- `_` <sub>(밑줄)</sub>
  - 외부 접근 불가능 표현
  - 강제 X <sub>(관습)</sub>
- 접근자 프로퍼티 사용
  - 데이터 접근 통제

### 읽기 전용 프로퍼티
- 프로퍼티 생성할 때만 값 할당
- 이후 값 수정 불가능
  - getter <sub>(획득자)</sub> 설정
  - setter <sub>(설정자)</sub> X
```javascript
class CoffeeMachine {
  // …

  constructor(power) {
    this._power = power;
  }

  // getter (획득자) 설정
  get power() {
    return this._power;
  }

  // setter (설정자) X
  /*
  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
   */
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

alert(`전력량: ${coffeeMachine.power} 커피머신`); // 전력량: 100 커피머신

coffeeMachine.power = 25; // Error, setter (설정자) 없음
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **\[g·s\]etter 함수**

##### 선호 함수 형식
- `get…`
- `set…`
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  getWaterAmount() {
    return this._waterAmount;
  }

  setWaterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
}

new CoffeeMachine().setWaterAmount(100);
```

#### 원하는 방식 사용

##### `get…` · `set…`
- 다수 인자 가능
- 좀 더 유연
- 코드량 ↑

##### `get` · `set` 문법
- 코드량 ↓

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **protected 필드 : 상속됨**

##### 클래스 상속 시
- 하위 클래스 메서드
  - `protected` <sub>(프로퍼티)</sub> 접근 가능
    - `this._waterAmount`
    - `this._power`
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  constructor(power) {
    this._power = power;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
}

class MegaMachine extends CoffeeMachine {
  _syrupAmount = 0;

  constructor(power, cleaner) {
    super(power);
    this._cleaner = cleaner;
  }

  get syrupAmount() {
    return this._syrupAmount;
  }

  set syrupAmount(value) {
    if (value < 0) throw new Error("시럽의 양은 음수가 될 수 없습니다.");
    this._syrupAmount = value;
  }
}

// 하위 클래스 생성
let megaMachine = new MegaMachine(100, 10);

// 시럽 추가
megaMachine.syrupAmount = -10; // Error: 시럽의 양은 음수가 될 수 없습니다.
```

<br />

### `private` 프로퍼티

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 추가됨**

- 부분 · 미지원 엔진 사용 시
  - 폴리필 구현

<br />

##### `private` 프로퍼티 · 메서드
- 제안 목록 등재 문법
  - 명세서 등재 직전 상태
- `#` 으로 시작
  - 클래스 안에서만 접근
```javascript
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }

    if (value > this.#waterLimit) {
      throw new Error("물이 용량을 초과합니다.");
    }
  }

}

let coffeeMachine = new CoffeeMachine();

// 클래스 외부
// - private 접근 X
coffeeMachine.#checkWater();      // Error
coffeeMachine.#waterLimit = 1000; // Error
```

##### `#`
- JS 지원 문법
- `private` 필드 의미
  - 클래스 외부 · 자손 클래스 접근 X

##### `private` · `public` 필드 상충 X
- `private` · `public` 프로퍼티
  - 동시 존재 가능
```javascript
class CoffeeMachine {
  #waterAmount = 10;
  waterAmount = 20;
}
```

##### `waterAmount`
- `#waterAmount` 접근자
```javascript
class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;
alert(machine.#waterAmount); // Error
```

##### 장점
- 언어 자체에 의해 강제

##### 단점
- 상속 클래스
  - 직접 접근 X
  - \[g·s\]etter 사용
```javascript
class MegaCoffeeMachine extends CoffeeMachine {
  method() {

    // CoffeeMachine 통해서만 접근 가능
    alert( this.#waterAmount ); // Error
  }
}
```

##### 제약사항 : 너무 엄격
- 상속 클래스
  - 상위 클래스 내부 접근 시
    - 정당한 사유 존재
- `protected` 필드 더 자주 쓰이는 이유
  - 언어 차원 지원 X

<br />

## 요약
객체 지향 프로그래밍에선 내부 인터페이스와 외부 인터페이스를 구분하는 것을 \[캡슐화(encapsulation)\]라는 용어를 사용해 설명합니다.

캡슐화는 이점은 다음과 같습니다.

**사용자가 자신의 발등을 찍지 않도록 보호**

커피 머신를 함께 사용하는 개발팀이 있다고 상상해봅시다. "Best CoffeeMachine"이라는 회사에서 만든 이 커피 머신은 현재 잘 작동하고 있지만, 보호 커버가 없어서 내부 인터페이스가 노출되어있는 상황입니다.

교양있는 팀원들은 모두 설계 의도에 맞게 커피 머신을 사용합니다. 그런데 어느 날 John이라는 개발자가 자신의 능력을 과신하며 커피 머신 내부를 살짝 만지게 됩니다. 이틀 후, 커피 머신은 고장이 나버렸죠.

커피 머신이 고장 난 건 John의 잘못이라기보다는, 보호 커버를 없애고 John이 마음대로 조작하도록 내버려 둔 사람의 잘못입니다.

프로그래밍에서도 마찬가지입니다. 외부에서 의도치 않게 클래스를 조작하게 되면 그 결과는 예측할 수 없게 됩니다.

**지원 가능**

실제 개발 과정에서 일어나는 상황은 커피 머신 사례보다 훨씬 복잡합니다. 커피 머신은 한번 구매하면 끝이지만 실제 코드는 유지보수가 끊임없이 일어나기 때문입니다.

**내부 인터페이스를 엄격하게 구분하면, 클래스 개발자들은 사용자에게 알리지 않고도 자유롭게 내부 프로퍼티와 메서드들을 수정할 수 있습니다.**

내부 인터페이스가 엄격히 구분된 클래스를 만지고 있다면, 그 어떤 외부 코드도 내부 `private` 메서드에 의존하고 있지 않기 때문에 `private` 메서드의 이름을 안전하게 바꿀 수 있고, 매개변수를 변경하거나 없앨 수도 있다는 것을 알아 두면 됩니다.

사용자 입장에선 새로운 버전이 출시되면서 내부 정비가 전면적으로 이뤄졌더라도 외부 인터페이스만 똑같다면 업그레이드가 용이하다는 장점이 있습니다.

**복잡성 은닉**

사람들은 간단한 것을 좋아합니다. 내부는 간단치 않더라도 최소한 외형은 간단해야 하죠.

프로그래머들도 예외는 아닙니다.

**구현 세부 사항이 숨겨져 있으면 간단하고 편리해집니다. 외부 인터페이스에 대한 설명도 문서화하기 쉬워지죠.**

내부 인터페이스를 숨기려면 `protected`나 `private` 프로퍼티를 사용하면 됩니다.
- `protected` 필드는 `_`로 시작합니다. `_`은 자바스크립트에서 지원하는 문법은 아니지만, `protected` 필드를 나타낼 때 관습처럼 사용됩니다. 개발자는 `protected` 프로퍼티가 정의된 클래스와 해당 클래스를 상속받는 클래스에서만 `_`가 붙은 필드에 접근해야 합니다.
- `private` 필드는 `#`로 시작하며, 자바스크립트에서 지원하는 문법입니다. `#`로 시작하는 필드는 해당 필드가 정의된 클래스 내부에서만 접근 가능합니다.
모든 브라우저에서 `private` 필드를 지원하진 않지만 폴리필을 구현하여 사용할 수 있습니다.
