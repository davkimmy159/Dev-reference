`private` · `protected`
====

##### 객체 지향 프로그래밍
- 내부 · 외부 인터페이스 구분
  - 가장 중요한 원리 중 하나

### 실생활 예제

#### 커피 머신 내 인타페이스 분리

##### 외부 인터페이스
- 단순 · 사용자 전용
  - 버튼 1개
  - 화면 1개
  - 구멍 1 ~ 2개

![coffee](../../images/01/09/04/coffee.jpg)

##### 내부 인터페이스
- 복잡 · 업자 <sub>(생산자 · 수리기사 등)</sub> 전용
  - 필터
  - 물통
  - 파이프
  - 구동 장치
  - 회로 기판
  - 기타 등등

![coffee-inside](../../images/01/09/04/coffee-inside.jpg)

##### 커피 머신 사용
- 단순한 외부 인터페이스 이용
  - 작동 과정 숙지 불필요
  - 물 공급 <sub>(입력)</sub> · 내린 커피 <sub>(결과)</sub> 중요
- 복잡한 내부 인터페이스 이용 불필요
  - 사용법 난이도 ↑
  - 감전 위험
  - 기타 등등

### 내부 · 외부 인터페이스

##### 객체 지향 프로그래밍
- 프로퍼티 · 메서드 분류 <sub>(2가지)</sub>
  - a. 내부 인터페이스
  - b. 외부 인터페이스

##### a. 내부 인터페이스
- 클래스 외부 접근 불가능
  - 동일 클래스 내 타 구성 요소 접근 가능
- 내부 세부사항
  - 각자 정보 이용해 객체 동작
- 외부 인터페이스 통해서만 사용 가능

##### b. 외부 인터페이스
- 클래스 외부 접근 가능
- 작업 시 객체 내부 동작 과정 숙지 불필요 <sub>(장점)</sub>

#### 객체 필드 <sub>(프로퍼티 · 메서드)</sub> 타입 <sub>(2가지)</sub>

##### a. `public`
- 어디서든 접근 가능
  - 외부 인터페이스 구성

##### b. `private`
- 클래스 내부에서만 접근 가능
  - 내부 인터페이스 구성

##### `protected` <sub>(≒ `private`)</sub>
- 자신 · 자손 클래스 내부에서만 접근 가능
  - 내부 인터페이스 구성
- 자손 클래스 내 필드 접근 경우 多
  - `private` 대비 더 많이 사용
- JS 미지원
  - 모방 사용 多

##### JS 내 `protected` 모방 <sub>(관습)</sub>
- 필드 명 앞 `_` <sub>(밑줄)</sub> 추가 <sub>(`field` → `_field`)</sub>
  - 외부 접근 불가능 필드 표현
- 접근자 프로퍼티 사용
  - 데이터 접근 통제

### 프로퍼티 보호

##### `CoffeeMachine` <sub>(클래스)</sub> 내 필드
- `waterAmount` <sub>(물 양)</sub>

##### `public` 필드
- 외부에서 접근 · 값 수정 가능
```javascript
class CoffeeMachine {
  waterAmount = 0; // public

  constructor(power) {
    this.power = power;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 양 설정 (외부에서 직접 수정)
coffeeMachine.waterAmount = 200;
```

##### `protected` 필드 <sub>(모방)</sub>
- 접근 · 값 수정 통제
  - 물 양 `0` 미만 값 설정 방지
- `waterAmount` → `_waterAmount`
```javascript
class CoffeeMachine {
// waterAmount = 0; // public
  _waterAmount = 0; // protected (모방)

  constructor(power) {
    this.power = power;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  // 물 양 0 미만 값 설정 방지
  set waterAmount(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }

    this._waterAmount = value;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 양 음수 설정 시 에러
coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
```

### 읽기 전용 프로퍼티

##### `CoffeeMachine` <sub>(클래스)</sub> 내 필드
- `power` <sub>(전력량)</sub>

##### `public` 필드
- 외부에서 접근 · 값 수정 가능
```javascript
class CoffeeMachine {
  …

  constructor(power) {
    this.power = power; // public
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 전력량 설정 (외부에서 직접 수정)
coffeeMachine.power = 25;
```

##### `protected` 필드 <sub>(모방)</sub>
- 접근 · 값 수정 통제
  - 객체 생성 후 값 수정 방지
- `power` → `_power`

power 프로퍼티를 읽기만 가능하도록 만들어봅시다. 프로퍼티를 생성할 때만 값을 할당할 수 있고, 그 이후에는 값을 절대 수정하지 말아야 하는 경우가 종종 있는데, 이럴 때 읽기 전용 프로퍼티를 활용할 수 있습니다.

커피 머신의 경우에는 전력이 이에 해당합니다.

읽기 전용 프로퍼티를 만들려면 setter(설정자)는 만들지 않고 getter(획득자)만 만들어야 합니다.

- 프로퍼티 생성할 때만 값 할당
- 이후 값 수정 불가능
  - getter <sub>(획득자)</sub> 설정
  - setter <sub>(설정자)</sub> X
```javascript
class CoffeeMachine {
  …

  constructor(power) {
 // this.power  = power;
    this._power = power;
  }

  …

  // getter 구현
  get power() {
    return this._power;
  }

  /* setter 미구현
  set power(value) {
    this._power = value;
  }
   */
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 전력량: 100 커피머신
alert(`전력량: ${coffeeMachine.power} 커피머신`);

// Error, setter (설정자) 없음
coffeeMachine.power = 25;
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **\[g·s\]etter 함수**

##### 선호 함수 형식
- `get…`
- `set…`
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  getWaterAmount() {
    return this._waterAmount;
  }

  setWaterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
}

new CoffeeMachine().setWaterAmount(100);
```

#### 원하는 방식 사용

##### `get…` · `set…`
- 다수 인수 가능
- 좀 더 유연
- 코드량 ↑

##### `get` · `set` 문법
- 코드량 ↓

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **protected 필드 : 상속됨**

##### 클래스 상속 시
- 하위 클래스 메서드
  - `protected` <sub>(프로퍼티)</sub> 접근 가능
    - `this._waterAmount`
    - `this._power`
```javascript
class CoffeeMachine {
  _waterAmount = 0;

  constructor(power) {
    this._power = power;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this._waterAmount = value;
  }
}

class MegaMachine extends CoffeeMachine {
  _syrupAmount = 0;

  constructor(power, cleaner) {
    super(power);
    this._cleaner = cleaner;
  }

  get syrupAmount() {
    return this._syrupAmount;
  }

  set syrupAmount(value) {
    if (value < 0) throw new Error("시럽의 양은 음수가 될 수 없습니다.");
    this._syrupAmount = value;
  }
}

// 하위 클래스 생성
let megaMachine = new MegaMachine(100, 10);

// 시럽 추가 (에러)
megaMachine.syrupAmount = -10; // Error: 시럽의 양은 음수가 될 수 없습니다.
```

<br />

### `private` 프로퍼티

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 명세서 추가**

- 부분 · 미지원 엔진 사용 시
  - 폴리필 구현

<br />

##### `private` 프로퍼티 · 메서드
- 제안 목록 등재 문법
  - 명세서 등재 직전 상태
- `#` 으로 시작
  - 클래스 내에서만 접근
```javascript
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }

    if (value > this.#waterLimit) {
      throw new Error("물이 용량을 초과합니다.");
    }
  }

}

let coffeeMachine = new CoffeeMachine();

// 클래스 외부
// - private 접근 X

// Error
coffeeMachine.#checkWater();

// Error
coffeeMachine.#waterLimit = 1000;
```

##### `#`
- JS 지원 문법
- `private` 필드 의미
  - 클래스 외부 · 자손 클래스 접근 X

##### `private` · `public` 필드 상충 X
- `private` · `public` 프로퍼티
  - 동시 존재 가능
```javascript
class CoffeeMachine {
  #waterAmount = 10;
  waterAmount = 20;
}
```

##### `waterAmount`
- `#waterAmount` 접근자
```javascript
class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) {
      throw new Error("물의 양은 음수가 될 수 없습니다.");
    }
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;

// Error
alert(machine.#waterAmount);
```

##### 장점
- 언어 자체에 의해 강제

##### 단점
- 상속 클래스
  - 직접 접근 X
  - \[g·s\]etter 사용
```javascript
class MegaCoffeeMachine extends CoffeeMachine {
  method() {

    // Error
    // - CoffeeMachine 통해서만 접근 가능
    alert( this.#waterAmount );
  }
}
```

##### 제약사항 : 너무 엄격
- 상속 클래스
  - 상위 클래스 내부 접근 시
    - 정당한 사유 존재
- `protected` 필드 더 자주 쓰이는 이유
  - 언어 차원 미지원

<br />

요약
====

##### 객체 지향 프로그래밍
- 내 · 외부 인터페이스 구분
  - 캡슐화

### 캡슐화 이점

#### 1. 사용자 사용 보호

##### 클래스 세부 구현 조작 방지
- 외부 : 의도치 않게 클래스 조작 시
  - 결과 예측 X

#### 2. 지원 가능

##### 클래스 개발자들
- 자유롭게 내부 프로퍼티 · 메서드 수정
  - 사용자 알림 불필요

##### 내부 인터페이스 엄격히 구분 시
- 외부 코드 : 내부 `private` 메서드 의존 X
  - `private` 메서드명 변경 가능
  - 매개변수 변경 · 제거 가능

##### 사용자 입장 <sub>(새 버전 출시 경우)</sub>
- 전면적 내부 정비 · 외부 인터페이스 동일
  - 업그레이드 용이

#### 3. 복잡성 은닉
- 숨겨진 구현 세부 사항
  - 간단 · 편리
- 외부 인터페이스 설명
  - 문서화 용이

#### 내부 인터페이스 숨기기
- `protected` · `private` 프로퍼티

##### `protected` 필드
- `_` 시작 <sub>(관습 · JS 미지원)</sub>
- 상속 클래스에서만 접근 가능

##### `private` 필드
- `#` 시작 <sub>(JS 지원)</sub>
- 해당 필드 정의 클래스 내부에서만 접근 가능
- 일부 브라우저 미지원
  - 폴리필 구현 필요
