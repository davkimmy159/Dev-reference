정적 메서드 · 프로퍼티
=========================

##### 정적 메서드
- `prototype` 메서드 X
- 클래스 함수
  - 클래스 자체 메서드 설정
- `static` <sub>(키워드)</sub>
```javascript
class User {

  // 정적 메서드
  static staticMethod() {

    // this 값
    // - User (클래스 생성자) 자체
    // - 점 앞 객체
    alert(this === User); // true
  }
}

↓↓↓

// 정적 메서드
// - 프로퍼티 직접 할당
class User { }
User.staticMethod = function() {
  alert(this === User); // true
};

// 사용법
User.staticMethod(); // true
```

##### 특정 객체 X
- 클래스 속한 함수
```javascript
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title ); // CSS
```

#### 팩토리 메서드 예제

##### 특정 조건의 `article` <sub>(인스턴스)</sub> 생성
- 매개변수 관련 정보 담긴 `article`
  - `title`
  - `date`
  - 기타 등등
- 현재 날짜 기반 비어있는 `article`
- 기타 등등

##### 구현 방법
- 생성자
- 클래스 정적 메서드
```javascript
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  // 팩토리 메서드
  // - 정적 메서드)
  static createTodays() {

    // this == Article
    return new this("Today's digest", new Date());
  }
}

let article = Article.createTodays();

alert( article.title ); // Today's digest
```

##### `Article.createTodays()` <sub>(정적 메서드)</sub>
- 객체 필요할 때마다 호출
- `article` <sub>(객체)</sub> 메서드 X
- 전체 클래스 메서드
```javascript
// 정적 메서드
// - DB 관련 클래스에도 사용
//   - 항목 검색 · 저장 · 삭제 등
/*
 Article (클래스)
 - article (객체) 관리 특별 클래스 가정
 - article (객체) 삭제
  - 정적 메서드
 */
Article.remove({id: 12345});
```

### 정적 프로퍼티

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 추가됨**

- 최근 스펙 추가됨
- 예시 : Chrome 에서만 동작할 수 있음

<br />

- 일반 클래스 프로퍼티 유사
- `static` <sub>(키워드)</sub>
  - 프로퍼티 앞
```javascript
class Article {
  static publisher = "Ilya Kantor";
}

↓↓↓

Article.publisher = "Ilya Kantor";

alert( Article.publisher ); // Ilya Kantor
```

### 정적 프로퍼티 · 메서드 상속
```javascript
class Animal {
  static planet = "지구";

  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }

}

// Animal 상속
class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }
}

let rabbits = [
  new Rabbit("흰 토끼", 10),
  new Rabbit("검은 토끼", 5)
];

// 상속된 정적 메서드
rabbits.sort(Rabbit.compare);

rabbits[0].run(); // 검은 토끼가 속도 5로 달립니다.

// 상속된 정적 프로퍼티
alert(Rabbit.planet); // 지구
```

![animal-rabbit-static](../../images/01/09/03/animal-rabbit-static.svg)

##### `Rabbit extends Animal`
- `[[Prototype]]` 참조 2개 생성
  - 둘 다 프로토타입 통해 상속
1. `Rabbit` <sub>(함수)</sub> → `Animal` <sub>(함수)</sub>
2. `Rabbit.prototype` → `Animal.prototype`
```javascript
class Animal {}
class Rabbit extends Animal {}

// 정적 메서드
alert(Rabbit.__proto__ === Animal); // true

// 일반 메서드
alert(Rabbit.prototype.__proto__ === Animal.prototype); // true
```

<br />

## 요약

##### 정적 메서드
- '전체' 클래스 필요 기능
- 특정 클래스 인스턴스 한정 X
- 클래스 선언부 내 위치
- 메서드 앞 `static` <sub>(키워드)</sub>

##### ex\)
- 인스턴스 간 비교 메서드
```javascript
Article.compare(article1, article2)
```
- 팩토리 메서드
```javascript
Article.createTodays()
```

##### 정적 프로퍼티
- 클래스 수준 데이터 저장
- 개별 인스턴스 한정 X

#### 정적 메서드 · 프로퍼티

##### 문법
```javascript
class MyClass {
  static property = …;

  static method( … ) { … }
}
```

##### `static` 선언
- 기술적으로 클래스 자체 직접 할당 동일
```javascript
MyClass.property = …;
MyClass.method = { … }
```

##### 상속 가능
- `class B extends A`
  - `B` 프로토타입 → `A` 가리키게 합니다(`B.[[Prototype]] = A`). 따라서 `B`에서 원하는 프로퍼티나 메서드를 찾지 못하면 `A`로 검색이 이어집니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `Object`를 상속받는 클래스
아시다시피, 객체는 보통 `Object.prototype`를 상속받고 `hasOwnProperty`같은 '일반' 객체 메서드에 접근할 수 있습니다.

예시:
```javascript
class Rabbit {
  constructor(name) {
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

// 메서드 hasOwnProperty는 Object.prototype에서 왔습니다.
alert( rabbit.hasOwnProperty('name') ); // true
```

그런데 `class Rabbit extends Object`같이 상속을 명시적으로 해주는 경우와 그냥 `class Rabbit`를 사용하는 경우, 결과가 다를까요?

만약 다르다면 어떤 것이 다를까요?

아래 예시에서 `class Rabbit extends Object`를 사용한 코드가 있는데, 실행해보면 동작하지 않습니다. 어디서 문제가 생긴걸까요? 코드를 수정해보세요.
```javascript
class Rabbit extends Object {
  constructor(name) {
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

alert( rabbit.hasOwnProperty('name') ); // Error
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

먼저, 해당 코드가 왜 작동하지 않는지 살펴봐야 합니다.

코드를 실행하면 이유를 찾을 수 있습니다. 상속 받는 클래스의 생성자는 `super()`를 반드시 호출해야 합니다. 그렇지 않으면 `this`가 '정의'되지 않습니다.

수정한 코드는 다음과 같습니다.
```javascript
class Rabbit extends Object {
  constructor(name) {
    super(); // 상속 클래스의 생성자에선 부모 생성자를 반드시 호출해야 합니다.
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

alert( rabbit.hasOwnProperty('name') ); // true
```

그런데 이게 끝이 아닙니다.

위와 같이 수정 해도, 여전히 `class Rabbit extends Object`와 `class Rabbit`는 다른점이 있습니다.

아시다시피 `extends` 문법은 두 개의 프로토타입을 설정합니다.
1. 생성자 함수의 `prototype` 사이(일반 메서드용)
2. 생성자 함수 자체 사이(정적 메서드용)

예시의 `class Rabbit extends Object`는 다음과 같은 관계를 만들죠.
```javascript
class Rabbit extends Object {}

alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true
alert( Rabbit.__proto__ === Object ); // (2) true
```

따라서 `Rabbit`은 아래와 같이 `Rabbit`을 통해 `Object`의 정적 메서드에 접근할 수 있습니다.
```javascript
class Rabbit extends Object {}

// 보통은 Object.getOwnPropertyNames 로 호출합니다.
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b
```

그런데 `extends Object`가 없으면, `Rabbit.__proto__`는 `Object`로 설정되지 않습니다.

데모:
```javascript
class Rabbit {}

alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true
alert( Rabbit.__proto__ === Object ); // (2) false (!)
alert( Rabbit.__proto__ === Function.prototype ); // true (모든 함수의 기본 프로토타입)

// error, no such function in Rabbit
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error
```

이런 이유 때문에 `Rabbit에`서 `Object`의 정적 메서드를 사용할 수 없습니다.

한편, `Function.prototype`은 `call`, `bind` 등의 '일반' 함수 메서드를 가집니다. 내장 객체, `Object`의 생성자는 `Object.__proto__` === `Function.prototype` 관계를 갖기 때문에 `Function.prototype`에 정의된 일반 함수 메서드는 두 경우 모두에 사용할 수 있습니다.

이해를 돕기 위한 그림:

![rabbit-extends-object](../../images/01/09/03/rabbit-extends-object.svg)

그냥 클래스를 정의하는 것과 명시적으로 `Object`를 상속해 클래스를 정의하는 것의 차이를 요약하면 다음과 같습니다.

|`class Rabbit`|`class Rabbit extends Object`|
|---|---|
|–|생성자에서 `super()`를 반드시 호출해야 함|
|`Rabbit.__proto__ === Function.prototype`|`Rabbit.__proto__ === Object`|
