`symbol`
====

##### 객체 내 프로퍼티 키 허용 자료형
- `string`
- `symbol`

### `symbol`

##### 용도
- 유일 식별자

##### `Symbol([name])`
- `symbol` 값 생성
- `[name]`
  - 설명 <sub>(`symbol` 이름)</sub>
    - 디버깅 시 유용
```javascript
// symbol 생성
let id1 = Symbol();

// 설명 (symbol 이름) 추가
let id2 = Symbol("id");
```

##### 유일성 보장
- 설명 <sub>(`symbol` 이름)</sub>
  - 단순 이름표 역할
- 설명 동일 `symbol` 다수 생성 시
  - 각 `symbol` 값 전부 상이

##### 동일 설명 `symbol` 2개 비교
```javascript
let id1 = Symbol("id");
let id2 = Symbol("id");

alert( id1 == id2 ); // false
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`symbol` → `string` 자동 형 변환 X**

##### JS 내 `string` 암시적 형 변환 <sub>(비교적)</sub> 자유롭게 발생
- ex\) `alert` <sub>(함수)</sub>
  - 거의 모든 값 전달 가능
- `symbol` <sub>(예외)</sub>
  - 타 자료형 암시적 <sub>(자동)</sub> 형 변환 X
```javascript
let id = Symbol("id");

// TypeError: Cannot convert a Symbol value to a string
alert(id);
```

##### `string` · `symbol` 근본 상이
- JS '언어 차원 보호장치'
  - `symbol` → 타 자료형 변환 방지

##### `symbol` 출력
- `.toString()` <sub>(메서드)</sub> 명시적 호출
```javascript
let id = Symbol("id");
alert(id.toString()); // Symbol(id)
```

##### `Symbol.description` <sub>(프로퍼티)</sub>
- 설명 <sub>(`symbol` 이름)</sub> 에만 접근
```javascript
let id = Symbol("id");
alert(id.description); // id
```

<br />

### '숨김' 프로퍼티
- `symbol` 이용
- 외부 코드
  - 접근 불가능
  - 값 덮어쓸 수 없음
```javascript
// 서드파티 (외부) 코드 객체
let user = {
  name: "John"
};
let id = Symbol("id");
user[id] = 1;

// symbol 키로 데이터 접근
alert( user[id] );
```

##### 서드파티 코드 객체
- 함부로 새 프로퍼티 추가 X

##### 서드파티 코드에서 `symbol` 접근 X
- 서드파티 코드 모르게 식별자 부여

#### 각자 서로 코드 모른 채 `user` 식별해야 하는 상황 가정

##### `Symbol("id")` <sub>(전용 식별자)</sub> 사용
- 서드파티 코드
- 현재 작성 스크립트
- 제3 스크립트
```javascript
let id = Symbol("id");
user[id] = "제3 스크립트 id 값";
```

##### `symbol` : 유일성 보장
- 이름 같아도 식별자 충돌 X
- `"id"` <sub>(문자열)</sub> 식별자
  - 충돌 발생 가능
```javascript
let user = { name: "John" };

// "id" (문자열) 식별자 생성
user.id = "id 값";

// 제3 스크립트
// - 동일한 "id" (문자열) 식별자 생성
//   - 의도치 않게 값 덮어쓰여 식별자 무의미
user.id = "제3 스크립트 id 값"
```

#### `{…}` <sub>(객체 리터럴)</sub> 내 `symbol`

##### `{…}` <sub>(객체 리터럴)</sub> 로 객체 생성 시
- `[…]` <sub>(대괄호)</sub> 사용해 `symbol` 키 추가
```javascript
let id = Symbol("id");
let user = {
  name: "John",
  [id]: 123 // 문자열 X
//"id": 123
};
```

#### `for…in` <sub>(반복문)</sub> · `Object.keys(user)`

##### `symbol` 키 프로퍼티 배제
```javascript
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

// name, age
for (let key in user) alert(key);

// 직접 접근
alert( "직접 접근한 값: " + user[id] );
```

##### '`symbol` 프로퍼티 숨기기' 원칙
- 외부 스크립트 · 라이브러리
  - `symbol` 키 프로퍼티 접근 X

#### `Object.assign`

##### 객체 내 모든 프로퍼티 복사
- `symbol` 키 포함

##### 객체 복사 · 병합 시
- 프로퍼티 전부 사용 예상하여 JS 설계
  - ex\) `id` `symbol`
```javascript
let id = Symbol("id");
let user = {
  [id]: 123
};
let clone = Object.assign({}, user);
alert( clone[id] ); // 123
```

### 전역 `symbol`
1. 전역 `symbol` 레지스트리 내부 `symbol` 생성
2. 해당 `symbol` 접근 시
    - 이름 같으면 항상 동일 `symbol` 반환

#### `Symbol.for (key)`
- 레지스트리 내부 `symbol` 읽기 · 생성
- 호출 시
  - `key` <sub>(이름)</sub> `symbol` 반환
- 조건 부합 `symbol` 부재 시
  1. 새 `key` `symbol` 생성
  2. 레지스트리 내부 저장
  3. 반환
- 앱 내부 광범위 사용 `symbol`
```javascript
// 전역 레지스트리 내부 symbol 읽기
// symbol 부재 시
// - 새 symbol 생성 · 저장 · 반환
let id = Symbol.for ("id");

// 동일 이름으로 symbol 다시 읽기
let idAgain = Symbol.for ("id");

// 두 symbol 동일
alert( id === idAgain ); // true
```

#### `Symbol.keyFor`

##### 전역 `symbol` 이름 얻음
```javascript
// 이름 이용해 symbol 찾음
let sym1 = Symbol.for ("name");
let sym2 = Symbol.for ("id");

// symbol 이용해 이름 얻음
alert( Symbol.keyfor (sym1) ); // name
alert( Symbol.keyfor (sym2) ); // id
```

##### 검색 범위
- 전역 `symbol` 레지스트리

##### 일반 `symbol`
- `undefined` 반환
- `description` <sub>(프로퍼티)</sub> 사용
```javascript
let globalSymbol = Symbol.for ("name");
let localSymbol = Symbol("name");

// name
// - 전역 symbol
alert( Symbol.keyfor (globalSymbol) );

// undefined
// - 일반 symbol
alert( Symbol.keyfor (localSymbol) );

// name
// - 일반 symbol
alert( localSymbol.description );
```

### 시스템 `symbol`
- JS 내부 전용 `symbol`

##### 객체 미세 조정 시 활용
- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- 기타 등등

<br />

요약
====

##### `symbol`
- 원시형 데이터
- 유일무이한 식별자 생성

##### `Symbol()` 호출
- `symbol` 생성
- 설명 <sub>(`symbol` 이름)</sub>
  - 선택적 추가

##### 특징
- 동일 `symbol` 이름
  - 항상 값 상이

#### 전역 레지스트리
- `symbol` 이름 · 값 동일

##### `Symbol.for (key)`
- 전역 `symbol` 반환 <sub>(`symbol` 이름 : `key`)</sub>
- 해당 전역 `symbol` 부재 시
  - 새 전역 `symbol` 생성
- `key` <sub>(`symbol` 이름)</sub> 동일 시
  - 항상 동일 `symbol` 반환 <sub>(호출 위치 무관)</sub>

#### 주요 사용 사례

##### 1. 객체 '숨김' 프로퍼티 <sub>(`symbol` 키)</sub>
- 외부 스크립트 · 라이브러리 객체
  - 새 프로퍼티 추가
- `for…in` 순회 대상 X
  - 의도치 않게 프로퍼티 수정 X
- 외부 스크립트 · 라이브러리
  - `symbol` 정보 X
    - 프로퍼티 직접 접근 X
- '숨김' 프로퍼티
  - 우연히 사용 · 덮어씌워짐 예방
- 객체 내 정보 '은밀하게' 숨기기 <sub>(특징)</sub>
  - 외부 스크립트
    - 해당 정보 접근 X

##### 2. 시스템 `symbol` <sub>(JS 내부 사용)</sub>
- 접근 방법
  - `Symbol.*`
- 기본 동작 자유롭게 변경
  - 내장 메서드
  - 기타 등등

##### `symbol` 완전히 숨기기 X
- [`Object.getOwnPropertysymbols(obj)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertysymbols) <sub>(내장 메서드)</sub>
  - 모든 `symbol` 반환
- [`Reflect.ownKeys(obj)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) <sub>(메서드)</sub>
  - 객체 내 모든 키 <sub>(`symbol` 포함)</sub> 반환
- 대다수 라이브러리 · 내장 함수 등
  - 위 2가지 매서드 드물게 사용
