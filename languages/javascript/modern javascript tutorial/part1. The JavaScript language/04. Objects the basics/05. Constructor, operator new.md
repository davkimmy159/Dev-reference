`new` <sub>(연산자)</sub> · 생성자 <sub>(함수)</sub>
====

##### 용도
- 다수 유사 객체 생성

### 생성자 <sub>(함수)</sub>

##### 생성자 <sub>(함수)</sub> vs 일반 함수
- 기술적 차이 無 <sub>(동일)</sub>

##### 관례 <sub>(2가지)</sub>
- a. 함수명 1번째 글자 대문자
- b. 실행 시 `new` <sub>(연산자)</sub> 사용 필수

##### 실행 알고리즘
1. `{}` <sub>(빈 객체)</sub> 생성 후 `this` 할당
2. 함수 본문 실행
    - `this` 내 프로퍼티 추가 <sub>(`this` 수정)</sub>
3. `this` 반환

##### `new User(…)`
- `User` <sub>(생성자 함수)</sub> 실행
```javascript
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

↓↓↓

function User(name) {

  // {} (빈 객체) 암시적 생성 후 this 할당
  // this = {};

  // this 내 새 프로퍼티 추가
  this.name = name;
  this.isAdmin = false;

  // this 암시적 반환
  // return this;
}

let user = new User("보라");
/*
let user = {
  name: "보라",
  isAdmin: false
};
 */

alert(user.name);    // 보라
alert(user.isAdmin); // false
```
- 다수 유사 객체 생성 용이
```javascript
let user1 = new User("호진");
/*
let user1 = {
  name: "호진",
  isAdmin: false
};
 */

let user2 = new User("지민");
/*
let user2 = {
  name: "지민",
  isAdmin: false
};
 */
```

##### 생성자 <sub>(함수)</sub> 의의
- 재사용 객체 생성 코드 구현

##### 모든 함수 호출 시 `new` <sub>(연산자)</sub> 사용 가능 <sub>(주의)</sub>
- 생성자 <sub>(함수)</sub> 알고리즘 실행

##### 함수명 1번째 글자 대 · 소문자 여부

|함수명 1번째 글자|`new` <sub>(연산자)</sub>|
|---|:---:|
|대문자 <sub>(생성자 함수)</sub>|사용 필수|
|소문자 <sub>(일반 함수)</sub>|미사용|

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **익명 생성자 함수 <sub>(`new function() { … }`)</sub>**

##### 용도
- 재사용 필요 없는 복잡한 객체 생성

##### 장점
- 캡슐화
  - 긴 초기화 코드 분리
- 재사용 방지
  - 익명 함수 <sub>(함수 저장 X)</sub>
  - 단 한 번만 호출
```javascript
 // 익명 생성자 (함수)
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  /* 다양한 코드 有
   지역 변수
   복잡한 로직 · 구문
   기타 등등
   */
  …
};
```

### `new.target` · 생성자 <sub>(함수)</sub>

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **심화 학습**

##### 해당 문법
- 드물게 사용

<br />

##### `new.target` <sub>(프로퍼티)</sub>
- 함수 호출 시 `new` <sub>(연산자)</sub> 사용 여부

|`new` <sub>(연산자)</sub>|프로퍼티 값|
|:---:|:---:|
|미사용|`undefined`|
|사용|함수 자체|

```javascript
function User() {
  alert(new.target);
}

// 연산자 미사용 (일반 모드)
User();     // undefined

// 연산자 사용  (생성자 보드)
new User(); // function User { … }
```

##### 항시 생성자 <sub>(함수)</sub> 호출 트릭
- 일반적인 호출 시 <sub>(`new` 연산자 無)</sub>
  - `new` <sub>(연산자)</sub> 내부적 추가
```javascript
function User(name) {

  // new (연산자) 부재 시 추가
  if (!new.target) {

    // 생성자 (함수) 호출
    return new User(name);
  }

  this.name = name;
}

let bora = User("보라");
//       = new User("보라");

alert(bora.name); // 보라
```
- `new` 유무 무관 <sub>(동일 동작)</sub>
  - 좀 더 유연하게 코드 작성
- `new` 함께 호출 시
  - 새 객체 생성 동작 누구나 알 수 있음
- `new` 없는 객체 생성 남발 X

### 생성자 <sub>(함수)</sub> · `return` <sub>(문)</sub>

##### 생성자 내 `return`
- 객체 반환 시
  - `this` 대신 객체 반환
- 원시형 반환 시
  - 무시
  - `this` 반환
```javascript
function BigUser() {
  this.name = "원숭이";

  // this 반환 X
  // - 새 객체 반환
  return { name: "고릴라" };
}
alert( new BigUser().name ); // 고릴라

function SmallUser() {
  this.name = "원숭이";

  // 무시
  // - this 반환
  return;
}
alert( new SmallUser().name ); // 원숭이
```

##### `return` 명시 생성자 <sub>(함수)</sub>
- 거의 없음

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`(…)` <sub>(괄호)</sub> 생략하기**

##### 인수 없는 생성자
- `(…)` <sub>(괄호)</sub> 없이 호출 가능
  - 명세서 내 정의
  - 좋은 코딩 스타일 X
```javascript
// 호출 시 `(…)` (괄호) 無
let user1 = new User;
let user2 = new User();
```

<br />

### 생성자 내 메서드

##### 매개변수 이용해 객체 내부 자유롭게 구성
- 엄청난 유연성 확보

##### `this` 에 메서드 추가
```javascript
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( "제 이름은 " + this.name + "입니다." );
  };
}

let bora1 = new User("이보라");

// 제 이름은 이보라입니다.
bora1.sayHi();

// `{…}` (객체 리터럴)
bora2 = {
   name: "이보라",
   sayHi: function() { … }
}
```

<br />

요약
====

##### 생성자 <sub>(함수)</sub>
- 일반 함수
- 함수명 첫 글자 : 대문자
  - 일반 함수와 구분
- 호출 시 `new` <sub>(연산자)</sub> 필수
  - 내부 `this` 암시적 생성
  - 마지막 `this` 반환
- 다수 유사 객체 생성 시 유용

##### JS
- 다양한 생성자 <sub>(함수)</sub> 제공
  - `Date` <sub>(일시)</sub>
  - `Set` <sub>(집합)</sub>

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 함수 2개로 동일한 객체 만들기

##### `A` <sub>(함수)</sub> · `B` <sub>(함수)</sub> 작성
- `new A() == new B()` 성립
```javascript
function A() { … }
function B() { … }

let a = new A;
let b = new B;

alert( a == b ); // true
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

##### 두 함수
- `this` 반환 X
- 객체 반환
```javascript
let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true
```

<hr />

### 계산기 만들기

#### `Calculator` <sub>(생성자 함수)</sub> 작성

##### 메서드 3개 구현
- `read()`
  - 값 2개 입력 받은 후 객체 내 프로퍼티 저장
  - `prompt` <sub>(함수)</sub> 이용
- `sum()`
  - 프로퍼티 저장 값 2개 더한 후 반환
- `mul()`
  - 프로퍼티 저장 값 2개 곱한 후 반환
```javascript
let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
```

[정답](https://plnkr.co/edit/tGcIZnNXJZdRbb2M?p=preview)

<hr />

### 누산기 만들기

#### `Accumulator(startingValue)` <sub>(생성자 함수)</sub> 작성

##### `value` <sub>(프로퍼티)</sub>
- 현재 값 저장 <sub>(총합)</sub>
  - `startingValue` <sub>(시작 값)</sub>
  - 사용자 입력값 전체
- 최초 호출 시 생성자 인수 값 저장
  - `startingValue` <sub>(시작 값)</sub>

##### `read()` <sub>(메서드)</sub>
- 숫자 입력 받은 후 `value` 에 더하기
- `prompt` <sub>(함수)</sub> 사용
```javascript
// 최초값: 1
let accumulator = new Accumulator(1);

// 사용자 입력값 더하기
accumulator.read();
accumulator.read();

// 총합 출력
// - 최초값 · 사용자 입력값 전체
alert(accumulator.value);
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('더할 값을 입력해주세요.', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);
```

[정답](https://plnkr.co/edit/7CU6wBh2Q1plFL0A?p=preview)
