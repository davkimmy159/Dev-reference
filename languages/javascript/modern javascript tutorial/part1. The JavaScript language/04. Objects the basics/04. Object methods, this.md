메서드 · `this`
============

##### 메서드
- 객체 프로퍼티 → 함수 할당

### 메서드 만들기
```javascript
let user = {
  name: "John",
  age: 30
};
user.sayHi1 = function() {
  alert("안녕하세요!");
};
user.sayHi1();        // 안녕하세요!

// 함수 선언
function sayHi2() {
  alert("안녕하세요!");
};
user.sayHi2 = sayHi2; // 선언된 함수 → 메서드 등록
user.sayHi2();        // 안녕하세요!
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **객체 지향 프로그래밍**

- object-oriented programming <sub>(OOP)</sub>
- 객체 사용하여 개체 표현
  - 올바른 개체 선택 방법
  - 개체 사이 상호작용 표현 방법
  - 기타 등등
- 추천 도서
  - 'GoF의 디자인 패턴' <sub>(_에릭 감마_)</sub>
  - 'UML을 활용한 객체지향 분석 설계' <sub>(_그래디 부치_)</sub>

<br />

#### 메서드 단축 구문
- 객체 상속 관련 미묘한 차이
  - `super` <sub>(`[[HomeObject]]`)</sub>
```javascript
user = {
  sayHi1: function() {
    alert("Hello");
  },

  // 단축 구문
  sayHi2() {
    alert("Hello");
  },
};
```

### 메서드와 `this`
- 객체에 저장된 정보 접근
- 메서드 내부 `this` <sub>(키워드)</sub>
  - 객체 접근
```javascript
let user = {
  name: "John",
  age: 30,
  sayHi() {
    alert(this.name); // this : 현재 객체
  }
};
user.sayHi(); // "John"
              // 메서드 실행 동안
              // - this → user (객체) 참조
```

##### 외부 변수 사용해 객체 참조
- `this` 사용 X
- 객체 할당 변수 사용
  - 예상치 못한 에러 발생 가능
```javascript
let user = {
  name: "John",
  age: 30,
  sayHi() {

    // this X
    // user (변수) 사용
    alert( user.name );
  }
};
let admin = user; // 객체 참조 값 복사
user = null;      // user (변수) → null 할당
admin.sayHi();    // Error: Cannot read property 'name' of null
                  // sayHi() 메서드 내
                  // - 엉뚱한 참조 발생 (null.name)
```

### 자유로운 `this`
- 모든 함수
  - `this` 사용 가능
```javascript
function sayHi() {
  alert( this.name );
}
```
- `this` 값
  - 런타임에 결정
  - 컨텍스트 따라 달라짐
- 동일 함수 : 다른 객체에서 호출 시
  - `this` 참조 값 상이
```javascript
let user = { name: "John" };
let admin = { name: "Admin" };
function sayHi() {
  alert( this.name );
}

// 두 별개 객체
// - 동일 함수 사용
user.f  = sayHi;
admin.f = sayHi;

// 함수 호출 시
// - this : '. (점) 앞' 객체 참조
// this 값 달라짐
user.f();     // John , this == user (객체)
admin.f();    // Admin, this == admin (객체)
admin['f'](); // Admin, 점 · 대괄호 동일 동작
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **객체 없이 호출 : `this` == `undefined`**

- 객체 없이 함수 호출 가능
```javascript
function sayHi() {
  alert(this);
}
sayHi(); // undefined
```

##### 엄격 모드
- `this` → `undefined` 할당
- `this.name` 접근 시
  - 에러 발생

##### 비엄격 모드
  - `this` → 전역 객체 참조
    - `window` <sub>(브라우저 환경 전역 객체)</sub>
    - `"use strict"` 도입 배경
- 대개 실수로 작성된 경우 多
- 함수 본문 `this` 존재 시
  - 객체 컨텍스트 내 함수 호출 예상하기

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **자유로운 `this` 가 만드는 결과**

##### _'bound this'_
- 항상 메서드 정의된 객체 참조 <sub>(고정)</sub>

##### JS `this`
- 런타임에 결정
- 메서드 정의 위치 상관 X
- '`.` <sub>(점)</sub> 앞' 객체 따라 '자유롭게' 결정

##### 장점
- 함수 <sub>(메서드)</sub> 하나만 생성 후
  - 여러 객체 재사용

##### 단점
- 유연함 → 실수

<br />

### `this` 없는 화살표 함수

##### 화살표 함수
- 고유한 `this` 소유 X
  - 별개 `this` 생성 X
- `this` 참조 시
  - 외부 컨텍스트 `this` 이용
  - 평범한 외부 함수 `this` 값 가져옴

```javascript
let user = {
  firstName: "보라",
  sayHi() {

    // 화살표 함수 this
    //  - user.sayHi (메서드) 의 this (user) 사용
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // 보라
```

<br />

## 요약
- 객체 프로퍼티에 저장된 함수를 '메서드’라고 부릅니다.
- `object.doSomthing()`은 객체를 '행동’할 수 있게 해줍니다.
- 메서드는 this로 객체를 참조합니다.

`this` 값은 런타임에 결정됩니다.
- 함수를 선언할 때 `this`를 사용할 수 있습니다. 다만, 함수가 호출되기 전까지 `this`엔 값이 할당되지 않습니다.
- 함수를 복사해 객체 간 전달할 수 있습니다.
- 함수를 객체 프로퍼티에 저장해 `object.method()`같이 ‘메서드’ 형태로 호출하면 `this`는 `object`를 참조합니다.

화살표 함수는 자신만의 `this`를 가지지 않는다는 점에서 독특합니다. 화살표 함수 안에서 `this`를 사용하면, 외부에서 `this` 값을 가져옵니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 객체 리터럴에서 `this` 사용하기
함수 `makeUser`는 객체를 반환합니다.

이 객체의 `ref`에 접근하면 어떤 결과가 발생하고, 그 이유는 뭘까요?
```javascript
function makeUser() {
  return {
    name: "John",
    ref: this
  };
};

let user = makeUser();

alert( user.ref.name ); // 결과가 어떻게 될까요?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

에러가 발생합니다.

직접 실행해 봅시다.
```javascript
function makeUser() {
  return {
    name: "John",
    ref: this
  };
};

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
```
에러가 발생하는 이유는 `this` 값을 설정할 땐 객체 정의가 사용되지 않기 때문입니다. `this` 값은 호출 시점에 결정됩니다.

위 코드에서 `makeUser()` 내 `this`는 `undefined`가 됩니다. 메서드로써 호출된 게 아니라 함수로써 호출되었기 때문입니다.

`this` 값은 전체 함수가 됩니다. 코드 블록과 객체 리터럴은 여기에 영향을 주지 않습니다.

따라서 `ref: this`는 함수의 현재 `this` 값을 가져옵니다.

`this`의 값이 `undefined`가 되게 함수를 다시 작성하면 다음과 같습니다.
```javascript
function makeUser(){
  return this; // 이번엔 객체 리터럴을 사용하지 않았습니다.
}

alert( makeUser().name ); // Error: Cannot read property 'name' of undefined
```

보시다시피 `alert( makeUser().name )`와 위쪽에서 살펴본 `alert( user.ref.name )`의 결과가 같은 것을 확인할 수 있습니다.

에러가 발생하지 않게 하려면 코드를 다음과 같이 수정하면 됩니다.
```javascript
function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
};

let user = makeUser();

alert( user.ref().name ); // John
```

이렇게 하면 `user.ref()`가 메서드가 되고 `this`는 `.` 앞의 객체가 되기 때문에 에러가 발생하지 않습니다.

<hr />

### 계산기 만들기
`calculator`라는 객체를 만들고 세 메서드를 구현해 봅시다.

- `read()`에선 프롬프트 창을 띄우고 더할 값 두 개를 입력받습니다. 입력받은 값은 객체의 프로퍼티에 저장합니다.
- `sum()`은 저장된 두 값의 합을 반환합니다.
- `mul()`은 저장된 두 값의 곱을 반환합니다.
```javascript
let calculator = {
  // ... 여기에 답안 작성 ...
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

```javascript
let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('첫 번째 값:', 0);
    this.b = +prompt('두 번째 값:', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
```

[정답](https://plnkr.co/edit/r7wjvIomjvNIlzrZ?p=preview)

<hr />

### 체이닝
올라가기(`up`)와 내려가기(`down`) 메서드를 제공하는 객체 `ladder`가 있습니다.
```javascript
let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // 사다리에서 몇 번째 단에 올라와 있는지 보여줌
    alert( this.step );
  }
};
```

메서드를 연이어 호출하고자 한다면 아래와 같이 코드를 작성할 수 있습니다.
```javascript
ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
```

`up`, `down`, `showStep을` 수정해 아래처럼 메서드 호출 체이닝이 가능하도록 해봅시다.
```javascript
ladder.up().up().down().showStep(); // 1
```

참고로 이런 방식은 자바스크립트 라이브러리에서 널리 사용됩니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

메서드를 호출할 때마다 객체 자신을 반환하게 하면 됩니다.
```javascript
let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
}

ladder.up().up().down().up().down().showStep(); // 1
```

체이닝이 길어질 땐 메서드 호출을 별도의 줄에 작성하면 가독성이 좋아집니다.
```javascript
ladder
  .up()
  .up()
  .down()
  .up()
  .down()
  .showStep(); // 1
```

[정답](https://plnkr.co/edit/b4rOsBhhD4dQ6MqQ?p=preview)
