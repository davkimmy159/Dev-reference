비동기 이터러블 <sub>(객체)</sub> · 제너레이터
====

### 비동기 이터러블 <sub>(객체)</sub>

##### 동기 <sub>(일반)</sub> vs 비동기 이터러블 <sub>(객체)</sub>

||동기|비동기|
|:---:|:---:|:---:|
|구현 메서드|`[Symbol.iterator]`|`[Symbol.asyncIterator]`|
|`next()` 반환 값|값 객체|`Promise` <sub>(객체)</sub>|
|반복문|`for…of`|`for await…of`|

```javascript
let obj = {

// ① 구현 메서드
//[Symbol.iterator]() {
  [Symbol.asyncIterator]() {
    return {

      // ② next (메서드) 반환 값
      //    next() {…}
      async next() {…} // 항상 Promise (객체) 반환
    };
  }
};

// ③ 반복문
//for       (let … of obj) {…}
(async () => {
  for await (let … of obj) {…}
})();
```

##### 이터러블 <sub>(객체)</sub> 비동기화
```javascript
let range = {
  from: 1,
  to: 5,

  // ① 구현 메서드
  // - for await…of (비동기 반복문) 최초 실행 시 호출
//[Symbol.iterator]() {
  [Symbol.asyncIterator]() {

    // 이터레이터 (객체) 반환
    // - for await…of (비동기 반복문) 동작 대상
    //   - next (메서드) 내 다음 값 설정
    return {
      current: this.from,
      last: this.to,

      // ② next (메서드) 반환 값
      //    next() {
      async next() { // 항상 Promise (객체) 반환

        // for await…of (비동기 반복문)
        // - 각 반복 시 next (메서드) 호출
        //   - Promise (객체) 반환 필수

        // await 사용 (비동기 작업) 가능
        await new Promise(resolve => setTimeout(resolve, 1000));

        if (this.current <= this.last) {
          return {done: false, value: this.current++};
        } else {
          return {done: true};
        }
      }
    };
  }
};

/* ③ 반복문
  for       (let value of range) {
    value; // 1, 2, 3, 4, 5
  }
 */
(async () => {

  // ④
  for await (let value of range) {
    value; // 1, 2, 3, 4, 5
  }
})();
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`...` <sub>(전개 구문)</sub> 비동기 동작 불가능**

##### 동기 <sub>(일반)</sub> 이터러블 <sub>(객체)</sub> 필요 기능
- `[Symbol.iterator]` <sub>(메서드)</sub> 호출
  - `...` <sub>(전개 구문)</sub>
  - `for…of` <sub>(동기 반복문)</sub>
  - 기타 등등
- `[Symbol.asyncIterator]` <sub>(메서드)</sub> 호출 X
  - 비동기 이터러블 <sub>(객체)</sub> 사용 불가능
```javascript
// [Symbol.iterator] (메서드) 미구현 → 에러
[...range];
```

<br />

### 비동기 제너레이터

##### 동기 <sub>(일반)</sub> vs 비동기 제너레이터

||동기|비동기|
|:---:|:---:|:---:|
|선언|`function*`|`async function*`|
|`next()` 반환 값|값 객체|`Promise` <sub>(객체)</sub>|
|반복문|`for…of`|`for await…of`|

##### 제너레이터 비동기화
```javascript
// ① 선언
//    function* generate(s, e) {
async function* generate(s, e) {
  for (let i = s; i <= e; i++) {

    // await (키워드) 사용 가능
    await new Promise(resolve => setTimeout(resolve, 1000));

    // ② next (메서드) 반환 값
    // async (키워드) → 항상 Promise (객체) 반환
    yield i;
  }
}

/* ③ 반복문
  for       (let value of generate(1, 5)) {
    alert(value); // 1, 2, 3, 4, 5
  }
 */
(async () => {
  for await (let value of generate(1, 5)) {
    alert(value); // 1, 2, 3, 4, 5
  }
})();
```
- `next` <sub>(메서드)</sub> 호출 <sub>(결괏값 반환)</sub> 시
  - `await` <sub>(키워드)</sub> 필요
```javascript
let g = generate(1, 5);

//  result =       g.next();
let result = await g.next();
```

### 이터러블 <sub>(객체)</sub> · 제너레이터

##### 이터러블 <sub>(객체)</sub> 구현 방법 <sub>(2가지)</sub>
- a. 일반 객체 <sub>(`next` 메서드 구현)</sub> 반환
- b. 제너레이터 객체 반환 <sub>(사용 빈도 ↑)</sub>
```javascript
let obj = {

  // ⓐ 일반 객체 (next 메서드 구현) 반환
  [Symbol.iterator]() { // 일반 함수 구현
    return {
      next() {…}
    }
  },

  // ⓑ 제너레이터 객체 반환
// [Symbol.iterator]: function*() {
  *[Symbol.iterator]() { // 제너레이터 함수 구현
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};
```
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    return {
      next() {…}
    }
  }
}
```
```javascript
let range = {
  from: 1,
  to: 5,

// [Symbol.iterator]: function*() {
  *[Symbol.iterator]() {
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for (let value of range) {

  // 1, 2, 3, 4, 5
  alert(value);
}
```

##### `range` <sub>(커스텀 객체)</sub>
- 반복 가능

##### `*[Symbol.iterator]` <sub>(제너레이터)</sub>
- 값 나열 로직 구현

##### 비동기 동작 <sub>(제너레이터)</sub> 추가 시
- `[Symbol.iterator]`
  - → `async [Symbol.asyncIterator]`
- 매우 간단

##### ※ 이터러블 <sub>(객체)</sub>
- `[Symbol.iterator]` <sub>(메서드)</sub> 구현
  - 제너레이터 사용 시
    - 비동기 동작 추가 : 매우 간단
```javascript
let range = {
  from: 1,
  to: 5,

//       [Symbol.asyncIterator]: async function*() {
  async *[Symbol.asyncIterator]() {
    for (let value = this.from; value <= this.to; value++) {

      // 값 사이 사이
      // - 약간의 공백 추가
      await new Promise(resolve => setTimeout(resolve, 1000));
      yield value;
    }
  }
};

(async () => {

  for await (let value of range) {

    // 1, 2, 3, 4, 5
    alert(value);
  }

})();
```

### 실제 사례

##### 페이지네이션 기능 구현
- '한 페이지' 구성
  - 일정 숫자 단위 정보
- 다음 페이지 url 함께 응답

##### API 예시
- 이터러블 <sub>(객체)</sub> 대상 반복 작업
  - 커밋 정보 담김
```javascript
// GitHub 리포지토리
// - 커밋 정보 얻어옴
let repo = 'javascript-tutorial/en.javascript.info';

for await (let commit of fetchCommits(repo)) {
  // 각 커밋 처리
}
```

##### `fetchCommits(repo)` <sub>(함수)</sub>
- 필요할 때마다 요청 보낸 후
  - 커밋 정보 가져옴
- 페이지네이션 관련 일 모두 처리

##### `for await…of` <sub>(비동기 반복문)</sub>
- 각 커밋 처리

##### 비동기 제너레이터 이용 시
- 함수 쉽게 구현
```javascript
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {

    // ①
    const response = await fetch(url, {

      // GitHub
      // - 모든 요청에 user-agent (헤더) 강제
      headers: {'User-Agent': 'Our script'},
    });

    // ②
    // 응답
    // - JSON 형태
    //   - 커밋 담긴 배열
    const body = await response.json();

    // ③
    // url 추출
    // - 헤더에 담긴 다음 페이지 표시
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage?.[1];

    url = nextPage;

    // ④
    // 커밋 하나씩 반환 (yield)
    // - 페이지 끝날 때까지
    for (let commit of body) {
      yield commit;
    }
  }
}
```

##### 1. `fetch` <sub>(다운로드 메서드)</sub>
- 정보 함께 실어 요청
  - 인증 정보
  - 헤더
  - 기타 등등
- `User-Agent` → 헤더

##### 2. `response.json()` <sub>(`fetch` 전용 메서드)</sub>
- 요청 결과 → JSON 파싱

##### 3. 다음 페이지 url
- Link <sub>(응답 헤더)</sub> 추출
  - 정규표현식 사용
  - `https://api.github.com/repositories/93253246/commits?page=2`

##### 4. 커밋 하나씩 반환
- 전체 다 반환 시
  1. 다음 `while (url)` <sub>(반복문)</sub> 트리거
  2. 서버에 요청 재전송

##### 사용법
```javascript
(async () => {

  let count = 0;

  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {

    console.log(commit.author.login);

    // 100번째 커밋
    // - 중단
    if (++count == 100) {
      break;
    }
  }

})();
```

##### 페이지네이션 관련 내부 메커니즘
- 외부에서 간섭 X

##### 단순히 비동기 제너레이터 사용
- 원하는 커밋 반환받기

### 요약

##### 일반적인 이터레이터 · 제너레이터
- 시간 걸리지 않는 데이터

##### 비동기 이터레이터 · 제너레이터
- 비동기적으로 들어오는 데이터
  - 약간의 지연 발생

##### 문법 차이

||iterable|`async` iterable|
|---|---|---|
|iterator 반환 메서드|`[Symbol.iterator]`|`[Symbol.asyncIterator]`|
|`next()` <sub>(메서드)</sub> 반환 값|`{value: …, done: boolean}`|`Promise` <sub>( `{value: …, done: boolean}` )</sub>|

||generator|`async` generator|
|---|---|---|
|선언|`function*`|`async function*`|
|`next()` <sub>(메서드)</sub> 반환 값|`{value: …, done: boolean}`|`Promise` <sub>( `{value: …, done: boolean}` )</sub>|

##### 비동기 제너레이터
- 띄엄띄엄 들어오는 데이터 스트림 처리
  - 용량 큰 파일 업 · 다운로드 등

##### 일부 호스트 환경 <sub>(브라우저 등)</sub>
- `Streams` API 제공
  - 데이터 스트림 처리
  - 한 스트림 →  다른 스트림

<br />

요약
====

##### 일반 이터레이터 · 제너레이터
- 데이터 가져오는 시간 少 경우
- `for…of`
##### 비동기 이터레이터 · 제너레이터
- 데이터 비동기적으로 가져오는 경우 <sub>(지연 발생)</sub>
- `for await…of`

#### 일반 vs 비동기 이터레이터 <sub>(문법)</sub>

||`iterable`|`async iterable`|
|---|---|---|
|`iterator` 반환 메서드|`[Symbol.iterator]`|`[Symbol.asyncIterator]`|
|`next()` 반환 값|`{value:…, done: boolean} <sub>(객체)</sub>`|`Promise` <sub>(객체)</sub><br />- `{value:…, done: boolean}`|

##### 일반 vs 비동기 제너레이터 <sub>(문법)</sub>

||`generator`|`async generator`|
|---|---|---|
|선언|`function*`|`async function*`|
|`next()` 반환 값|`{value:…, done: boolean}` <sub>(객체)</sub>|`Promise` <sub>(객체)</sub><br />- `{value:…, done: boolean}`|

##### 웹 개발 경우
- 띄엄띄엄 들어오는 데이터 스트림 처리 多
  - ex\) 용량 큰 파일 업 · 다운로드
  - 비동기 제너레이터 유용

##### `Streams` <sub>(데이터 스트림 처리 API)</sub>
- 일부 호스트 환경 <sub>(브라우저 등)</sub> 제공
- 데이터 변경 후 데이터 전달 <sub>(A 스트림 → B 스트림)</sub>
  - 한쪽에서 받은 데이터
    - 다른 쪽 즉각 전달 가능
