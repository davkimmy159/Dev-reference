`Promise` <sub>(객체)</sub> 에러 처리
====

##### `Promise` <sub>(객체)</sub> 거부 시 제어 흐름 이동
- 거부 처리 핸들러 → 최근접 에러 처리 핸들러
  - 체이닝 시 에러 처리 용이

##### `catch` 핸들러
- 모든 이전 `Promise` <sub>(객체)</sub> 거부 <sub>(에러)</sub> 처리
  - 체인 끝 위치 권장
- 동작 정상 수행 시 실행 X
- 문제 발생 시 실행
  - 네트워크 이상
  - 부적절한 JSON 형식
  - 기타 등등

##### `fetch` <sub>(메서드)</sub> → 부재 url 전달
```javascript
fetch('https://no-such-server') // 거부 발생
  .then(response => response.json())

  // 이전 핸들러 내 에러 (Promise 객체 거부) 처리
  .catch(alert);
```

##### 응답 내 부적절한 JSON 형식 에러 처리
```javascript
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";

    document.body.append(img);

    setTimeout(() => {
      img.remove();

      resolve(githubUser);
    }, 3000);
  }))

  // 이전 핸들러 내 에러 (Promise 객체 거부) 처리
  .catch(e => (e.message);
```

### 암시적 `try…catch`

##### `Promise` <sub>(객체)</sub> · 핸들러 내 코드 대상 적용
- 에러 시 거부 처리 <sub>(에러 → 거부)</sub>
  - 에러 == 거부된 `Promise` <sub>(객체)</sub>
```javascript
new Promise((resolve, reject) => {
  throw new Error("에러");
}).catch(alert); // Error: 에러

↓↓↓

new Promise((resolve, reject) => {
  reject(new Error("에러"));
}).catch(alert); // Error: 에러
```

##### 핸들러 내 에러 시 제어 흐름 이동
- 에러 <sub>(거부)</sub> 핸들러 → 최근접 에러 처리 핸들러
```javascript
new Promise((resolve, reject) => {
  resolve("OK");
}).then((result) => {

  // Promise (객체) 거부
  throw  new Error("에러");
//reject(new Error("에러"));

// 이전 핸들러 내 에러 (Promise 객체 거부) 처리
}).catch(alert); // Error: 에러
```

##### 모든 에러 유형 처리 <sub>(`throw` 문 외)</sub>
```javascript
new Promise((resolve, reject) => {
  resolve("OK");
}).then((result) => {
  blabla();// 부재 함수 호출
//reject(new ReferenceError(…));

// 이전 핸들러 내 ReferenceError (Promise 객체 거부) 처리
}).catch(alert); // ReferenceError: blabla is not defined
```

##### `catch` 핸들러 처리 대상
- 명시적인 거부
- 이전 핸들러 내 비정상 에러 <sub>(에러 → 거부)</sub>

### 다시 던지기

#### `catch` 핸들러

##### `try…catch` 유사 역할 수행
- 다수 이전 `then` 핸들러 내 모든 에러 처리
- 에러 분석 후 처리 불가능 에러 다시 던지기

##### 제어 흐름 이동
- 에러 처리 성공 → 최근접 `then` 핸들러
  - 동작 속행
```javascript
/* 실행 순서
 ① Promise (객체)
 ② catch 핸들러
 ③ then 핸들러
 */

// ①
new Promise((resolve, reject) => {
  throw  new Error("에러");
//reject(new Error("에러"));

// ②
}).catch(function(e) {
  `${e} 처리 완료 · 동작 속행`;

// ③
}).then(() => "다음 핸들러 동작");
```
- `throw` <sub>(문)</sub> 사용 → 최근접 에러 처리 핸들러
  - 에러 다시 던지기
```javascript
/* 실행 순서
 ① Promise (객체)
 ② catch 핸들러 (1번째)
 ③ catch 핸들러 (2번째)
 */

// ①
new Promise((resolve, reject) => {
  throw  new Error("에러");
//reject(new Error("에러"));

// ②
}).catch(function(e) {
  if (e instanceof URIError) {
    …처리 가능 에러 처리…

  // Error ≠ URIError
  } else {
    throw e; // 처리 불가능 에러 다시 던지기
  }

// 핸들러 미실행
}).then(function() {
  …

// ③
}).catch(e => {
  `알 수 없는 에러 발생: ${e}`;
  // 반환 값 無 → 동작 속행
});
```

### 미처리 거부

##### 미처리 에러 <sub>(거부)</sub> → 전역 에러 생성
- 체인 끝 `catch` 핸들러 無
- `catch` 핸들러 내 에러 처리 X
- 기타 등등
```javascript
new Promise(function() {
  noSuchFunction(); // 부재 함수 호출 (에러)
//reject(…);
}).then(() => {
  …이행된 Promise (객체) 처리…
}); // 체인 끝 catch 핸들러 無
    // - 전역 에러 생성
```

##### [`unhandledrejection`](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections) <sub>(브라우저 표준 이벤트)</sub>
- 전역 에러 시 발생
- 특수 내부 프로퍼티
  - `promise`
    - 거부된 `Promise` <sub>(에러 유발 객체)</sub>
  - `reason`
    - 미처리 에러 객체

|프로퍼티|값|
|:---:|---|
|`promise`|거부된 `Promise` <sub>(에러 유발 객체)</sub>|
|`reason`|미처리 에러 객체|

```javascript
window.addEventListener('unhandledrejection', function(event) {

  // unhandledrejection (이벤트)
  // - 특수 프로퍼티 2개

  // "[object Promise]"
  // - 에러 생성 Promise (객체)
  alert(event.promise);

  // 미처리 에러 객체
  alert(event.reason); // Error: 에러
});

new Promise(function() {
  throw new Error("에러");
}); // 에러 처리 .catch (핸들러) X
```

##### 에러 발생 · 체인 끝 `.catch` 핸들러 無
- `unhandledrejection` 핸들러 트리거
  - `event` <sub>(객체 · 에러 정보 포함)</sub> 받음
  - 핸들러 내 원하는 작업 수행
- 보통 회복 불가능
- 최선의 방법
  - 사용자에게 문제 상황 알리기
  - 서버에 에러 정보 전송 <sub>(가능 시)</sub>

##### 기타 호스트 환경 <sub>(Node.js 등)</sub>
- 미처리 에러 다루는 다양한 방법 제공

<br />

요약
====

#### `.catch`

##### 모든 `Promise` <sub>(객체)</sub> 내 발생 에러 처리
- `reject()` 호출
- 에러 던지기

##### 에러 처리
- 필요 지점에 정확히 위치
- 방법 알고 있어야 함

##### 핸들러
- 에러 분석
  - 커스텀 에러 클래스 유용
- 알 수 없는 에러 <sub>(프로그래밍 실수 등)</sub>
  - 다시 던지기

##### 에러 발생 시 회복 방법 없는 경우
- `.catch` 미사용 OK

##### 전역 에러 처리 핸들러
- 미처리 에러 추적 후 사용자 · 서버 알림
  - 아무 설명 없는 '그냥 사망' 방지
- ex\) 브라우저 환경
  - `unhandledrejection` <sub>(핸들러)</sub>

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `setTimeout` <sub>(함수)</sub> 내 에러

##### `.catch` 핸들러 트리거 여부 · 이유
```javascript
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("에러");
  }, 1000);
}).catch(alert);
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### `.catch` 핸들러 트리거 X

##### 암시적 `try…catch`
- 함수 코드 감싸고 있음
  - 모든 동기적 에러 처리

##### `setTimeout` <sub>(메서드)</sub> 내 에러 발생 시점
- executor 실행 중 X
- 나중
  - `Promise` <sub>(객체)</sub> : 에러 처리 X
