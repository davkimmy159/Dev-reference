프라미스 API
===========

##### `Promise` 클래스
- 5가지 정적 메서드 구현

### `Promise.all`
- 다수 프라미스 동시 실행 후
  - 모든 프라미스 준비될 때까지 대기

##### 유용한 상황
- 복수 URL
  - 동시 요청 전송
- 복수 다운로드 모두 완료 후
  - 콘텐츠 처리

##### 문법
```javascript
let promise = Promise.all([...promises...]);
```

##### 인수
- 이터러블 <sub>(객체)</sub>
  - 대개 배열
  - 프라미스 요소

##### 반환 값
- 새 프라미스

##### 배열 안 프라미스 모두 처리 시
- 새로운 프라미스 이행
- `result` <sub>(새 배열)</sub>
  - 인수 내 요소 <sub>(프라미스)</sub> 결괏값 모음

##### 예시
- 3초 후 처리
- 반환 값 <sub>(새 프라미스)</sub> 내 `result`
  - `[1, 2, 3]` <sub>(배열)</sub>
```javascript
/*
 모든 프라미스 처리 완료 시
 - [1, 2, 3] 반환
 각 프라미스
 - 배열 구성 요소
 */
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert);
```
##### `result` <sub>(배열)</sub> 요소 순서
- 인수 내 요소 <sub>(프라미스)</sub> 순서 유지
- 1번째 요소 <sub>(프라미스)</sub>
  - 가장 늦게 이행
  - 가장 처음 위치

##### 작업 데이터 담긴 배열
- 프라미스 배열 매핑 후
  - `Promise.all` 배열 감싸기 트릭
- URL 담긴 배열
  - `fetch` <sub>(함수)</sub> 사용해 처리
```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/Violet-Bora-Lee',
  'https://api.github.com/users/jeresig'
];

// url 요소 → 프라미스 요소 매핑
// - fetch (메서드)
let requests = urls.map(url => fetch(url));

Promise.all(requests) // 모든 작업 이행될 때까지 대기
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```

##### 사용자 정보 가져오기
- GitHub 유저명 배열 사용
- `id` 기준 장바구니 목록 불러오기 <sub>(실무)</sub> 유사
```javascript
let names = ['iliakan', 'Violet-Bora-Lee', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {

    // 모든 응답
    // - 성공적으로 이행 완료 상태
    for(let response of responses) {

      // 모든 url 응답 코드
      // - 200
      alert(`${response.url}: ${response.status}`);
    }

    return responses;
  })

  // 응답 메시지 배열
  // - JSON 매핑 후 내용 읽기
  .then(responses => Promise.all(responses.map(r => r.json())))

  // 응답 메시지 (JSON 형태)
  // - 파싱 후 users (배열) 저장
  .then(users => users.forEach(user => alert(user.name)));
```

##### 전달 인수 내 요소 <sub>(프라미스)</sub> 중 하나라도 거부 시
- 반환 값 <sub>(새 프라미스)</sub> 상태
  - 에러 함께 바로 거부
```javascript
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),

  // 에러 발생
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: 에러 발생!
```

##### 2초 후 2번째 프라미스 거부
- `Promise.all` 전체 거부
- `.catch` 핸들러 실행

##### 거부 에러
- == `Promise.all` 전체 결과

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **에러 발생 시 다른 프라미스 무시**

##### 프라미스 하나라도 거부 시
- 즉시 거부
- 완전히 무시
  - 인수 내 다른 요소 <sub>(프라미스)</sub> 결과
  - 이행된 프라미스 결과

##### 다수 호출 생성 <sub>(`fetch` 함수 사용 등)</sub>
- 호출 하나 실패 시
  - 다른 호출들 계속 진행
- 다른 호출들 신경 X
  - 프라미스는 처리됨 <sub>(결과 무시)</sub>

##### 프라미스 : '취소' 개념 X
- `Promise.all`
  - 프라미스 취소 X
- `AbortController` 사용 시
  - 프라미스 취소 가능
  - 프라미스 API X

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **일반 값 : `Promise.all(iterable)` 전달 가능**

##### 인수
- 대개 프라미스 요소 이러터블 <sub>(객체)</sub>
  - 대부분 배열

##### 요소
- 대개 프라미스
- 非프라미스 객체
  - '그대로' 결과 배열에 전달
```javascript
Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2, // 非프라미스 요소
  3  // 非프라미스 요소
]).then(alert); // 1, 2, 3
```
- 이미 결과 알고 있는 값
  - 그냥 그대로 전달

### `Promise.allSettled`

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 추가됨**

- 스펙 추가된 지 얼마 안 된 문법
- 구식 브라우저
  - 폴리필 필요

<br />

##### `Promise.all`
- 프라미스 하나라도 거절 시
  - 전체 거절
- 프라미스 결과 모두 필요할 때 유용
  - '모 아니면 도'
```javascript
Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')

  // render (메서드)
  // - fetch (메서드) 결과 전부 있어야 제대로 동작
]).then(render);
```

##### `Promise.allSettled`
- 모든 프라미스 처리될 때까지 대기
- 반환 배열 요소
```javascript
// 응답 성공
{ status: "fulfilled", value:  result }

// 에러 발생
{ status: "rejected" , reason: error }
```

##### 여러 사람 정보 가져오기 <sub>(`fetch` 함수)</sub>
- 여러 요청 중 하나 실패
  - 다른 요청 결과 여전히 필요
- `Promise.allSettled` 사용
  - 각 프라미스 상태 · 값 · 에러 받음
```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/Violet-Bora-Lee',
  'https://no-such-url'
];

/*
results (인수) 값
[
  { status: 'fulfilled',  value: …응답… },
  { status: 'fulfilled',  value: …응답… },
  { status: 'rejected' , reason: …에러 객체… }
]
 */
Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => {
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

#### 폴리필
- 브라우저 미지원 시 구현
```javascript
if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      status: 'fulfilled',
      value
    }), reason => ({
      status: 'rejected',
      reason
    }))));
  };
}
```
##### `promises.map`
- 입력값 → 프라미스 변화
  - `p => Promise.resolve(p)`
  - 프라미스 아닌 값 받은 경우
- 모든 프라미스
  - `.then` 핸들러 추가

##### `.then` 핸들러 : 결괏값 변환
- `value` <sub>(프라미스 성공 결괏값)</sub>
```javascript
{ status: 'fulfilled', value }
```
- `reason` <sub>(프라미스 실패 결괏값)</sub>
```javascript
{ status: 'rejected' , reason }
```

### `Promise.race`
- `Promise.all` 유사
- 가장 먼저 처리되는 프라미스 결과 · 에러 반환

##### 문법
```javascript
let promise = Promise.race(iterable);
```
```javascript
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

##### `result` 값
- 1번째 프라미스
  - 가장 빨리 처리
- '경주의 승자' 나타난 순간
  - 다른 프라미스 결과 · 에러 무시

### `Promise.resolve` · `Promise.reject`
- 근래 거의 사용 X
  - `async` · `await` 등장

#### `Promise.resolve`

##### `Promise.resolve(value)`
- 이행 상태 프라미스 생성
  - 결괏값 == `value`
```javascript
// 동일 작업 수행
let promise = new Promise(resolve => resolve(value));
```
- 함수가 프라미스 반환 필요 시 사용
  - 호환성 목적

##### `loadCached` <sub>(함수)</sub>
- `URL` <sub>(인수)</sub> 대상 `fetch` <sub>(함수)</sub> 호출
  - 그 결과 기억 <sub>(`cache`)</sub>
- 추후 동일 `URL` 대상 `fetch` <sub>(함수)</sub> 호출 시
  - 캐시 내 호출 결과 즉시 가져옴
- `Promise.resolve`
  - 캐시 된 내용 → 프라미스 변환
    - 항상 프라미스 반환
```javascript
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {

    // 프라미스 반환 보장
    // - 언제나 then (메서드) 사용 가능
    return Promise.resolve(cache.get(url));
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
```

##### `loadCached` <sub>(함수)</sub> 호출 : 프라미스 반환 보장
- `loadCached(url).then( … )`
- `loadCached` <sub>(함수)</sub> 뒤
  - 언제나 `then` <sub>(메서드)</sub> 호출 가능

### `Promise.reject`

##### `Promise.reject(error)`
- 거부 상태 프라미스 생성
  - 결괏값 == `error`
```javascript
// 동일 작업 수행
let promise = new Promise((resolve, reject) => reject(error));
```
- 실무
  - 쓸 일 거의 없음
