`Promise` <sub>(객체)</sub> API
====

##### `Promise` <sub>(클래스)</sub>
- 5가지 정적 메서드 구현

### `Promise.all`

##### 다수 `Promise` <sub>(객체)</sub> 동시 실행 후 전체 처리 대기
```javascript
let promise = Promise.all(promises);
```

##### `promises` <sub>(이터러블 객체)</sub>
- `Promise` <sub>(객체)</sub> 요소 저장
- 보통 배열 전달

##### 반환 값 <sub>(새 `Promise` 객체)</sub>
- `promises` <sub>(인수)</sub> 전부 처리 시 이행
  - 거부 <sub>(개수 무관)</sub> 발생 시 즉시 거부
- `result` <sub>(프로퍼티 · 배열)</sub>
  - 처리 결과 저장 <sub>(`promises` 내 순서 유지)</sub>
  - 거부 시 에러 객체 저장

##### 다수 요청 동시 처리 시 유용
- 다수 url 동시 요청 전송 후
  - 전체 다운로드 완료 시 내용 처리

##### 3초 후 `Promise.all` <sub>(메서드)</sub> 처리
```javascript
let promise = Promise.all([

  // 1 (3초 지연)
  new Promise(resolve => setTimeout(() => resolve(1), 3000)),

  // 2 (2초 지연)
  new Promise(resolve => setTimeout(() => resolve(2), 2000)),

  // 3 (1초 지연)
  new Promise(resolve => setTimeout(() => resolve(3), 1000))

// result (프로퍼티) 내 결괏값 저장 (배열)
// - 인수 (이터러블 객체) 내 요소 순서 유지 (처리 시간 무관)
]).then(alert); // 1,2,3
```

##### 유용한 트릭
1. 데이터 배열 → `Promise` <sub>(객체)</sub> 배열 매핑
2. `Promise.all` <sub>(메서드)</sub> 적용

##### url 배열 → `Promise` <sub>(객체)</sub> 매핑 후 적용
- `fetch` <sub>(메서드)</sub> 사용
```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/Violet-Bora-Lee',
  'https://api.github.com/users/jeresig'
];

// url 요소 → Promise (객체) 요소 매핑
let requests = urls.map(url => fetch(url));

Promise.all(requests) // 모든 작업 이행 대기
  .then(responses => {
    return responses.forEach(r => `${r.url}: ${r.status}`);
  });
```

##### 사용자 정보 요청
- GitHub 유저명 배열 사용
```javascript
let names = ['iliakan', 'Violet-Bora-Lee', 'jeresig'];
let requests = names.map(name => {
  return fetch(`https://api.github.com/users/${name}`);
});

Promise.all(requests)

  // 모든 응답 이행 완료 상태
  .then(responses => {
    for (let r of responses) {
      `${r.url}: ${r.status}`; // …: 200
    }

    return responses;
  })

  // 응답 메시지 → JSON 파싱
  .then(responses => {
    Promise.all(responses.map(r => r.json()));
  })
  .then(users => {
    return users.forEach(user => user.name);
  });
```

##### 인수 <sub>(`Promise` 객체 그룹)</sub> 내 거부 발생
- 즉시 거부 <sub>(에러 객체 저장)</sub>
```javascript
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),

  // 거부
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러")), 2000)),

  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))

// result (프로퍼티) 내 에러 객체 저장
]).catch(alert); // Error: 에러
```

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **에러 시 타 `Promise` <sub>(객체)</sub> 무시**

##### 인수 <sub>(`Promise` 객체 그룹)</sub> 내 거부 발생 시 즉시 거부
- `result` <sub>(프로퍼티)</sub> 내 결괏값 <sub>(배열)</sub> 무시
  - 타 `Promise` <sub>(객체)</sub> 이행 결과 무시

##### 다수 `fetch`<sub>(메서드)</sub> 호출
- 일부 실패 발생 가능
  - 나머지 정상 처리 <sub>(결과 무시)</sub>

##### `Promise` <sub>(객체)</sub> 내 '취소' 개념 無
- `Promise.all` <sub>(메서드)</sub>
  - `Promise` <sub>(객체)</sub> 취소 기능 無
- `AbortController` <sub>(객체)</sub>
  - `Promise` <sub>(객체)</sub> 취소 가능 <sub>(전용 API X)</sub>

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`Promise` <sub>(객체)</sub> 외 전달 가능**

##### 전달 인수 <sub>(이터러블 객체 · 보통 배열)</sub> 내 요소
- 보통 `Promise` <sub>(객체)</sub>
- `Promise` <sub>(객체)</sub> 외 값 가능
  - '그대로' 결과 배열 전달
```javascript
Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2, // 숫자 (그대로 전달)
  3  // 숫자 (그대로 전달)
]).then(alert); // 1, 2, 3
```

##### `Promise` <sub>(객체)</sub> 처리 불필요 값
- 그대로 전달 가능

<br />

### `Promise.allSettled`

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **최근 명세서 추가**

##### 구식 브라우저
- 폴리필 필요

<br />

##### `Promise.all` <sub>(메서드)</sub>
- 인수 <sub>(`Promise` 객체 그룹)</sub> 내 거부 발생 시
  - 즉시 전체 거절
- `Promise` <sub>(객체)</sub> 전체 결과 필수 시 유용
  - '모 아니면 도'
```javascript
Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')

  // render (메서드)
  // - 동작 시 전체 요청 결과 필요
]).then(render);
```

##### `Promise.allSettled` <sub>(메서드)</sub>
- 인수 <sub>(`Promise` 객체 그룹)</sub> 전체 처리 대기
  - 결과 유형 <sub>(이행 · 거부)</sub> 무관
- 결괏값 배열 반환
```javascript
[
  // 이행 (성공)
  {status: "fulfilled", value:  result},

  // 거부 (에러)
  {status: "rejected" , reason: error}
]
```

##### 여러 사람 정보 가져오기 <sub>(`fetch` 메서드)</sub>
- 다수 요청 중 하나 실패
  - 다른 요청 결과 여전히 필요
- `Promise.allSettled` 사용
  - 각 `Promise` <sub>(객체)</sub> 상태 · 값 · 에러 받음
```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/Violet-Bora-Lee',
  'https://no-such-url'
];

/*
results (인수) 값
[
  {status: 'fulfilled',  value: …응답…},
  {status: 'fulfilled',  value: …응답…},
  {status: 'rejected' , reason: …에러 객체…},
]
 */
Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => {
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

#### 폴리필
- 브라우저 미지원 시 구현
```javascript
if (!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      status: 'fulfilled',
      value
    }), reason => ({
      status: 'rejected',
      reason
    }))));
  };
}
```

##### `promises.map`
- 입력값 → `Promise` <sub>(객체)</sub> 변화
  - `p => Promise.resolve(p)`
  - `Promise` <sub>(객체)</sub> 아닌 값 받은 경우
- 모든 `Promise` <sub>(객체)</sub>
  - `.then` 핸들러 추가

##### `.then` 핸들러 : 결괏값 변환
- `value` <sub>(`Promise` 객체 성공 결괏값)</sub>
```javascript
{status: 'fulfilled', value}
```
- `reason` <sub>(`Promise` 객체 실패 결괏값)</sub>
```javascript
{status: 'rejected' , reason}
```

### `Promise.race`

##### 가장 먼저 처리되는 `Promise` <sub>(객체)</sub> 결과 · 에러 반환
- `Promise.all` 유사

##### 문법
```javascript
let promise = Promise.race(iterable);
```
```javascript
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

##### `result` 값
- 1번째 `Promise` <sub>(객체)</sub>
  - 가장 빨리 처리
- '경주의 승자' 나타난 순간
  - 다른 `Promise` <sub>(객체)</sub> 결과 · 에러 무시

### `Promise.[resolve.reject]`

##### 근래 거의 사용 X
- `async` · `await` 등장

#### `Promise.resolve`

##### `Promise.resolve(value)`
- 이행된 `Promise` <sub>(객체)</sub> 생성
  - 결괏값 == `value`
```javascript
// 동일 작업 수행
let promise = new Promise(resolve => resolve(value));
```

##### 함수 : `Promise` <sub>(객체)</sub> 반환 필요 시 사용
- 호환성 목적

##### `loadCached` <sub>(함수)</sub>
- `url` <sub>(인수)</sub> 대상 `fetch` <sub>(메서드)</sub> 호출
  - 그 결과 기억 <sub>(`cache`)</sub>
- 추후 동일 url 대상 `fetch` <sub>(메서드)</sub> 호출 시
  - 캐시 내 호출 결과 즉시 가져옴
- `Promise.resolve`
  - 캐시 된 내용 → `Promise` <sub>(객체)</sub> 변환
    - 항상 `Promise` <sub>(객체)</sub> 반환
```javascript
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {

    // Promise (객체) 반환 보장
    // - 항상 then (메서드) 사용 가능
    return Promise.resolve(cache.get(url));
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
```

##### `loadCached` <sub>(함수)</sub> 호출 : `Promise` <sub>(객체)</sub> 반환 보장
- `loadCached(url).then(…)`
- `loadCached` <sub>(함수)</sub> 뒤
  - 항상 `then` <sub>(메서드)</sub> 호출 가능

### `Promise.reject`

##### `Promise.reject(error)`
- 거부된 `Promise` <sub>(객체)</sub> 생성
  - 결괏값 == `error`
```javascript
// 동일 작업 수행
let promise = new Promise((resolve, reject) => reject(error));
```

##### 실무
- 쓸 일 거의 없음

<br />

요약
====

#### `Promise` <sub>(클래스)</sub> 정적 메서드 <sub>(5가지)</sub>

##### 1. `Promise.all(promises)` <sub>(최다 사용)</sub>
- 모든 `Promise` <sub>(객체)</sub> 이행 대기 후
  - 결괏값 배열 반환
- 하나라도 실패 시 거부
  - 나머지 `Promise` <sub>(객체)</sub> 결과 무시

##### 2. `Promise.allSettled(promises)` <sub>(최근 추가)</sub>
- 모든 `Promise` <sub>(객체)</sub> 처리 대기 후
  - 결과 <sub>(객체)</sub> 배열 반환
- 결과 <sub>(객체)</sub> 프로퍼티
  - `status`
    - `"fulfilled"`
    - `"rejected"`
  - `value` <sub>(성공)</sub> · `reason` <sub>(실패)</sub>

##### 3. `Promise.race(promises)`
- 가장 빠른 처리 결과 · 에러 담은 `Promise` <sub>(객체)</sub> 반환

##### 4. `Promise.resolve(value)`
- 이행된 `Promise` <sub>(객체)</sub> 생성
  - 전달 값 <sub>(인수)</sub> 사용

##### 5. `Promise.reject(error)`
- 거부된 `Promise` <sub>(객체)</sub> 생성
  - 전달 에러 <sub>(인수)</sub> 사용
