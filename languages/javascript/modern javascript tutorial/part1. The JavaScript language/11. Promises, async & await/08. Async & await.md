`async` · `await`
=============

- `async` · `await`
  - 프라미스 좀 더 편하게 사용

### `async` 함수
- `async` <sub>(키워드)</sub>
  - `function` 앞 위치
```javascript
async function f() {
  return 1;
}
```
- 항상 프라미스 반환
- 프라미스 아닌 값 반환 시
  - 이행 상태 프라미스로 감싸 반환
```javascript
async function f() {
  return 1;
}

f().then(alert); // 1
```
- 명시적으로 프라미스 반환 가능
  - 결과 동일
```javascript
async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
```

### `await`

##### 문법
```javascript
// async 함수 안에서만 동작
let value = await promise;
```

##### JS : `await` <sub>(키워드)</sub> 도달 시
1. 프라미스 처리 대기
2. 프라미스 처리 완료 시
    - 결과 반환 · 실행 재개
```javascript
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("완료!"), 1000)
  });

  // 1. 프라미스 이행 완료 때까지 대기
  // 2. 프라미스 처리 후 실행 재개
  //    - 프라미스 result 값 → result (변수) 할당
  let result = await promise;

  alert(result);
}

// 1초 후
// - "완료!" 출력
f();
```

##### 프라미스 처리 대기 중
- 엔진 : 다른 일 수행 <sub>(CPU 리소스 낭비 X)</sub>
  - 다른 스크립트 실행
  - 이벤트 처리
  - 기타 등등

##### `promise.then` 대비
- 가독성 ↑
- 사용 난이도 ↓

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **일반 함수 : `await` X**

##### 일반 함수
- `await` 사용 시
  - 문법 에러 발생
```javascript
function f() {
  let promise = Promise.resolve(1);
  let result = await promise; // Syntax error
}
```

<br />

##### `showAvatar()` <sub>(함수)</sub> 예시 <sub>(프라미스 체이닝 챕터)</sub>
- `async` · `await` 사용해 다시 작성
  1. `.then` 호출 → `await`
  2. `function` 앞 : `async`
```javascript
async function showAvatar() {

  // JSON 읽기
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // github 사용자 정보 읽기
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // 아바타 보여주기
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // 3초 대기
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`await` : 최상위 레벨 코드 X**

```javascript
// 최상위 레벨 코드에서 사용 시
// - 문법 에러 발생
let response = await fetch('/article/promise-chaining/user.json');
let user = await response.json();
```

##### 트릭
- 익명 `async` 함수 <sub>(코드 감싸기)</sub>
```javascript
(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  …
})();
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`await` : `thenable` <sub>(객체)</sub> 사용 가능**

##### 서드파티 객체
- 프라미스 미제공
  - 프라미스 호환 객체 제공
- `.then` <sub>(메서드)</sub> 지원
  - `await` 함께 사용 가능
```javascript
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve);

    // 1초 후 이행
    // - result 값 : this.num * 2
    setTimeout(() => resolve(this.num * 2), 1000);
  }
};

async function f() {
  // 1초 후
  // - result (변수) 값 : 2
  let result = await new Thenable(1);
  alert(result);
}

f();
```

##### `await` : 객체 <sub>(`.then` 구현 · 프라미스 X)</sub> 전달 시
1. `.then` <sub>(메서드)</sub> 호출
    - 인수 제공 <sub>(내장 함수)</sub>
      - `resolve`
      - `reject`
    - `Promise executor` 작업 동일
2. 인수 <sub>(`resolve` · `reject`)</sub> 중 하나 호출 대기
    - 호출 결과 함께 다음 작업 진행

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`async` 클래스 메서드**

##### `async` 클래스 메서드 선언
- `async` <sub>(키워드)</sub>
  - 메서드명 앞 위치
```javascript
class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1
```
- `async` 함수 · 메서드 <sub>(동일)</sub>
  - 프라미스 반환
  - `await` 사용 가능

<br />

### 에러 핸들링

#### 프라미스 <sub>(`await promise`)</sub>

##### 정상 이행 시
- `result` 반환
  - 프라미스 객체 내 저장 값

##### 거부 시
- 에러 던져짐
  - `throw` <sub>(문)</sub> 유사
```javascript
async function f() {
  await Promise.reject(new Error("에러 발생!"));
}

// 동일 코드
async function f() {
  throw new Error("에러 발생!");
}
```
- 프라미스 거부 전
  - 약간의 시간 지체 발생 경우 有
- `await`
  - 에러 던지기 전 지연 발생

##### `await` 가 던진 에러
- 에러 잡기 가능 <sub>(`try…catch`)</sub>
```javascript
async function f() {

  try {
    let response = await fetch('http://유효하지-않은-주소');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();
```

##### 에러 발생 시
- 제어 흐름 → `catch` <sub>(블록)</sub>

##### 코드 여러 줄 감싸기 <sub>(`try`)</sub>
```javascript
async function f() {

  try {
    let response = await fetch('http://유효하지-않은-주소');
    let user = await response.json();
  } catch(err) {
    // fetch와 response.json에서 발행한 에러 모두를 여기서 잡습니다.
    alert(err);
  }
}

f();
```

##### `try…catch` 부재 시
- `.catch` <sub>(핸들러)</sub> 추가
  - 거부 프라미스 처리
```javascript
async function f() {
  let response = await fetch('http://유효하지-않은-주소');
}

// f()
// - 거부 상태 프라미스
f().catch(alert); // TypeError: failed to fetch // (*)
```

##### `.catch` <sub>(핸들러)</sub> 미추가 시
- 미처리 프라미스 에러 발생
- `unhandledrejection` 사용
  - 전역 이벤트 핸들러

<br />

## 요약
`function` 앞에 `async` 키워드를 추가하면 두 가지 효과가 있습니다.
1. 함수는 언제나 프라미스를 반환합니다.
2. 함수 안에서 `await`를 사용할 수 있습니다.

프라미스 앞에 `await` 키워드를 붙이면 자바스크립트는 프라미스가 처리될 때까지 대기합니다. 처리가 완료되면 조건에 따라 아래와 같은 동작이 이어집니다.
1. 에러 발생 – 예외가 생성됨(에러가 발생한 장소에서 `throw error`를 호출한 것과 동일함)
2. 에러 미발생 – 프라미스 객체의 `result` 값을 반환

`async`/`await`를 함께 사용하면 읽고, 쓰기 쉬운 비동기 코드를 작성할 수 있습니다.

`async`/`await`를 사용하면 `promise.then/catch`가 거의 필요 없습니다. 하지만 가끔 가장 바깥 스코프에서 비동기 처리가 필요할 때같이 `promise.then/catch`를 써야만 하는 경우가 생기기 때문에 `async/await`가 프라미스를 기반으로 한다는 사실을 알고 계셔야 합니다. 여러 작업이 있고, 이 작업들이 모두 완료될 때까지 기다리려면 `Promise.all`을 활용할 수 있다는 점도 알고 계시기 바랍니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `async`와 `await`를 사용하여 코드 변경하기
프라미스 체이닝 챕터의 예시 중 하나를 `.then`/`catch` 대신 `async`/`await를` 사용해 다시 작성해봅시다.
```javascript
function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new Error(response.status);
      }
    })
}

loadJson('no-such-user.json')
  .catch(alert); // Error: 404
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

자세한 설명은 아래에서 확인할 수 있습니다.
```javascript
// 함수 loadJson은 async 함수가 됩니다.
async function loadJson(url) {

  // 함수 안의 .then을 전부 await로 바꿉니다.
  let response = await fetch(url);

  if (response.status == 200) {

    /*
    위 답안처럼 await를 사용해도 되지만, 아래처럼 return response.json()를 사용해도 됩니다.
    if (response.status == 200) {
      return response.json(); // (3)
    }
    대신, 이렇게 작성하면 프라미스가 이행되는걸 await를 사용해 바깥 코드에서 기다려야 합니다. 위 예시는 해당 사항이 없지만 말이죠.
     */
    let json = await response.json();
    return json;
  }

  throw new Error(response.status);
}

loadJson('no-such-user.json')

  // loadJson에서 던져진 에러는 .catch에서 처리됩니다. loadJson을 호출하는 코드는 async 함수 내부가 아니기 때문에 await loadJson(…)을 사용할 수 없습니다.
  .catch(alert); // Error: 404
```

<hr />

### `async`와 `await`를 사용해서 '다시 던지기' 예시 재작성하기
프라미스 체이닝 챕터에서 다뤘던 ‘다시 던지기(rethrow)’ 관련 예시를 기억하실 겁니다. 이 예시를 `.then`/`catch` 대신 `async`/`await를` 사용해 다시 작성해 봅시다.

그리고 `demoGithubUser` 안의 반복(recursion)은 반복문(loop)을 사용해 작성하도록 합시다. `async`/`await`를 사용하면 쉽게 작성할 수 있습니다.
```javascript
class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    })
}

// 유효한 사용자를 찾을 때까지 반복해서 username을 물어봄
function demoGithubUser() {
  let name = prompt("GitHub username을 입력하세요.", "iliakan");

  return loadJson(`https://api.github.com/users/${name}`)
    .then(user => {
      alert(`이름: ${user.name}.`);
      return user;
    })
    .catch(err => {
      if (err instanceof HttpError && err.response.status == 404) {
        alert("일치하는 사용자가 없습니다. 다시 입력해 주세요.");
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}

demoGithubUser();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

속임수랄게 없는 문제입니다. `demoGithubUser`안의 `.catch`를 `try...catch`로 교체하고 필요한 곳에 `async`/`await를` 추가하면 됩니다.
```javascript
class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

async function loadJson(url) {
  let response = await fetch(url);
  if (response.status == 200) {
    return response.json();
  } else {
    throw new HttpError(response);
  }
}

// 유효한 사용자를 찾을 때까지 반복해서 username을 물어봄
async function demoGithubUser() {

  let user;
  while(true) {
    let name = prompt("GitHub username을 입력하세요.", "iliakan");

    try {
      user = await loadJson(`https://api.github.com/users/${name}`);
      break; // 에러가 없으므로 반복문을 빠져나옵니다.
    } catch(err) {
      if (err instanceof HttpError && err.response.status == 404) {
        // 얼럿 창이 뜬 이후에 반복문은 계속 돕니다.
        alert("일치하는 사용자가 없습니다. 다시 입력해 주세요.");
      } else {
        // 알 수 없는 에러는 다시 던져집니다.
        throw err;
      }
    }
  }


  alert(`이름: ${user.name}.`);
  return user;
}

demoGithubUser();
```

<hr />

### `async`가 아닌 함수에서 `async` 함수 호출하기
‘일반’ 함수가 하나 있는데, 여기서 `async` 함수를 어떻게 하면 호출하고, 그 결과를 사용할 수 있을까요?
```javascript
async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));

  return 10;
}

function f() {
  // ...코드...
  // async wait()를 호출하고 그 결과인 10을 얻을 때까지 기다리려면 어떻게 해야 할까요?
  // f는 일반 함수이기 때문에 여기선 'await'를 사용할 수 없다는 점에 주의하세요!
}
```

참고: 문제 자체는 아주 간단하지만, `async`와 `await`를 학습한 지 얼마 안 된 개발자들이 쉽게 접하는 상황입니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

`async`/`await가` 내부에서 어떻게 동작하는지 알아야 문제를 풀 수 있습니다.

`async` 함수를 호출하면 프라미스가 반환되므로, `.then`을 붙이면 됩니다.
```javascript
async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));

  return 10;
}

function f() {
  // shows 10 after 1 second
  wait().then(result => alert(result));
}

f();
```
