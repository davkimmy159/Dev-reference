마이크로태스크
=============

##### 프라미스 핸들러 <sub>(`.then` · `.catch` · `.finally`)</sub>
- 항상 비동기적 실행

##### 프라미스 핸들러 아래 코드
- 핸들러보다 먼저 실행
  - 프라미스 즉시 이행해도 동일
```javascript
let promise = Promise.resolve();

promise.then(() => alert("프라미스 성공!"));

alert("코드 종료");

// 메시지 출력 순서
// 1. "코드 종료"
// 2. "프라미스 성공!"
```

### 마이크로태스크 큐
- 비동기 작업 처리
  - 적절한 관리 필요

##### 용어
- ECMA
  - `PromiseJobs` <sub>(내부 큐)</sub>
- V8 엔진
  - 마이크로태스크 큐 <sub>(선호 용어)</sub>

##### 명세서 설명
- 먼저 들어온 작업 : 먼저 실행
  - first-in-first-out <sub>(FIFO)</sub>
- 실행할 것 아무것도 남아있지 않을 때
  - 마이크로태스크 큐 내 작업 실행 시작

#### 요약

##### 어떤 프라미스 준비 완료 시
- 해당 프라미스 핸들러
  - 큐에 들어감
  - 실행 X

##### 현재 코드에서 자유로운 상태 되었을 때
- 엔진 : 큐에서 작업 꺼내 실행
- 위 예시
  - `'코드 종료'` 먼저 출력되는 이유

![promiseQueue](../../images/01/11/07/promiseQueue.svg)

##### 프라미스 핸들러
- 항상 내부 큐 통과

##### 여러 개의 핸들러 체인
- 각 핸들러
  - 비동기적 실행

##### 큐 내 핸들러들 실행 시점
1. 현재 코드 완료되고
2. 큐 내 적체된 이전 핸들러들 실행 완료 시

##### 위 예시 : '프라미스 성공!' → '코드 종료' <sub>(순서 바꾸기)</sub>
- `then` <sub>(메서드)</sub> 사용
  - `'코드 종료'` → 큐에 넣기
```javascript
Promise.resolve()
  .then(() => alert("프라미스 성공!"))
  .then(() => alert("코드 종료"));
```

### 처리되지 못한 거부

##### `unhandledrejection` <sub>(이벤트)</sub>
- 미처리 거부 프라미스
  - 전역 에러

##### '처리되지 못한 거부'
- 마이크로태스크 큐 끝
  - 프라미스 에러 미처리 시 발생

##### `.catch` 핸들러 추가
- 에러 처리
```javascript
let promise = Promise.reject(new Error("프라미스 실패!"));
promise.catch(err => alert('잡았다!'));

// 에러 처리됨
// - unhandledrejection (이벤트) 핸들러 실행 X
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

##### `.catch` 핸들러 미추가
- 마이크로태스크 큐 내 빈 이후
  - `unhandledrejection` <sub>(이벤트)</sub> 트리거
```javascript
let promise = Promise.reject(new Error("프라미스 실패!"));

// 에러 미처리됨
// - Error: "프라미스 실패!"
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

##### 에러 지연 처리 <sub>(`setTimeout` 이용)</sub>
```javascript
let promise = Promise.reject(new Error("프라미스 실패!"));
setTimeout(() => promise.catch(err => alert('잡았다!')), 1000);

// Error: "프라미스 실패!"
window.addEventListener('unhandledrejection', event => alert(event.reason));
```

##### 실행 순서
1. `"프라미스 실패!"`
    - `unhandledrejection` 핸들러
2. `"잡았다!"`
    - `.catch` 핸들러 <sub>(`setTimeout` 안)</sub>

##### `unhandledrejection` <sub>(이벤트)</sub> 생성 시점
- 마이크로태스크 큐 내 작업 모두 완료 후

##### 엔진 : 프라미스들 검사
- 큐 내 핸들러 중 하나라도 '거부' 상태 시
  - `unhandledrejection` <sub>(핸들러)</sub> 트리거

##### 위 예시 `.catch` 핸들러 <sub>(`setTimeout` 사용해 추가)</sub>
- 결국 트리거 됨
  - 다만 `unhandledrejection` 발생 이후

### 에러 지연 처리 추가 설명

##### microtask 큐 작업
- 핸들러
  - `.then`
  - `.catch`
  - `.finally`
- 기타 등등

##### macrotask 큐 작업
- `setTimeout`
- `setInterval`
- I/O operations
- UI rendering
- 기타 등등

##### 진행 순서
1. microtask 큐 내 작업
2. macrotask 큐 내 작업

##### 예시 <sub>(에러 지연 처리)</sub> 진행 순서
1. microtask 큐 내 작업 진행
2. macrotask 큐 내
    - 에러 처리 작업 진행
3. 미처리 거부 상태 프라미스 발견
    - `unhandledrejection` <sub>(이벤트)</sub> 발생

![Microtask_Macrotask](../../images/01/11/07/Microtask_Macrotask.gif)

##### 부가 설명
1. 프라미스 즉시 거부 처리
2. `.catch` 핸들러 호출 <sub>(`setTimeout` 안)</sub>
3. 스케줄링 '기록'
    - 즉시 실행 X
4. 에러 발생
    - `unhandledrejection` <sub>(이벤트)</sub> 발생
5. `window` <sub>(전역객체)</sub>
    - 이벤트 발생 감지
6. `.catch` 핸들러 스캐쥴링 실행
    - 에러 처리

<br />

## 요약
모든 프라미스 동작은 '마이크로태스크 큐'(ES8 용어)라 불리는 내부 '프라미스 잡(promise job)' 큐에 들어가서 처리되기 때문에 프라미스 핸들링은 항상 비동기로 처리됩니다.

따라서 `.then`/`.catch`/`.finally` 핸들러는 항상 현재 코드가 종료되고 난 후에 호출됩니다.

어떤 코드 조각을 `.then`/`.catch`/`.finally가` 호출된 이후에 실행하고 싶다면 `.then`을 체인에 추가하고 이 안에 코드 조각을 넣으면 됩니다.

브라우저와 Node.js를 포함한 대부분의 자바스크립트 엔진에선 마이크로태스크가 '이벤트 루프(event loop)'와 '매크로태스크(macrotask)'와 깊은 연관 관계를 맺습니다. 이 둘은 프라미스와는 직접적인 연관성이 없기 때문에, [이벤트 루프와 매크로태스크, 마이크로태스크](../../part2.%20Browser,%20Document,%20Events,%20Interfaces/06.%20Miscellaneous/03.%20Event%20loop%20-%20microtasks%20and%20macrotasks.md)에서 따로 다루도록 하겠습니다.
