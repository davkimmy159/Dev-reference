`Promise` <sub>(객체)</sub> 체이닝
====

##### 형태
1. 1초 후 최초 `Promise` <sub>(객체)</sub> 이행
2. 1번째 `then` 핸들러 호출
3. ② 반환 값 → 다음 `then` 핸들러 전달
4. 과정 반복
```javascript
new Promise(function(resolve, reject) {

  // ① 최초 이행 (1초 지연)
  setTimeout(() => resolve(1), 1000);

  // ② 1번째 핸들러 실행 (1초 후)
}).then(function(result) {
  result; // 1
  return result * 2;

  // ③ 2번째 핸들러 실행
}).then(function(result) {
  result; // 2
  return result * 2;

  // ④ 3번째 핸들러 실행
}).then(function(result) {
  result; // 4
  return result * 2;
});
```

##### `then` 핸들러 인수 <sub>(이전 동작 처리 결과)</sub>
- 핸들러 체인 따라 전달

![promise-then-chain](../../images/01/11/03/promise-then-chain.svg)

##### `then(…)` <sub>(메서드)</sub>
- `Promise` <sub>(객체)</sub> 반환
  - 메서드 연속 호출 <sub>(체이닝)</sub> 가능

##### `then` 핸들러 반환 값
- `result` <sub>(내부 프로퍼티)</sub> 할당
  - 다음 핸들러 이용 <sub>(인수 전달)</sub>

##### 단일 `Promise` <sub>(객체)</sub> 대상 다수 `then` <sub>(메서드)</sub> 호출
- 독립 핸들러 등록 <sub>(체이닝 X)</sub>
  - 독립적 처리
  - 순차적 처리 X <sub>(처리 결과 전달 X)</sub>
- 드물게 사용
  - 보통 체이닝 사용
```javascript
let promise = new Promise(function(resolve, reject) {

  // 최초 이행
  setTimeout(() => resolve(1), 1000);
});

// 독립 (1번째) 핸들러 (개별 실행 · 1초 후)
promise.then(function(result) {
  result;  // 1 (최초 처리 결과)
  return result * 2;
})/* .then(…) */; // ← 체이닝

// 독립 (1번째) 핸들러 (개별 실행 · 1초 후)
promise.then(function(result) {
  result;  // 1 (최초 처리 결과)
  return result * 2;
});

// 독립 (1번째) 핸들러 (개별 실행 · 1초 후)
promise.then(function(result) {
  result;  // 1 (최초 처리 결과)
  return result * 2;
});
```

![promise-then-many](../../images/01/11/03/promise-then-many.svg)

### `Promise` <sub>(객체)</sub> 반환

##### `then` 핸들러
- `Promise` <sub>(객체)</sub> 생성 · 반환 가능
  - 처리 결과 → 다음 핸들러 전달 <sub>(인수)</sub>
- 다음 핸들러
  - 이전 `Promise` <sub>(객체)</sub> 처리 대기
```javascript
new Promise(function(resolve, reject) {

  // 최초 이행 (1초 지연)
  setTimeout(() => resolve(1), 1000);

// 1번째 then 핸들러
// - 최초 이행 시 실행 (1초 후)
}).then(function(result) {
  result; // 1 (최초 처리 결과)

  // 새 Promise (객체) 생성 후 반환 (1초 지연)
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

// 2번째 then 핸들러
// - 새 Promise (객체) 이행 시 실행 (1초 후)
}).then(function(result) {
  result; // 2 (새 Promise 객체 처리 결과)

  // 새 Promise (객체) 생성 후 반환 (1초 지연)
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

// 3번째 then 핸들러
// - 새 Promise (객체) 이행 시 실행 (1초 후)
}).then(function(result) {
  result; // 4 (새 Promise 객체 처리 결과)
});
```

### `loadScript` <sub>(함수)</sub> 개선

##### 체이닝 적용
1. `loadScript` <sub>(함수)</sub> 호출
   - `Promise` <sub>(객체)</sub> 반환
2. 다음 `then` 핸들러
   - 새 `Promise` <sub>(객체)</sub> 이행 시 실행
3. 이후 초기화 진행
   - 다음 스크립트 로딩 준비
```javascript
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload  = () => resolve(script);
    script.onerror = () => reject(new Error(`${src} 로딩 중 에러`));

    document.head.append(script);
  });
}

// 최초 이행
loadScript("/article/promise-chaining/one.js")

  // 1번째 then 핸들러
  // - 최초 이행 시 실행
  .then(function(script) {

    // loadScript (함수) 호출 반환
    // - 새 Promise (객체) 생성 후 반환
    return loadScript("/article/promise-chaining/two.js");
  })

  // 2번째 then 핸들러
  // - 새 Promise (객체) 이행 시 실행
  .then(function(script) {

    // loadScript (함수) 호출 반환
    // - 새 Promise (객체) 생성 후 반환
    return loadScript("/article/promise-chaining/three.js");
  })

  // 3번째 then 핸들러
  // - 새 Promise (객체) 이행 시 실행
  .then(function(script) {

    // 모든 스크립트 순차 로드 완료
    // - 스크립트 내 함수 호출
    one();
    two();
    three();
  });
```
- 화살표 함수 사용 <sub>(간결성 ↑)</sub>
```javascript
function loadScript(src) {…}

loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    one();
    two();
    three();
  });
```

##### 코드 증가 뱡향 <sub>(콜백 vs `Promise` 객체)</sub>

||방향|
|:---:|:---:|
|콜백 <sub>('멸망의 피라미드')</sub>|→|
|`Promise` <sub>(객체)</sub>|↓|

##### `then` <sub>(메서드)</sub> 즉시 이어 호출 가능 <sub>(핸들러 내 호출 X)</sub>
- 동일 체이닝 동작 수행
- 우측 <sub>(→)</sub> 코드 증가
  - 콜백 동일 문제 발생 <sub>('멸망의 피라미드')</sub>
- 중첩 함수
  - 외부 스코프 접근 가능 <sub>(가끔 유용)</sub>
- 가장 깊은 중첩 함수
  - 모든 핸들러 인수 접근 가능
    - `script1`
    - `script2`
    - `script3`
```javascript
loadScript("/article/promise-chaining/one.js").then(script1 => {
  loadScript("/article/promise-chaining/two.js").then(script2 => {
    loadScript("/article/promise-chaining/three.js").then(script3 => {
      one();
      two();
      three();
    });
  });
});
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`thenable` <sub>(객채)</sub>**

##### 핸들러 반환 가능 값
- `Promise` <sub>(객체)</sub>
- `thenable` <sub>(객체)</sub>
  - `then` <sub>(메서드)</sub> 구현
  - `Promise` <sub>(객체)</sub> 동일 방식 처리

##### 서드파티 라이브러리 내 자체 객체 <sub>(`thenable`)</sub>
- `then` <sub>(메서드)</sub> 구현
  - `Promise` <sub>(내장 객체)</sub> 호환 <sub>(상속 불필요)</sub>
- 자체 확장 <sub>(커스텀)</sub> 메서드 구현
```javascript
class Thenable {
  constructor(num) {
    this.num = num;
  }

  then(resolve, reject) {
    resolve; // function() { …내장 코드… }

    // 이행 (1초 지연)
    // - this.num * 2 (처리 결과) 전달
    setTimeout(() => resolve(this.num * 2), 1000);
  }
}

new Promise(resolve => resolve(1))

  // 1번째 then 핸들러
  // - 최초 이행 시 실행
  .then(result => {

    /* then 핸들러 반환 객체 확인 (JS)
     then (메서드) 구현 시 호출
     - resolve · reject (내장 인수) 전달
       - 둘 중 하나 호출 대기
     - 호출 결과 → 다음 핸들러 전달
     */
    return new Thenable(result);
  })

  // 2번째 then 핸들러
  // - Thenable (객체) 이행 시 실행
  .then(alert); // 2 (1초 후)
```

<br />

### `fetch` <sub>(메서드)</sub> · 체이닝 함께 응용하기

##### 프론트 단
- 네트워크 요청 시
  - `Promise` <sub>(객체)</sub> 자주 사용

##### `fetch` <sub>(메서드)</sub>
- 원격 서버에서 정보 가져옴
- 다양한 선택 매개변수 보유
```javascript
let promise = fetch(url);
```

##### 1. `url` 에 네트워크 요청 보내기
- `Promise` <sub>(객체)</sub> 반환

##### 2. 원격 서버
- 응답 <sub>(헤더 포함)</sub> 보냄

##### 3. `Promise` <sub>(객체)</sub>
- `response` <sub>(객체)</sub> 함께 이행
- `response` <sub>(객체)</sub> 전체 완전 다운로드 전
  - 이행 상태 되어버림

##### 4. 응답 완전히 종료
- 응답 전체 읽기
  - `response.text()` 호출

##### `response.text()`
- 텍스트 전체 <sub>(from 원격 서버)</sub> 다운로드 후
  - 이행된 `Promise` <sub>(객체)</sub> 반환
    - `result` 값 : 텍스트 전체

##### `user.json` <sub>(정보)</sub> 요청 전송
- 서버에서 해당 텍스트 불러옴
```javascript
fetch('/article/promise-chaining/user.json')

  // 원격 서버 응답 시
  // - .then 핸들러 함수형 인수 실행
  .then(function(response) {

    // response.text() 호출
    // - 응답 텍스트 전체 다운로드 시
    //   - 응답 텍스트 → 새 이행된 Promise (객체) 생성 · 반환
    return response.text();
  })
  .then(function(text) {

    // {"name": "Violet-Bora-Lee", "isAdmin": true}
    // - 원격에서 받아온 파일 내용
    alert(text);
  });
```

##### `response.json()`
- 원격에서 받아온 데이터 읽은 후 `JSON` 파싱
```javascript
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())

  // Violet-Bora-Lee, 이름만 성공적으로 가져옴
  .then(user => alert(user.name));
```

##### 불러온 사용자 정보 이용해 추가 동작 실행
1. GitHub 요청 전송
2. 사용자 프로필 불러오기
3. 아바타 출력
```javascript
// user.json (사용자 정보) 요청 전송
fetch('/article/promise-chaining/user.json')

  // 응답 내용 불러오기
  // - JSON 형태
  .then(response => response.json())

  // GitHub 요청 전송
  .then(user => fetch(`https://api.github.com/users/${user.name}`))

  // 응답 내용 불러오기
  // - JSON 형태
  .then(response => response.json())

  // 3초 간 아바타 이미지 표시
  // - githubUser.avatar_url
  .then(githubUser => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    // 아바타 3초 표시
    setTimeout(() => img.remove(), 3000);
  });
```

##### 아바타 3초 표시 후 사라진 다음 무언가 하고 싶을 때
- ex\) 사용자 정보 수정 폼 표시 등
- 체인 확장
  - 아바타 사라질 때 이행된 `Promise` <sub>(객체)</sub> 반환
```javascript
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())

  /*
   .then 핸들러
   - new Promise (생성자) 반환
     - setTimeout (메서드) 내 resolve(githubUser) 호출 시
       - 처리 상태 변화
   다음 .then 핸들러
   - 이전 결과 대기
   */
   // new Promise (생성자) 반환
  .then(githubUser => new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();

      // resolve (내장 콜백 함수) 호출 시
      // - 다음 .then 핸들러 진행
      resolve(githubUser);
    }, 3000);
  }))

  // 3초 후 동작
  .then(githubUser => alert(`${githubUser.name}의 이미지를 성공적으로 출력하였습니다.`));
```

##### 비동기 동작 : 항상 `Promise` <sub>(객체)</sub> 반환 구현
- 추후 체인 확장 필요 시
  - 손쉽게 체인 확장

##### 재사용 가능한 함수 단위 분리
```javascript
function loadJson(url) {
  return fetch(url)
    .then(response => response.json());
}

function loadGithubUser(name) {
  return fetch(`https://api.github.com/users/${name}`)
    .then(response => response.json());
}

function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}

// 함수 이용
loadJson('/article/promise-chaining/user.json')
  .then(user => loadGithubUser(user.name))
  .then(showAvatar)
  .then(githubUser => alert(`Finished showing ${githubUser.name}`))
  …;
```

<br />

요약
====

##### 핸들러 <sub>(`then` · `.catch` · `.finally`)</sub> : `Promise` <sub>(객체)</sub> 반환 시
- 나머지 체인
  - `Promise` <sub>(객체)</sub> 처리 대기
- 처리 완료 시
  - `result` <sub>(값 · 에러)</sub> 다음 체인 전달

![promise-handler-variants](../../images/01/11/03/promise-handler-variants.svg)

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### `then` vs `catch`

##### 두 코드 동일 동작 여부
```javascript
promise.then(f1).catch(f2);
promise.then(f1, f2);
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

#### 동작 상이

##### 1번째 코드
- `f1` 내 에러 발생 시
  - `.catch` 에러 처리
```javascript
promise
  .then(f1)
  .catch(f2);
```

##### 2번째 코드
- `f1` 내 발생 에러 처리 X
```javascript
promise
  .then(f1, f2);
```

##### `then` 내 결과 · 에러
- 다음 `then` · `.catch` 전달

##### `then` 핸들러 내 에러 발생 시
- 체인 아래로 전달

##### 2번째 코드 `f1` 아래
- 이어지는 체인 X
