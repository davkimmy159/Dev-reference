프로토타입 상속
==============

- 기존 기능 가져와 확장
  - JS 언어 고유 기능

### `[[Prototype]]` <sub>(숨김 프로퍼티)</sub>
- 명세서 명명
- JS 객체 보유
- 값
  - 객체 참조
  - `null`
- 타 객체 참조 시 참조 대상
  - 프로토타입 <sub>(prototype)</sub>

![object-prototype-empty](../../images/01/08/01/object-prototype-empty.svg)

#### 프로토타입 동작 방식
- '신비스러운' 면 존재

##### 객체 프로퍼티 접근
- 해당 프로퍼티 부재 시
  - 자동으로 프로토타입에서 프로퍼티 찾음
  - 프로토타입 상속

##### `[[Prototype]]` <sub>(프로퍼티)</sub>
- 내부 · 숨김 프로퍼티
- 다양한 방법 사용해 값 설정 가능
  - ex&#41; `__proto__`
```javascript
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`__proto__`**

##### `[[Prototype]]` 전용 접근자 프로퍼티
- `getter` <sub>(획득자)</sub>
- `setter` <sub>(설정자)</sub>

##### 여전히 사용 가능
- 하위 호환성

##### 비교적 근래 작성 스크립트
- `__proto__` 대신 함수 사용 가능
- `Object.getPrototypeOf`
  - 획득 <sub>(get)</sub>
- `Object.setPrototypeOf`
  - 설정 <sub>(set)</sub>

##### 명세서 규정
  - 브라우저 환경에서만 지원

##### 실상
  - 모든 호스트 환경 <sub>(server-side 등)</sub> 지원

<br />
<br />

```javascript
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

// rabbit (자식 객체) 내 프로퍼티 부재 시
// - 자동으로 animal (부모 객체) 에서 프로퍼티 얻음
rabbit.__proto__ = animal;

alert( rabbit.eats );  // true,
                       // [[Prototype]] → animal (부모 객체) 참조
                       // - eats (프로퍼티) 존재
alert( rabbit.jumps ); // true
```

![proto-animal-rabbit](../../images/01/08/01/proto-animal-rabbit.svg)

- `rabbit` 프로토타입 : `animal`
  - `rabbit` 은 `animal` 을 상속받음
- 프로토타입에서 상속받은 프로퍼티
  - 상속 프로퍼티
```javascript
let animal = {
  eats: true,
  walk() {
    alert("동물이 걷습니다.");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

rabbit.walk(); // 동물이 걷습니다.
```

![proto-animal-rabbit-walk](../../images/01/08/01/proto-animal-rabbit-walk.svg)

```javascript
let animal = {
  eats: true,
  walk() {
    alert("동물이 걷습니다.");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk (메서드)
// - 프로토타입 체인 통해 상속받음
longEar.walk();       // 동물이 걷습니다.
                      // animal (조부모 객체) 에서 상속받음
alert(longEar.jumps); // true,
                      // rabbit (부모 객체) 에서 상속받음
```

![proto-animal-rabbit-chain](../../images/01/08/01/proto-animal-rabbit-chain.svg)

#### 프로토타입 체이닝 제약사항

##### 순환 참조 X
- `__proto__` 이용해 닫힌 형태로 다른 객체 참조
  - 에러 발생

##### `__proto__` 값
- 객체 · `null` 만 가능
- 다른 자료형 무시

##### 객체 내 하나의 `[[Prototype]]` 만 존재
- 객체 2개 상속 X

### 프로토타입 : 읽기 전용
- 프로퍼티 읽을 때만 사용
- 프로퍼티 추가 · 수정 · 삭제
  - 객체에 직접 실행
  - 프로토타입에 실행 X
```javascript
let animal = {
  eats: true,
  walk() {
    // rabbit (자식 객체) : 메서드 사용 X
  }
};

let rabbit = {
  __proto__: animal
};

// rabbit (자식 객체)
// - walk (메서드) 직접 할당
rabbit.walk = function() {
  alert("토끼가 깡충깡충 뜁니다.");
};

/*
 rabbit.walk() 호출 시
 - 프로토타입 메서드 X
 - rabbit (자식 객체) 내 직접 추가한 메서드 실행
*/
rabbit.walk(); // 토끼가 깡충깡충 뜁니다.
```

![proto-animal-rabbit-walk-2](../../images/01/08/01/proto-animal-rabbit-walk-2.svg)

#### 접근자 프로퍼티 상속

##### `setter` <sub>(값 설정 함수)</sub>
- 값 설정 위해 `setter` <sub>(함수)</sub> 호출 시
  - 조금 다르게 동작
```javascript
let user = {
  name: "John",
  surname: "Smith",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

// 프로토타입 getter 함수 실행
alert(admin.fullName); // John Smith

// 프로토타입 setter 함수 실행
// - admin (자식 객체)
//   - name · surname (프로퍼티) 추가
admin.fullName = "Alice Cooper";

alert(admin.fullName); // Alice Cooper
alert(user.fullName);  // John Smith,
                       // 본래 user (부모 객체) 내 있었던 프로퍼티 값
```

##### 자식 객체 : `setter` 할당 연산 <sub>(`set fullName`)</sub>
- 프로토타입 `setter` <sub>(함수)</sub> 호출
- `user` <sub>(부모 객체)</sub> 프로퍼티 추가 X

### `this` 의미

##### `this` : 프로토타입 영향 X
- 메서드 호출 주체 <sub>(객체 · 프로토타입)</sub> 상관 X
  - 언제나 `.` <sub>(점)</sub> 앞 객체
- `setter` <sub>(함수)</sub> 호출 시 `this` 값
  - `admin` <sub>(자식 객체)</sub>
  - `user` <sub>(부모 객체)</sub> X

##### 거대 부모 객체
- 한 객체 내 메서드 다수 구현
  - 여러 객체에서 상속
- 상속받은 메서드 사용 시
  - 객체 자신 상태 수정
  - 프로토타입 수정 X
```javascript
// animal (부모 객체)
// - 다양한 메서드 구현
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`동물이 걸어갑니다.`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: "하얀 토끼",
  __proto__: animal
};

// rabbit (자식 객체)
// - isSleeping (새 프로퍼티) 추가
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined
```

![proto-animal-rabbit-walk-3](../../images/01/08/01/proto-animal-rabbit-walk-3.svg)

##### 상속받은 객체들
- 프로토타입 구현 메서드 사용 가능

##### 상속받은 메서드 내 `this`
- `.`<sub>(점)</sub> 앞 객체 <sub>(메서드 호출 시점)</sub>
  - 해당 객체 상태 변화
  - 프로토타입 변화 X
- 즉
  - 메서드 공유
  - 객체 상태 공유 X

### `for…in` <sub>(반복문)</sub>
- 상속 프로퍼티
  - 순회대상 포함
```javascript
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// Object.keys
// - 상속 프로퍼티 배제
alert(Object.keys(rabbit));          // jumps

// for…in
// - 상속 프로퍼티 포함
for(let prop in rabbit) alert(prop); // jumps, eats
```

##### `obj.hasOwnProperty(key)`
- 상속 프로퍼티
  - `false` 반환
- `obj` <sub>(객체)</sub> 내 구현 프로퍼티
  - `true` 반환
- 응용
  - 상속 프로퍼티 걸러냄
```javascript
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  // 객체 자신 프로퍼티
  // - jumps
  if (isOwn) {
    alert(`객체 자신의 프로퍼티: ${prop}`);

  // 상속 프로퍼티
  // - eats
  } else {
    alert(`상속 프로퍼티: ${prop}`);
  }
}
```

![rabbit-animal-object](../../images/01/08/01/rabbit-animal-object.svg)

##### `{ … }` <sub>(객체 리터럴)</sub> 방식 선언 시
- `Object.prototype` 상속

##### `Object.prototype` 내 모든 메서드
- `enumerable: false` <sub>(플래그)</sub> 설정
  - 'non-enumerable'
  - `for…in` 배제

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **키 · 값 쌍 순회 메서드 대부분 : 상속 프로퍼티 배제**

- 프로토타입 상속 프로퍼티 배제
- 해당 객체 내 정의 프로퍼티만 포함
- ex&#41;
  - `Object.keys`
  - `Object.values`
  - 기타 등등

<br />

## 요약
- 자바스크립트의 모든 객체엔 숨김 프로퍼티 `[[Prototype]]`이 있는데, 이 프로퍼티는 객체나 `null`을 가리킵니다.
- `obj.__proto__`를 사용하면 프로토타입에 접근할 수 있습니다. `__proto__`는 `[[Prototype]]`의 getter · setter로 쓰이는데, 요즘엔 잘 쓰지 않습니다. 자세한 사항은 뒤쪽 챕터에서 다룰 예정입니다.
- `[[Prototype]]`이 참조하는 객체를 '프로토타입’이라고 합니다.
- 객체에서 프로퍼티를 읽거나 메서드를 호출하려는데 해당하는 프로퍼티나 메서드가 없으면 자바스크립트는 프로토타입에서 프로퍼티나 메서드를 찾습니다.
- 접근자 프로퍼티가 아닌 데이터 프로퍼티를 다루고 있다면, 쓰기나 지우기와 관련 연산은 프로토타입을 통하지 않고 객체에 직접 적용됩니다.
- 프로토타입에서 상속받은 `method`라도 `obj.method()`를 호출하면 `method` 안의 `this`는 호출 대상 객체인 `obj`를 가리킵니다.
- `for..in` 반복문은 객체 자체에서 정의한 프로퍼티뿐만 아니라 상속 프로퍼티도 순회 대상에 포함합니다. 반면, 키-값과 관련된 내장 메서드 대부분은 상속 프로퍼티는 제외하고 객체 자체 프로퍼티만을 대상으로 동작합니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 프로토타입 이해하기
객체 두 개를 이용해 쌍을 만들고 이를 수정하는 코드가 아래에 있습니다.

얼럿창에 어떤 값이 나올지 예측해보세요.
```javascript
let animal = {
  jumps: null
};
let rabbit = {
  __proto__: animal,
  jumps: true
};

alert( rabbit.jumps ); // ? (1)

delete rabbit.jumps;

alert( rabbit.jumps ); // ? (2)

delete animal.jumps;

alert( rabbit.jumps ); // ? (3)
```

세 개의 답을 제출하셔야 합니다.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

1. `true` – `rabbit`에서 가져옴.
2. `null` – `animal`에서 가져옴.
3. `undefined` – 더 이상 프로퍼티를 찾을 수 없음.

<hr />

### 검색 알고리즘
이번에 풀 과제는 두 부분으로 구성됩니다.

먼저, 아래 객체를 살펴봅시다.
```javascript
let head = {
  glasses: 1
};

let table = {
  pen: 3
};

let bed = {
  sheet: 1,
  pillow: 2
};

let pockets = {
  money: 2000
};
```

1. `__proto__`를 사용해서, 프로퍼티 조회가 `pockets` → `bed` → `table` → `head`의 경로를 따르도록 하세요. `pockets.pen`은 `table`에 있는 `3`, `bed.glasses`는 `head`에 있는 `1`이 되어야 합니다.
2. `pockets.glasses`로 `glasses`를 얻는 것이 빠를까요? 아니면 `head.glasses`로 얻는 것이 빠를까요? 필요하다면 벤치마크를 사용해 성능을 측정해 보세요.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

1.
`__proto__`를 추가해봅시다.
```javascript
let head = {
  glasses: 1
};

let table = {
  pen: 3,
  __proto__: head
};

let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table
};

let pockets = {
  money: 2000,
  __proto__: bed
};

alert( pockets.pen ); // 3
alert( bed.glasses ); // 1
alert( table.money ); // undefined
```

2.
모던 엔진에선 객체에서 프로퍼티를 가져오는 것과 객체의 프로토타입에서 프로퍼티를 가져오는 것 사이에 성능적인 차이가 없습니다. 모던 엔진은 프로퍼티가 어디서 발견됐는지 기억하고 있다가 다음 요청 시 이 정보를 재사용합니다.

`pockets.glasses`을 예시로 들어봅시다. 엔진은 `glasses`가 발견된 곳(`head`)을 기억하고 있다가, 다음 요청부턴 이 프로퍼티가 발견된 곳에서 검색을 시작할 겁니다. 모던 엔진은 뭔가 변화가 생기면 내부 캐시를 변경해줄 정도로 똑똑하기 때문에 최적화를 안전하게 수행해줍니다.

<hr />

### 어디에 프로퍼티가 추가될까요
`animal`을 상속받는 `rabbit`이 있습니다.

`rabbit.eat()`을 호출했을 때, `animal`과 `rabbit` 중 어떤 객체에 `full` 프로퍼티가 생길까요?
```javascript
let animal = {
  eat() {
    this.full = true;
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.eat();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

정답: `rabbit`

점 앞에 있는 객체는 `this`이기 때문에, `rabbit.eat()`은 `rabbit`을 변경합니다.

프로퍼티를 찾는 것과 프로퍼티를 실행하는 것은 완전히 다른 일입니다.

메서드 `eat`은 프로토타입에서 찾을 수 있지만, 메서드를 실행할 땐 `this`가 `rabbit`이 되어 해당 메서드가 실행됩니다.

<hr />

### 왜 햄스터 두 마리 모두 배가 꽉 찼을까요
`hamster` 객체를 상속받는 햄스터 `speedy`와 `lazy`가 있다고 가정해봅시다.

둘 중 한 마리에게만 먹이를 줘도, 다른 한 마리의 배 역시 꽉 찹니다. 왜 그럴까요? 어떻게 하면 이런 이상한 일이 일어나지 않게 할 수 있을까요?
```javascript
let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 햄스터 speedy가 음식을 먹습니다.
speedy.eat("apple");
alert( speedy.stomach ); // apple

// 햄스터 lazy는 음식을 먹지 않았는데 배에 apple이 있다고 나오네요. 왜 그럴까요? lazy는 배가 비어있도록 고쳐주세요.
alert( lazy.stomach ); // apple
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

`speedy.eat("apple")`을 호출하면 무슨 일이 일어나는지 주의 깊게 알아보아야 원인을 파악할 수 있습니다.
1. 메서드 `speedy.eat`은 프로토타입 `hamster`에서 발견되는데, 점 앞엔 객체 `speedy`가 있으므로 `this`엔 `speedy`가 할당되어 메서드가 실행됩니다.
2. `this.stomach.push()`를 실행하려면 프로퍼티 `stomach`을 찾아서 여기에 `push`를 호출해야 합니다. 그런데 `this`인 `speedy`엔 프로퍼티 `stomach`이 없습니다.
3. `stomach`을 찾기위해 프로토타입 체인을 거슬러 올라가보니 `hamster`에 `stomach`이 있는것을 발견합니다.
4. `push` 메서드는 프로토타입 `hamster`에 있는 `stomach` 을 대상으로 동작하여 프로토타입에 `food`가 추가됩니다.

모든 햄스터가 하나의 `stomach`를 공유하는 이유는 바로 이런 동작방식 때문입니다.

`lazy.stomach.push(...)`, `speedy.stomach.push()`를 호출했을 때 모두 프로퍼티 `stomach`은 프로토타입에서 발견됩니다. 따라서 새로운 데이터는 `stomach`에 추가됩니다.

문제를 해결하려면 `push` 메서드가 아닌 `this.stomach=`을 사용해 데이터를 할당하면 됩니다.
```javascript
let hamster = {
  stomach: [],

  eat(food) {
    // this.stomach.push(food) 대신에 food를 this.stomach에 할당
    this.stomach = [food];
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// 햄스터 speedy가 음식을 먹습니다.
speedy.eat("apple");
alert( speedy.stomach ); // apple

// lazy는 음식을 먹지 않았기 때문에 배가 비어있습니다.
alert( lazy.stomach ); // (아무것도 출력 안됨)
```

`this.stomach=`은 객체 자체에 해당 프로퍼티를 추가하지 프로토타입 체인에서 `stomach`을 찾지 않기 때문에 의도한 대로 잘 작동합니다.

이 방법 말고도 햄스터가 각자의 `stomach`를 가지게 하면 문제를 사전에 차단할 수 있습니다.
```javascript
let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster,
  stomach: []
};

let lazy = {
  __proto__: hamster,
  stomach: []
};

// 햄스터 speedy가 음식을 먹습니다.
speedy.eat("apple");
alert( speedy.stomach ); // apple

// lazy는 음식을 먹지 않았기 때문에 배가 비어있습니다.
alert( lazy.stomach ); // (아무것도 출력 안됨)
```

문제의 `stomach`처럼 특정 객체의 상태를 설명하는 프로퍼티는 조상 객체가 아닌 객체 자체에 정의하는 것이 이런 문제를 차단할 수 있는 일반적인 방법입니다.
