 프로토타입 메서드 · `__proto__` 부재 객체
======================================

##### `__proto__`
- 브라우저 대상 개발 시
  - 다소 구식 <sub>(권장 X)</sub>
- 표준 관련 내용 명시

#### 모던 메서드

##### `Object.create(proto, [descriptors])`
- `proto` 참조하는 빈 객체 생성
  - `[[Prototype]]` → `proto` 참조
- `descriptors` <sub>(프로퍼티 설명자)</sub>
  - 선택적 전달

##### `Object.getPrototypeOf(obj)`
- `obj.[[Prototype]]` 반환

##### `Object.setPrototypeOf(obj, proto)`
- `obj.[[Prototype]]` → `proto` 설정
```javascript
let animal = {
  eats: true
};

// 새 객체 생성
// - 프로토타입 → animal 참조
let rabbit = Object.create(animal);

alert(rabbit.eats); // true
alert(Object.getPrototypeOf(rabbit) === animal); // true

// rabbit (자식 객체) 프로토타입 → {} 참조
Object.setPrototypeOf(rabbit, {});
```

##### `Object.create`
- 프로퍼티 설명자
  - 선택적 전달
```javascript
let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

alert(rabbit.jumps); // true
```
- `for…in` 보다 더 8효과적으로 객체 복제
```javascript
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

##### 모든 프로퍼티 복제한 완벽한 사본 생성
- 열거 가능 프로퍼티
- 열거 불가능 프로퍼티
- 데이터 프로퍼티
- getter
- setter
- `[[Prototype]]`
- 기타 등등

### 비하인드 스토리

##### `[[Prototype]]` 다루는 방법 다양
- 목표 하나
- 수단 여러 가지

#### 역사적인 이유

##### 생성자 함수의 `prototype` <sub>(프로퍼티)</sub>
- 아주 오래전부터 사용

##### 2012년, `Object.create` 표준 추가
- 주어진 프로토타입 사용해 객체 생성 가능
- 프로토타입 얻기 · 설정 불가능
- `__proto__` <sub>(브라우저 비표준 접근자)</sub> 구현 시
  - 프로토타입 얻기 · 설정 가능

##### 2015년,<br />`Object.\[g·s\]etPrototypeOf` 표준 추가
- `__proto__` 기능 동일 수행
- 이미 `__proto__` 사용 매우 多
  - 사실상 표준 <sub>(명세서 부록 B 수록)</sub>

##### 명세서 부록 B 내용
- 브라우저 이외 호스트 환경
  - 선택사항

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **속도 중요 : 기존 객체 `[[Prototype]]` 변경 X**

##### 언제나 `[[Prototype]]` 얻기 · 설정 가능
- 기술적 제약 X
  - `Object.setPrototypeOf`
  - `obj.__proto__ = …`

##### 대개 객체 생성 시 `[[Prototype]]` 설정 · 이후 수정 X
- JS 엔진
  - 이런 시나리오 토대로 최적화

##### 프로토타입 그때그때 바꾸는 연산
- 객체 프로퍼티 접근 관련 최적화 망침
  - 성능에 나쁜 영향

<br />

### 아주 단순한 객체

##### 객체
- 키 · 값 쌍 있는 연관 배열로 사용 가능

##### 사용자 직접 입력한 키로 객체 생성 시 <sub>(커스텀 사전 등)</sub>
- 사소한 결함 발생
  - `"__proto__"` : 문자열 키로 사용 X
```javascript
let obj = {};
let key = prompt("입력하고자 하는 key는 무엇인가요?", "__proto__");
obj[key] = "… 값 …";

alert(obj[key]); // [object Object]
```

#### `__proto__`

##### 할당 가능 타입
- 객체
- `null`

##### 객체 할당 시
- 프로토타입 중간에 바뀜 <sub>(== 치명적인 버그)</sub>
  - 예상치 못한 일 발생
  - 버그 원인 찾기 어려움
- 프로토타입 중간에 바뀌는 시나리오
  - 대게 배제한 채 개발 진행
- 서버 사이드 <sub>(JS 사용 시)</sub>
  - 취약점 가능성 有
- 내장 메서드 <sub>(`toString` 등)</sub> 에 할당 시
  - 예상치 못한 일 발생 가능

##### 문제 해결 방법
1. 객체 대신 맵 사용
2. 객체 프로토타입 제거 후 사용

##### `__proto__`
- 객체 프로퍼티 X
- `Object.prototype` 접근자 프로퍼티

##### `__proto__` 읽기 · 쓰기 시
- 프로토타입에서 `getter` · `setter` 호출
  - `[[Prototype]]` 통해 호출

##### `[[Prototype]]` 접근 수단
- `[[Prototype]]` 그 자체 X

![object-prototype-2](../../images/01/08/04/object-prototype-2.svg)

##### 객체 : 연관 배열 역할 수행 <sub>(간단한 트릭)</sub>
- `Object.create(null)`
  - 프로토타입 없는 빈 객체 생성
  - `[[Prototype]]` == `null`
```javascript
let obj = Object.create(null);
let key = prompt("입력하고자 하는 key는 무엇인가요?", "__proto__");
obj[key] = "… 값 …";

alert(obj[key]); // "… 값 …"
```

![object-prototype-null](../../images/01/08/04/object-prototype-null.svg)

##### `Object.create(null)` : 객체 생성 시
- `__proto__`
  - `getter` · `setter` 상속 X
  - 평범한 데이터 프로퍼티처럼 처리

##### 프로토타입 없는 빈 객체
- 아주 단순한 순수 사전식 객체
- `{ … }` <sub>(일반 객체)</sub> 보다 훨씬 단순
- 내장 메서드 X <sub>(`toString 등`)</sub>
  - 연관 배열로 사용 시 문제 X
```javascript
let obj = Object.create(null);

alert(obj); // Error: Cannot convert object to primitive value
            // - toString (내장 메서드) 없음
```

##### 객체 관련 메서드 대다수
- `Object.something( … )` 형태
  - ex\) `Object.keys(obj)`
- 프로토타입 메서드 X
  - '아주 단순한 객체' : 사용 가능


<br />

## 요약

##### `__proto__`
- `[[Prototype]]` \[g·s\]etter
- `Object.prototype` 내 정의

#### 프로토타입 직접 접근 모던 메서드

##### `Object.create(proto, [descriptors])`
- 객체 생성
- `proto` <sub>(인수)</sub>
  - `[[Prototype]]`
  - `null` 가능
- `[descriptors]` <sub>(인수)</sub>
  - 프로퍼티 설명자

##### `Object.getPrototypeOf(obj)`
- `obj.[[Prototype]]` 반환
- `__proto__` <sub>(getter)</sub> 동일

##### `Object.setPrototypeOf(obj, proto)`
- `obj.[[Prototype]]` → `proto` 설정
- `__proto__` <sub>(setter)</sub> 동일

##### 사용자 : 키 직접 설정 <sub>(커스텀 사전)</sub>
- `"__proto__"` 키 설정 시
  - 에러 발생 <sub>(예측 불가능 결과)</sub>
- `Object.create(null)`
  - `__proto__` 없는 객체
  - '아주 단순한' 객체
- 맵 사용

##### `Object.create`
- 얕은 복사
```javascript
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

#### 기타 메서드

##### `Object.[key·value·entrie]s(obj)`
- `obj` 내 열거 가능 요소 담은 배열 반환
  - 프로퍼티 키
  - 값
  - 키 · 값 쌍

##### `Object.getOwnPropertySymbols(obj)`
- `obj` 내 심볼형 키 담은 배열 반환

##### `Object.getOwnPropertyNames(obj)`
- `obj` 내 문자형 키 담은 배열 반환

##### `Reflect.ownKeys(obj)`
- `obj` 내 키 전체 담은 배열 반환

##### `obj.hasOwnProperty(key)`
- `obj` 자체 구현 <sub>(상속 X)</sub> 키 중 `key` 존재 시
  - `true` 반환

##### 객체 프로퍼티 반환 메서드 <sub>(`Object.keys` 등)</sub>
- 객체 '직접 소유' 프로퍼티만 반환
- `for…in` <sub>(반복문)</sub>
  - 상속 프로퍼티 포함 순회

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 사전에 `toString` 추가하기
`key`/`value` 쌍을 저장하기 위해 `Object.create(null)`로 생성된 `dictionary` 객체가 있습니다.

그 안에 쉼표로 구분된 키 목록을 반환하는 `dictionary.toString()`메서드를 추가하십시오. `toString`은 객체 위의 `for..in`에 나타나서는 안 됩니다.

작동 방식은 다음과 같습니다.
```javascript
let dictionary = Object.create(null);

// dictionary.toString 메서드를 추가하는 코드

// 데이터를 추가합니다.
dictionary.apple = "Apple";
dictionary.__proto__ = "test"; // __proto__는 여기서 일반적인 프로퍼티 키입니다.

// 반복문에는 apple과 __proto__ 만 있습니다.
for(let key in dictionary) {
  alert(key); // "apple" 다음 "__proto__"입니다.
}

// toString이 동작하는 부분입니다.
alert(dictionary); // "apple,__proto__"
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

이 메서드는 `Object.keys`를 사용하여 열거 가능한 모든 키를 가져와서 목록으로 출력할 수 있습니다.

`toString`을 열거할 수 없도록 하기 위해 프로퍼티 설명자를 사용하여 `toString`을 정의하겠습니다. `Object.create` 문법을 사용하면 프로퍼티 설명자를 두 번째 인수로 사용하여 객체를 제공할 수 있습니다.
```javascript
let dictionary = Object.create(null, {
  toString: { // toString 프로퍼티를 정의합니다.
    value() { // value는 함수입니다.
      return Object.keys(this).join();
    }
  }
});

dictionary.apple = "Apple";
dictionary.__proto__ = "test";

// apple과 __proto__는 반복문 안에 있습니다.
for(let key in dictionary) {
  alert(key); // "apple" 다음 "__proto__"가 있습니다.
}

// toString에 의해 쉼표로 구분된 프로퍼티 목록
alert(dictionary); // "apple,__proto__"
```

설명자를 사용하여 프로퍼티를 만들면 기본적으로 플래그가 `false`입니다. 따라서 위 코드에서 `dictionary.toString`은 열거할 수 없습니다.

다음 챕터 프로퍼티 플래그와 설명자를 참고하시기 바랍니다.

<hr />

### 호출 간의 차이점
새로운 `rabbit` 객체를 만들어 봅시다.
```javascript
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert(this.name);
};

let rabbit = new Rabbit("Rabbit");
```

아래와 같이 메서드를 호출하면 동일하게 동작할지 다르게 동작할지 예상해 보세요.
```javascript
rabbit.sayHi();
Rabbit.prototype.sayHi();
Object.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

`this`는 실제 점 앞에 있는 객체를 나타내기 때문에, 첫 번째 호출에선 `this`가 `rabbit`이고, 다른 호출에선 `Rabbit.prototype`입니다.

따라서 첫 번째 호출만이 `Rabbit`을 출력하고 다른 호출은 `undefined`를 출력합니다.
```javascript
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert( this.name );
}

let rabbit = new Rabbit("Rabbit");

rabbit.sayHi();                        // Rabbit
Rabbit.prototype.sayHi();              // undefined
Object.getPrototypeOf(rabbit).sayHi(); // undefined
rabbit.__proto__.sayHi();              // undefined
```
