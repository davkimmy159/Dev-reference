함수 `prototype` <sub>(프로퍼티)</sub>
========================

##### 생성자 함수
- `new` <sub>(연산자)</sub> 사용해 객체 생성
- `[[Prototype]]` 설정 시
  - 프로토타입 정보 사용

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### JS 만들어졌을 당시
- 프로토타입 기반 상속
  - 주요 기능 중 하나

##### 과거 프로토타입 직접 접근 방법 X
- 그나마 믿고 사용할 수 있었던 방법
  - 생성자 함수 `prototype` <sub>(프로퍼티)</sub>
- 많은 스크립트
  - 아직 이 방법 사용

<br />

##### `F.prototype` <sub>(프로퍼티)</sub>
- `F` <sub>(생성자 함수)</sub> 의 프로토타입
- `F` <sub>(생성자 함수)</sub> 에 정의된 일반 프로퍼티
- 프로토타입과 비슷
- 일반 프로퍼티 (특별 X)
```javascript
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

// new Rabbit 호출해 객체 생성 시
// - [[Prototype]] → animal (부모 객체) 설정
Rabbit.prototype = animal;

// rabbit.__proto__ == animal
let rabbit = new Rabbit("흰 토끼");

alert( rabbit.eats ); // true
```

![proto-constructor-animal-rabbit](../../images/01/08/02/proto-constructor-animal-rabbit.svg)

- → <sub>(가로 화살표)</sub>
  - `prototype` <sub>(일반 프로퍼티)</sub>
- ↑ <sub>(세로 화살표)</sub>
  - `[[Prototype]]` <sub>(내부 · 숨김 프로퍼티)</sub>
  - `rabbit` → `animal` 상속

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`F.prototype` : `new F` 호출 때만 사용**

##### `new F` 호출 시
1. 객체 생성
2. 생성된 객체의 `[[Prototype]]` 설정

##### 객체 생성 후 `F.prototype` 값 변화 시
1. `F.prototype = otherObject`
2. `new F` 호출해 생성된 또 다른 객체
    - `[[Prototype]]` → `otherObject`
- 기존 객체
  - `[[Prototype]]` → `F.prototype`
  - 그대로 유지

<br />

### 함수 디폴트 프로퍼티 <sub>(`prototype` · `constructor`)</sub>

##### 모든 함수
- 기본적으로 `prototype` <sub>(프로퍼티)</sub> 보유

##### 디폴트 `prototype` <sub>(프로퍼티)</sub>
- `{ constructor : 함수 자신 }` <sub>(객체)</sub> 참조
  - `constructor` <sub>(프로퍼티)</sub> → 함수 자신
```javascript
function Rabbit() {}

// 암묵적 디폴트 prototype 설정
// - 함수 생성만 해도 자동으로 설정
// Rabbit.prototype = { constructor: Rabbit };

alert( Rabbit.prototype.constructor == Rabbit ); // true
```

![function-prototype-constructor](../../images/01/08/02/function-prototype-constructor.svg)

##### `new Rabbit()` 실행해 만든 모든 객체
- `constructor` <sub>(프로퍼티)</sub> 사용 가능
  - `[[Prototype]]` 거침
```javascript
function Rabbit() {}

// 암묵적 디폴트 prototype (프로퍼티) 설정
// Rabbit.prototype = { constructor: Rabbit };

// { constructor: Rabbit } (프로토타입 객체) 상속받음
// - Rabbit.prototype
let rabbit = new Rabbit();

// [[Prototype]] 거쳐 constructor (프로퍼티) 접근
alert(rabbit.constructor == Rabbit); // true
```

![rabbit-prototype-constructor](../../images/01/08/02/rabbit-prototype-constructor.svg)

##### `constructor` <sub>(프로퍼티)</sub>
- 새 객체 생성 시
  - 기존 객체의 `constructor` 사용 가능
```javascript
function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit("흰 토끼");
let rabbit2 = new rabbit.constructor("검정 토끼");
```

##### 객체 생성에 사용된 생성자 알 수 없는 경우 유용
- ex&#41; 서드 파티 라이브러리 객체 등

##### `constructor` : 가장 중요한 점
- JS
  - 알맞은 `constructor` 값 보장 X
- '함수 : 기본으로 `prototype` 설정된다'
  - 라는 사실 그게 전부
- `constructor` 관련 발생하는 모든 일
  - 전적으로 개발자에게 달려있음

##### 함수 디폴트 `prototype` → 다른 객체 할당
- `new` <sub>(연산자)</sub> 사용해 객체 생성 시
  - 객체에 `constructor` <sub>(프로퍼티)</sub> 없음
```javascript
function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};

let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // false
```

##### `constructor` 기본 성질 제대로 활용하기
- `prototype` 전체 덮어쓰기 X
- 디폴트 `prototype` 유지
  - 원하는 프로퍼티 추가 · 제거
```javascript
function Rabbit() {}

/*
 Rabbit.prototype 전체 덮어쓰기 X
 디폴트 prototype 유지
 - Rabbit.prototype.constructor
 프로퍼티 추가
 */
Rabbit.prototype.jumps = true
```

##### 실수로 `prototype` 덮어썼을 경우
- `constructor` 수동으로 다시 생성
  - 다시 사용 가능
```javascript
// 수동으로 constructor 추가
// - constructor 특징 그대로 사용 가능
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};
```

<br />

## 요약
이번 챕터에선 생성자 함수를 이용해 만든 객체의 `[[Prototype]]`이 어떻게 설정되는지 간략히 알아보았습니다. 이 방법을 기반으로 하는 고급 프로그래밍 패턴에 대해선 추후 학습할 예정입니다.

몇 가지 사항만 명확하게 이해하고 있으면 지금까지 배운 것들은 복잡하지 않습니다.
- 생성자 함수에 기본으로 세팅되는 프로퍼티(`F.prototype`)는 `[[Prototype]]`과 다릅니다. `F.prototype`은 `new F()`를 호출할 때 만들어지는 새로운 객체의 `[[Prototype]]`을 설정합니다.
- `F.prototype`의 값은 객체나 `null`만 가능합니다. 다른 값은 무시됩니다.
- 지금까지 배운 내용은 생성자 함수를 `new`를 사용해 호출할 때만 적용됩니다.

참고로 일반 객체엔 `"prototype"` 프로퍼티를 추가해도 아무런 일이 일어나지 않습니다.
```javascript
let user = {
  name: "John",
  prototype: "Bla-bla" // 마술은 일어나지 않습니다.
};
```

모든 함수는 기본적으로 `F.prototype = { constructor : F }`를 가지고 있으므로 `"constructor"` 프로퍼티를 사용하면 객체의 생성자를 얻을 수 있습니다.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 'prototype' 변경하기
아래 코드에선 `new Rabbit`를 만들고 `Rabbit`의 `"prototype"`을 변경합니다.

시작 코드는 다음과 같습니다.
```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

alert( rabbit.eats ); // true
```

1. 아래와 같은 코드를 추가(강조된 줄)하면 얼럿창엔 무엇이 출력될까요?
```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

Rabbit.prototype = {};

alert( rabbit.eats ); // ?
```

2. 아래와 같이 코드를 변경하면 얼럿창엔 무엇이 출력될까요?
```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

Rabbit.prototype.eats = false;

alert( rabbit.eats ); // ?
```

3. 아래와 같이 delete를 사용하면 얼럿창엔 무엇이 출력될까요?
```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

delete rabbit.eats;

alert( rabbit.eats ); // ?
```

4. 마지막 코드를 실행하면 얼럿창엔 무엇이 출력될까요?
```javascript
function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

delete Rabbit.prototype.eats;

alert( rabbit.eats ); // ?
```

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

정답:

1. `true`

`Rabbit.prototype`에 무언가를 할당하면 그 값이 새로운 객체의 `[[Prototype]]`이 됩니다. 다만 이미 만들어진 객체엔 이 규칙이 적용되지 않습니다.

2. `false`

객체는 참조에 의해 할당됩니다. `Rabbit.prototype`이 참조하는 객체는 단 하나뿐인데, 이 객체는 `Rabbit.prototype`과 `rabbit`의 `[[Prototype]]`을 사용해 참조할 수 있습니다.

따라서 둘 중 하나의 참조를 사용해 객체의 내용을 변경하면 다른 참조를 통해서도 변경 내용을 볼 수 있습니다.

3. `true`

`delete` 연산은 객체에 직접 적용됩니다. `delete rabbit.eats`는 `rabbit`에서 `eats` 프로퍼티를 제거하는데, `rabbit`엔 `eats`가 없습니다. 따라서 `delete`는 아무런 영향을 주지 않습니다.

4. `undefined`

프로퍼티 `eats`가 프로토타입에서 삭제되었기 때문에 `eats`는 더이상 존재하지 않습니다.

<hr />

### 동일한 생성자 함수로 객체 만들기
생성자 함수가 하나 있고, 이 생성자 함수를 사용해 만든 임의의 객체 `obj`가 있다고 가정해봅시다. 지금은 이 생성자 함수를 사용해 새로운 객체를 만들어야하는 상황입니다.

정체를 모르는 생성자 함수를 사용해 새로운 객체를 만드는게 가능할까요?
```javascript
let obj2 = new obj.constructor();
```

위와 같은 코드를 사용해 객체를 만들 수 있게 해주는 생성자 함수를 작성해보세요. 여기에 더하여 위와 같은 코드가 동작하지 않도록 하는 예시도 하나 만들어보세요.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

`"constructor"` 프로퍼티에 제대로 된 값이 저장되어있다면 위와 같은 접근법이 가능합니다.

기본 `"prototype"`를 변경하지 않았다면 아래 예시는 의도한 대로 동작합니다.
```javascript
function User(name) {
  this.name = name;
}

let user = new User('John');
let user2 = new user.constructor('Pete');

alert( user2.name ); // Pete (잘 동작하네요!)
```

`User.prototype.constructor == User`이기 때문에 위 예시는 제대로 동작합니다.

그런데 누군가가 `User.prototype`를 덮어쓰고 `User`를 참조하는 `constructor`를 다시 만들어주는 걸 잊었다면 문제의 접근법은 실패합니다.

예시:
```javascript
function User(name) {
  this.name = name;
}
User.prototype = {}; // (*)

let user = new User('John');
let user2 = new user.constructor('Pete');

alert( user2.name ); // undefined
```

왜 `user2.name`이 `undefined`가 될까요?

그 이유는 `new user.constructor('Pete')`가 아래와 같이 동작하기 때문입니다.

1. `new user.constructor('Pete')`는 `user`에서 `constructor`를 찾는데 아무것도 찾지 못합니다.
2. 객체에서 원하는 프로퍼티를 찾지 못했기 때문에 프로토타입에서 검색을 시작합니다. `user`의 프로토타입은 `User.prototype`인데, `User.prototype`은 빈 객체입니다.
3. `User.prototype`은 일반 객체 {}이고, 일반 객체의 프로토타입은 `Object.prototype`입니다. `Object.prototype.constructor == Object`이므로 `Object`가 사용됩니다.

결국에 `let user2 = new user.constructor('Pete');`는 `let user2 = new Object('Pete')`가 됩니다. 그런데 `Object`의 생성자는 인수를 무시하고 항상 빈 객체를 생성합니다. 따라서 `let user2 = new Object('Pete')`는 `let user2 = {}`와 같다고 생각할 수 있습니다. `user2.name`이 `undefined`인 이유가 여기에 있습니다.
