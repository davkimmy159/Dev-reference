테스트 자동화 · `Mocha`
====================

- 현업
  - 광범위 사용

### 테스트 진행 이유

#### 함수 하나 작성 가정
- 대개 매개변수 · 결과 관계 중심 구상

##### 기능 구현 상태 확인
- 실행 결과 · 결과 계속 비교
  - 개발 중 콘솔 창 등 이용

##### 실제 실행 결과 ≠ 기대 결과
- 코드 수정 후 재실행 · 결과 비교
  - 기능 완성 때까지 과정 반복

##### 코드 '수동' 재실행
- 상당히 불완전
  - 무언가 놓치기 쉬움

##### 구체적인 예 <sub>(`f` 함수 구현)</sub>
1. 코드 작성
2. `f(1)` 테스트
    - 정상 동작
3. `f(2)` 테스트
    - 비장상 동작
4. 코드 수정 다시 테스트
    - 정상 동작
5. f`(1)` 다시 테스트
6. … 

##### 수많은 유스 케이스 생각하며 코드 작성
- 코드 변경 시 모든 유스 케이스 상기 불가능
  - 하나 수정 → 다른 문제 발생

##### 테스트 코드 <sub>(테스팅 자동화)</sub>
- 실제 동작 관여 코드와 별개로 작성
- 다양한 조건 하 함수 실행
  - 실행 · 기대 결과 비교

### [Behavior Driven Development <sub>(BBD)</sub>](https://en.wikipedia.org/wiki/Behavior-driven_development)

##### 3가지 결합
- 테스트 <sub>(test)</sub>
- 문서 <sub>(documentation)</sub>
- 예시 <sub>(example)</sub>


### 거듭제곱 함수 · 명세서 <sub>(사례 ①)</sub>

##### `pow(x, n)` <sub>(함수)</sub> 구현 가정
- `x` 를 `n` 번 곱하기
- `n` 조건
  - 자연수
  - 0 이상

##### 본격적 코드 작성 전 할 일
- 코드 동작 상상 후 자연어 표현
  - 명세서 · 스펙 <sub>(spec[ification])</sub>
    - 유스 케이스 상세 설명 · 테스트
```javascript
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

#### 스펙 주요 구성 요소 <sub>(3가지)</sub>

##### 1. `describe("title", function() { … })`
- 구현 기능 설명
  - `pow` <sub>(함수)</sub> 동작 설명
- `it` 블록 모으기

##### 2. `it("유스 케이스 설명", function() { … })`
- 1번째 인수
  - 특정 유스 케이스 설명 <sub>(자연어 작성)</sub>
- 2번째 인수
  - 유스 케이스 테스트 함수

##### 3. `assert.equal(value1, value2)`
- 인수끼리 동등 비교
- 상이 판단 시
  - 에러 반환

##### `assert.[*]` <sub>(함수)</sub>
- 동작 테스트 실행

##### 명세서 : 실행 가능
- 실행 시
  - `it` 블록 내 테스트 실행

### 개발 순서
1. 명세서 초안 작성
    - 기본적인 테스트 포함
2. 명세서 초안대로 코드 작성
3. 코드 작동 확인 <sub>(명세서 실행)</sub>
    - 테스트 프레임워크 사용
      - [Mocha](https://mochajs.org)
      - 기타 등등
    - 코드 문제 존재 시
      - 에러 출력
    - 에러 미출력 때까지 코드 수정
4. 모든 테스트 통과
    - 코드 초안 완성
5. 명세서 : 미고려 유스케이스 추가
    - 테스트 실패 발생
6. 모든 테스트 통과 때까지 코드 수정
    - → 3단계로 롤백
7. 기능 완성 때까지 3 ~ 6단계 반복

##### 반복적인 <sub>(iterative)</sub> 성격
- 명세서 작성 · 실행 · 테스트
- 모든 테스트 통과 때까지 반복

##### `pow` <sub>(함수)</sub> 스펙 초안
- 위에서 작성 완료 <sub>(1단계 완료)</sub>

### 스펙 실행하기

#### 테스트 라이브러리 <sub>(3가지)</sub>

##### [Mocha](https://mochajs.org/) <sub>(핵심 프레임워크)</sub>
- 테스팅 · 실행 관련 주요 함수 제공
  - `describe`
  - `it`
  - 기타 등등

##### [Chai](https://www.chaijs.com/)
- 다양한 assertion 제공
  - `assert.equal`
  - 기타 등등

##### [Sinon](https://sinonjs.org/)
- 함수 정보 획득
  - 내장 함수 등 모방

##### 공통점
- 모든 실행 환경 내 사용 가능

##### `pow` <sub>(함수)</sub> 스펙 · 라이브러리
```html
<!DOCTYPE html>
<html>
<head>
  <!-- mocha css (결과 출력에 사용) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  
  <!-- Mocha 프레임워크 코드 로드 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    // 기본 설정
    mocha.setup('bdd');
  </script>

  <!-- chai 프레임워크 코드 로드 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // assert 전역 선언
    // - chai 기능 중 하나
    let assert = chai.assert;
  </script>
</head>

<body>
  <script>
    function pow(x, n) {
      /* 코드 작성 */
    }
  </script>

  <!--
  테스트 스크립트 로드
  - describe
  - it
  - 기타 등등
  -->
  <script src="test.js"></script>

  <!-- 테스트 결과 출력 요소 -->
  <div id="mocha"></div>

  <!-- 테스트 실행 -->
  <script>
    mocha.run();
  </script>
</body>

</html>
```
1. `<head>`
    - 서드파티 라이브러리 · 스타일 로드
      - 테스트에 필요
2. `<script>`
    - 테스트 대상 함수 <sub>(`pow`)</sub> 코드
3. 테스트 <sub>(외부 스크립트 (`test.js`) 에서 로드)</sub>
    - `describe("pow", ...)`
4. `<div id="mocha">` <sub>(HTML 요소)</sub>
    - Mocha 실행 결과 출력
5. `mocha.run()`
    - 테스트 실행 명령어

##### 결과

![pow-1](../../images/01/03/05/pow-1.png)


##### 현재 `pow` <sub>(함수)</sub> 본문 X
- `pow(2,3)`
  - `undefined` 반환
    - 테스트 실패

##### 고수준 테스트 러너 <sub>([karma](https://karma-runner.github.io/latest/index.html) 등)</sub>
- 다양한 종류의 테스트 자동 실행

### 코드 초안

##### 오로지 테스트 통과 목적
```javascript
function pow(x, n) {
  return 8;
}
```

##### 스펙 실행
- 에러 발생 X
 
![pow-min](../../images/01/03/05/pow-min.png)

### 스펙 개선하기

##### 현재 초안
- 틀린 실행 결과 · 테스트 통과
  - 실무에서 빈번히 발생
- 유스 케이스 추가
  - `pow(3, 4) = 81` 테스트

#### 스펙 내 테스트 추가 방법

##### 1. `assert` 하나 더 추가 <sub>(기존 `it` 블록)</sub>
- `assert` 내 에러 발생 시
  - `it` 블록 즉시 종료
- 1번째 `assert` 실패 시
  - 2번째 `assert` 실행 · 결과 확인 X
```javascript
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
```

##### 2. 테스트 <sub>(`it` 블록)</sub> 하나 더 추가
- 더 많은 정보 얻기 가능
- 권장 방법
```javascript
describe("pow", function() {

  it("2를 세 번 곱하면 8입니다.", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3을 네 번 곱하면 81입니다.", function() {
    assert.equal(pow(3, 4), 81);
  });

});
```

##### 테스트 규칙 권장
- 테스트 하나
  - 한 가지만 확인
- 한 테스트 내 연관 없는 사항 2개
  - 분리

##### 테스트 추가 <sub>(2번째 방법)</sub> 결과

![pow-2](../../images/01/03/05/pow-2.png)

##### 추가한 테스트 실패
- 함수 반환 기대값 : `81`
  - 함수 반환값 : `8`

### 코드 개선하기
- 2번째 테스트 통과 목적
```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

##### 더 많은 값 테스트
- `for` <sub>(반복문)</sub>
  - `it` 블록 자동 생성
```javascript
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

##### 결과

![pow-3](../../images/01/03/05/pow-3.png)

### 중첩 `describe`
- 그룹 형성

##### 중첩 `describe` 내 헬퍼 함수 · 반복문
- `makeTest` <sub>(헬퍼 함수)</sub>
  - `for` <sub>(반복문)</sub> 에서만 사용
- 함께 `pow` <sub>(함수)</sub> 동작 확인
```javascript
describe("pow", function() {

  describe("x를 세 번 곱합니다.", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x}을/를 세 번 곱하면 ${expected}입니다.`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // describe · it
  // - 더 많은 테스트 추가 가능
});
```

##### 새 테스트 '하위 그룹' 정의
- 새로 정의된 테스트 하위 그룹
  - 들여쓰기 적용 상태 출력

![pow-4](../../images/01/03/05/pow-4.png)

##### 이후 최상위 레벨
- `describe` · `it` <sub>(자체 헬퍼 함수 有)</sub> 추가 시
  - 자체 헬퍼 함수
    - `makeTest` <sub>(헬퍼 함수)</sub> 접근 X

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`before` · `after` · `[before·after]Each`**

##### 사용처
- 대개 초기화 용도
  - 카운터 변수 : `0` 설정
  - 테스트 · 그룹 교체 시 필요 작업 실행

##### 함수 실행 시점
- `before`
  - (전체) 테스트 시작 전
- `after`
  - (전체) 테스트 종료 후
- `[before·after]Each`
  - 매 `it` 시직 전 · 종료 후
```javascript
describe("test", function() {

  before(() => alert("테스트 시작 (테스트 시작 전)"));
  after( () => alert("테스트 종료 (테스트 종료 후)"));

  beforeEach(() => alert("단일 테스트 시작 (각 테스트 시작 전)"));
  afterEach( () => alert("단일 테스트 종료 (각 테스트 종료 후)"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

##### 실행 순서
```javascript
테스트 시작 (테스트 시작)          // before
단일 테스트 시작 (각 테스트 시작 전) // beforeEach
1
단일 테스트 종료 (각 테스트 종료 후) // afterEach
단일 테스트 시작 (각 테스트 시작 전) // beforeEach
2
단일 테스트 종료 (각 테스트 종료 후) // afterEach
테스트 종료 (테스트 종료 후)       // after
```
- [코드](https://plnkr.co/edit/7qRYvAeAPcW1qm9A?p=preview)

<br />

### 스펙 확장하기

##### 1번째 반복
- `pow` <sub>(함수)</sub> 기본 기능 구현
- 또 다른 반복
  - 기능 개선

##### `n` <sub>(함수 매개변수)</sub>
- 조건
  - 양의 정수
  - 부적합 시
    - `NaN` 반환 필요
- JS 수학 관련 연산 중 에러 발생 시
  - `NaN` 반환

##### 테스트 추가
- `n` <sub>(매개변수)</sub> 조건 부적합 시
  - `NaN` 반환 여부 검사
```javascript
describe("pow", function() {

  // …

  it("n이 음수일 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, -1));
  });

  it("n이 정수가 아닐 때 결과는 NaN입니다.", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
```

##### 결과

![pow-nan](../../images/01/03/05/pow-nan.png)

##### 기존 함수
- `n` : 음수 · 정수 아닌 경우 상정 X
  - 새 추가 테스트
    - 반드시 실패

##### BDD 핵심
1. 실패할 수밖에 없는 테스트 추가
2. 코드 개선
    - 테스트 통과할 수 있게
    - 에러 발생하지 않게

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **다양한 assertion**

##### [Chai](https://www.chaijs.com/) <sub>(라이브러리)</sub>
- 다양한 `assertion` 지원

##### 지원 목록 일부
- `assert.isNaN`
  - `NaN` 여부 확인
- `assert.equal(value1, value2)`
  - `value1 == value2` 확인
- `assert.strictEqual(value1, value2)`
  - `value1 === value2` 확인
- `assert.not(strict)equal`
  - `!= · !==` 확인
- `assert.isTrue(value)`
  - `value === true` 확인
- `assert.isFalse(value)`
  - `value === false` 확인
- 이 외 다양한 assertion
  - [docs](https://www.chaijs.com/api/assert/)

<br />

새롭게 추가한 테스트를 통과할 수 있도록 `pow`에 코드를 몇 줄 추가해보겠습니다.
```javascript
function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

이제 에러 없이 테스트를 모두 통과하네요.

[sandbox 내의 마지막 문제를 열고 풀어보세요.](https://plnkr.co/edit/UvezyTK4eJJpVwN7?p=preview)

<br />

## 요약
요약
BDD에선 스펙을 먼저 작성하고 난 후에 구현을 시작합니다. 구현이 종료된 시점에는 스펙과 코드 둘 다를 확보할 수 있습니다.

스펙의 용도는 세 가지입니다.
- 테스트
  - 함수가 의도하는 동작을 제대로 수행하고 있는지 보장함
- 문서
  - 함수가 어떤 동작을 수행하고 있는지 설명해줌. `describe`와 `it`에 설명이 들어감
- 예시
  - 실제 동작하는 예시를 이용해 함수를 어떻게 사용할 수 있는지 알려줌

스펙이 있기 때문에 개발자는 안전하게 함수를 개선하거나 변경할 수 있습니다. 함수를 처음부터 다시 작성해야 하는 경우가 생겨도 스펙이 있으면 기존 코드와 동일하게 동작한다는 것을 보장할 수 있습니다.

코드가 바뀌어도 기존에 구현된 기능에 영향을 주지 않게 하는 건 대규모 프로젝트에서 매우 중요합니다. 프로젝트 규모가 커지면 함수 하나를 이곳저곳에서 사용하는데, 수동으로 변경된 함수가 이 함수를 사용하는 모든 곳에서 제대로 동작하는지 확인하는 건 불가능하기 때문입니다.

테스트를 하지 않고 코드를 작성해왔다면 개발자들은 둘 중 한 갈래의 길로 빠져버리고 맙니다.
1. 아무 대책 없이 코드를 변경합니다. 부작용을 생각하지 않고 함수를 수정했기 때문에 어디선가 버그가 발생하고 맙니다.
2. 수정이나 개선을 기피하게 됩니다. 버그의 대가가 가혹하기 때문이죠. 코드가 구식이 되어도 그 누구도 코드를 건드리려 하지 않습니다. 좋지 않은 상황이죠.

**테스팅 자동화는 이런 문제를 피하게 도와줍니다!**

테스팅 자동화를 수행하고 있는 프로젝트라면 이런 문제를 걱정하지 않아도 됩니다. 코드에 변화가 있어도 스펙을 실행해 테스트를 진행하면 몇 초 만에 에러 발생 여부를 확인할 수 있습니다.

장점이 하나 더 있습니다. **잘 테스트 된 코드는 더 나은 아키텍처를 만듭니다.**

수정과 개선이 쉬우니까 당연히 좋은 아키텍처를 만들 수 있다고 생각할 수 있습니다. 하지만 또 다른 이유가 있습니다.

테스트를 작성하려면 함수가 어떤 동작을 하는지, 입력값은 무엇이고 출력값은 무엇인지 정의하고 난 후에 구현을 시작합니다. 코드는 정의된 사항을 뒷받침 할 수 있게 작성해야 하죠. 구현을 시작하는 순간부터 이미 좋은 아키텍처가 보장됩니다.

사실, 매번 이런 절차를 따라 구현한다는 게 쉽지만은 않습니다. 함수가 어떻게 동작해야 하는지 확신이 서지 않는 상황에서 코드를 작성하기도 전에 스펙을 작성해야 하므로 익숙하지 않을 수 있습니다. 그렇지만 테스트를 작성하면 일반적으로 개발 속도가 빨라지고 이전보다 코드를 더 안정적으로 작성할 수 있습니다.

튜토리얼 후반부의 과제에서 테스트 기반의 다양한 과제를 만나볼 수 있습니다. 여기서 사용된 예시보다 더 실용적인 예시를 곧 만나보도록 합시다.

명세서를 만들 때는 어느 정도의 자바스크립트 지식이 필요한데, 우리는 이제 막 자바스크립트 학습을 시작한 상황입니다. 지금 당장은 명세서를 작성할 필요가 없지만, 이번 챕터에서 복잡한 명세서를 읽을 수 있는 능력을 함양했기 때문에 뒷 챕터에선 여러분들도 충분히 명세서를 작성할 수 있을것이라 믿습니다.

<br />

## <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 잘못된 점 찾기
함수 `pow`의 테스트 코드를 보고 무엇이 잘못되었나 알아보세요.
```javascript
it("주어진 숫자의 n 제곱", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});
```

참고: 문법 오류는 없고, 모든 테스트가 문제없이 통과합니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

개발자는 위와 같이 테스트 코드를 작성하려는 유혹에 빠지곤 합니다.

위 코드엔 세 개의 assert, 즉 세 개의 테스트가 있지만 결론적으로 테스트 함수는 하나뿐입니다.

이렇게 테스트 코드를 작성하면 당장은 쉽게 테스트를 진행할 수 있지만, 에러가 발생했을 때 에러의 원인을 찾기가 힘들어집니다.

실행 흐름이 복잡한 경우 에러가 발생하면 에러를 만든 입력값이 무엇이었는지를 일일이 확인해야 합니다. _테스트 코드를 디버깅_ 해야 하는 웃픈 상황이 발생하는 거죠.

테스트는 명확한 입력값, 출력값과 함께 여러 개의 `it` 블록으로 쪼개 작성하는 것이 좋습니다.

아래와 같이 말이죠.
```javascript
describe("주어진 숫자의 n 제곱", function() {
  it("5를 1 제곱하면 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5를 2 제곱하면 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5를 3 제곱하면 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
```

기존에 하나만 있던 `it` 블록을 여러 개로 쪼개 `describe` 안에 넣어보았습니다. 이렇게 하면 에러가 발생했을 때 입력값이 무엇인지 쉽게 파악할 수 있습니다.

여기에 더하여 위와 같이 `it` 블록을 여러 개로 쪼개면 `it` 대신 `it.only`를 사용해 원하는 테스트만 실행해 볼 수 있습니다.
```javascript
describe("주어진 숫자의 n 제곱", function() {
  it("5를 1 제곱하면 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  // Mocha는 아래 블록만 실행합니다.
  it.only("5를 2 제곱하면 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5를 3 제곱하면 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
```
