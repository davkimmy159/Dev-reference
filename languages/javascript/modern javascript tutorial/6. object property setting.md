프로퍼티 플래그와 설명자
======================

### 프로퍼티 플래그
- 플래그 (flag) 속성 3가지
  - writable
    - `true` &nbsp;&nbsp;: 값 수정 가능
    - `false` : 읽기만 가능
  - enumerable
    - `true` &nbsp;&nbsp;: 반복문 사용해 나열 가능
    - `false` : 반복문 사용해 나열 X
  - configurable
    - `true` &nbsp;&nbsp;: 프로퍼티 삭제 · 플래그 수정 가능
    - `false` : 프로퍼티 삭제 · 플래그 수정 X
- `Object.getOwnPropertyDescriptor`
  - 특정 프로퍼티 정보 모두 얻음
```javascript
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```
- obj
  - 정보 얻고자 하는 객체
- propertyName
  - 정보 얻고자 하는 객체 내 프로퍼티
- 반환 값
  - 프로퍼티 설명자 (descriptor) 객체
    - 프로퍼티 값 · 3가지 플래그 정보
```javascript
let user = {
  name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/* property descriptor:
{
  "value": "John",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/
```
- `Object.defineProperty`
  - 플래그 변경
```javascript
Object.defineProperty(obj, propertyName, descriptor)
```
- `obj, propertyName`
  - 설명자 적용 대상 객체 · 프로퍼티
- `descriptor`
  - 사용할 프로퍼티 설명자
- 객체 해당 프로퍼티 존재 시 플래그 원하는 대로 변경
- 프로퍼티 미존재 시 인수 넘겨받은 정보 이용해 새로운 프로퍼티 생성
- 플래그 정보 미존재 시 자동으로 `false` 설정
```javascript
let user = {};

Object.defineProperty(user, "name", {
  value: "John"
});

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": "John",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */
```

#### 평범한 방식 vs `defineProperty`
- 차이점 : 플래그
  - `defineProperty` 플래그 값 명시 X
    - 자동으로  `false`

### `writable` 플래그
- non-writable 설정
```javascript
let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  writable: false
});

user.name = "Pete"; // Error: Cannot assign to read only property 'name'
```

#### 에러는 엄격 모드에서만 발생합니다.
- 비 엄격 모드 읽기 전용 프로퍼티 값 쓰려고 시도
  - 에러 발생 X
  - 값 변경 X
  - 플래그 규칙 위반 시 에러 없이 그냥 무시
- `defineProperty` 메서드 사용해 프로퍼티 밑바닥부터 생성
```javascript
let user = { };

Object.defineProperty(user, "name", {
  value: "John",

  // 어떤 플래그 true 할지 명시
  enumerable: true,
  configurable: true
});

alert(user.name);   // John
user.name = "Pete"; // Error
```

### `enumerable` 플래그
- 객체 내장 메서드 `toString` 열거 불가능 (non-enumerable)
  - `for…in` 사용 시 안 나타남
  - 커스텀 `toString` 추가 시 나타남
```javascript
let user = {
  name: "John",
  toString() {
    return this.name;
  }
};

for (let key in user) alert(key); // name, toString
```
- `enumerable` 플래그 값 `false` 설정
  - `for…in` 사용 시  커스텀 `toString` 나타나지 않음
```javascript
let user = {
  name: "John",
  toString() {
    return this.name;
  }
};

Object.defineProperty(user, "toString", {
  enumerable: false
});

for (let key in user) alert(key); // name
```
- 열거 불가능 프로퍼티
  - `Object.keys` 배제
```javascript
alert(Object.keys(user)); // name
```

### `configurable` 플래그
- `configurable : false`
  - 몇몇 내장 객체 · 프로퍼티 기본 설정
  - 해당 프로퍼티 객체에서 삭제 X
  - ex) 내장 객체 `Math.PI` 프로퍼티
    - 쓰기 · 열거 · 구성 X
```javascript
let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": 3.141592653589793,
  "writable": false,
  "enumerable": false,
  "configurable": false
}
*/
```
- 코드 사용해 `Math.PI` 값 변경 · 덮어쓰기 · 삭제 X
```javascript
Math.PI = 3; // Error
```
- `configurable : false`
  - 돌이킬 방법 X
  - `defineProperty` 사용해도 값 `true` X
- 구체적 제약사항
  - `configurable` 플래그 수정 X
  - `enumerable` 플래그 수정 X
  - `writable`
    - `false` → `true` &nbsp;&nbsp;X
    - `true` &nbsp;&nbsp;→ `false` O
  - 접근자 프로퍼티 `get` · `set` 변경 X
    - 새롭게 생성 O
- “영원히 변경할 수 없는” 프로퍼티 생성 가능
```javascript
let user = { };

Object.defineProperty(user, "name", {
  value: "John",
  writable: false,
  configurable: false
});

/*
 user.name 프로퍼티 값 · 플래그 변경 X
 변경 시도 시 에러 발생
 - user.name = "Pete"
 - delete user.name
 - Object.defineProperty(user, "name", { value: "Pete" })
 */
Object.defineProperty(user, "name", {writable: true}); // Error
```

#### "non-configurable"은 "non-writable"과 다릅니다.
- `configurable` : `false`
  - `writable` : `true` → 프로퍼티 값 변경 가능
  - 플래그 값 변경 · 프로퍼티 삭제 막기 위해 존재
  - 프로퍼티 값 변경 막기 X

### `Object.defineProperties`
- 프로퍼티 여러 개 한 번에 정의
```javascript
Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2
  // ...
});
```
```javascript
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
  // ...
});
```

### `Object.getOwnPropertyDescriptors`
- 프로퍼티 설명자 전부 한꺼번 가져옴
- `Object.defineProperties` 함께 사용 시 객체 · 플래그 함께 복사
- 심볼형 프로퍼티 포함한 프로퍼티 설명자 전체 반환
```javascript
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
```
- 할당 연산자
  - 플래그 복사 X
- `for…in`
  - 심볼형 프로퍼티 X
```javascript
for (let key in user) {
  clone[key] = user[key]
}
```

### 객체 수정을 막아주는 다양한 메서드
- 실무에서 드물게 사용
- 한 객체 내 프로퍼티 전체 대상 제약사항 설정
  - `Object.preventExtensions(obj)`
    - 객체 새로운 프로퍼티 추가 X
  - `Object.seal(obj)`
    - 새로운 프로퍼티 추가 · 기존 프로퍼티 삭제 X
    - 프로퍼티 전체 `configurable: false` 설정 동일 효과
  - `Object.freeze(obj)`
    - 새로운 프로퍼티 추가 · 기존 프로퍼티 삭제 · 수정 X
    - 프로퍼티 전체 `configurable: false`, `writable: false` 설정 동일 효과
- 제약사항 확인
  - `Object.isExtensible(obj)`
    - 새로운 프로퍼티를 추가 X
      - `false`
    - 새로운 프로퍼티를 추가 O
      - `true`
  - `Object.isSealed(obj)`
    - 프로퍼티 추가 · 삭제 X, 모든 프로퍼티 `configurable: false`
      - `true`
  - `Object.isFrozen(obj)`
    - 프로퍼티 추가 · 삭제 · 변경 X, `configurable: false` · `writable: false`
      - `true`

<br />

프로퍼티 getter와 setter
=======================

- 객체 프로퍼티 두 종류
  - 데이터 프로퍼티 (data property)
  - 접근자 프로퍼티 (accessor property)
    - 본질 : 함수
      - 값 획득 (get) · 설정 (set)
    - 외부 코드에서 함수 아닌 일반적인 프로퍼티처럼 보임

### getter와 setter
- `getter` (획득자) · `setter` (설정자)’ 메서드
- 객체 리터럴 안 `getter` · `setter` 메서드
  - `get` · `set`
```javascript
let obj = {

  // getter, obj.propName
  // 프로퍼티 읽을 때 실행
  get propName() { },

  // setter, obj.propName = value
  // 프로퍼티 값 할당 시 실행
  set propName(value) { }
};
```
```javascript
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

alert(user.fullName); // John Smith

// 주어진 값 사용해 set fullName 실행
user.fullName = "Alice Cooper";

alert(user.name);     // Alice
alert(user.surname);  // Cooper
```
- 바깥 코드 접근자 프로퍼티 일반 프로퍼티처럼 사용
- 함수처럼 호출 X, 일반 프로퍼티 값 접근처럼 평범하게 사용
  - 나머지 작업 `getter` · `setter` 메서드 뒷단 처리
- `getter` · `setter` 메서드 구현 시 `fullName` 가상 프로퍼티
  - 읽기 · 쓰기 가능, 존재 X

### 접근자 프로퍼티 설명자
- 데이터 프로퍼티 설명자 · 접근자 프로퍼티 설명자 상이
  - `value` · `writable` X
  - `get`
    - 인수 없는 함수
    - 프로퍼티 읽을 때 동작
  - `set`
    - 인수 하나 함수
    - 프로퍼티 값 쓸 때 호출
  - `enumerable`
    - 데이터 프로퍼티 동일
  - `configurable`
    - 데이터 프로퍼티 동일
- `defineProperty` 설명자 `get` · `set` 전달
  - `fullName` 접근자 생성
```javascript
let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName);            // John Smith

for(let key in user) alert(key); // name, surname
```
- 프로퍼티
  - 접근자 프로퍼티 (`get` · `set`) · 데이터 프로퍼티 (value) 중 한 종류만 가능
  - 둘 다 설정
    - 에러 발생
```javascript
// Error: Invalid property descriptor.
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
```

### `getter` · `setter` 똑똑하게 활용하기
- 실제 프로퍼티 값 감싸는 래퍼 (wrapper) 처럼 사용
  - 프로퍼티 값 원하는 대로 통제
```javascript
let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요.");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = "";   // 너무 짧은 이름을 할당하려 함
```
- `user` 이름
  - `_name` 저장
- 프로퍼티 접근
  - `getter` · `setter` 통해 진행
- 기술적으로 외부 코드 `user._name` 사용해 바로 접근 가능
  - 관습 : 밑줄 `_` 시작 프로퍼티 객체 내부에서만 활용, 외부 간섭 X

### 호환성을 위해 사용하기
- 접근자 프로퍼티 `getter` · `setter` 사용해 데이터 프로퍼티 행동 · 값 원하는 대로 조정
- 데이터 프로퍼티 `name` · `age` 사용자 객체 구현
```javascript
function User(name, age) {
  this.name = name;
  this.age = age;
}

let john = new User("John", 25);

alert( john.age ); // 25
```
- 요구사항 바뀌어 `age` 대신 `birthday` 저장
```javascript
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let john = new User("John", new Date(1992, 6, 1));
```
- 생성자 함수 수정 시 기존 코드 중 프로퍼티 `age` 사용 코드 전부 수정
  - 시간 오래 소모
  - 여러 사람 `age` 사용 시 모두 찾아 수정 힘듦
  - `user` 안 `age` 있어도 나쁠 것 없음
- `age` 위한 `getter` 추가
```javascript
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // age 현재 날짜 · 생일 기준 계산
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // birthday 사용
alert( john.age );      // age 사용
```
