원시값의 메서드
==============

- 원시값
  - 원시형 값
  - 종류
    - string
    - number
    - bigint
    - boolean
    - symbol
    - null
    - undefined
- 객체
  - 프로퍼티 다양한 종류 값 저장
  - 중괄호 {} 생성
  - 함수 ≒ 객체
  - 함수 프로퍼티
  - 다양한 내장 객체 (고유 프로퍼티 · 메서드 보유)
    - 날짜
    - 오류
    - HTML 요소 (HTML element) 등
  - 시스템 자원 소모량 多
  - 원시값보다 heavy, 내부 구조 유지 위해 추가 자원 사용

### 원시값 객체처럼 사용하기
- "원시 래퍼 객체 (object wrapper)"
  - 원시값 메서드 · 프로퍼티 접근 시 추가 기능 제공
  - String
  - Number
  - Boolean
  - Symbol
```javascript
let str = "Hello";
alert( str.toUpperCase() ); // HELLO
```
1. 문자열 str : 원시값
    - 원시값 프로퍼티 (toUpperCase) 접근 시 특별한 객체 (String) 생성
      - 특별한 객체 (String) :  문자열 값 알고 있음, 유용한 메서드 보유
2. 메서드 실행 후 새로운 문자열 반환
3. 특별한 객체 파괴, 원시값 str만 남음

#### String / Number / Boolean 생성자 사용 X
- Java 등의 몇몇 언어에선 new Number(1) 또는 new Boolean(false)와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있습니다.

- 자바스크립트 하위 호환성 위해 래퍼 객체 생성자 호출 가능
  - 비추천 (혼동)
```javascript
// 자료형 혼동
alert( typeof 0 );             // "number"
alert( typeof new Number(0) ); // "object"!

// 객체 논리 평가 시 항상 true 반환
let zero = new Number(0);
if (zero) { // 변수 zero == 객체, 조건문 참
  alert( "그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!" );
}
```
- new 없이  String / Number / Boolean 사용 OK
  - 상식 맞게 인수 원하는 형 원시값 변환
```javascript
let num = Number("123"); // 문자열 → 숫자
```
#### null / undefined 메서드 없음
- 특수 자료형 null · undefined 원시값
  - null · undefined
  - 자료형 연관 "래퍼 객체" X
  - 메서드 X
  - "가장 원시적" 자료형
  - 프로퍼티 접근 시 에러 발생
```javascript
alert(null.test); // error
```

<br />

숫자형
=====

- 일반적인 숫자
  - '배정밀도 부동소수점 숫자 (double precision floating point number)'
  - 64비트 형식 IEEE-754 저장
  - -253 < x < 253 범위 제약

- BigInt
  - 임의 길이 정수
  - 아주 특별한 경우에만 사용

### 숫자를 입력하는 다양한 방법
- 숫자 옆 'e' · '-e' → '0' 개수
```javascript
// 10 거듭제곱
1e3    === 1    * 1000
1.23e6 === 1.23 * 1000000

// 음수 10 거듭제곱
1e-3    === 1    / 1000    // 0.001
1.23e-6 === 1.23 / 1000000 // 0.00000123
```

#### 16진수, 2진수, 8진수
- 16진수
  - 다양한 곳 두루 사용
    - 색 표현
    - 문자 인코딩 등
  - '0x'
- 2진수 · 8진수
  - 아주 드물게 사용
  -  '0b' · '0o'
```javascript
// 16진수
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자 구별 X)

// 2진수, 8진수
let a = 0b11111111; // 255의 2진수
let b = 0o377;      // 255의 8진수
alert( a == b );    // true, (진법만 상이)
```

### toString(base)
- base진법 표현 후 문자형 변환 · 반환
```javascript
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
- base
  - 2 ~ 36
  - 기본값 : 10
  - 유스 케이스
    - base = 16
      - 숫자 : 0 ~ 9
      - 10 이상 : A ~  F
      - 16진수 색, 문자 인코딩 등 표현
    - base = 2
      - 숫자 : 0, 1
      - 연산 디버깅 주 사용
    - base = 36
      - 숫자 : 0 ~ 9
      - 10 이상 : A ~ Z
      - 긴 숫자 식별자 축약
        - url 축약 등
```javascript
// base = 36

// 점 2개
alert( 123456..toString(36) );  // 2n9c

// 괄호
alert( (123456).toString(36) ); // 2n9c
```
#### 점 두 개와 메서드 호출
- 숫자 대상 메서드 toString 직접 호출
  - 점 2개 사용
  - 점 1개 사용 시
    - 첫 번째 점 이후 소수부 인식 후 에러 발생 가능
    - 점 하나 더 추가 시 소수부 없다고 판단, 함수 호출
    - 대신 괄호 사용 가능

### 어림수 구하기
- 어림수 관련 내장 함수
  - Math.floor
    - 소수점 첫째 자리 내림(버림)
    - 3.1 → 3
    - -1.1 → -2
  - Math.ceil
    - 소수점 첫째 자리 올림
    - 3.1 → 4
    - -1.1 → -1
  - Math.round
    - 소수점 첫째 자리 반올림
    - 3.1 → 3
    - 3.6 → 4
    - -1.1 → -1
  - Math.trunc (Internet Explorer 미지원)
    - 소수부 무시
    - 3.1 → 3
    - -1.1 → -1

||Math.floor|Math.ceil|Math.round|Math.trunc|
|:---:|:---:|:---:|:---:|:---:|
|3.1|3|4|3|3|
|3.6|3|4|4|3|
|-1.1|-2|-1|-1|-1|
|-1.6|-2|-1|-2|-1|

#### 소수점 n-th번째 수 기준 어림수
- ① 곱하기와 나누기
  1. '숫자 * (n*10)'
  2. 어림수 내장 함수 호출
  3. '숫자 / (n*10)'
```javascript
// 소수점 2번째 수 기준
let num = 1.23456;

// 1.23456 → 123.456 → 123 → 1.23
alert( Math.floor(num * 100) / 100 );
```

- ② toFixed(n)
  - 가장 가까운 값 올림 · 버림
    - Math.round 유사
  - 반환 값 : 문자열
    - 단항 덧셈 연산자 · Number() : 숫자형 변환
  - 소수부 길이 < 인수 : 끝에 0 추가
```javascript
let num1 = 12.34;
alert( num1.toFixed(1) ); // "12.3"
let num2 = 12.36;
alert( num2.toFixed(1) ); // "12.4"

// 숫자형 변환
alert( +num2.toFixed(1) ); // 12.4
alert( Number(num2.toFixed(1)) ); // 12.4

//소수부 길이 < 인수
let num3 = 12.34;
alert( num3.toFixed(5) ); // "12.34000" (소수부 길이 5 맞춤)
```

### 부정확한 계산
- 숫자 내부적으로 64비트 형식 IEEE-754 표현
  - 숫자 저장 시 정확히 64비트 필요
    - 52비트 : 숫자 저장
    - 11비트 : 소수점 위치 (정수 : 0)
    - 1비트 : 부호 저장
  - 숫자 너무 커지면 64비트 공간 넘쳐 Infinity 처리
```javascript
alert( 1e500 ); // Infinity
```
#### 정밀도 손실 (loss of precision)
```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1 + 0.2 );        // 0.30000000000000004
```
- 숫자 0, 1 이루어진 이진수 변환되어 연속된 메모리 공간 저장
- 분수 : 이진법 표현 시 무한 소수 (10진법 쉽게 표현)
  - 2진법 체계
    - 2의 거듭제곱 나눈 값 잘 동작
    - 2의 거듭제곱 아닌 값 나누면 무한 소수
  -  2진법 0.1 · 0.2 정확하게 저장 방법 X
  - IEEE-754 : 가능한 가장 가까운 숫자 반올림 방법 사용해 문제 해결
    - 반올림 규칙 적용 시 '작은 정밀도 손실’ 발생
    ```javascript
    alert( 0.1.toFixed(20) ); // 0.10000000000000000555
    ```
    - 숫자 덧셈 시 '정밀도 손실’도 덧셈
  - 문제 해결
    - ⓐ toFixed(n) 메서드 사용해 어림수 생성
      - 항상 문자열 반환
      - 소수점 다음 숫자 항상 항상 인수 갯수
      - 단항 덧셈 연산자 : 숫자형 형 변환
    ```javascript
    let sum = 0.1 + 0.2;
    alert( sum.toFixed(2) ); // 0.30

    // 단항 덧셈 연산자 (숫자형 형 변환)
    alert( +sum.toFixed(2) ); // 0.3
    ```
    - ⓑ 10 거듭제곱 곱 / 나누기
      1. 숫자에 임시 10 거듭제곱 곱하여 정수 변환
      2. 연산
      3. 다시 10 거듭제곱 나누기
      - 정수 대상 수학 연산 : 비교적 에러 小
      - 마지막 나눗셈 : 소수 다시 등장
        - 오류 완전 제거 X
      ```javascript
      alert( (0.1 * 10 + 0.2 * 10) / 10 );     // 0.3
      alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
      ```
  - 무한소수 방지 완벽 방법 X
    - 필요 때마다 '꼬리’ 잘라 어림수 생성

#### 흥미로운 발견
```javascript
alert( 9999999999999999 ); // 10000000000000000
```
- 정밀도 손실
  - 숫자 저장 52비트 공간 모자람
    - 최소 유효 숫자 (the least significant digit) 손실
- 자바스크립트 숫자 손실 발생해도 오류 발생 X
  - 적절한 포맷으로 숫자 맞추는 데 최선

#### 두 종류의 0
- 0, -0 존재
  - 숫자 부호 단일 비트 저장
  - 0 포함 모든 숫자 부호 설정 가능
  - 대부분의 연산 0, -0 동일 취급 → 차이 두드러지지 않는 편

### isNaN과 isFinite
- Infinity · -Infinity : 그 어떤 숫자보다 큰 · 작은 특수 숫자 값
- NaN : 에러 표현 값
- 숫자형, but ‘비정상적인’ 숫자
- 구분 위한 특별 함수 존재
  - isNaN(value)
    - 인수 숫자 변환 후 NaN 테스트
  ```javascript
  alert( isNaN(NaN) );   // true
  alert( isNaN("str") ); // false

  // 자기 자신 포함 그 어떤 값과도 동일 X (함수 필요 이유)
  alert( NaN === NaN );  // false
  ```
  - isFinite(value)
    - 인수 숫자 변환 후 일반 숫자 경우 true 반환
  ```javascript
  alert( isFinite("15") );     // true
  alert( isFinite("str") );    // false
  alert( isFinite(Infinity) ); // false

  // 종종 문자열 일반 숫자 검증에 사용
  // 숫자 아닌 값 · Infinity · -Infinity 입력 시 false
  let num = +prompt("숫자를 입력하세요.", '');
  alert( isFinite(num) );
  ```
- 빈 문자열 · 공백만 있는 문자열 ("")
  - isFinite 포함 모든 숫자 관련 내장 함수 0 취급

#### Object.is와 비교하기
- Object.is
  - 값 비교 특별 내장 메서드
  - 예외 제외 '===' 전부 동일
  ```javascript
  // 예외
  Object.is(NaN, NaN) // true
  Object.is(0, -0)    // false
  ```

### parseInt와 parseFloat
- 단항 덧셈 연산자 '+' · Number() 사용 숫자형 변환 시 규칙 엄격 적용
  - 피연산자 숫자 아니면 형 변환 실패
  - 엄격 규칙 미적용 : 문자열 처음 · 끝 공백 무시
  ```javascript
  alert( +"100px" ); // NaN
  ```
- parseInt, parseFloat
  - 불가능할 때까지 문자열 숫자 읽음<br />숫자 읽는 도중 오류 발생 시 이미 수집된 숫자 반환
    - parseInt : 정수
    - parseFloat : 부동 소수점 숫자
    ```javascript
    alert( parseInt('100px') );    // 100
    alert( parseFloat('12.5em') ); // 12.5

    alert( parseInt('12.3') );     // 12 (정수 부분만 반환)
    alert( parseFloat('12.3.4') ); // 12.3 (두 번째 점 숫자 읽기 멈춥)
    ```
  - NaN 반환 : 읽을 수 있는 숫자 없을 시
  ```javascript
  alert( parseInt('a123') ); // NaN
  ```

####parseInt(str, radix)의 두 번째 인수
- parseInt 두 번째 매개 변수
  - 진수 지정
  ```javascript
  alert( parseInt('0xff', 16) ); // 255
  alert( parseInt('ff', 16) );   // 255 (0x 없이도 동작)
  alert( parseInt('2n9c', 36) ); // 123456
  ```

### 기타 수학 함수
- 내장 객체 Math
  - 다양한 수학 관련 함수, 상수 보유
    - Math.random()
      - 0 ~ 1 사이 난수 반환 (1 제외)
      ```javascript
      alert( Math.random() ); // 0.1234567894322
      alert( Math.random() ); // 0.5435252343232
      alert( Math.random() ); // ... (무작위 수)
      ```

    - Math.max(a, b, c...) / Math.min(a, b, c...)
      - 인수 중 최대 · 최솟값 반환
      ```javascript
      alert( Math.max(3, 5, -10, 0, 1) ); // 5
      alert( Math.min(1, 2) );            // 1
      ```
    - Math.pow(n, power)
      - n을 power번 거듭제곱 값 반환
      ```javascript
      alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
      ```

<br />

문자열
=====

- 페이지 인코딩 방식 상관없이 항상 UTF-16 형식

### 따옴표

- 작은따옴표 (")
- 큰따옴표 　(')
- 백틱　　　 (`)
  - 템플릿 리터럴 (template literal)
    - ${…}
  ```javascript
  function sum(a, b) {
    return a + b;
  }
  alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
  ```
    - 문자열 여러 줄 걸쳐 작성
    ```javascript
    let guestList = `손님:
    * John
    * Pete
    * Mary
    `;
    ```
      - 작은따옴표, 큰따옴표 여러줄 문자열 X
  - 템플릿 함수 (template function)
    - 첫 번째 백틱 바로 앞 함수 이름 존재 시 함수 백틱 안 문자열 조각 · 표현식 평가 결과 인수로 받아 자동 호출
      - ex) func`string`
      - '태그드 템플릿(tagged template)'
      - 드물게 사용

### 특수 기호

|특수 문자|설명|
|---|---|
|\n|줄 바꿈|
|\r|캐리지 리턴(carriage return)<br />Windows에서 캐리지 리턴, 줄 바꿈 특수 문자 조합해 줄 바꿈<br />- (\r\n)<br />캐리지 리턴 단독 사용 경우 X|
|\\' · \\"|따옴표|
|\\\\ |역슬래시|
|\t|탭|
|b · \f · \v|백스페이스 (Backspace)<br />폼 피드 (Form Feed)<br />세로 탭 (Vertical Tab)<br />- 호환성 유지 위해 남아있는 기호 (요즘 사용 X)|
|\xXX|16진수 유니코드 XX로 표현한 유니코드 글자<br />- ex) 알파벳 'z' → '\x7A'|
|\uXXXX|UTF-16 인코딩 규칙 사용 16진수 코드 XXXX로 표현한 유니코드 기호<br />XXXX 반드시 네 개의 16진수 구성<br />- ex) \u00A9 → 저작권 기호 © 유니코드|
|\u{X…XXXXXX}<br />(1개 ~ 6개 사이 16진수 글자)|UTF-32 표현 유니코드 기호<br />몇몇 특수 글자 두 개의 유니코드 기호 사용해 인코딩되므로 4바이트 차지<br />이 방법 사용 시 긴 코드 삽입 가능|
- 유니코드
```javascript
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫, 중국어(긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호(긴 유니코드)
```
- 모든 특수 문자 역슬래시 \ 시작
  - '이스케이프 문자 (escape character)'
- 문자열 내 따옴표
```javascript
alert( 'I\'m the Walrus!' ); // 역슬래시
alert( `I'm the Walrus!` );  // 백틱
```
- 문자열 안 역슬래시 \ 표시
  - \\\\
```javascript
alert( `역슬래시: \\` ); // \
```

### 문자열의 길이
- length 프로퍼티
```javascript
// '\n' : ‘특수 문자’ 1개 → 길이 1
alert( `My\n`.length ); // 3
```
### 특정 글자에 접근하기
- 대괄호[] · charAt(pos) 메서드
  - 위치 0부터 시작
```javascript
let str = `Hello`;

// 첫 번째 글자
alert( str[0] );        // H
alert( str.charAt(0) ); // H

// 마지막 글자
alert( str[str.length - 1] ); // o
```
- 대괄호[] 선호
- charAt 하위 호환성 위해 남아있는 메서드
- 접근 위치 글자 없는 경우
  - 대괄호[] → undefined
  - charAt　→ 빈 문자열
```javascript
let str = `Hello`;

alert( str[1000] );        // undefined
alert( str.charAt(1000) ); // '' (빈 문자열)
```
- for..of
  - 문자열 구성 글자 대상 반복 작업
```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o
}
```

### 문자열의 불변성
- 문자열 수정 불가능
- 문자열 중간 글자 하나 수정 시 에러 발생
  - 완전히 새로운 문자열 생성 후 할당
```javascript
let str1 = 'Hi';

str1[0] = 'h';    // Error: Cannot assign to read only property '0' of string 'Hi'
alert( str1[0] ); // 동작 X

let str2 = 'Hi';

str2 = 'h' + str2[1]; // 문자열 전체 교체
alert( str2 );        // hi
```

### 대·소문자 변경하기
- toLowerCase() · toUpperCase()
  - 대문자 ↔ 소문자
```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

// 글자 하나만 변경
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

### 부분 문자열 찾기

#### str.indexOf(substr, pos)
- 문자열 str의 pos에서부터 시작
- 부분 문자열 substr 어디 위치하는지 검색
- 원하는 부분 문자열 찾으면 위치 반환, 그렇지 않으면 -1 반환
```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0 ('Widget' with id)
alert( str.indexOf('widget') ); // -1, indexOf : 대·소문자 따짐
alert( str.indexOf("id") );     // 1, (W'id'get with id)
```
- 두 번째 매개변수 pos
  - 선택적 사용
  - 해당 위치 검색 시작
```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12 (Widget with id)
                              //       ↑ 검색 시작
```
- 문자열 내 부분 문자열 전체 대상 작업
  - 반복문 안 indexOf 사용
```javascript
let str = 'As sly as a fox, as strong as an ox';
let target = 'as';
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `위치: ${foundPos}` );
  pos = foundPos + 1; // 다음 위치 기준 검색 이어 시작
}

↓↓↓

let str = "As sly as a fox, as strong as an ox";
let target = "as";
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```
#### str.lastIndexOf(substr, position)
- 문자열 끝에서부터 부분 문자열 검색
- 반환 부분 문자열 위치
  - 문자열 끝 기준

#### if문 조건식 indexOf 주의 점
- if문 : 0 → false 간주
  - -1과 비교
```javascript
let str = "Widget with id";

// if(0) → false
if (str.indexOf("Widget")) {
  alert("찾았다!");
}

// -1 비교
if (str.indexOf("Widget") != -1) {
    alert("찾았다!"); // 의도한 대로 동작합니다.
}
```

#### 비트 NOT '~' 연산자를 사용한 기법
- 오래전부터 전해 오는 방법
- 피연산자 32비트 정수 변환 후 (소수부 모두 버려짐) 모든 비트 반전
  - ~n → -(n+1)
```javascript
alert( ~2 );  // -3 → -( 2+1)
alert( ~1 );  // -2 → -( 1+1)
alert( ~0 );  // -1 → -( 0+1)
alert( ~-1 ); //  0 → -(-1+1)
              // (n == 0 유일)
```
- ~-1 응용 (n == 0)
- 직관적 X → 비권장
```javascript
let str = "Widget";
if (~str.indexOf("Widget")) {
  alert( '찾았다!' );
}
```
- ~4294967295 == 0
  - 아주 긴 문자열 주의

#### includes, startsWith, endsWith
- 비교적 근래 나온 메서드
- str.includes(substr, pos)
  - str에 부분 문자열 substr 있으면 true, 없으면 false
    - 위치 정보 X, 포함 여부
  - 두 번째 인수
    - 해당 위치부터 부분 문자열 검색
```javascript
alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") );             // false
alert( "Widget".includes("id") );             // true
alert( "Widget".includes("id", 3) );          // false (3번째 위치 이후 "id" 없음)
```
- str.startsWith · str.endsWith
- str이 특정 문자열 시작 · 종료 여부 확인
```javascript
alert( "Widget".startsWith("Wid") ); // true
alert( "Widget".endsWith("get") );   // true
```

### 부분 문자열 추출하기
- 부분 문자열 추출 관련 메서드
  - substring
  - substr
  - slice
#### str.slice(start [, end])
- 문자열 start ~ end 까지 (end 미포함) 반환
```javascript
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin'
alert( str.slice(0, 1) ); // 's'
```
- 두 번째 인수 생략 시 명시 위치 ~ 문자열 끝 반환
```javascript
let str = "stringify";
alert( str.slice(2) ); // ringify
```
- start · end 음수 가능
  - 문자열 끝에서부터 카운팅 시작
```javascript
let str = "stringify";
alert( str.slice(-5, -1) ); // ngif
                        // stringify
                        //     ↑ ~ ↑
                        //    -5  -1
```

#### str.substring(start [, end])
- start · end 사이 문자열 반환
- slice 아주 유사
  - 차이 : start > end 가능
    - 음수 인수 허용 X
    - 음수 → 0 처리
```javascript
let str = "stringify";

alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

alert( str.slice(2, 6) ); // "ring"
alert( str.slice(6, 2) ); // ""
```

#### str.substr(start [, length])
- start ~, length 개 글자 반환
  - 첫 번째 인수 음수
    - 뒤에서부터 카운트
```javascript
let str = "stringify";
alert( str.substr(2, 4) ); // ring

let str = "stringify";
alert( str.substr(-4, 2) ); // gi
```


|메서드|추출 부분 문자열|음수 허용 여부(인수)|
|---|---|---|
|slice(start, end)|start ~ end 까지 (end 미포함)|음수 허용|
|substring(start, end)|start ~ end 사이|음수 0 취급|
|substr(start, length)|start ~, length개|음수 허용|

#### 어떤 메서드를 선택해야 하나요?
- 모두 사용 OK
- substr 단점
  - 구식 스크립트 대응 위해 남겨 둔 브라우저 전용 기능들 명시 부록 B(Annex B) 정의
    - 거의 모든 곳 메서드 동작
    - 브라우저 이외 호스트 환경 제대로 동작 X 가능성 有

### 문자열 비교하기
- 알파벳 순서 기준 글자끼리 비교
- 모든 문자열 UTF-16 사용해 인코딩
  - UTF-16 모든 글자 → 숫자 형식 코드 매칭
#### str.codePointAt(pos)
- pos 위치 글자 코드 반환
```javascript
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
```
#### String.fromCodePoint(code)
- 숫자 형식 code 대응 글자 생성
- '\u' 뒤 특정 글자 대응 16진수 코드 붙이는 방식 가능
```javascript
alert( String.fromCodePoint(90) ); // Z

// 90 16진수 변환 → 5a
alert( '\u005a' ); // Z
```
- 예외 사항
  - 소문자 > 대문자
  - 발음 구별 기호 (diacritical mark) 붙은 문자 알파벳 순서 기준 X
```javascript
// 소문자 > 대문자
alert( 'a' > 'Z' ); // true

// 발음 구별 기호
alert( 'Österreich' > 'Zealand' ); // true

// 예외 사항 이유
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}

alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```
- 글자 대응 숫자 형식 코드 기준 비교
  - 코드 큼 → 대응 글자 큼

#### 문자열 제대로 비교하기
- 언어마다 문자 체계 다름
  -  문자열비교 알고리즘 생성 어려움
- 문자열 비교 위해 페이지 사용 언어 브라우저 인식 필요
  - 모던 브라우저 대부분 국제화 관련 표준 ECMA-402 지원
    - 언어 다를 시 적용 문자열 비교 규칙, 규칙 준수 메서드 정의
      - ex) str.localeCompare(str2)
        - str &nbsp;< &nbsp;str2 → 음수
        - str &nbsp;> &nbsp;str2 → 양수
        - str == str2 → 0
      ```javascript
      alert( 'Österreich'.localeCompare('Zealand') ); // -1
      ```

### 문자열 심화

#### 서로게이트 쌍
- 자주 사용 글자들 모두 2바이트 코드 보유
  - 유럽권 언어 글자, 숫자, 상형 문자 대다수 2바이트 표현 체계 사용
  - 2바이트 65,536(2의 16승)개 조합 외 불가
    - 현존 기호 모두 표현 불충분
- '서로게이트 쌍 (surrogate pair)'
  - 제약 극복 위해 사용 빈도 낮은 기호 2바이트 글자 쌍 사용해 인코딩
  - 서로게이트 쌍 사용해 인코딩한 기호 길이 : 2
  ```javascript
  alert( '𝒳'.length );  // 2, 수학에서 쓰이는 대문자 X
  alert( '😂'.length ); // 2, 웃으면서 눈물 흘리는 얼굴 이모티콘
  alert( '𩷶'.length );  // 2, 사용 빈도 낮은 중국어 (상형문자)
  ```
  - 자바스크립트 초기 서로게이트 쌍 미존재
    - 서로게이트 쌍 표현 기호 제대로 처리 X
  - String.fromCodePoint · str.codePointAt
    - 명세서 추가된 지 얼마 안 된 메서드
    - 서로게이트 쌍 제대로 처리 몇 안 되는 메서드
    - 두 메서드 등장 전 String.fromCharCode · str.charCodeAt 사용
      - fromCodePoint · codePointAt 동일 동작
      - 서로게이트 쌍 처리 X
  - 서로게이트 쌍 두 글자 취급
    - 기호 가져오기 까다로움
    - 서로게이트 쌍 구성 글자들 붙어있을 때만 의미 有
    ```javascript
    alert( '𝒳'[0] ); // 이상한 기호 출력
    alert( '𝒳'[1] ); // 서로게이트 쌍 일부 출력
    ```
  - 기술적으로 서로게이트 쌍 대응 코드 사용해 감지 가능
    - 글자 코드 0xd800 ~ 0xdbff 사이 있으면 이 코드 서로게이트 쌍 구성하는 첫 번째 글자 표현 의미
    - 서로게이트 쌍 구성 두 번째 글자 코드 반드시 0xdc00 ~ 0xdfff 사이 존재
    - 범위 0xd800 ~ 0xdbff · 0xdc00 ~ 0xdfff
      - 표준에서 서로게이트 쌍 위해 일부러 비워둔 코드
    ```javascript
    // charCodeAt 서로게이트 쌍 처리 X
    // → 서로게이트 쌍 구성 부분 코드 반환
    alert( '𝒳'.charCodeAt(0).toString(16) ); // d835 (0xd800 ~ 0xdbff 사이 코드)
    alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3 (0xdc00 ~ 0xdfff 사이 코드)
    ```

#### 발음 구별 기호와 유니코드 정규화
- 여러 언어 베이스 글자 위 · 아래 발음 구별 기호 붙여 글자 구성
  - ex) a → àáâäãåā
- 이런 ‘합성’ 글자 대부분 UTF-16 테이블 독자적인 코드 보유
- 모든 합성 글자 코드 부여 X
  - 조합 가능 글자 수 너무 많음
- 임의 조합 지원 위해 UTF-16 몇 개 유니코드 문자 남겨둠
  - 베이스 글자 뒤 하나 ~ 여러 개 유니코드 문자 붙여 베이스 글자 꾸밈
  - ex) S + \u0307 (유니코드 문자) → Ṡ
  ```javascript
  alert( 'S\u0307' ); // Ṡ
  ```
  - 발음 구별 기호 하나 붙인 상태에서 추가 발음 구별 기호
    - 필요 기호 유니코드 문자 붙여주기
    - ex) Ṡ + \u0323 (유니코드 문자) → Ṩ
  ```javascript
  alert( 'S\u0307\u0323' ); // Ṩ
  ```
  - 엄청난 유연성 제공
  - 단점
    - 눈에 같은 글자, but 유니코드 조합 다름
    ```javascript
    let s1 = 'S\u0307\u0323'; // Ṩ (S + 윗 점 + 아랫 점)
    let s2 = 'S\u0323\u0307'; // Ṩ (S + 아랫 점 + 윗 점)

    alert( `s1: ${s1}, s2: ${s2}` );

    alert( s1 == s2 ); // 눈에 같은 글자, but 동등 비교 시 false
    ```
    - 해결
      - '유니코드 정규화 (unicode normalization)' 알고리즘 사용해 각 문자열 동일한 형태로 '정규화’
      - 유니코드 정규화 알고리즘 str.normalize() 구현
      ```javascript
      alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

      // 3개 글자 하나로 결합
      // Ṩ '\u1e68' (유니코드)
      alert( "S\u0307\u0323".normalize().length );      // 1
      alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
      ```
    - 현실
      - Ṩ → 하나 유니코드 결합
        - UTF-16 작업자들 Ṩ '충분히 나타날 수 있는 사례’ 생각하고 UTF-16 테이블 포함 · 코드 부여
    - 실무
      - 유니코드 표준 부록 Unicode Normalization Forms 해당 내용

<br />

배열
====

- 순서 컬렉션 저장 자료구조

### 배열 선언
- 대부분 두 번째 방법 선호
```javascript
let arr = new Array();
let arr = [];
```
- 대괄호 안 초기 요소 삽입
```javascript
let fruits = ["사과", "오렌지", "자두"];
```
- 각 배열 요소 숫자 (인덱스) : 0 ~
  - 배열 내 순서
- 배열 내 특정 요소 얻기
  - 대괄호 안 인덱스
```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

// 배열 내 특정 요소 수정
fruits[2] = '배'; ["사과", "오렌지", "배"]

// 새로운 요소 추가
fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]

// 배열 요소 갯수
alert( fruits.length ); // 4

// 요소 전체 출력
alert( fruits ); // 사과,오렌지,배,레몬
```
- 배열 요소 자료형 제약 X
```javascript
let arr = [
  '사과',
  { name: '이보라' },
  true,
  function() { alert('안녕하세요.'); }
];

// 인덱스 1 요소 (객체) name 프로퍼티
alert( arr[1].name ); // 이보라

// 인덱스 3 요소 (함수) 실행
arr[3]();             // 안녕하세요.
```

#### trailing 쉼표
- 배열 마지막 요소 : 쉼표 사용 가능
- 모든 줄 생김새 유사
  - 요소 추가 · 삭제 용이
```javascript
let fruits = [
  "사과",
  "오렌지",
  "자두",
];
```

### pop·push와 shift·unshift
- 큐 (queue)
  - 배열 사용해 만드는 대표적인 자료구조
  - 선입선출 (First-In-First-Out, FIFO)
  - 순서 있는 컬렉션 저장
  - 큐 주요 연산
    - push : 맨 끝에 요소 추가
    - shift &nbsp;: 제일 앞 요소 꺼내 제거 후 남은 요소들 앞으로 밈
- 스택 (stack)
  - 배열 사용해 만드는 대표적인 자료구조
  - 후입선출 (Last-In-First-Out, LIFO)
  - 스택 주요 연산
    - push : 스택 끝에 요소 삽입
    - pop : 스택 끝 요소 추출
- 배열
  - 큐, 스택 둘다 생성 가능
  - 데큐 (deque, Double Ended Queue)
    - 처음 · 끝 요소 더하기 · 빼기 연산 제공 자료구조

#### 배열 끝 작업 메서드
- pop &nbsp;: 배열 끝 요소 제거 후 제거한 요소 반환
- push : 배열 끝에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// pop
alert( fruits.pop() ); // 배
alert( fruits ); // 사과,오렌지

// push
// fruits.push(...)
// fruits[fruits.length] = ... (동일)
fruits.push("배");
alert( fruits ); // 사과,오렌지,배
```

#### 배열 앞 작업 메서드
- shift 　: 배열 앞 요소 제거 후 제거한 요소 반환
- unshift : 배열 앞에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// shift
alert( fruits.shift() ); // 사과
alert( fruits ); // 오렌지,배

// unshift
fruits.unshift('사과');
alert( fruits ); // 사과,오렌지,배
```
- push · unshift
  - 요소 여러 개 한 번에 더하기 가능
```javascript
let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

alert( fruits ); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

### 배열의 내부 동작 원리
- 특별한 종류의 객체
- 숫자형 키 사용
  - 객체 기본 기능 이외 순서 있는 컬렉션 제어 메서드
  - length 프로퍼티
- 배열 본질 : 객체
```javascript
let fruits = ["바나나"]

let arr = fruits;        // 참조 복사
alert( arr === fruits ); // true

arr.push("배");          // 참조 이용해 배열 수정
alert( fruits );         // 바나나,배
```
#### 배열 특수 내부 표현방식
- 배열 요소 인접한 메모리 공간에 차례로 저장해 연산 속도 ↑
- 이 방법 이외 배열 관련 연산 최적화 기법 다양
- 배열 '순서있는 자료 컬렉션’ X, 일반 객체처럼 다루면 최적화 기법들 제대로 동작 X
```javascript
let fruits = [];
fruits[99999] = 5; // 배열 길이보다 훨씬 큰 숫자 사용해 프로퍼티 생성
fruits.age = 25;   // 임의의 이름 사용해 프로퍼티 생성
```
- 배열 객체이므로 원하는 프로퍼티 추가해도 문제 발생 X
- 자바스크립트 엔진 배열 일반 객체처럼 다루게 되어 배열 최적화 기법이 동작 X
  - 배열 특유 이점 사라짐
    - 숫자 아닌 값 프로퍼티 키로 사용
    ```javascript
    arr.test = 1;
    ```
    - 앞, 끝에만 요소 추가
    ```javascript
    arr[0] = 1;
    arr[1000] = 2;
    ```
    - 요소 역순으로 삽입
    ```javascript
    arr[1000] = 1;
    arr[999] = 2;
    ```
- 배열 사용 시 목적 맞게 사용
- 임의의 키 사용 시 일반 객체 적합

### 성능
- shift · unshift → 느림
  1. 인덱스 0 요소 제거·추가
  2. 모든 요소 좌 · 우 이동
      - 모든 인덱스 1씩 감소 · 증가
  3. length 프로퍼티 값 갱신
  - 배열 요소 많으면 요소 이동 시간 ↑, 메모리 관련 연산 ↑
- push · pop 빠름
  1. 마지막에 요소 추가 · 제거
  2. length 프로퍼티 값 갱신
  - 요소 이동 수반 X
  - 기존 인덱스 그대로 유지

### 반복문
#### for문
  - 배열 순회 가장 오래된 방법
  - 순회시 인덱스 사용
```javascript
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```
#### for..of
  - 요소 값
  - 요소 인덱스 X
```javascript
let fruits = ["사과", "오렌지", "자두"];

for (let fruit of fruits) {
  alert( fruit );
}
```
#### for..in
  - 배열 : 객체형
```javascript
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```
#### for..in 문제점
- 모든 프로퍼티 대상 순회
  - 숫자 키 외 프로퍼티 순회 대상 포함
  - 유사 배열 (array-like) 객체
    - 브라우저 · 기타 호스트 환경 사용 객체
    - length 프로퍼티, 요소 인덱스
    - 숫자형 키 외 프로퍼티 · 메서드 존재 가능
      - for..in 사용 시 이 모든 것 대상 순회 진행
        - ‘필요 없는’ 프로퍼티들 문제 일으킬 가능성 ↑
- 객체에 최적화
  - 배열 사용 시 객체 대비 10 ~ 100배 느림
  - 반복문 속도 빠름 → 병목 지점에서만 문제
- 배열 되도록 for..in 사용 X

