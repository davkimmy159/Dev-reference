원시값의 메서드
==============

- 원시값
  - 원시형 값
  - 종류
    - `string`
    - `number`
    - `bigint`
    - `boolean`
    - `symbol`
    - `null`
    - `undefined`
- 객체
  - 프로퍼티 다양한 종류 값 저장
  - 중괄호 `{…}` 생성
  - 함수 ≒ 객체
  - 함수 프로퍼티
  - 다양한 내장 객체 <sub>(고유 프로퍼티 · 메서드 보유)</sub>
    - 날짜
    - 오류
    - HTML 요소 등
  - 시스템 자원 소모량 多
  - 원시값보다 heavy, 내부 구조 유지 위해 추가 자원 사용

### 원시값 객체처럼 사용하기
- 원시 래퍼 객체
  - 원시값 메서드 · 프로퍼티 접근 시 추가 기능 제공
  - `String`
  - `Number`
  - `Boolean`
  - `Symbol`
```javascript
let str = "Hello";
alert( str.toUpperCase() ); // HELLO
```
1. 문자열 `str` : 원시값
    - 원시값 프로퍼티 `.toUpperCase` 접근 시 특별한 객체 `String` 생성
      - 특별한 객체 `String`
        - 문자열 값 알고 있음
        - 유용한 메서드 보유
2. 메서드 실행 후 새로운 문자열 반환
3. 특별한 객체 파괴, 원시값 `str` 만 남음

#### `String` · `Number` · `Boolean` 생성자 사용 X
- Java 등의 몇몇 언어 `new Number(1)` · `new Boolean(false)` 같은 문법 사용해 원하는 타입 "래퍼 객체" 직접 생성 가능
<br /><br />
- 자바스크립트 하위 호환성 위해 래퍼 객체 생성자 호출 가능
  - 비추천 <sub>(혼동)</sub>
```javascript
// 자료형 혼동
alert( typeof 0 );             // "number"
alert( typeof new Number(0) ); // "object"!

// 객체 논리 평가 시 항상 true 반환
let zero = new Number(0);
if (zero) { // 변수 zero == 객체, 조건문 참
  alert( "그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!" );
}
```
- `new` 없이  `String` · `Number` · `Boolean` 사용 OK
  - 상식 맞게 인수 원하는 형 원시값 변환
```javascript
let num = Number("123"); // 문자열 → 숫자
```

#### `null` · `undefined` 메서드 없음
- 특수 자료형 `null` · `undefined` 원시값
  - `null` · `undefined`
  - 자료형 연관 "래퍼 객체" X
  - 메서드 X
  - "가장 원시적" 자료형
  - 프로퍼티 접근 시 에러 발생
```javascript
alert(null.test); // error
```

<br />

숫자형
=====

- 일반적인 숫자
  - '배정밀도 부동소수점 숫자 (double precision floating point number)'
  - 64비트 형식 IEEE-754 저장
  - -253 < x < 253 범위 제약

- `BigInt`
  - 임의 길이 정수
  - 아주 특별한 경우에만 사용

### 숫자를 입력하는 다양한 방법
- 숫자 옆 `e` · `-e` → `0` 개수
```javascript
// 10 거듭제곱
1e3    === 1    * 1000
1.23e6 === 1.23 * 1000000

// 음수 10 거듭제곱
1e-3    === 1    / 1000    // 0.001
1.23e-6 === 1.23 / 1000000 // 0.00000123
```

#### 16진수, 2진수, 8진수
- 16진수
  - 다양한 곳 두루 사용
    - 색 표현
    - 문자 인코딩 등
  - `0x`
- 2진수 · 8진수
  - 아주 드물게 사용
  -  `0b` · `0o`
```javascript
// 16진수
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자 구별 X)

// 2진수, 8진수
let a = 0b11111111; // 255의 2진수
let b = 0o377;      // 255의 8진수
alert( a == b );    // true, (진법만 상이)
```

### `toString(base)`
- `base` 진법 표현 후 문자형 변환 · 반환
```javascript
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
- `base`
  - 2 ~ 36
  - 기본값 : 10
  - 유스 케이스
    - `base` : 16
      - 숫자 　&nbsp;: 0 ~ 9
      - 10 이상 : A ~  F
      - 16진수 색, 문자 인코딩 등 표현
    - `base` : 2
      - 숫자 : 0, 1
      - 연산 디버깅 주 사용
    - `base` : 36
      - 숫자 　&nbsp;: 0 ~ 9
      - 10 이상 : A ~ Z
      - 긴 숫자 식별자 축약
        - url 축약 등
```javascript
// base = 36

// 점 2개
alert( 123456..toString(36) );  // 2n9c

// 괄호
alert( (123456).toString(36) ); // 2n9c
```

#### 점 두 개와 메서드 호출
- 숫자 대상 메서드 `toString` 직접 호출
  - `.` 2개 사용
  - `.` 1개 사용 시
    - 첫 번째 점 이후 소수부 인식 후 에러 발생 가능
    - 점 하나 더 추가 시 소수부 없다고 판단, 함수 호출
    - 대신 괄호 사용 가능

### 어림수 구하기
- 어림수 관련 내장 함수
  - `Math.floor`
    - 소수점 첫째 자리 내림 <sub>(버림)</sub>
    - `3.1` &nbsp;&nbsp;→ `3`
    - `-1.1` → `-2`
  - `Math.ceil`
    - 소수점 첫째 자리 올림
    - `3.1` &nbsp;&nbsp;→ `4`
    - `-1.1` → `-1`
  - `Math.round`
    - 소수점 첫째 자리 반올림
    - `3.1` &nbsp;&nbsp;→ `3`
    - `3.6` &nbsp;&nbsp;→ `4`
    - `-1.1` → `-1`
  - `Math.trunc` <sub>(Internet Explorer 미지원)</sub>
    - 소수부 무시
    - `3.1` &nbsp;&nbsp;→ `3`
    - `-1.1` → `-1`

||`Math.floor`|`Math.ceil`|`Math.round`|`Math.trunc`|
|:---:|:---:|:---:|:---:|:---:|
|`3.1`|`3`|`4`|`3`|`3`|
|`3.6`|`3`|`4`|`4`|`3`|
|`-1.1`|`-2`|`-1`|`-1`|`-1`|
|`-1.6`|`-2`|`-1`|`-2`|`-1`|

#### 소수점 n-th번째 수 기준 어림수
1. 곱하기 · 나누기
    1. 숫자 * (n * 10)
    2. 어림수 내장 함수 호출
    3. 숫자 / (n * 10)
```javascript
// 소수점 2번째 수 기준
let num = 1.23456;

// 1.23456 → 123.456 → 123 → 1.23
alert( Math.floor(num * 100) / 100 );
```

2. `toFixed(n)`
    - 가장 가까운 값 올림 · 버림
      - `Math.round` 유사
    - 반환 값 : 문자열
      - 단항 덧셈 연산자 · `Number()`
        - 숫자형 변환
    - 소수부 길이 < 인수
    - 끝에 `0` 추가
```javascript
let num1 = 12.34;
alert( num1.toFixed(1) ); // "12.3"
let num2 = 12.36;
alert( num2.toFixed(1) ); // "12.4"

// 숫자형 변환
alert( +num2.toFixed(1) ); // 12.4
alert( Number(num2.toFixed(1)) ); // 12.4

//소수부 길이 < 인수
let num3 = 12.34;
alert( num3.toFixed(5) ); // "12.34000" (소수부 길이 5 맞춤)
```

### 부정확한 계산
- 숫자 내부적으로 64비트 형식 IEEE-754 표현
  - 숫자 저장 시 정확히 64비트 필요
    - 52비트
      - 숫자 저장
    - 11비트
      - 소수점 위치 <sub>(정수 : 0)</sub>
    - 1비트
      - 부호 저장
  - 숫자 너무 커지면 64비트 공간 넘쳐 `Infinity` 처리
```javascript
alert( 1e500 ); // Infinity
```

#### 정밀도 손실
```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1 + 0.2 );        // 0.30000000000000004
```
- 숫자 0, 1 이루어진 이진수 변환되어 연속된 메모리 공간 저장
- 분수
  - 2진법 표현 시 무한 소수 <sub>(10진법 쉽게 표현)</sub>
  - 2진법 체계
    - 2의 거듭제곱 나눈 값 잘 동작
    - 2의 거듭제곱 아닌 값 나누면 무한 소수
  -  2진법 0.1 · 0.2 정확하게 저장 방법 X
  - IEEE-754
    - 가능한 가장 가까운 숫자 반올림 방법 사용해 문제 해결
    - 반올림 규칙 적용 시 '작은 정밀도 손실’ 발생
    ```javascript
    alert( 0.1.toFixed(20) ); // 0.10000000000000000555
    ```
    - 숫자 덧셈 시 '정밀도 손실’도 덧셈
  - 문제 해결
    1. `toFixed(n)` 메서드 사용해 어림수 생성
        - 항상 문자열 반환
        - 소수점 다음 숫자 항상 항상 인수 갯수
        - 단항 덧셈 연산자
          - 숫자형 형 변환
    ```javascript
    let sum = 0.1 + 0.2;
    alert( sum.toFixed(2) ); // 0.30

    // 단항 덧셈 연산자 (숫자형 형 변환)
    alert( +sum.toFixed(2) ); // 0.3
    ```
    2. 10 거듭제곱 곱 / 나누기
        1. 숫자에 임시 10 거듭제곱 곱하여 정수 변환
        2. 연산
        3. 다시 10 거듭제곱 나누기
        - 정수 대상 수학 연산
          - 비교적 에러 小
        - 마지막 나눗셈
          - 소수 다시 등장
          - 오류 완전 제거 X
        ```javascript
        alert( (0.1 * 10 + 0.2 * 10) / 10 );     // 0.3
        alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        ```
    - 무한소수 방지 완벽 방법 X
      - 필요 때마다 '꼬리’ 잘라 어림수 생성

#### 흥미로운 발견
```javascript
alert( 9999999999999999 ); // 10000000000000000
```
- 정밀도 손실
  - 숫자 저장 52비트 공간 모자람
    - 최소 유효 숫자 손실
- 자바스크립트 숫자 손실 발생해도 오류 발생 X
  - 적절한 포맷으로 숫자 맞추는 데 최선

#### 두 종류의 `0`
- `0` · `-0` 존재
  - 숫자 부호 단일 비트 저장
  - `0` 포함 모든 숫자 부호 설정 가능
  - 대부분의 연산 `0` · `-0` 동일 취급
    - 차이 두드러지지 않는 편

### `isNaN` · `isFinite`
- `Infinity` · `-Infinity`
  - 그 어떤 숫자보다 큰 · 작은 특수 숫자 값
- `NaN`
  - 에러 표현 값
- 숫자형, but ‘비정상적인’ 숫자
- 구분 위한 특별 함수 존재
  - `isNaN(value)`
    - 인수 숫자 변환 후 `NaN` 테스트
  ```javascript
  alert( isNaN(NaN) );   // true
  alert( isNaN("str") ); // false

  // 자기 자신 포함 그 어떤 값과도 동일 X (함수 필요 이유)
  alert( NaN === NaN );  // false
  ```
  - `isFinite(value)`
    - 인수 숫자 변환 후 일반 숫자 경우 `true` 반환
  ```javascript
  alert( isFinite("15") );     // true
  alert( isFinite("str") );    // false
  alert( isFinite(Infinity) ); // false

  // 종종 문자열 일반 숫자 검증에 사용
  // 숫자 아닌 값 · Infinity · -Infinity 입력 시 false
  let num = +prompt("숫자를 입력하세요.", '');
  alert( isFinite(num) );
  ```
- `""` 빈 문자열 · `"   "`공백만 있는 문자열
  - `isFinite` 포함 모든 숫자 관련 내장 함수 `0` 취급

#### `Object.is`와 비교하기
- `Object.is`
  - 값 비교 특별 내장 메서드
  - 예외 제외 `===` 전부 동일
  ```javascript
  // 예외
  Object.is(NaN, NaN) // true
  Object.is(0, -0)    // false
  ```

### `parseInt` 와 `parseFloat`
- 단항 덧셈 연산자 `+` · `Number()` 사용 숫자형 변환 시 규칙 엄격 적용
  - 피연산자 숫자 아니면 형 변환 실패
  - 엄격 규칙 미적용
    - 문자열 처음 · 끝 공백 무시
  ```javascript
  alert( +"100px" ); // NaN
  ```
- `parseInt` · `parseFloat`
  - 불가능할 때까지 문자열 숫자 읽음<br />숫자 읽는 도중 오류 발생 시 이미 수집된 숫자 반환
    - `parseInt`
      - 정수
    - `parseFloat`
      - 부동 소수점 숫자
    ```javascript
    alert( parseInt('100px') );    // 100
    alert( parseFloat('12.5em') ); // 12.5

    alert( parseInt('12.3') );     // 12 (정수 부분만 반환)
    alert( parseFloat('12.3.4') ); // 12.3 (두 번째 점 숫자 읽기 멈춥)
    ```
  - `NaN` 반환
    - 읽을 수 있는 숫자 없을 시
  ```javascript
  alert( parseInt('a123') ); // NaN
  ```

#### `parseInt(str, radix)` 의 두 번째 인수
- `parseInt` 두 번째 매개 변수
  - 진수 지정
  ```javascript
  alert( parseInt('0xff', 16) ); // 255
  alert( parseInt('ff', 16) );   // 255 (0x 없이도 동작)
  alert( parseInt('2n9c', 36) ); // 123456
  ```

### 기타 수학 함수
- 내장 객체 `Math`
  - 다양한 수학 관련 함수 · 상수 보유
    - `Math.random()`
      - 0 ~ 1 사이 난수 반환 <sub>(1 제외)</sub>
      ```javascript
      alert( Math.random() ); // 0.1234567894322
      alert( Math.random() ); // 0.5435252343232
      alert( Math.random() ); // ... (무작위 수)
      ```

    - `Math.max(a, b, c...)` · `Math.min(a, b, c...)`
      - 인수 중 최대 · 최솟값 반환
      ```javascript
      alert( Math.max(3, 5, -10, 0, 1) ); // 5
      alert( Math.min(1, 2) );            // 1
      ```
    - `Math.pow(n, power)`
      - `n`을 `power`번 거듭제곱 값 반환
      ```javascript
      alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
      ```

<br />

문자열
=====

- 페이지 인코딩 방식 상관없이 항상 UTF-16 형식

### 따옴표
- 작은따옴표 `"`
- 큰따옴표 　`'`
- 백틱　　　 `` ` ``
  - 템플릿 리터럴
    - `${…}`
  ```javascript
  function sum(a, b) {
    return a + b;
  }
  alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
  ```
    - 문자열 여러 줄 걸쳐 작성
      - `"` · `'` 불가능
    ```javascript
    let guestList = `손님:
    * John
    * Pete
    * Mary
    `;
    ```
  - 템플릿 함수
    - 첫 번째 백틱 바로 앞 함수 이름 존재 시 함수 백틱 안 문자열 조각 · 표현식 평가 결과 인수로 받아 자동 호출
      - ex&#41; ``func`string` ``
      - '태그드 템플릿'
      - 드물게 사용

### 특수 기호

|특수 문자|설명|
|---|---|
|`\n`|줄 바꿈|
|`\r`|캐리지 리턴<br />Windows 에서 캐리지 리턴, 줄 바꿈 특수 문자 조합해 줄 바꿈<br />- `\r\n`<br />캐리지 리턴 단독 사용 경우 X|
|`\'` · `\"`|따옴표|
|`\\` |역슬래시|
|`\t`|탭|
|`b` · `\f` · `\v`|백스페이스<br />폼 피드<br />세로 탭<br />- 호환성 유지 위해 남아있는 기호 <sub>(요즘 사용 X)</sub>|
|`\xXX`|16진수 유니코드 XX로 표현한 유니코드 글자<br />- ex&#41; 알파벳 `z` → `\x7A`|
|`\uXXXX`|UTF-16 인코딩 규칙 사용 16진수 코드 XXXX로 표현한 유니코드 기호<br />XXXX 반드시 네 개의 16진수 구성<br />- ex&#41; `\u00A9` → 저작권 기호 `©` 유니코드|
|`\u{X…XXXXXX}`<br /><sub>(1개 ~ 6개 사이 16진수 글자)</sub>|UTF-32 표현 유니코드 기호<br />몇몇 특수 글자 두 개의 유니코드 기호 사용해 인코딩되므로 4바이트 차지<br />이 방법 사용 시 긴 코드 삽입 가능|
- 유니코드
```javascript
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫, 중국어(긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호(긴 유니코드)
```
- 모든 특수 문자 역슬래시 `\` 시작
  - '이스케이프 문자'
- 문자열 내 따옴표
```javascript
alert( 'I\'m the Walrus!' ); // 역슬래시
alert( `I'm the Walrus!` );  // 백틱
```
- 문자열 안 역슬래시 `\` 표시
  - `\\`
```javascript
alert( `역슬래시: \\` ); // \
```

### 문자열의 길이
- `length` 프로퍼티
```javascript
// '\n' : ‘특수 문자’ 1개 → 길이 1
alert( `My\n`.length ); // 3
```

### 특정 글자에 접근하기
- `[]` 대괄호 · `charAt(pos)` 메서드
  - 위치 0부터 시작
```javascript
let str = `Hello`;

// 첫 번째 글자
alert( str[0] );        // H
alert( str.charAt(0) ); // H

// 마지막 글자
alert( str[str.length - 1] ); // o
```
- `[]` 대괄호 선호
- `charAt(pos)` 하위 호환성 위해 남아있는 메서드
- 접근 위치 글자 없는 경우
  - `[]` 대괄호
    - `undefined`
  - `charAt(pos)`
    - `""` 빈 문자열
```javascript
let str = `Hello`;

alert( str[1000] );        // undefined
alert( str.charAt(1000) ); // '' (빈 문자열)
```
- `for…of`
  - 문자열 구성 글자 대상 반복 작업
```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o
}
```

### 문자열의 불변성
- 문자열 수정 불가능
- 문자열 중간 글자 하나 수정 시 에러 발생
  - 완전히 새로운 문자열 생성 후 할당
```javascript
let str1 = 'Hi';

str1[0] = 'h';    // Error: Cannot assign to read only property '0' of string 'Hi'
alert( str1[0] ); // 동작 X

let str2 = 'Hi';

str2 = 'h' + str2[1]; // 문자열 전체 교체
alert( str2 );        // hi
```

### 대 · 소문자 변경하기
- `toLowerCase()` · `toUpperCase()`
  - 대문자 ↔ 소문자
```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

// 글자 하나만 변경
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

### 부분 문자열 찾기

#### `str.indexOf(substr, pos)`
- 문자열 `str` 의 `pos` 에서부터 시작
- 부분 문자열 `substr` 어디 위치하는지 검색
- 원하는 부분 문자열 찾으면 위치 반환, 그렇지 않으면 `-1` 반환
```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0 ('Widget' with id)
alert( str.indexOf('widget') ); // -1, indexOf : 대·소문자 따짐
alert( str.indexOf("id") );     // 1, (W'id'get with id)
```
- 두 번째 매개변수 `pos`
  - 선택적 사용
  - 해당 위치 검색 시작
```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12 (Widget with id)
                              //       ↑ 검색 시작
```
- 문자열 내 부분 문자열 전체 대상 작업
  - 반복문 안 `indexOf` 사용
```javascript
let str = 'As sly as a fox, as strong as an ox';
let target = 'as';
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `위치: ${foundPos}` );
  pos = foundPos + 1; // 다음 위치 기준 검색 이어 시작
}

↓↓↓

let str = "As sly as a fox, as strong as an ox";
let target = "as";
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

#### `str.lastIndexOf(substr, position)`
- 문자열 끝에서부터 부분 문자열 검색
- 반환 부분 문자열 위치
  - 문자열 끝 기준

#### `if` 문 조건식 `indexOf` 주의 점
- `0` == `false` 간주
- `-1` 과 비교
```javascript
let str = "Widget with id";

// if(0) → false
if (str.indexOf("Widget")) {
  alert("찾았다!");
}

// -1 비교
if (str.indexOf("Widget") != -1) {
    alert("찾았다!"); // 의도한 대로 동작합니다.
}
```

#### `~` 비트 NOT 연산자를 사용한 기법
- 오래전부터 전해 오는 방법
- 피연산자 32비트 정수 변환 후 <sub>(소수부 모두 버려짐)</sub> 모든 비트 반전
  - `~n` → `-(n+1)`
```javascript
alert( ~2 );  // -3 → -( 2+1)
alert( ~1 );  // -2 → -( 1+1)
alert( ~0 );  // -1 → -( 0+1)
alert( ~-1 ); //  0 → -(-1+1)
              // (n == 0 유일)
```
- `~-1` 응용 → `n == 0`
- 직관적 X · 비권장
```javascript
let str = "Widget";
if (~str.indexOf("Widget")) {
  alert( '찾았다!' );
}
```
- `~4294967295` == `0`
  - 아주 긴 문자열 주의

#### `includes` · `startsWith` · `endsWith`
- 비교적 근래 나온 메서드
- `str.includes(substr, pos)`
  - `str` 에 부분 문자열 `substr` 있으면 `true` , 없으면 `false`
    - 위치 정보 X, 포함 여부
  - 두 번째 인수
    - 해당 위치부터 부분 문자열 검색
```javascript
alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") );             // false
alert( "Widget".includes("id") );             // true
alert( "Widget".includes("id", 3) );          // false (3번째 위치 이후 "id" 없음)
```
- `str.startsWith` · `str.endsWith`
- `str` 이 특정 문자열 시작 · 종료 여부 확인
```javascript
alert( "Widget".startsWith("Wid") ); // true
alert( "Widget".endsWith("get") );   // true
```

### 부분 문자열 추출하기
- 부분 문자열 추출 관련 메서드
  - `substring`
  - `substr`
  - `slice`

#### `str.slice(start [, end])`
- 문자열 `start` ~ `end` 까지 <sub>(`end` 미포함)</sub> 반환
```javascript
let str = "stringify";
alert( str.slice(0, 5) ); // 'strin'
alert( str.slice(0, 1) ); // 's'
```
- 두 번째 인수 생략 시 명시 위치 ~ 문자열 끝 반환
```javascript
let str = "stringify";
alert( str.slice(2) ); // ringify
```
- `start` · `end` 음수 가능
  - 문자열 끝에서부터 카운팅 시작
```javascript
let str = "stringify";
alert( str.slice(-5, -1) ); // ngif
                        // stringify
                        //     ↑ ~ ↑
                        //    -5  -1
```

#### `str.substring(start [, end])`
- `start` · `end` 사이 문자열 반환
- `slice` 아주 유사
  - 차이
    - `start` > `end` 가능
    - 음수 인수 허용 X
    - 음수 → `0` 처리
```javascript
let str = "stringify";

alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

alert( str.slice(2, 6) ); // "ring"
alert( str.slice(6, 2) ); // ""
```

#### `str.substr(start [, length])`
- `start` ~, `length` 개 글자 반환
  - 첫 번째 인수 음수
    - 뒤에서부터 카운트
```javascript
let str = "stringify";
alert( str.substr(2, 4) ); // ring

let str = "stringify";
alert( str.substr(-4, 2) ); // gi
```


|메서드|추출 부분 문자열|음수 허용 여부 <sub>(인수)</sub>|
|---|---|---|
|`slice(start, end)`|`start` ~ `end` 까지 <sub>(`end` 미포함)</sub>|음수 허용|
|`substring(start, end)`|`start` ~ `end` 사이|음수 `0` 취급|
|`substr(start, length)`|`start` ~, `length` 개|음수 허용|

#### 어떤 메서드를 선택해야 하나요?
- 모두 사용 OK
- `substr` 단점
  - 구식 스크립트 대응 위해 남겨 둔 브라우저 전용 기능들 명시 부록 B 정의
    - 거의 모든 곳 메서드 동작
    - 브라우저 이외 호스트 환경 제대로 동작 X 가능성 有

### 문자열 비교하기
- 알파벳 순서 기준 글자끼리 비교
- 모든 문자열 UTF-16 사용해 인코딩
  - UTF-16 모든 글자 → 숫자 형식 코드 매칭

#### `str.codePointAt(pos)`
- `pos` 위치 글자 코드 반환
```javascript
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
```

#### `String.fromCodePoint(code)`
- 숫자 형식 code 대응 글자 생성
- `\u` 뒤 특정 글자 대응 16진수 코드 붙이는 방식 가능
```javascript
alert( String.fromCodePoint(90) ); // Z

// 90 16진수 변환 → 5a
alert( '\u005a' ); // Z
```
- 예외 사항
  - 소문자 > 대문자
  - 발음 구별 기호 붙은 문자 알파벳 순서 기준 X
```javascript
// 소문자 > 대문자
alert( 'a' > 'Z' ); // true

// 발음 구별 기호
alert( 'Österreich' > 'Zealand' ); // true

// 예외 사항 이유
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}

alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```
- 글자 대응 숫자 형식 코드 기준 비교
  - 코드 큼 → 대응 글자 큼

#### 문자열 제대로 비교하기
- 언어마다 문자 체계 다름
  -  문자열비교 알고리즘 생성 어려움
- 문자열 비교 위해 페이지 사용 언어 브라우저 인식 필요
  - 모던 브라우저 대부분 국제화 관련 표준 ECMA-402 지원
    - 언어 다를 시 적용 문자열 비교 규칙, 규칙 준수 메서드 정의
      - ex&#41; `str.localeCompare(str2)`
        - `str` &nbsp;< &nbsp;`str2` → 음수
        - `str` &nbsp;> &nbsp;`str2` → 양수
        - `str` == `str2` → `0`
      ```javascript
      alert( 'Österreich'.localeCompare('Zealand') ); // -1
      ```

### 문자열 심화

#### 서로게이트 쌍
- 자주 사용 글자들 모두 2바이트 코드 보유
  - 유럽권 언어 글자, 숫자, 상형 문자 대다수 2바이트 표현 체계 사용
  - 2바이트 65,536 (2<sup>16</sup>) 개 조합 외 불가
    - 현존 기호 모두 표현 불충분
- '서로게이트 쌍'
  - 제약 극복 위해 사용 빈도 낮은 기호 2바이트 글자 쌍 사용해 인코딩
  - 서로게이트 쌍 사용해 인코딩한 기호 길이
    - 2
  ```javascript
  alert( '𝒳'.length );  // 2, 수학에서 쓰이는 대문자 X
  alert( '😂'.length ); // 2, 웃으면서 눈물 흘리는 얼굴 이모티콘
  alert( '𩷶'.length );  // 2, 사용 빈도 낮은 중국어 (상형문자)
  ```
  - 자바스크립트 초기 서로게이트 쌍 미존재
    - 서로게이트 쌍 표현 기호 제대로 처리 X
  - `String.fromCodePoint` · `str.codePointAt`
    - 명세서 추가된 지 얼마 안 된 메서드
    - 서로게이트 쌍 제대로 처리 몇 안 되는 메서드
    - 두 메서드 등장 전 `String.fromCharCode` · `str.charCodeAt` 사용
      - `fromCodePoint` · `codePointAt` 동일 동작
      - 서로게이트 쌍 처리 X
  - 서로게이트 쌍 두 글자 취급
    - 기호 가져오기 까다로움
    - 서로게이트 쌍 구성 글자들 붙어있을 때만 의미 有
    ```javascript
    alert( '𝒳'[0] ); // 이상한 기호 출력
    alert( '𝒳'[1] ); // 서로게이트 쌍 일부 출력
    ```
  - 기술적으로 서로게이트 쌍 대응 코드 사용해 감지 가능
    - 글자 코드 `0xd800` ~ `0xdbff` 사이 있으면 이 코드 서로게이트 쌍 구성하는 첫 번째 글자 표현 의미
    - 서로게이트 쌍 구성 두 번째 글자 코드 반드시 `0xdc00` ~ `0xdfff` 사이 존재
    - 범위 `0xd800` ~ `0xdbff` · `0xdc00` ~ `0xdfff`
      - 표준에서 서로게이트 쌍 위해 일부러 비워둔 코드
    ```javascript
    // charCodeAt 서로게이트 쌍 처리 X
    // → 서로게이트 쌍 구성 부분 코드 반환
    alert( '𝒳'.charCodeAt(0).toString(16) ); // d835 (0xd800 ~ 0xdbff 사이 코드)
    alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3 (0xdc00 ~ 0xdfff 사이 코드)
    ```

#### 발음 구별 기호와 유니코드 정규화
- 여러 언어 베이스 글자 위 · 아래 발음 구별 기호 붙여 글자 구성
  - ex&#41; `a` → `àáâäãåā`
- 이런 ‘합성’ 글자 대부분 UTF-16 테이블 독자적인 코드 보유
- 모든 합성 글자 코드 부여 X
  - 조합 가능 글자 수 너무 많음
- 임의 조합 지원 위해 UTF-16 몇 개 유니코드 문자 남겨둠
  - 베이스 글자 뒤 하나 ~ 여러 개 유니코드 문자 붙여 베이스 글자 꾸밈
  - ex&#41; `S` + `\u0307` <sub>(유니코드 문자)</sub> → `Ṡ`
  ```javascript
  alert( 'S\u0307' ); // Ṡ
  ```
  - 발음 구별 기호 하나 붙인 상태에서 추가 발음 구별 기호
    - 필요 기호 유니코드 문자 붙여주기
    - ex&#41; `Ṡ` + `\u0323` <sub>(유니코드 문자)</sub> → `Ṩ`
  ```javascript
  alert( 'S\u0307\u0323' ); // Ṩ
  ```
  - 엄청난 유연성 제공
  - 단점
    - 눈에 같은 글자, but 유니코드 조합 다름
    ```javascript
    let s1 = 'S\u0307\u0323'; // Ṩ (S + 윗 점 + 아랫 점)
    let s2 = 'S\u0323\u0307'; // Ṩ (S + 아랫 점 + 윗 점)

    alert( `s1: ${s1}, s2: ${s2}` );

    alert( s1 == s2 ); // 눈에 같은 글자, but 동등 비교 시 false
    ```
    - 해결
      - '유니코드 정규화' 알고리즘 사용해 각 문자열 동일한 형태로 '정규화’
      - 유니코드 정규화 알고리즘 `str.normalize()` 구현
      ```javascript
      alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

      // 3개 글자 하나로 결합
      // Ṩ '\u1e68' (유니코드)
      alert( "S\u0307\u0323".normalize().length );      // 1
      alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
      ```
    - 현실
      - `Ṩ` → 하나 유니코드 결합
        - UTF-16 작업자들 `Ṩ` '충분히 나타날 수 있는 사례’ 생각하고 UTF-16 테이블 포함 · 코드 부여
    - 실무
      - 유니코드 표준 부록 Unicode Normalization Forms 해당 내용

<br />

배열
====

- 순서 컬렉션 저장 자료구조

### 배열 선언
- 대부분 두 번째 방법 선호
```javascript
let arr = new Array();
let arr = [];
```
- 대괄호 안 초기 요소 삽입
```javascript
let fruits = ["사과", "오렌지", "자두"];
```
- 각 배열 요소 숫자 (인덱스)
  - 0 ~
  - 배열 내 순서
- 배열 내 특정 요소 얻기
  - 대괄호 안 인덱스
```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

// 배열 내 특정 요소 수정
fruits[2] = '배'; ["사과", "오렌지", "배"]

// 새로운 요소 추가
fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]

// 배열 요소 갯수
alert( fruits.length ); // 4

// 요소 전체 출력
alert( fruits ); // 사과,오렌지,배,레몬
```
- 배열 요소 자료형 제약 X
```javascript
let arr = [
  '사과',
  { name: '이보라' },
  true,
  function() { alert('안녕하세요.'); }
];

// 인덱스 1 요소 (객체) name 프로퍼티
alert( arr[1].name ); // 이보라

// 인덱스 3 요소 (함수) 실행
arr[3]();             // 안녕하세요.
```

#### trailing 쉼표
- 배열 마지막 요소
  - 쉼표 사용 가능
- 모든 줄 생김새 유사
  - 요소 추가 · 삭제 용이
```javascript
let fruits = [
  "사과",
  "오렌지",
  "자두",
];
```

### `pop` · `push` vs `shift` · `unshift`
- 큐 <sub>(queue)</sub>
  - 배열 사용해 만드는 대표적인 자료구조
  - 선입선출 <sub>(First-In-First-Out, FIFO)</sub>
  - 순서 있는 컬렉션 저장
  - 큐 주요 연산
    - `push`
      - 맨 끝에 요소 추가
    - `shift`
      - 제일 앞 요소 꺼내 제거 후 남은 요소들 앞으로 밈
- 스택 <sub>(stack)</sub>
  - 배열 사용해 만드는 대표적인 자료구조
  - 후입선출 <sub>(Last-In-First-Out, LIFO)</sub>
  - 스택 주요 연산
    - `push`
      - 스택 끝에 요소 삽입
    - `pop`
      - 스택 끝 요소 추출
- 배열
  - 큐 · 스택 둘다 생성 가능
  - 데큐 <sub>(deque, Double Ended Queue)</sub>
    - 처음 · 끝 요소 더하기 · 빼기 연산 제공 자료구조

#### 배열 끝 작업 메서드
- `pop`
  - 배열 끝 요소 제거 후 제거한 요소 반환
- `push`
  - 배열 끝에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// pop
alert( fruits.pop() ); // 배
alert( fruits ); // 사과,오렌지

// push
// fruits.push(...)
// fruits[fruits.length] = ... (동일)
fruits.push("배");
alert( fruits ); // 사과,오렌지,배
```

#### 배열 앞 작업 메서드
- `shift`
  - 배열 앞 요소 제거 후 제거한 요소 반환
- `unshift`
  - 배열 앞에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// shift
alert( fruits.shift() ); // 사과
alert( fruits ); // 오렌지,배

// unshift
fruits.unshift('사과');
alert( fruits ); // 사과,오렌지,배
```
- `push` · `unshift`
  - 요소 여러 개 한 번에 더하기 가능
```javascript
let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

alert( fruits ); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

### 배열의 내부 동작 원리
- 특별한 종류의 객체
- 숫자형 키 사용
  - 객체 기본 기능 이외 순서 있는 컬렉션 제어 메서드
  - `length` 프로퍼티
- 배열 본질 → 객체
```javascript
let fruits = ["바나나"]

let arr = fruits;        // 참조 복사
alert( arr === fruits ); // true

arr.push("배");          // 참조 이용해 배열 수정
alert( fruits );         // 바나나,배
```

#### 배열 특수 내부 표현방식
- 배열 요소 인접한 메모리 공간에 차례로 저장해 연산 속도 ↑
- 이 방법 이외 배열 관련 연산 최적화 기법 다양
- 배열 '순서있는 자료 컬렉션’ X, 일반 객체처럼 다루면 최적화 기법들 제대로 동작 X
```javascript
let fruits = [];
fruits[99999] = 5; // 배열 길이보다 훨씬 큰 숫자 사용해 프로퍼티 생성
fruits.age = 25;   // 임의의 이름 사용해 프로퍼티 생성
```
- 배열 객체이므로 원하는 프로퍼티 추가해도 문제 발생 X
- 자바스크립트 엔진 배열 일반 객체처럼 다루게 되어 배열 최적화 기법이 동작 X
  - 배열 특유 이점 사라짐
    - 숫자 아닌 값 프로퍼티 키로 사용
    ```javascript
    arr.test = 1;
    ```
    - 앞, 끝에만 요소 추가
    ```javascript
    arr[0] = 1;
    arr[1000] = 2;
    ```
    - 요소 역순으로 삽입
    ```javascript
    arr[1000] = 1;
    arr[999] = 2;
    ```
- 배열 사용 시 목적 맞게 사용
- 임의의 키 사용 시 일반 객체 적합

### 성능
- `shift` · `unshift` → 느림
  1. 인덱스 0 요소 제거 · 추가
  2. 모든 요소 좌 · 우 이동
      - 모든 인덱스 1씩 감소 · 증가
  3. `length` 프로퍼티 값 갱신
  - 배열 요소 많으면 요소 이동 시간 · 메모리 관련 연산 ↑
- `push` · `pop` 빠름
  1. 마지막에 요소 추가 · 제거
  2. `length` 프로퍼티 값 갱신
  - 요소 이동 수반 X
  - 기존 인덱스 그대로 유지

### 반복문

#### `for` 문
  - 배열 순회 가장 오래된 방법
  - 순회시 인덱스 사용
```javascript
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

#### `for…of`
  - 요소 값
  - 요소 인덱스 X
```javascript
let fruits = ["사과", "오렌지", "자두"];

for (let fruit of fruits) {
  alert( fruit );
}
```

#### `for…in`
  - 배열 → 객체형
```javascript
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```

#### `for…in` 문제점
- 모든 프로퍼티 대상 순회
  - 숫자 키 외 프로퍼티 순회 대상 포함
  - 유사 배열 객체
    - 브라우저 · 기타 호스트 환경 사용 객체
    - `length` 프로퍼티, 요소 인덱스
    - 숫자형 키 외 프로퍼티 · 메서드 존재 가능
      - `for…in` 사용 시 이 모든 것 대상 순회 진행
        - ‘필요 없는’ 프로퍼티들 문제 일으킬 가능성 ↑
- 객체에 최적화
  - 배열 사용 시 객체 대비 10 ~ 100배 느림
  - 반복문 속도 빠름 → 병목 지점에서만 문제
- 배열 되도록 `for…in` 사용 X

### `length` 프로퍼티
- 배열 조작 시 `length` 프로퍼티 자동 갱신
- 가장 큰 인덱스 + 1 <sub>(배열 내 요소 개수 X)</sub>
  - 배열 요소 하나
    - 인덱스 아주 큰 정수 일 시 `length` 프로퍼티 아주 커짐
  ```javascript
  // 잘못된 배열 사용
  let fruits = [];
  fruits[123] = "사과";

  alert( fruits.length ); // 124
  ```
- `length` 프로퍼티 쓰기 가능
  - 값 수동 증가 : 아무 일 X
  - 값 수동 감소 : 배열 잘림
    - 짧아진 배열 되돌리기 X
    - `arr.length = 0;` → 간단하게 배열 비우기
```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 자르기
alert( arr ); // [1, 2]

arr.length = 5; // 본래 길이 수동 증가
alert( arr[3] ); // undefined (삭제된 기존 요소들 복구 X)
```

### `new Array()`
- 배열 생성
```javascript
let arr = new Array("사과", "배", "기타");
```
- 잘 사용되지 않는 편
- 까다로운 기능
  - 숫자형 인수 하나 전달 · 호출 시
    - 요소 X
    - 길이 == 인수
  ```javascript
  let arr = new Array(2);

  alert( arr[0] ); // undefined (요소 없음)
  alert( arr.length ); // 길이 : 2
  ```

### 다차원 배열
- 배열 안 배열
- 행렬 저장
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5
```

### `toString`
- 배열 `toString` 메서드 구현
  - 요소 쉼표 구분 문자열 반환
```javascript
let arr = [1, 2, 3];

alert( arr );                     // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
- 배열 `Symbol.toPrimitive` · `valueOf` 메서드 X
- 문자열 형 변환 발생
```javascript
alert( [] + 1 );    // "1"
alert( [1] + 1 );   // "11"
alert( [1,2] + 1 ); // "1,21"

alert( "" + 1 );    // "1"
alert( "1" + 1 );   // "11"
alert( "1,2" + 1 ); // "1,21"
```

<br />

배열과 메서드
============

### 요소 추가 · 제거 메서드

#### `splice`
- `delete`
  - 배열 요소 1개 삭제 <sub>(배열 역시 객체형)</sub>
  - 원하는 요소 삭제
  - 배열 요소 여전히 3개
    - `arr.length` == `3`
```javascript
let arr = ["I", "go", "home"];
delete arr[1];       // "go" 삭제
alert( arr[1] );     // undefined

// delete 요소 삭제 후 배열
// arr = ["I",  , "home"];
alert( arr.length ); // 3
```
- `arr.splice(start)`
  - 요소 추가 · 삭제 · 교체 가능
```javascript
arr.splice(index[, deleteCount, elem1, ..., elemN])
```
- `index`
  - 조작 가할 1번째 요소 인덱스 <sub>(index)</sub>
- `deleteCount`
  - 제거 요소 개수
- `elem1, ..., elemN`
  - 배열 추가할 요소
```javascript
/* 요소 삭제 */
let arr1 = ["I", "study", "JavaScript"];
arr1.splice(1, 1); // 인덱스 1부터 요소 1개 제거
alert( arr1 );     // ["I", "JavaScript"]

/* 요소 삭제 후 다른 요소 대체 */
let arr2 = ["I", "study", "JavaScript", "right", "now"];

 // 처음(0) 3개(3) 요소 삭제 후 다른 요소 대체
arr2.splice(0, 3, "Let's", "dance");
alert( arr2 )      // ["Let's", "dance", "right", "now"]

/* 삭제된 요소 구성 배열 반환 */
let arr3 = ["I", "study", "JavaScript", "right", "now"];
let removed = arr3.splice(0, 2); // 처음 2개 요소 삭제
alert( removed ); // "I", "study" ← 삭제된 요소 구성 배열

/* deleteCount == 0    */
/* 삭제 X, 새 요소 추가 */
let arr = ["I", "study", "JavaScript"];

// 인덱스 2부터 0개 요소 삭제
// 그 후, "complex", "language" 추가
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"

/* 음수 인덱스     */
/* 배열 끝에서부터 */
let arr = [1, 2, 5];

// 인덱스 -1부터 (배열 끝 1번째 요소) 0개 요소 삭제 후 3, 4 추가
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5
```

#### `slice`
```javascript
arr.slice([start], [end])
```
- "`start`" ~ "`end`" 인덱스 <sub>("`end`" 제외)</sub> 요소 복사한 새로운 배열 반환
- "`start`" · "`end`" 음수
  - 배열 끝부터 요소 개수
- 인수 X
  - 복사본 생성
- 문자열 메서드 `str.slice` 유사 동작
```javascript
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s
alert( arr.slice(-2) );   // s,t
```

#### `concat`
- 기존 배열 요소 사용해 새로운 배열 생성
- 기존 배열 요소 추가
- 인수
  - 배열 · 값
  - 개수 제한 X
```javascript
arr.concat(arg1, arg2...)
```
- `arr` 속한 모든 요소 + `arg1` · `arg2` 등 속한 모든 요소 한데 모은 새로운 배열 반환
- 인수 `argN` 배열일 경우 배열 모든 요소 복사
```javascript
let arr = [1, 2];
alert( arr.concat([3, 4]) );         // 1,2,3,4
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
alert( arr.concat([3, 4], 5, 6) );   // 1,2,3,4,5,6
```
- 제공받은 배열 요소 복사해 활용
- 객체 인자
  - <sub>(유사 배열 객체라도)</sub> 객체 분해 X
  - 통으로 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```
- 인자의 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable` 존재 시 배열처럼 취급
  - 객체 전체 X
  - 객체 프로퍼티 값 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

#### `forEach` 로 반복작업 하기
- 주어진 함수 배열 요소 각각에 실행
- 인수 함수 반환값 무시
```javascript
arr.forEach(function(item, index, array) {
  // ...
});
```
```javascript
// 각 요소마다 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

// 각 요소마다 인덱스 정보 더해서 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

### 배열 탐색하기

#### `indexOf` · `lastIndexOf` · `includes`
- 동일 이름 문자열 메서드 문법 · 작업 동일
- `arr.indexOf(item, from)`
  - 인덱스 `from` 부터 시작해 `item` <sub>(요소)</sub> 검색
  - 요소 발견 시 해당 요소 인덱스 반환
  - 요소 미발견 시 `-1` 반환
- `arr.lastIndexOf(item, from)`
  - 위 메서드 동일 기능
  - 검색 끝에서부터
- `arr.includes(item, from)`
  - 인덱스 `from` 부터 시작해 `item` 있는지 검색
  - 해당 요소 발견 시 `true` 반환
```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) );     // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) );  // -1
alert( arr.includes(1) );    // true
```
- 요소 검색 시 완전 항등 연산자 `===` 사용
  - `false` 검색하면 정확히 `false` 만 검색, `0` 검색 X
- `includes`
  - 요소 위치 X, 요소 배열 내 존재 여부 확인
  - `NaN` 제대로 처리
    - `indexOf` · `lastIndexOf` 와의 차이
```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) );  // -1 (완전 항등 비교 '===' NaN 동작 X)
alert( arr.includes(NaN) ); // true (NaN 여부 확인)
```

#### `find` 와 `findIndex`
- 특정 조건 부합 요소 검색
```javascript
let result = arr.find(function(item, index, array) {
  // true 반환 시 반복 중단, 해당 요소 반환
  // 조건 해당 요소 없으면 undefined 반환
});
```
- `find`
  - 요소 전체 대상 함수 순차적으로 호출
    - `item`
      - 함수 호출 요소
    - `index`
      - 요소 인덱스
    - `array`
      - 배열 자기 자신
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // John
```
- 가장 많이 사용되는 패턴
  - `(item => item.id == 1)`
    - 인자 하나
    - 다른 인자들 (`index` · `array`) 자주 사용 X
- `arr.findIndex`
  - `find` 동일
  - 요소 반환 X
  - 요소 인덱스 반환
  - 조건 해당 요소 없으면 `-1` 반환

#### `filter`
- 조건 부합 요소 전체 담은 배열 반환
```javascript
let results = arr.filter(function(item, index, array) {
  // 조건 충족 요소 results에 순차적으로 추가
  // 조건 충족 요소 하나도 없으면 빈 배열 반환
});
```
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명 반환
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
```
### 배열을 변형하는 메서드

#### `map`
- 배열 요소 전체 대상 함수 호출
- 함수 호출 결과 배열로 반환
```javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값 반환
});
```
```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

#### `sort(fn)`
- 배열 요소 정렬
- 배열 자체 변경
- 재정렬 된 배열 반환
  - 이미 배열 자체 수정되었기 때문에 반환 값 잘 사용 X
```javascript
let arr = [ 1, 2, 15 ];

// arr 내부 재정렬
// 인수 없으면 요소 문자열 취급 재정렬 (사전편집순 : "2" > "15")
arr.sort();
alert( arr );           // 1, 15, 2

// 새로운 정렬 기준 함수
// - 값 두 개 비교, 반환 값 존재
function compareNumeric(a, b) {
  if (a > b) return 1;  // 1번째 값 > 2번째 값
  if (a == b) return 0; // 두 값 동일
  if (a < b) return -1; // 1번째 값 < 2번째 값
}
arr.sort(compareNumeric);
alert(arr);             // 1, 2, 15
```
- 정렬 과정 어떤 요소끼리 비교 발생했는지 확인
```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

#### 정렬 함수는 어떤 숫자든 반환할 수 있습니다.
- 정렬 함수 반환 값 제약 X
- 양수 반환
   - 1번째 인수 > 2번째 인수
- 음수 반환
   - 1번째 인수 < 2번째 인수
```javascript
// 간결한 표현
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15

// 화살표 함수 (더 간결)
arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
```

#### 문자열엔 `localeCompare` 사용하세요.
- `Ö` 같은 문자 있는 언어 대응
  - `str.localeCompare` 메서드 사용
```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );
// Andorra,Vietnam,Österreich (제대로 정렬 X)

alert( countries.sort( (a, b) => a.localeCompare(b) ) );
// Andorra,Österreich,Vietnam (제대로 정렬)
```

#### `reverse`
- 요소 역순 정렬
- 재정렬된 배열 반환
```javascript
let arr = [1, 2, 3, 4, 5];

arr.reverse();
alert( arr ); // 5,4,3,2,1
```

#### `split`
- `str.split(delim)`
  - 구분자 (delimiter) `delim` 기준 문자열 분리
```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');
for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
}
```
- 두 번째 인수
  - 숫자
  - 배열 길이 제한
  - 길이 넘어서는 요소 무시
  - 실무 가끔 사용
```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

#### 문자열을 글자 단위로 분리하기
- 구분자
  - 빈 문자열 → 문자열 글자 단위 분리
```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

#### `arr.join(glue)`
- 인수 `glue` 기준 배열 요소 모두 합친 후 하나의 문자열 생성
```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');
alert( str ); // Bilbo;Gandalf;Nazgul
```

#### `reduce` · `reduceRight`
- 각 요소 돌면서 반복 작업 수행
  - 값 하나 도출
```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
- 인수 함수
  - 배열 모든 요소 대상 차례차례 적용
  - 적용 결과
    - 다음 함수 호출 시 사용
- 함수 인수
  - `initial`
    - 함수 최초 호출 시 사용 초깃값 <sub>(옵션)</sub>
  - `accumulator`
    - 이전 함수 호출 결과
  - `item`
     - 현재 배열 요소
  - `index`
    - 요소의 위치
  - `array`
    - 배열
- 이전 함수 호출 결과
  -  다음 함수 호출 시 첫 번째 인수 (`previousValue`) 사용
```javascript
let arr = [1, 2, 3, 4, 5];

// 배열 모든 요소 더하기
// 일반적으로 인수 2개 사용
let result = arr.reduce((sum, current) => sum + current, 0);
alert( result ); // 15

// 초깃값 제거
let result = arr.reduce((sum, current) => sum + current);
alert( result ); // 15
```

|`sum`|`current`|`result`|
|:---:|:---:|:---:|
|1번째 호출|`0`|`1`|`1`|
|2번째 호출|`1`|`2`|`3`|
|3번째 호출|`3`|`3`|`6`|
|4번째 호출|`6`|`4`|`10`|
|5번째 호출|`10`|`5`|`15`|

- 초깃값 없을 시
  - 배열 1번째 요소 초깃값 사용
  - 2번째 요소부터 함수 호출
  - 빈 배열
    - 호출 시 에러 발생
    - 항상 초깃값 명시 권장
  ```javascript
  let arr = [];

  // TypeError: Reduce of empty array with no initial value
  // 초깃값 설정 시 초깃값 반환
  arr.reduce((sum, current) => sum + current);
  ```
- `arr.reduceRight`
  - `reduce` 동일 기능
  - 배열 오른쪽부터 연산 수행

### `Array.isArray` 로 배열 여부 알아내기
- 배열 독립된 자료형 X
  - 객체형 취급
  - `typeof`
    - 일반 객체 · 배열 구분 X
```javascript
alert(typeof {}); // object
alert(typeof []); // object
```
- `Array.isArray(value)`
  - value == 배열
    - true
  - value !== 배열
    - false
```javascript
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

### 배열 메서드와 `thisArg`
- 함수 호출 대부분의 배열 메서드 <sub>(`find` · `filter` · `map` 등, `sort` 제외)</sub>
  - `thisArg` 매개변수 옵션
  - 가끔 사용되는 인수
```javascript
// 선택적으로 사용할 수 있는 마지막 인수
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```
- `thisArg` == `func` 의 `this`
```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// thisArg == canJoin 컨텍스트 (army 객체) 정보
//                                        thisArg
let soldiers = users.filter(army.canJoin, army);

/* 동일, thisArg 방식 좀 더 이해 쉬움 (더 자주 사용)
let soldiers = users.filter(user => army.canJoin(user))
 */

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
- `thisArgs` 에 `army` 미지정 시
  - `army.canJoin` 단독 함수 취급, 함수 본문 내 `this` → `undefined` 에러 발생

<br />

iterable 객체
=============

- 반복 가능한 객체
  - 배열 일반화 객체
  - 이터러블 개념 사용 시 어떤 객체든 `for…of` 반복문 적용 가능
- 배열 대표적인 이터러블
- 배열 외 다수 내장 객체 반복 가능
  - 문자열 역시 이터러블
- 배열 아닌 객체 어떤 것들의 컬렉션 <sub>(목록, 집합 등)</sub> 나타낼 경우 `for…of` 문법 적용 시 컬렉션 순회 유용

### `Symbol.iterator`
- `range` 이터러블 만들려면 <sub>(`for…of` 동작하도록 하려면</sub>
  - 객체에 `Symbol.iterator` <sub>(특수 내장 심볼)</sub> 메서드 추가
    1. `for…of` 시작 시 `for…of` 가 `Symbol.iterator` 호출
        - `Symbol.iterator` 없으면 에러 발생
        - `Symbol.iterator` 반드시 이터레이터 <sub>(메서드 `next` 보유 객체)</sub> 반환
    2. 이후 `for…of` 반환된 객체 <sub>(이터레이터)</sub> 만 대상으로 동작
    3. `for…of` 다음 값 필요 시 `for…of` 는 이터레이터 `next()` 메서드 호출
    4. `next()` 반환 값
        - 형태
          - `{ done: Boolean, value: any }`
        - `done=true`
          - 반복 종료 의미
        - `done=false`
          -  value 다음 값 저장
- 직접 이터러블 객체 생성해보기
  - `for…of` 적용 적합해 보이는 배열 아닌 객체 생성
  - 객체 `range` 숫자 간격 표현
```javascript
// for..of 동작 목표
// for(let num of range) ... num=1,2,3,4,5
let range = {
  from: 1,
  to: 5
};

// 1. for..of 최초 호출 시 Symbol.iterator 호출
range[Symbol.iterator] = function() {

  // Symbol.iterator 이터레이터 객체 반환
  // 2. 이후 for..of 반환된 이터레이터 객체만을 대상 동작, 이때 다음 값 정해짐
  return {
    current: this.from,
    last: this.to,

    // 3. for..of 반복문 반복마다 next() 호출
    next() {
      // 4. next() 반환 값 : 객체 { done:.., value :... } 형태
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 결과
for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- 이터러블 객체 핵심
  - '관심사의 분리 <sub>(Separation of concern, SoC)</sub>'
- `range` 메서드 `next()` 보유 X
  - 대신 `range[Symbol.iterator]()` 호출해서 만든 ‘이터레이터’ 객체
  - 이 객체 메서드 `next()` 반복에 사용될 값 생성
  - 이터레이터 객체 · 반복 대상 객체 분리
- 이터레이터 객체 · 반복 대상 객체 합쳐서 `range` 자체 이터레이터 만들면 코드 더 간단
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- `range[Symbol.iterator]()` 객체 `range` 자체 반환
- 반환 객체 필수 메서드 `next()` 보유
- `this.current` 반복 얼마나 진행되었는지 나타내는 값 저장
- 코드 더 짧아짐
  - 이렇게 작성 좋을 때 종종 有
- 단점
  - 두 개 `for…of` 반복문 하나의 객체 동시 사용 X
    - 이터레이터 <sub>(객체 자신</sub> 하나뿐 → 두 반복문 반복 상태 공유
    - 동시 두 개 `for…of` 사용 → 비동기 처리에서도 흔한 케이스 X

#### 무한개의 이터레이터
- 무수히 많은 이터레이터 가능
- `range.to` 에 `Infinity` 할당 시 `range` 무한대
  - 무수히 많은 의사 난수 생성 이터러블 객체 가능
    - 이 방법 유용한 경우 有
- `next` 제약사항 X
  - `next` 값 계속 반환
    - 정상적인 동작
  - 위와 같은 이터러블에 `for…of` 반복문 사용 시 끝 X
    - `break` 사용해 언제든지 반복 중단 가능

### 문자열은 이터러블입니다
- 배열 · 문자열
  - 가장 광범위하게 쓰이는 내장 이터러블
```javascript
// for..of 문자열 각 글자 순회
for (let char of "test") {
  // 글자 하나당 한 번 실행 (4회 호출)
  alert( char ); // t, e, s, t 차례대로 출력
}

// 서로게이트 쌍 잘 동작
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, 😂 차례대로 출력
}
```

### 이터레이터를 명시적으로 호출하기
- 이터레이터 명시적 호출하는 경우 거의 無
- `for…of` 보다 반복 과정 더 잘 통제
- 반복 과정 여러 개로 쪼개기 가능
  - 반복 시작했다가 잠시 멈춰 다른 작업 하다가 다시 반복 시작 등
```javascript
// 직접 호출 순회
// 문자열 이터레이터 생성 후 값 ‘수동으로’ 가져옴
let str = "Hello";

// for..of 사용 동일 작업
// for (let char of str) alert(char);
let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자 하나씩 출력
}
```

### 이터러블 vs 유사 배열
- 이터러블 <sub>(iterable)</sub>
  -  `Symbol.iterator` 메서드 구현 객체
- 유사 배열
  - 인덱스 · `length` 프로퍼티 <sub>(배열처럼 보이는 객체)</sub>
- 브라우저 등의 호스트 환경 자바스크립트 사용 시
  - 이터러블 객체 · 유사 배열 객체 · 이터러블 + 유사배열 객체 종종 존재
    - `for…of` 사용 가능
    - 숫자 인덱스, `length` 프로퍼티
    - 대표적으로 문자열
- 이터러블 객체 ≠ 유사 배열 객체
- 유사 배열 객체 ≠ 이터러블 객체
```javascript
// 유사 배열 객체
// 이터러블 객체 X
let arrayLike = { // 인덱스 · length 프로퍼티 → 유사 배열
  0: "Hello",
  1: "World",
  length: 2
};

// Symbol.iterator 미존재 → 에러 발생
for (let item of arrayLike) {}
```
- 이터러블 · 유사 배열
  - 대개 배열 X
    - `push` · `pop` 등 메서드 지원 X
    - 이터러블 · 유사 배열 배열처럼 다루고 싶을 때 불편함 초래

### `Array.from`
- 이터러블 · 유사 배열 ‘진짜’ `Array` 생성
  - 배열 메서드 사용 가능
```javascript
// 유사 배열 → 배열
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

// 객체 받아 이터러블 · 유사 배열인지 조사
// 인수 이터러블 · 유사 배열인 경우
// - 새로운 배열 생성 후 객체 모든 요소 새롭게 만든 배열로 복사
let arr = Array.from(arrayLike); // 배열 메서드 정상 동작
alert(arr.pop());
```
```javascript
// 이터러블 → 배열
// 챕터 위쪽 예시 range
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (배열 문자열 형 변환 정상 동작)
```
- ‘매핑’ 함수 선택적 인수
```javascript
Array.from(obj[, mapFn, thisArg])
```
- `mapFn` 두 번째 인수
  - 새로운 배열 `obj` 요소 추가 전 각 요소 대상 `mapFn` 적용
  - 새로운 배열 `mapFn` 적용 후 반환 값 추가
- `thisArg` 세 번째 인수
  - 각 요소 `this` 지정
```javascript
// 챕터 위쪽 예시 range
// 각 숫자 제곱
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```
```javascript
// 문자열 → 배열
let str = '𝒳😂';

// str 분해 → 글자 담긴 배열
let chars1 = Array.from(str);

alert(chars1[0]);     // 𝒳
alert(chars1[1]);     // 😂
alert(chars1.length); // 2

//str.split 과 달리 문자열 자체 보유 이터러블 속성 이용해 동작
// - for..of 처럼 서로게이트 쌍 정상 적용
let chars2 = [];

// Array.from 내부 → 동일 반복문 동작
for (let char of str) {
  chars2.push(char);
}

alert(chars2[0]);     // 𝒳
alert(chars2[1]);     // 😂
alert(chars2.length); // 2
```
- 서로게이트 쌍 처리 `slice` 직접 구현
```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 내장 순수 메서드 : 서로게이트 쌍 미지원
alert( str.slice(1, 3) ); // 쓰레깃값 출력 (영역 다른 특수 값)
```

<br />

맵과 셋
=======

### 맵
- 키 있는 데이터 저장
  - 객체 유사
- 키 다양한 자료형 허용
- 주요 메서드 · 프로퍼티
  - `new Map()`
    - 맵 생성
  - `map.set(key, value)`
    - `key` 이용해 `value` 저장
  - `map.get(key)`
    - `key` 해당 값 반환
    - `key` 미존재 시 `undefined` 반환
  - `map.has(key)`
    - `key` 존재 시 `true`
    - `key` 미존재 시 `false` 반환
  - `map.delete(key)`
    - `key` 해당 값 삭제
  - `map.clear()`
    - 맵 안 모든 요소 제거
  - `map.size`
    - 요소 개수 반환
```javascript
let map = new Map();

map.set('1', 'str1');   // 문자형 키
map.set(1, 'num1');     // 숫자형 키
map.set(true, 'bool1'); // 불린형 키

// 객체 : 키 문자형 변환
// 맵   : 키 타입 변환 X (그대로 유지)
alert( map.get(1)   );  // 'num1'
alert( map.get('1') );  // 'str1'

alert( map.size ); // 3
```
- 객체와 달리 키 문자형 변환 X
- 키 자료형 제약 X

#### `map[key]` 는 `map` 을 쓰는 바른 방법이 아닙니다.
- `map[key]` 사용 가능
  - `map` 일반 객체 취급
    - 여러 제약 발생
- `map` 사용 시 전용 메서드 사용

#### 맵은 키로 객체를 허용합니다.
```javascript
let john1 = { name: "John" };

let visitsCountMap1 = new Map();
visitsCountMap1.set(john1, 123);

alert( visitsCountMap1.get(john1) );         // 123

// 객체 객체형 키
let john2 = { name: "John" };

let visitsCountObj2 = {};                    // 객체
visitsCountObj2[john2] = 123;                // 객체 키로 값 (123) 저장

alert( visitsCountObj2["[object Object]"] ); // 123 (문자열 형 변환 발생)
```

#### 맵이 키를 비교하는 방식
- SameValueZero 알고리즘 사용해 값 등가 여부 확인
  - 일치 연산자 `===` 거의 유사
  - 차이
    - `NaN === NaN` 취급
    - `NaN` 키 사용 가능

#### 체이닝
- `map.set` 호출 시 맵 자신 반환
```javascript
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```

### 맵의 요소에 반복 작업하기
- `map.keys()`
  - 각 요소 키 모은 반복 가능한 <sub>(이터러블)</sub> 객체 반환
- `map.values()`
  - 각 요소 값 모은 이터러블 객체 반환
- `map.entries()`
  - 요소 [키 · 값] 한 쌍 이터러블 객체 반환
    - 이터러블 객체
      - `for…of` 반복문
```javascript
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 키 대상 순회
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 값 대상 순회
for (let amount of recipeMap.values()) {
  alert(amount);    // 500, 350, 50
}

// [키, 값] 쌍 대상 순회
for (let entry of recipeMap) { // recipeMap.entries() 동일
  alert(entry);     // cucumber,500 ...
}
```
- 내장 메서드 `forEach` 지원 <sub>(배열 유사)</sub>
```javascript
// 각 (키, 값) 쌍 대상 함수 실행
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 ...
});
```
#### 맵은 삽입 순서를 기억합니다.
- 값 삽입 순서대로 순회 실시
  - 객체
    - 프로퍼티 순서 기억 X

### `Object.entries` : 객체를 맵으로 바꾸기
- 각 요소 키 · 값 쌍 배열 · 이터러블 객체
  - 초기화 용도 맵 전달해 새로운 맵 생성
```javascript
// 각 요소 [키, 값] 쌍 배열
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
alert( map.get('1') ); // str1

// 객체 내장 메서드 Object.entries(obj)
// - 객체 키-값 쌍 요소([key, value]) 배열 반환
let obj = {
  name: "John",
  age: 30
};

/* Object.entries(obj)
{
  name: "John",
  age: 30
}
↓↓↓
[
  ["name","John"],
  ["age", 30]
]
*/
let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
```

### `Object.fromEntries` : 맵을 객체로 바꾸기
- 각 요소 [키 · 값] 쌍 배열 → 객체
```javascript
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);
/*
↓↓↓
{
  banana: 1,
  orange: 2,
  meat: 4
}
*/

alert(prices.orange); // 2
```
  - `map.entries()`
    - 맵 [키 · 값] 요소 보유 이터러블 반환
```javascript
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

 // 맵 → 일반 객체
let obj = Object.fromEntries(map.entries());
//        Object.fromEntries(map); → '.entries()' 생략
/*
↓↓↓
{
  banana: 1,
  orange: 2,
  meat: 4
}
*/

alert(obj.orange); // 2
```
- 인수 이터러블 객체
  - `.entries()` 생략 동일 동작
  - 반드시 배열 전달 X
- `map` 에서의 일반적인 반복
  - `map.entries()` 사용 동일하게 키 · 값 쌍 반환
  - `map` 동일한 키 · 값 보유 일반 객체 얻음

### 셋
- 중복 미허용 값 모아놓은 컬렉션
- 키 없는 값 저장
- 주요 메서드
  - `new Set(iterable)`
    - 셋 생성
    - 이터러블 객체 전달받으면 <sub>(대개 배열 전달받음)</sub> 그 안 값 복사해 셋 삽입
  - `set.add(value)`
    - 값 추가 후 셋 자신 반환
  - `set.delete(value)`
    - 값 제거
      - 셋 내 값 있어 제거 성공 시
        - `true` 반환
      - 셋 내 값 없어 제거 실패 시
        - `false` 반환
  - `set.has(value)`
    - 셋 내 값 존재 시
      - `true` 반환
    - 셋 내 값 부재 시
      - `false` 반환
  - `set.clear()`
    - 셋 비움
  - `set.size`
    - 셋 내 요소 개수 반환
- 셋 내 동일한 값 존재 시 `set.add(value)` 아무리 많이 호출해도 아무런 반응 X
  - 셋 내 값 중복 없는 이유
```javascript
let set = new Set();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// 유일무이한 값만 저장
alert( set.size );  // 3

for (let user of set) {
  alert(user.name); // John, Pete, Mary
}
```
- 셋 대신 배열 사용해 정보 저장 후, 중복 값 여부 배열 메서드 `arr.find` 이용해 확인 가능
  - `arr.find` 배열 내 요소 전체 뒤져 중복 값 찾음
    - 성능 ↓
    - 셋 : 값 유일무이 확인 최적화

### 셋의 값에 반복 작업하기
- `for…of` · `forEach`
```javascript
let set = new Set(["oranges", "apples", "bananas"]);

// for…of
for (let value of set) alert(value);

// forEach
// 인수 : 맵과의 호환성 때문
// - 맵 forEach 콜백 : 세 개 인수
// - 맵 ↔ 셋 교체 용이
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```
- 반복 작업 메서드
  - `set.keys()`
    - 셋 내 모든 값 보유 이터러블 객체 반환
  - `set.values()`
    - `set.keys` 동일 작업
    - 맵과의 호환성 위한 메서드
  - `set.entries()`
    - 셋 내 각 값 이용해 만든 `[value, value]` 배열 포함 이터러블 객체 반환
    - 맵과의 호환성 위한 메서드

<br />

위크맵과 위크셋
===============================

- 자바스크립트 엔진 도달 가능한 <sub>(추후 사용 가능성 있는)</sub> 값 메모리에 유지
```javascript
let john = { name: "John" };

// 위 객체 john 참조 통해 접근 가능
// 참조 null 덮어쓰면 위 객체 더 이상 도달 불가능
// 객체 메모리에서 삭제
john = null;
```
- 자료구조 구성 요소
  - 자신 속한 자료구조 메모리에 남아있는 동안 대개 도달 가능한 값 취급
    - 메모리에서 삭제 X
      - 객체 프로퍼티
      - 배열 요소
      - 맵 · 셋 구성 요소 등
```javascript
// 배열 메모리에 남아있는 한, 배열 요소 객체 메모리에 남아있음
// (객체 참조 아무것도 없어도)
let john = { name: "John" };
let array = [ john ];

john = null; // 참조 null 덮어씀

// john 객체 → 배열 요소
// 가비지 컬렉터 대상 X
// array[0] : 해당 객체 얻음
alert(JSON.stringify(array[0]));
```
- 맵 객체 키
  - 맵 메모리에 있는 한 객체 메모리에 남음
    - 가비지 컬렉터 대상 X
```javascript
let john = { name: "John" };
let map = new Map();
map.set(john, "...");

john = null; // 참조 null 덮어씀

// john 객체 맵 안 저장
// map.keys() 이용해 해당 객체 얻기 가능
for(let obj of map.keys()){
  alert(JSON.stringify(obj));
}

alert(map.size);
```

### 위크맵
- 일반 맵과 전혀 다름
- 키 객체 가비지 컬렉션 대상

#### 맵 vs 위크맵 차이 ①
- 키
  - 반드시 객체
  - 원시값 X
```javascript
let weakMap = new WeakMap();
let obj = {};

weakMap.set(obj, "ok");        // 정상 동작 (객체 키)
weakMap.set("test", "Whoops"); // 문자열("test") 키 사용 X
                               // Error: Invalid value used as weak map key
```
- 위크맵 키 객체 참조 미존재 시
  - 해당 객체 메모리 · 위크맵 자동 삭제
```javascript
let john = { name: "John" };
let weakMap = new WeakMap();

weakMap.set(john, "...");

john = null; // 참조 null 덮어씀

// john 객체 메모리에서 제거
```
- `"john"` 객체 오로지 위크맵 키 사용
  - 참조 덮어쓰면 객체 위크맵  · 메모리에서 자동 삭제

#### 맵 vs 위크맵 차이 ②
- 반복 작업 · `keys()` · `values()` · `entries()` 메서드 미지원
- 키 · 값 전체 얻기 불가능
- 위크맵 지원 메서드
  - `weakMap.get(key)`
  - `weakMap.set(key, value)`
  - `weakMap.delete(key)`
  - `weakMap.has(key)`
- 적은 메서드 제공
  - 가비지 컬렉션 동작 방식
    - 객체 모든 참조 잃으면 자동 가비지 컬렉션 대상
    - 가비지 컬렉션 동작 시점 정확히 인지 X
      - 시점 자바스크립트 엔진 결정
      - 그 즉시 · 대기 중 함께 삭제될 수도
      - 한 번에 메모리 청소할 수 or 부분 부분 메모리 청소할 수도
        - 현재 위크맵 요소 몇 개 있는지 정확히 파악 자체 불가능
        - 위크맵 요소 </sub>(키 · 값)</sub> 전체 대상 무언가를 동작 자체 불가능

### 유스 케이스: 추가 데이터
- 부차적인 데이터 저장할 곳 필요할 때
  - 서드파티 라이브러리 같은 외부 코드 ‘속한’ 객체 작업
    - 이 객체 데이터 추가
    - 추가 데이터
      - 객체 살아있는 동안에만 유효
- 위크맵 원하는 데이터 저장
  - 키 : 객체 사용
    - 객체 가비지 컬렉션 대상 될 때 데이터 함께 제거
```javascript
// john 사망 시 비밀문서 자동 파기
weakMap.set(john, "비밀문서");
```
```javascript
/* 📁 visitsCount.js */
// 맵 사용자 방문 횟수 저장
let visitsCountMap = new Map();

// 사용자 방문 시 방문 횟수 ↑
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

/* 📁 main.js */
let john = { name: "John" };

countUser(john); // John 방문 횟수 증가

// John 방문 횟수 셀 필요 없어지면 john null로 덮어씀
john = null;
```
- `"john"` 객체 가비지 컬렉션 대상 되어야 하는데 `visitsCountMap` 키 사용되고 있어 메모리에서 삭제 X
- 특정 사용자 객체 메모리에서 사라지면 해당 객체 대한 정보 <sub>(방문 횟수)</sub> 손수 지워줘야 하는 상황
  - 이렇게 하지 않으면 `visitsCountMap` 차지 메모리 공간 한없이 ↑
  - 애플리케이션 구조 복잡할 경우 쓸모 없는 데이터 수동 비우기 꽤 골치 아픔
- 위크맵 사용해 문제 예방
```javascript
/* 📁 visitsCount.js */
// 위크맵 사용자 방문 횟수 저장함
let visitsCountMap = new WeakMap();

// 사용자 방문 시 방문 횟수 ↑
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```
- 위크맵 사용해 사용자 방문 횟수 저장 시 `visitsCountMap` 수동 청소 필요 X
- `"john"` 객체 도달 가능하지 않은 상태 되면 자동 메모리에서 삭제
- 위크맵 키 </sub>(`"john"`)</sub> 대응 값 <sub>(`"john"` 방문 횟수)</sub> 자동 가비지 컬렉션 대상

### 유스 케이스: 캐싱
- 캐싱 <sub>(caching)</sub> 필요할 때 유용
- 시간 오래 걸리는 작업 결과 저장해서 연산 시간 · 비용 절약 기법
- 동일 함수 여러 번 호출해야 할 때, 최초 호출 시 반환된 값 어딘가 저장 후 다음에 함수 호출 대신 저장된 값 사용
```javascript
/* 📁 cache.js */
let cache = new Map();

// 연산 수행 후 그 결과 맵에 저장
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

/* 📁 main.js */
// 함수 process() 호출
let obj = {/* ... 객체 ... */};

// 함수 호출
let result1 = process(obj);

// 동일 함수 2번째 호출
// 연산 수행 X, 맵 저장 결과 가져옴
let result2 = process(obj);

// 객체 쓸모없어지면 null 덮어씀
obj = null;

// 객체 여전히 cache 안 존재 (메모리 낭비)
// 수동 cache 청소 필요
alert(cache.size); // 1
```
- 위크맵 문제 예방
- 객체 메모리에서 삭제 시, 캐시 저장 결과 <sub>(함수 연산 결과)</sub> 역시 메모리에서 자동 삭제
```javascript
// 📁 cache.js
let cache = new WeakMap();

// 이하 동일

// cache.size 사용 불가능
// obj 가비지 컬렉션 대상 되므로 캐싱 데이터 역시 메모리에서 삭제
// 삭제 진행 후 cache 그 어떤 요소 미존재
```

### 위크셋
- 셋 유사
- 차이
  - 객체만 저장 가능
  - 원시값 저장 X
- 셋 안 객체 도달 가능할 때만 메모리 유지
- 적은 메서드 지원
  - `add`
  - `has`
  - `delete`
- 미지원 메서드 · 프로퍼티
  - `size`
  - `keys()`
  - 반복 작업 관련 메서드
- 부차적인 데이터 저장 시 사용 <sub>(위크맵 유사)</sub>
- 복잡한 데이터 저장 X
  - 간단한 정보 보관 용도
    - "예" · “아니오” 등
```javascript
let visitedSet = new WeakSet();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john);
visitedSet.add(pete);
visitedSet.add(john);

alert(visitedSet.has(john)); // true
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet에서 john 객체 자동 삭제
```
- 위크맵 · 위크셋 가장 큰 단점
  - 반복 작업 불가능
  - 저장 자료 한 번에 얻기 불가능
  - 위크맵 · 위크셋 이용 주요 작업 방해 X
  - 객체 함께 ‘추가’ 데이터 저장 용도

<br />

`Object.keys` · `values` · `entries`
============================

- 순회 관련 메서드
  - `keys()`
  - `values()`
  - `entries()`
- 순회 관련 메서드 사용 가능 자료구조
  - `Map`
  - `Set`
  - `Array`
- 포괄적인 용도
  - 메서드 적용 자료구조 일련 합의 준수
    - 커스텀 자료구조 대상 순회 시
      - 기존 메서드 사용 X
      - 직접 메서드 구현
- 일반 객체용 순회 관련 메서드 <sub>(자료구조 메서드 문법 상이)</sub>
  - `Object.keys(obj)`
    - 객체 키 배열 반환
  - `Object.values(obj)`
    - 객체 값 배열 반환
  - `Object.entries(obj)`
    - [키 · 값] 쌍 배열 반환

||맵|객체|
|---|---|---|
|호출 문법|`map.keys()`|`Object.keys(obj)` ≠ `obj.keys()`|
|반환 값|iterable 객체|‘진짜’ 배열|

#### 차이 ①
- 호출 주체
  - `Object.keys(obj)`　&nbsp;O
  - `obj.keys()` 　　　　X
- 유연성
  - 복잡한 자료구조 전체 → 객체 기반
  - 커스텀 메서드 구현 상태
    - 커스텀 메서드 · 내장 메서드 둘 다 사용 가능

#### 차이 ②
- 반환 값
  - 배열 <sub>(객체 한 종류)</sub> 　O
  - iterable 객체 　　　　X
- 하위 호환성
```javascript
let user = {
  name: "John",
  age: 30
};

// Object.keys(user)    → [ "name", "age" ]
// Object.values(user)  → [ "John", 30 ]
// Object.entries(user) → [ ["name","John"], ["age",30] ]
```
- `Object.values` 사용 시 프로퍼티 값 대상 원하는 작업 가능
```javascript
let user = {
  name: "Violet",
  age: 30
};

// 값 순회
for (let value of Object.values(user)) {
  alert(value); // Violet, 30 연속적으로 출력
}
```

#### `Object.keys` · `values` · `entries` 는 심볼형 프로퍼티를 무시합니다.
- 심볼형 키 프로퍼티 무시
  - `for…in` 반복문
  - `Object.keys`
  - `Object.values`
  - `Object.entries`
- 대개 심볼형 키 연산 대상 미포함 권장
  - 필요한 경우
    - `Object.getOwnPropertySymbols`
      - 심볼형 키 배열 형태 반환 메서드
    - `Reflect.ownKeys(obj)`
      - 키 전체 배열 형태 반환

### 객체 변환하기
- 객체 대상 배열 전용 메서드 <sub>(`map` · `filter` 등)</sub> 사용 X
- `Object.entries` · `Object.fromEntries` 순차적으로 적용 시 객체 배열 전용 메서드 사용 가능
- 적용 방법
  1. `Object.entries(obj)`
      - 객체 키 · 값 쌍 요소 배열 얻기
  2. 배열에 `map` 등 배열 전용 메서드 사용
  3. `Object.fromEntries(array)`
    - 메서드 사용 후 반환 배열 다시 객체 변환
```javascript
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

// 객체 → 배열 → 배열 전용 메서드 → 객체
//                  .map      .fromEntries
let doublePrices = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```

<br />

구조 분해 할당
=============

- 구조 분해 할당
  - 객체 · 배열 변수로 '분해’
  - 함수 매개변수 多
  - 매개변수 기본값 필요 등

### 배열 분해하기
```javascript
// 이름과 성을 요소로 가진 배열
let arr = ["Bora", "Lee"]

// 구조 분해 할당
// firstName ← arr[0]
// surname   ← arr[1]
let [firstName, surname] = arr;

alert(firstName); // Bora
alert(surname);   // Lee

// 반환 값 배열 메서드 함께 활용
let [firstName, surname] = "Bora Lee".split(' ');
```

#### '분해 <sub>(destructuring)</sub>' 는 '파괴 <sub>(destructive)</sub>'를 의미하지 않습니다.
- '분해 <sub>(destructurize)</sub>' 의미
- 분해 대상 수정 · 파괴 X
- 배열 요소 직접 변수 할당보다 코드 양 ↓
```javascript
// 구조 분해 할당
let [firstName1, surname1] = arr;

// 직접 할당
let firstName2 = arr[0];
let surname2 = arr[1];
```

#### 쉼표를 사용하여 요소 무시하기
- 쉼표 사용 시 불필요 배열 요소 버림
```javascript
// 두 번째 요소는 필요하지 않음
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
```

#### 할당 연산자 우측엔 모든 이터러블이 올 수 있습니다.
- 모든 이터러블 <sub>(iterable, 반복 가능 객체)</sub> 적용 가능
```javascript
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

#### 할당 연산자 좌측엔 뭐든지 올 수 있습니다.
- 할당 연산자 좌측
  - ‘할당할 수 있는’ 것이라면 어떤 것이든 가능
  - 객체 프로퍼티 가능
```javascript
let user = {};
[user.name, user.surname] = "Bora Lee".split(' ');

alert(user.name); // Bora
```

#### `.entries()` 로 반복하기
- `Object.entries(obj)` · 구조 분해 조합해 객체 키 · 값 순회해 변수 분해 할당
```javascript
// 객체
let user1 = {
  name: "John",
  age: 30
};

// 객체 키 · 값 순회
for (let [key, value] of Object.entries(user1)) {
  alert(`${key}:${value}`); // name: John, age: 30
}

// 맵
let user2 = new Map();
user2.set("name", "John");
user2.set("age", "30");

// 맵 키 · 값 순회
for (let [key, value] of user2) {
  alert(`${key}:${value}`); // name: John, age: 30
}
```

#### 변수 교환 트릭
- 두 변수 값 교환
```javascript
let guest = "Jane";
let admin = "Pete";

[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane
```

#### `...` 로 나머지 요소 가져오기
- ‘나머지’ 요소 가져오기
- 나머지 배열 요소 저장 새로운 배열
```javascript
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// `rest` : 배열입니다.
alert(rest[0]);     // Consul
alert(rest[1]);     // of the Roman Republic
alert(rest.length); // 2
```
- `...` 변수 앞의 점 세 개
- 가장 마지막 위치

#### 기본값
- 할당 변수 개수 > 분해 배열 길이
  - 에러 발생 X
  - 할당 값 없으면 `undefined` 취급
```javascript
let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname);   // undefined
```
- `=`
  - 할당 값 없을 때 '기본값' 설정
```javascript
// 기본값
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius    (배열 값)
alert(surname); // Anonymous (기본값)
```
- 복잡한 표현식 · 함수 호출 기본값 가능
  - 할당 값 없을 때 표현식 평가 ·  함수 호출
```javascript
// 값 미제공 때만 함수 호출
// prompt 한 번만 호출 (name의 prompt)
let [surname = prompt('성을 입력하세요.'), name = prompt('이름을 입력하세요.')] = ["김"];

alert(surname); // 김 (배열 값)
alert(name);    // prompt 값
```

### 객체 분해하기
- 우측
  - 분해 대상 객체
- 좌측
  - 상응 객체 프로퍼티 '패턴’
```javascript
let {var1, var2} = {var1:…, var2:…}
```
```javascript
// 분해 대상 객체 프로퍼티 키 목록 패턴 사용
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
- 순서 미중요
```javascript
// let {...} 안 순서 바뀌어도 동일 동작
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
```
- 할당 연산자 좌측 좀 더 복잡한 패턴 가능
- 분해 대상 객체 프로퍼티 · 변수 연결 조정
  - `:` 콜론
    - `분해 대상 객체 프로퍼티: 목표 변수`
```javascript
// 객체 프로퍼티 · 다른 이름 변수 저장
// 콜론 (:)
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { 객체 프로퍼티: 목표 변수 }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title
alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```
- `=`
  - 프로퍼티 부재 대비 기본값 설정
```javascript
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
- 표현식 · 함수 호출 기본값 할당 가능
  - 값 미제공 시 표현식 평가 · 함수 호출
```javascript
let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // prompt 창 입력 값
```
- `:` 콜론 · `=` 할당 연산자 동시 사용 가능
```javascript
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```
- 프로퍼티 많은 복잡한 객체 원하는 정보만 뽑아오기
```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// title만 변수로 뽑아내기
let { title } = options;

alert(title); // Menu
```

#### 나머지 패턴 `...`
- 나머지 프로퍼티 어딘가에 할당
- 모던 브라우저 지원
- IE 등 몇몇 구식 브라우저 미지원
  - 바벨 <sub>(Babel)</sub> 이용
```javascript
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// rest = 나머지 프로퍼티들
let {title, ...rest} = options;

// rest → { height: 200, width: 100 } 할당
alert(rest.height);  // 200
alert(rest.width);   // 100
```

#### `let` 없이 사용하기
- 기존 변수 분해 값 할당 가능
```javascript
// 잘못된 코드
let title, width, height;

// SyntaxError: Unexpected token '='
// 코드 블록으로 인식
{title, width, height} = {title: "Menu", width: 200, height: 100};
```
- 표현식 안에 있지 않으면서 주요 코드 흐름 상에 있는 `{…}`
  - 코드 블록 인식
  - 코드 블록 본래 용도
    - 문 <sub>(statement)</sub> 묶기
  ```javascript
  {
    // 코드 블록
    let message = "Hello";
    // ...
    alert( message );
  }
  ```
- 할당문 괄호 `(…)` 감싸 `{…}` 코드 블록 아닌 표현식으로 해석
```javascript
let title, width, height;

({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
```

### 중첩 구조 분해
- 객체 · 배열 다른 객체 · 배열 포함 시, 좀 더 복잡한 패턴 사용
  - 중첩 배열 · 객체 정보 추출
```javascript
/*
options.size 프로퍼티
- 또 다른 객체
items 프로퍼티
- 배열
대입 연산자 좌측 패턴
- 정보 추출 대상 객체 options 같은 구조
*/
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// 코드 여러 줄 걸쳐 작성해 의도하는 바 명확히 드러냄
let {
  size: {                // size 객체 프로퍼티
    width,
    height
  },
  items: [item1, item2], // items 배열 프로퍼티
  title = "Menu"         // 분해 객체 title 프로퍼티 미존재 → 기본값 사용
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
// extra 미할당

// size · items 전용 변수 X
// 전용 변수 대신 size · items 안 정보 변수 할당
```

### 똑똑한 함수 매개변수
- 종종 함수 매개변수 상당수 선택적으로 사용
```javascript
function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
```
- 넘겨주는 인수 순서 틀려 문제 발생 가능
- 대부분의 매개변수 기본값 설정
  - 굳이 인수 넘겨주지 않아도 되는 경우 문제 발생
```javascript
// 기본값 사용 시 undefined 여러 개 전달
// 가독성 ↓
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
```
- 매개변수 객체에 모아 함수 전달
- 함수 전달받은 객체 분해하여 변수 할당
```javascript
// 함수에 전달할 객체
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// 전달받은 객체 분해 후 변수 즉시 할당
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items  → 객체 options
  // width, height → 기본값
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
```
- 중첩 객체 · `:` 콜론 조합
  - 좀 더 복잡한 구조 분해
```javascript
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,                // width  → w
  height: h = 200,               // height → h
  items: [item1, item2]          // items 1번째 요소 → item1
}) {                             // items 2번째 요소 → item2
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```
- 똑똑한 함수 매개변수 문법
  - 구조 분해 할당 문법 동일
```javascript
// incomingProperty → varName
// 값 부재 시 defaultValue 기본값 사용
function({
  incomingProperty: varName = defaultValue
  ...
})
```
- 함수 매개변수 구조 분해 시
  - 반드시 인수 전달 가정 유의
  - 모든 인수 기본값 할당 시 빈 객체 명시적으로 전달
```javascript
showMenu({}); // 모든 인수 기본값 할당
showMenu();   // 에러가 발생 가능
```
- 빈 객체 `{}` 인수 전체의 기본값 설정
- 어떤 경우든 분해할 것 존재
  - 인수 전부 미전달 시 에러 발생 X
```javascript
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
```

<br />

Date 객체와 날짜
===============

- 생성 · 수정 시간 저장
- 시간 측정
- 현재 날짜 출력 등

### 객체 생성하기

#### `new Date()`
  - 인수 없이 호출 시 현재 날짜 · 시간 저장된 `Date` 객체 반환
```javascript
let now = new Date();
alert( now ); // 현재 날짜 · 시간 출력
```

#### `new Date(milliseconds)`
- UTC 기준 <sub>(UTC+0)</sub> 1970.1.1 00:00:00 에서 milliseconds 밀리초 <sub>(1/1000 초)</sub> 후 시점 저장된 `Date` 객체 반환
```javascript
// 1970.1.1 00:00:00 (UTC+0) 표현 객체
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// 1970.1.1 24시간 후 → 1970.1.1 (UTC+0)
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
```
- 타임스탬프 <sub>(timestamp)</sub>
  - 1970년 첫날 기준 흘러간 밀리초 나타내는 정수
  - 날짜 숫자 형태로 간편하게 표현
  - `new Date(timestamp)` · 타임스탬프 사용해 특정 날짜 저장된 `Date` 객체 손쉽게 생성
  - `date.getTime()` 메서드 사용해 `Date` 객체 타임스탬프 추출
- 1970.1.1 이전 날짜 해당 타임스탬프 값
  - 음수
```javascript
// 1969.12.31
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
```

#### `new Date(datestring)`
- 인수 문자열 하나
  - 해당 문자열 자동으로 구문 분석
  - 구문 분석 적용 알고리즘
    - `Date.parse` 사용 알고리즘 동일
```javascript
let date = new Date("2017-01-26");
alert(date);
// 인수 시간 미지정하지 → GMT 자정 가정
// 코드 실행 시간대 (timezone) 따라 출력 문자열 바뀜
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// or
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
// 등 출력
```

#### `new Date(year, month, date, hours, minutes, seconds, ms)`
- 주어진 인수 조합해 생성 가능 날짜 저장된 객체 반환 <sub>(지역 시간대 기준)</sub>
- 필수 : 1 · 2번째 인수
  - `year`
    - 4자리 숫자
      - 2013 &nbsp;O
      - 98 　&nbsp;X
  - `month`
    - 0 <sub>(1월)</sub> ~ 11 <sub>(12월)</sub> 사이 숫자
  - `date`
    - 일
    - 값 부재 시 1일 처리
  - `hours` · `minutes` · `seconds` · `ms`
    - 값 없는 경우 `0` 처리
```javascript
new Date(2011, 0, 1, 0, 0, 0, 0); // 2011.1.1, 00:00:00
new Date(2011, 0, 1);             // 모든 인수 기본값 : 0

// 최소 정밀도 : 1밀리초 (1 / 1000초)
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date );                    // 2011.1.1., 02:03:04.567
```

### 날짜 구성요소 얻기
- `getFullYear()`
  - 연도 <sub>(4자릿수)</sub> 반환
- `getMonth()`
  - 월 반환 <sub>(`0` ~ `11`)</sub>
- `getDate()`
  - 일 반환 <sub>(`1` ~ `31`)</sub>
- `getHours()` · `getMinutes()` · `getSeconds()` · `getMilliseconds()`
  - 시 · 분 · 초 · 밀리초 반환

#### `getYear()` 말고 `getFullYear()` 를 사용하세요.
- 여러 자바스크립트 엔진 더는 사용되지 않는 <sub>(`deprecated`)</sub> 비표준 메서드 `getYear()` 구현
- 두 자릿수 연도 반환 경우 有
  - 절대 사용 X
  - `getFullYear()` 사용

#### `getDay()`
- `0` <sub>(일요일)</sub> ~ `6` <sub>(토요일)</sub> 중 하나 반환
- 몇몇 나라에서 요일의 첫날이 일요일이 아니긴 하지만, `getDay` 에선 항상 `0` 이 일요일을 나타냅니다. 이를 변경할 방법은 없습니다.

#### 위 메서드 모두 현지 시간 기준 날짜 구성요소 반환
- 표준시 <sub>(UTC+0)</sub> 기준 날짜 구성 요소 반환 메서드
  - `getUTCFullYear()`
  - `getUTCMonth()`
  - `getUTCDay()`
```javascript
// 현재 일시
let date = new Date();

// 현지 시간 기준 시
alert( date.getHours() );

// 표준시간대 (UTC+0, 일광 절약 시간제 미적용 런던 시간) 기준 시
alert( date.getUTCHours() );
```

#### `getTime()`
- 주어진 일시 ~ 1970.1.1 00:00:00 사이 간격 <sub>(밀리초 단위)</sub> 타임스탬프 반환

#### `getTimezoneOffset()`
- 현지 시간 ~ 표준 시간 차이 <sub>(분)</sub> 반환

### 날짜 구성요소 설정하기
- 날짜 구성요소 설정 메서드
  - `setFullYear(year, [month], [date])`
  - `setMonth(month, [date])`
  - `setDate(date)`
  - `setHours(hour, [min], [sec], [ms])`
  - `setMinutes(min, [sec], [ms])`
  - `setSeconds(sec, [ms])`
  - `setMilliseconds(ms)`
  - `setTime(milliseconds)` <sub>(1970.1.1 00:00:00 UTC ~ 밀리초 이후 나타내는 날짜 설정)</sub>
- `setTime()` 제외 모든 메서드 표준시 날짜 구성 요소 설정 메서드 有
  - ex&#41; `setUTCHours()`
```javascript
let today = new Date();

today.setHours(0);
alert(today); // 날짜 변경 X, 시 변경 (0)

today.setHours(0, 0, 0, 0);
alert(today); // 날짜 변경 X, 시, 분, 초 모두 변경 (00:00:00초)
```

### 자동 고침
- 범위 밖 값 설정 시 자동 고침 기능 활성화, 값 자동 수정
```javascript
let date = new Date(2013, 0, 32); // 2013.1.32 불가능
alert(date);                      // 2013.2.1  출력
```
- 입력받은 날짜 구성 요소 범위 벗어나면 초과분 자동으로 다른 날짜 구성요소 배분
- 윤년 자동 계산
```javascript
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 2016.3.1
```
- 일정 시간 지난 후 날짜 구하는데도 종종 사용
```javascript
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // 70초 후 날짜 출력
```
- 0 · 음수 날짜 구성요소 설정 가능
```javascript
let date = new Date(2016, 0, 2); // 2016.1.2

date.setDate(1);                 // 변경 (1일)
alert( date );                   // 2016.1.1

date.setDate(0);                 // 일 최솟값 : 1, 0 입력 시 전 달 마지막 날 설정 효과
alert( date );                   // 2015.12.31
```

### `Date` 객체를 숫자로 변경해 시간차 측정하기
- `Date` 객체 숫자형 변경 시 타임스탬프 <sub>(`date.getTime()` 호출 시 반환 값)</sub>
```javascript
let date = new Date();
alert(+date); // 타임스탬프 (date.getTime() 호출 동일)
```
- 날짜 마이너스 연산자 적용해 밀리초 기준 시차 구하기
```javascript
let start = new Date(); // 측정 시작

// 원하는 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date();   // 측정 종료

alert( `반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.` );
```

### `Date.now()`
- 현재 타임스탬프 반환 메서드
- `new Date().getTime()` 의미론적으로 동일
- 중간 Date 객체 미생성
  - `new Date().getTime()` 보다 빠름
    -  가비지 컬렉터 일 ↓
- 성능 중요 시 `Date.now()` 자주 활용
```javascript
let start = Date.now(); // 1970.1.1 ~ 현재까지의 밀리초

// 원하는 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now();   // done

// Date 객체 X, 숫자끼리 차감
alert( `반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.` );
```

### 벤치마크 테스트
- 비교 대상 성능 비교 · 시험 · 평가
- CPU 소모 큰 함수 신뢰할만한 벤치마크 <sub>(평가 기준)</sub> 구하려면 상당한 주의 필요
```javascript
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// 반환 값 : 밀리초
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

// 벤치마크 테스트
function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'diffSubtract 십만번 호출 소모 시간: ' + bench(diffSubtract) + 'ms' );
alert( 'diffGetTime  십만번 호출 소모 시간: ' + bench(diffGetTime) + 'ms' );
```
- 형 변환 X
  - 엔진 최적화 소모 자원 ↓
  - `getTime()` 훨씬 빠름
- 멀티 프로세스 지원 운영체제
  - 병렬 처리 <sub>(CPU 자원 투입)</sub> → 부정확
- 좀 더 신뢰할만한 벤치마크 테스트
  - benchmark 번갈아 가면서 여러 번 실행
```javascript
// ...동일...

let time1 = 0;
let time2 = 0;

// 벤치마크 테스트
// 함수 bench 각 함수 (diffSubtract, diffGetTime) 별로 10번씩 실행
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'diffSubtract에 소모된 시간: ' + time1 );
alert( 'diffGetTime에 소모된 시간: ' + time2 );
```
- 모던 자바스크립트 엔진 아주 많이 실행된 코드인 'hot code’ 대상 최적화 수행
  - 메인 반복문 실행 전 예열용 bench 실행
```javascript
// 메인 반복문 실행 전, "예열용" 코드
bench(diffSubtract);
bench(diffGetTime);

// 벤치마크 테스트 시작
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

#### 세밀한 벤치마킹을 할 때는 주의하세요
- 모던 자바스크립트 엔진 최적화 多
  - '만들어진 테스트’ · '실제 사례’ 결과 상이 가능
  - 특히 연산자, 내장 함수 등 아주 작은 것일수록 더 상이할 수 있음
  - 진지하게 성능 이해
    - 자바스크립트 엔진 동작 방식 공부
    - [Javscript v8 Engine](http://mrale.ph "Javscript v8 Engine Essay")

<br />

JSON과 메서드
============

- JSON <sub>(JavaScript Object Notation)</sub>
  - 값 · 객체 표현 범용 포맷 <sub>(RFC 4627 표준)</sub>
  - 데이터 교환 목적 사용 多
    - 클라이언트 측 언어 자바스크립트
- JSON 관련 메서드
  - `JSON.stringify`
    - 객체 → JSON
  - `JSON.parse`
    - JSON → 객체

### `JSON.stringify`
```javascript
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // string

alert(json);
/* JSON 인코딩된 객체:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
```
- JSON - □□□ - 객체
  - encoded <sub>(인코딩된)</sub>
  - serialized <sub>(직렬화 처리된)</sub>
  - stringified <sub>(문자열 변환된)</sub>
  - marshalled <sub>(결집된)</sub>
- JSON 인코딩 객체 vs 일반 객체
  - 문자열
    - 큰따옴표
    - 작은따옴표 X
    - 백틱 X
    - 'John' → "John"
  - 객체 프로퍼티명
    - 큰따옴표
    - age: 30 → "age": 30
- 적용 가능 자료형
  - 객체 `{…}`
  - 배열 `[…]`
  - 원시형
    - 문자형
    - 숫자형
    - 불린형 값
      - `true`
      - `false`
    - `null`
```javascript
// 숫자 → JSON : 숫자
alert( JSON.stringify(1) )          // 1

// 문자열 → JSON : 문자열 (큰따옴표 추가)
alert( JSON.stringify('test') )     // "test"

alert( JSON.stringify(true) );      // true
alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
```
- 데이터 교환 목적
  - 언어 종속 X 포맷
  - 자바스크립트 특유 객체 프로퍼티 `JSON.stringify` 처리 X
- `JSON.stringify` 호출 시 무시 프로퍼티
  - 함수 프로퍼티 <sub>(메서드)</sub>
  - 심볼형 프로퍼티 <sub>(심볼 키 프로퍼티)</sub>
  - `undefined` 프로퍼티
```javascript
let user = {
  sayHi() {            // 무시
    alert("Hello");
  },
  [Symbol("id")]: 123, // 무시
  something: undefined // 무시
};

alert( JSON.stringify(user) ); // {} (빈 객체)
```
- 중첩 객체 자동 문자열 변환
```javascript
let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* 객체 전체가 문자열로 변환되었습니다.
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
```
- 순환 참조
  - 객체 문자열 변환 X
```javascript
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;      // meetup → room
room.occupiedBy = meetup; // room   → meetup

JSON.stringify(meetup);   // Error: Converting circular structure to JSON
```

### `replacer` 로 원하는 프로퍼티만 직렬화하기
- `JSON.stringify` 문법
```javascript
let json = JSON.stringify(value[, replacer, space])
```
- `value`
  - 인코딩 하려는 값
- `replacer`
  - JSON 인코딩 목표 프로퍼티 배열 · 매핑 함수 `function(key, value)`
- `space`
  - 공백 문자 수 <sub>(서식 변경)</sub>
- 보통 `JSON.stringify` 인수 하나만 넘겨서 사용
  - 순환 참조 같이 전환 프로세스 정교하게 조정
    -  두 번째 인수
- JSON 변환 대상 프로퍼티 배열 두 번째 인수
  - 이 프로퍼티들만 인코딩
```javascript
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room             // meetup → room 참조
};

room.occupiedBy = meetup; // room → meetup 참조

// 문자열 participants 비어버림
// - 배열 'name' 프로퍼티 X (규칙 너무 까다로움)
alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}

// 배열 너무 길어짐
alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/

// Replacer 함수 사용
// replacer 함수 프로퍼티 (키, 값) 쌍 전체 대상 호출
// 기존 프로퍼티 값 대신 사용할 값 반환
// 특정 프로퍼티 직렬화 누락
//   - 반환 값 : undefined
alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));
/*
replacer 함수 처리 키 · 값 쌍 목록
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
```
- `replacer` 함수 중첩 객체 ∼ 배열 요소 포함한 모든 키 · 값 쌍 처리
- 재귀적으로 키 · 값 쌍 처리
  - 함수 내 `this`
    - 현재 처리 중인 프로퍼티 위치한 객체 참조
- 함수 최초 호출 때 `{"": meetup}` 형태 "래퍼 객체" 생성
  - 문자열 `":[object Object]"`
  - `replacer` 함수 가장 처음 처리하는 <sub>(key, value)</sub> 쌍
    - 키 : 빈 문자열
    - 값 : 변환 대상 객체 <sub>(`meetup`)</sub> 전체

### `space` 로 가독성 높이기
- 세 번째 인수 `space`
  - 중간 삽입 공백 문자 수
    - 가독성 ↑ 목표
```javascript
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

// 공백 문자 2개
alert(JSON.stringify(user, null, 2));
/*
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

    // 공백 문자 4개
alert(JSON.stringify(user, null, 4));
/*
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
```

### 커스텀 `toJSON`
- 객체 `toJSON` 메서드 구현 시
  - 객체 → JSON
  - `JSON.stringify` 감지, `toJSON` 자동 호출
- 직접 호출 · 중첩객체 사용
```javascript
let room = {
  number: 23,

  // 커스텀 toJSON
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

// 직접 호출
alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",

    // Date 객체 내장 메서드 toJSON 호출
    "date":"2017-01-01T00:00:00.000Z",

    // 중첩객체
    // 커스텀 toJSON
    "room": 23

    // 커스텀 toJSON 미존재 시
    "room": {"number":23}
  }
*/
```

### `JSON.parse`
- JSON 인코딩 객체 → 객체
```javascript
let value = JSON.parse(str, [reviver]);
```
- `str`
  - JSON 형식 문자열
- `reviver`
  - 모든 <sub>(key · value)</sub> 쌍 대상 호출 `function(key,value)` 함수
    - 값 변경
```javascript
// 문자열 변환 배열
let numbers = "[0, 1, 2, 3]";
numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1


// 중첩 객체
let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
```
- 디버깅 등의 목적 직접 JSON 생성 시 저지르는 실수 일부
```javascript
let json = `{
  name: "John",                     // 1: 프로퍼티명 큰따옴표 X
  "surname": 'Smith',               // 2: 프로퍼티 값 큰따옴표 O, 작은따옴표 X
  'isAdmin': false                  // 3: 프로퍼티 키 큰따옴표 O, 작은따옴표 X
  "birthday": new Date(2000, 2, 3), // 4: "new" 사용 X
                                    // 순수한 값 (bare value) 만 사용
  "friends": [0,1,2,3]              // 문제 없음
}`;
```
- JSON 주석 지원 X
- JSON5 포맷
  - 키 큰따옴표 X 가능
  - 주석 지원
  - 자바스크립트 명세서 정의 X <sub>(독자적인 라이브러리)</sub>

### `reviver` 사용하기
```javascript
// 서버로부터 문자열 변환 meetup 객체 전송 받음
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

// 역직렬화(deserialize) → 자바스크립트 객체
let meetup1 = JSON.parse(str);

// meetup1.date
// - 문자열 (Date 객체 X)
alert( meetup1.date.getDate() ); // 에러

// 두 번째 인수 reviver 함수 사용
let meetup2 = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // 정상 작동

// 중첩 객체
let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // 정상 작동
```
