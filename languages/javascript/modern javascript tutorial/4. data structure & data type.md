원시값의 메서드
==============

- 원시값
  - `string`
  - `number`
  - `bigint`
  - `boolean`
  - `symbol`
  - `null`
  - `undefined`
- 객체
  - 프로퍼티에 다양한 종류 값 저장
  - `{ … }` <sub>(중괄호)</sub> 로 생성
  - 함수 ≒ 객체
    - 함수 프로퍼티
  - 다양한 내장 객체 <sub>(고유 프로퍼티 · 메서드 보유)</sub>
    - 날짜
    - 오류
    - HTML 요소
    - 기타 등등
  - 시스템 자원 소모량 多
    - 원시값보다 heavy
    - 내부 구조 유지에 추가 자원 사용

### 원시값 객체처럼 사용하기
- 원시 래퍼 객체
  - 원시값 메서드 · 프로퍼티 접근 시 추가 기능 제공
    - `String`
    - `Number`
    - `Boolean`
    - `Symbol`
```javascript
let str = "Hello";
alert( str.toUpperCase() ); // HELLO
```
1. 원시값 프로퍼티 `.toUpperCase` 접근 시
    - 특별한 객체 `String` 생성
      - 문자열 값 알고 있음
      - 유용한 메서드 보유
2. 메서드 실행 후 새 문자열 반환
3. 특별한 객체 파괴 후 원시값만 남음

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`String` · `Number` · `Boolean` 생성자 사용 X**

- Java 등 몇몇 언어
  - 래퍼 객체 직접 생성 가능
    - ex&#41;
      - `new Number(1)`
      - `new Boolean(false)`
- 자바스크립트
  - 래퍼 객체 생성자 호출 가능
    - 하위 호환성
  - 비추천
    - 몇몇 상황 혼동
```javascript
// 자료형 혼동
alert( typeof 0 );             // number
alert( typeof new Number(0) ); // object

// 객체 논리 평가 시 항상 true 반환
let zero = new Number(0);
if (zero) { // 변수 zero == 객체 → 조건문 참
  alert( "그런데 여러분은 zero가 참이라는 것에 동의하시나요!?!" );
}
```
- `new` 없이  `String` · `Number` · `Boolean` 사용 OK
  - 상식 맞게 인수 원시값 형 변환
```javascript
let num = Number("123"); // 문자열 → 숫자
```

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`null` · `undefined` : 메서드 없음**

- 특수 자료형 `null` · `undefined` 원시값
  - 연관 래퍼 객체 X
  - 연관 메서드 X
  - '가장 원시적' 자료형
  - 프로퍼티 접근 시 에러 발생
```javascript
alert(null.test); // error
```

<br />

숫자형
=====

- 일반적인 숫자
  - 배정밀도 부동소수점 숫자 <sub>(double precision floating point number)</sub>
  - 64비트 형식 IEEE-754 저장
  - 범위 제약
    - -253 < x < 253

- `BigInt`
  - 임의 길이 정수
  - 아주 특별한 경우에만 사용

### 숫자를 입력하는 다양한 방법
- 숫자 마지막 `e` · `-e`
  - `0` 개수
```javascript
// 10 거듭제곱
1e3    === 1    * 1000     // 1000
1.23e6 === 1.23 * 1000000  // 1230000

// 음수 10 거듭제곱
1e-3    === 1    / 1000    // 0.001
1.23e-6 === 1.23 / 1000000 // 0.00000123
```

#### 16 · 2 · 8진수
- `0x` <sub>(16진수)</sub>
  - 다양한 곳 사용
    - 색 표현
    - 문자 인코딩
    - 기타 등등
- `0b` · `0o` <sub>(2진수 · 8진수)</sub>
  - 아주 드물게 사용
```javascript
// 16진수
alert( 0xff ); // 255
alert( 0xFF ); // 255, 대·소문자 구별 X

// 2진수, 8진수
let a = 0b11111111; // 255의 2진수
let b = 0o377;      // 255의 8진수
alert( a == b );    // true, 진법만 상이
```

### `toString(base)`
- `base` 진법 표현 후 문자형 변환 · 반환
```javascript
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
- `base`
  - 2 ~ 36
  - 기본값 : 10
  - 유스 케이스

|`base`|0 ~ 9| 10 ~ &nbsp;|용도|
|:---:|:---:|:---:|---|
|16|0 ~ 9|A ~ F|- 16진수 색<br />- 문자 인코딩 등|
|2|0 · 1||- 연산 디버깅 등|
|36|0 ~ 9|A ~ Z|- 긴 숫자 식별자 축약 등<br />　- ex&#41; url 축약|

```javascript
/* base = 36 */

// . (점) 2개
alert( 123456..toString(36) );  // 2n9c

// 괄호
alert( (123456).toString(36) ); // 2n9c
```

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`.` <sub>(점)</sub> 2개 · 메서드 호출**

- 숫자에서 `toString` 직접 호출
  - `.` <sub>(점)</sub> 2개 사용
  - `.` <sub>(점)</sub> 1개 사용 시
    - 1번째 `.` <sub>(점)</sub> 이후 소수부 인식
      - 에러 발생 가능
    - `.` <sub>(점)</sub> 하나 더 추가 시
      - 소수부 X 판단
      - 함수 호출
    - 대신 괄호 사용 가능

### 어림수 구하기
- 어림수 관련 내장 함수

|대상|`.floor`|`.ceil`|`.round`|`.trunc`|
|:---:|:---:|:---:|:---:|:---:|
|소수점|첫째 자리<br />내림 <sub>(버림)</sub>|첫째 자리<br />올림|첫째 자리<br />반올림|무시<br /><sub>(IE 미지원)</sub>|
|`3.1`|`3`|`4`|`3`|`3`|
|`3.6`|`3`|`4`|`4`|`3`|
|`-1.1`|`-2`|`-1`|`-1`|`-1`|
|`-1.6`|`-2`|`-1`|`-2`|`-1`|

#### 소수점 n번째 기준 어림수 구하기 2가지 방법
1. 곱하기 · 나누기
    1. 숫자 * 10<sup>n</sup>
    2. 어림수 내장 함수 호출
    3. 숫자 / 10<sup>n</sup>
```javascript
// 소수점 2번째 수 기준
let num = 1.23456;

// 1.23456
// 123.456
// 123
// 1.23
alert( Math.floor(num * 100) / 100 );
```

2. `toFixed(n)`
    - 가장 가까운 값 올림 · 버림
      - `Math.round` 유사
    - 반환 값
      - 문자열
      - 숫자형 변환 필요
        - `+` <sub>(단항 덧셈 연산자)</sub> · `Number()` <sub>(메서드)</sub>
    - 소수부 길이 < 인수
      - 끝에 `'0'` 추가
```javascript
let num1 = 12.34;
alert( num1.toFixed(1) );         // "12.3"

let num2 = 12.36;
alert( num2.toFixed(1) );         // "12.4"

// 숫자형 변환
alert( +num2.toFixed(1) );        // 12.4, + (단항 덧셈 연산자)
alert( Number(num2.toFixed(1)) ); // 12.4, Number() 생성자

//소수부 길이 < 인수
let num3 = 12.34;
alert( num3.toFixed(5) );         // "12.34000", 소수부 길이 5 맞춤
```

### 부정확한 계산
- 숫자 내부적으로 64비트 형식 IEEE-754 표현
  - 숫자 저장 시 정확히 64비트 필요
    |비트|저장|
    |---|---|
    |52|숫자|
    |11|소수점 위치<br /><sub>(정수 : 0)</sub>|
    |1|부호|
  - 숫자 너무 커짐
    - 64비트 공간 넘쳐 `Infinity` 처리
```javascript
alert( 1e500 ); // Infinity
```

#### 정밀도 손실
```javascript
alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1 + 0.2 );        // 0.30000000000000004
```
- 숫자 0 · 1 이루어진 이진수 변환 · 연속된 메모리 공간 저장
- 2진법 분수 표현 시 무한 소수
  - 10진법 분수 쉽게 표현
- 2진법 체계
  - 2<sup>n</sup> 으로 나눈 값 잘 동작
  - 다른 값으로 나누면 무한 소수
  - 0.1 · 0.2 등 정확하게 저장 방법 X
- IEEE-754
  - 가능한 가장 가까운 숫자 반올림해 문제 해결
  - 반올림 규칙 적용 시
    - '작은 정밀도 손실' 발생
  - 숫자 덧셈 시
    - '정밀도 손실'도 덧셈
```javascript
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```
#### 문제 해결
1. `toFixed(n)`
    - 어림수 생성 메서드
      - 가장 신뢰할 만한 방법
    - 항상 문자열 반환
    - 인수 갯수 == 반환값 소수자리 수
      - 인수 더 크면 나머지 `0` 채움
    - `+` <sub>(단항 덧셈 연산자)</sub>
      - 문자열 → 숫자형 형 변환
```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) );  // 0.30, 남은 자리 '0' 채움

// + (단항 덧셈 연산자)
// - 문자열 → 숫자형 형 변환
alert( +sum.toFixed(2) ); // 0.3
```
2. 10<sup>n</sup> 곱하기 · 나누기
    1. 10<sup>n</sup> 곱하기 <sub>(정수 변환)</sub>
    2. 연산
    3. 다시 10<sup>n</sup> 나누기
- 정수 수학 연산
  - 비교적 에러 ↓
- 마지막 10<sup>n</sup> 나누기
  - 소수 다시 등장
  - 오류 완전 제거 X
```javascript
alert( (0.1 * 10 + 0.2 * 10) / 10 );     // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```
- 무한소수 완벽 방지 방법 X
  - 필요 때마다 '꼬리' 잘라 어림수 생성

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **흥미로운 발견**

```javascript
alert( 9999999999999999 ); // 10000000000000000
```
- 정밀도 손실
  - 숫자 저장 공간 <sub>(52비트)</sub> 모자람
  - 최소 유효 숫자 손실
- 자바스크립트 숫자 손실 발생해도 오류 발생 X
  - 적절한 포맷으로 숫자 맞추는 데 최선

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **두 종류의 0**

- `0` · `-0` 존재
  - 숫자 부호 단일 비트 저장
  - `0` 포함 모든 숫자 부호 설정 가능
  - 대부분의 연산 `0` · `-0` 동일 취급
    - 차이 두드러지지 않는 편

### `isNaN` · `isFinite`
- `Infinity` · `-Infinity`
  - 그 어떤 숫자보다 큰 · 작은 특수 숫자 값
- `NaN`
  - 에러 표현 값
- 둘 다 숫자형 · 비정상적인 숫자 표현
- 구분 위한 특별 함수
  - `isNaN(value)` · `isFinite(value)`
- `isNaN(value)`
  - 인수 → 숫자 변환 후 `NaN` 테스트
```javascript
alert( isNaN(NaN) );   // true
alert( isNaN("str") ); // false

// 자기 자신 포함 그 어떤 값과도 동일 X
// - 함수 필요 이유
alert( NaN === NaN );  // false
```
- `isFinite(value)`
  - 인수 → 숫자 변환 후 일반 숫자 경우 `true` 반환
```javascript
alert( isFinite("15") );     // true
alert( isFinite("str") );    // false
alert( isFinite(Infinity) ); // false

// 종종 문자열 일반 숫자 검증에 사용
// 숫자 아닌 값 · Infinity · -Infinity 입력 시 false
let num = +prompt("숫자를 입력하세요.", '');
alert( isFinite(num) );
```
- 모든 숫자 관련 내장 함수 <sub>(`isFinite` 포함)</sub>
  - `""` <sub>(빈 문자열)</sub> · `"   "` <sub>(공백 문자열)</sub>
    - `0` 취급

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`Object.is` 와 비교하기**

- `Object.is`
  - 값 비교 특별 내장 메서드
  - `===` <sub>(일치 연산자)</sub> 동일
    - 예외 존재
  ```javascript
  // 예외
  Object.is(NaN, NaN) // true
  Object.is(0, -0)    // false
  ```

### `parseInt` 와 `parseFloat`
- `+` <sub>(단항 덧셈 연산자)</sub> · `Number()`
  - 숫자형 변환 시 규칙 엄격 적용
  - 피연산자 숫자 X
    - 형 변환 실패
  - 규칙 엄격 적용 제외 부분
    - 문자열 처음 · 끝 공백
      - 공백 무시
```javascript
alert( +"100px" ); // NaN
```
- `parseInt` · `parseFloat`
  - 불가능할 때까지 문자열 숫자 읽음
  - 숫자 읽는 중 오류 발생 시 수집된 숫자 반환
- `parseInt`
  - 정수
- `parseFloat`
  - 부동 소수점 숫자
```javascript
alert( parseInt('100px') );    // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') );     // 12  , 정수 부분만 반환
alert( parseFloat('12.3.4') ); // 12.3, 2번째 점에서 숫자 읽기 중단
```
- 읽을 수 있는 숫자 X
  - `NaN` 반환
```javascript
alert( parseInt('a123') ); // NaN, a에서 숫자 읽기 중단
                           // - 수집된 숫자 X
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`parseInt(str, radix)` 2번째 인수**

- `parseInt` 2번째 매개변수 <sub>(redix)</sub>
  - 진수 지정
  ```javascript
  alert( parseInt('0xff', 16) ); // 255
  alert( parseInt('ff', 16) );   // 255, '0x' 없이도 동작
  alert( parseInt('2n9c', 36) ); // 123456
  ```

### 기타 수학 함수
- 내장 객체 `Math`
  - 다양한 수학 관련 함수 · 상수 보유
- `Math.random()`
  - 0 ~ 1 사이 난수 반환 <sub>(1 제외)</sub>
  ```javascript
  alert( Math.random() ); // 0.1234567894322
  alert( Math.random() ); // 0.5435252343232
  alert( Math.random() ); // …, 무작위 수
  ```

- `Math.max(a, b, c …)` · `Math.min(a, b, c …)`
  - 인수 중 최대 · 최솟값 반환
  ```javascript
  alert( Math.max(3, 5, -10, 0, 1) ); // 5
  alert( Math.min(1, 2) ); // 1
  ```
- `Math.pow(n, power)`
  - `n`을 `power`번 거듭제곱한 값 반환
    - n<sup>power</sup>
  ```javascript
  alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
  ```

<br />

문자열
=====

- 항상 UTF-16 형식
  - 페이지 인코딩 방식 상관 X

### 따옴표
- 종류
  - `"` <sub>(큰따옴표)</sub>
  - `'` <sub>(작은따옴표)</sub>
  - `` ` `` <sub>(백틱)</sub>
- `` ` `` <sub>(백틱)</sub> · `${ … }` <sub>(템플릿 리터럴)</sub>
```javascript
function sum(a, b) {
  return a + b;
}
alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
```
  - `` ` `` <sub>(백틱)</sub> · 문자열 여러 줄 걸쳐 작성
    - `"` <sub>(큰따옴표)</sub> · `'`<sub>(작은따옴표)</sub> 불가능
  ```javascript
  let guestList = `손님:
  * John
  * Pete
  * Mary
  `;
  ```
- `` ` `` <sub>(백틱)</sub> · 템플릿 함수 <sub>(태그드 템플릿)</sub>
  - 1번째 `` ` `` <sub>(백틱)</sub> 바로 앞 함수명 존재 시
    - 함수 자동 호출
    - `` ` `` <sub>(백틱)</sub> 안 문자열 · 표현식 평가 결과
      - 함수 인수
  - 드물게 사용
    - ex&#41; ``func`string` ``

### 특수 기호

|특수 문자|설명|
|---|---|
|`\n`|줄 바꿈|
|`\r`|캐리지 리턴<br />- Windows 줄 바꿈 시<br />　- 캐리지 리턴 · 줄 바꿈 특수 문자 조합<br />　- `\r\n`<br />　- 캐리지 리턴 단독 사용 경우 X|
|`\'` · `\"`|따옴표|
|`\\` |역슬래시|
|`\t`|탭|
|`b` · `\f` · `\v`|백스페이스<br />폼 피드<br />세로 탭<br />- 호환성 유지 위해 남음<br />　- 요즘 사용 X|
|`\xXX`|유니코드 글자<br />- 16진수 유니코드 `XX`로 표현<br />- ex&#41; `z` <sub>(알파벳)</sub> → `\x7A`|
|`\uXXXX`|유니코드 기호<br />- 16진수 코드 `XXXX`로 표현<br />　- 'UTF-16' 인코딩 규칙 사용<br />- `XXXX` : 4개의 16진수 구성<br />- ex&#41; `\u00A9` → `©` <sub>(저작권 기호)</sub> 유니코드|
|`\u{X…XXXXXX}`<br /><sub>(1 ~ 6개 16진수 글자)</sub>|유니코드 기호<br />- 'UTF-32' 표현 <br />- 몇몇 특수 글자 4byte<br />　- 기호 2개 사용해 인코딩<br />　- 긴 코드 삽입 가능|
- 유니코드
```javascript
alert( "\u00A9" );    // ©
alert( "\u{20331}" ); // 佫,  중국어 (긴 유니코드)
alert( "\u{1F60D}" ); // 😍, 웃는 얼굴 기호 (긴 유니코드)
```
- 모든 특수 문자
  - `\` <sub>(역슬래시)</sub> 시작
    - '이스케이프 문자'
- 문자열 내 따옴표
```javascript
alert( 'I\'m the Walrus!' ); // 역슬래시
alert( `I'm the Walrus!` );  // 백틱
```
- 문자열 안 `\` <sub>(역슬래시)</sub> 표시
  - `\\`
```javascript
alert( `역슬래시: \\` ); // \
```

### 문자열의 길이
- `length` 프로퍼티
```javascript
// '\n' (특수 문자) : 길이 1
alert( `My\n`.length ); // 3
```

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`length` : 프로퍼티 (메서드 X)**

|사용||
|---|:---:|
|`length()`|X|
|`.length`|O|

### 특정 글자에 접근하기
- `[]` <sub>(대괄호)</sub> · `charAt(pos)` <sub>(메서드)</sub>
  - 위치 0 부터 시작
```javascript
let str = `Hello`;

// 1번째 글자
alert( str[0] );        // H
alert( str.charAt(0) ); // H

// 마지막 글자
alert( str[str.length - 1] ); // o
```
- `[]` <sub>(대괄호)</sub> 선호
- `charAt(pos)`
  - 하위 호환성 위해 남음
- 접근 위치 글자 없는 경우
  - `[]` <sub>(대괄호)</sub>
    - `undefined`
  - `charAt(pos)`
    - `""` <sub>(빈 문자열)</sub>
```javascript
let str = `Hello`;

alert( str[1000] );        // undefined
alert( str.charAt(1000) ); // '' (빈 문자열)
```
- `for…of` <sub>(반복문)</sub>
  - 문자열 구성 글자 대상 반복 작업
```javascript
for (let char of "Hello") {
  alert(char); // H,e,l,l,o
}
```

### 문자열의 불변성
- 문자열 수정 불가능
- 문자열 중간 글자 하나 수정 시 에러 발생
  - 새 문자열 생성 후 할당
```javascript
let str1 = 'Hi';

str1[0] = 'h';    // Error: Cannot assign to read only property '0' of string 'Hi'
alert( str1[0] ); // 동작 X

let str2 = 'Hi';

str2 = 'h' + str2[1]; // 문자열 전체 교체
alert( str2 );        // hi
```

### 대 · 소문자 변경하기
- `toLowerCase()` · `toUpperCase()`
  - 대문자 ↔ 소문자
```javascript
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

// 글자 하나만 변경
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

### 부분 문자열 찾기

#### `str.indexOf(substr, pos)`
- `str`<sub>(문자열)</sub> 의 `pos` <sub>(위치)</sub> 에서 시작
- `substr` <sub>(부분 문자열)</sub> 위치 검색
- 부분 문자열 찾음
  - 위치 반환
- 부분 문자열 못 찾음
  - `-1` 반환
```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); //  0, 'Widget' with id
alert( str.indexOf('widget') ); // -1,  대·소문자 따짐
alert( str.indexOf("id") );     //  1,  W'id'get with id
```
- 2번째 매개변수 <sub>(`pos`)</sub>
  - 선택적 사용
  - 검색 시작 위치
```javascript
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12, Widget with id
                              //       ↑ 검색 시작
```
- 문자열 내 부분 문자열 전체 대상 작업
  - 반복문 · `indexOf` 사용
```javascript
let str = 'As sly as a fox, as strong as an ox';
let target = 'as';

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `위치: ${foundPos}` );
  pos = foundPos + 1; // 바로 다음 위치에서 검색 이어 시작
}

↓↓↓

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`str.lastIndexOf(substr, position)`**
- `indexOf` 유사
- str <sub>(문자열)</sub> 끝부터 substr <sub>(부분 문자열)</sub> 검색
- 반환 부분 문자열 위치 기준
  - 문자열 끝

#### `if` 문 조건식 · `indexOf` 주의 점
- `if` 문 조건식
  - `0` <sub>(문자열 1번째 위치)</sub> == `false` 간주
  - `-1` 과 비교할 것
```javascript
let str = "Widget with id";

// if(0) : false
if (str.indexOf("Widget")) {
  alert("찾았다!");
}

// -1 과 비교
if (str.indexOf("Widget") != -1) {
    alert("찾았다!"); // 의도한 대로 동작
}
```

#### `~` <sub>(비트 NOT 연산자)</sub> 를 사용한 기법
- 오래전부터 전해 오는 방법
- 피연산자 32비트 정수 변환 후 <sub>(소수부 모두 버려짐)</sub> 모든 비트 반전
  - `~n` → `-(n+1)`
```javascript
alert( ~2 );  // -3 → -( 2+1)
alert( ~1 );  // -2 → -( 1+1)
alert( ~0 );  // -1 → -( 0+1)
alert( ~-1 ); //  0 → -(-1+1)
```
- `~-1` → `n == 0`
- 직관적 X
  - 비권장
```javascript
let str = "Widget";
if (~str.indexOf("Widget")) {
  alert( '찾았다!' );
}
```
- 아주 긴 문자열 주의
  - `~4294967295` == `0`

#### `includes` · `startsWith` · `endsWith`
- 비교적 근래 등장 메서드
- `str.includes(substr, pos)`
  - `str` <sub>(문자열)</sub> 에 `substr` <sub>(부분 문자열)</sub>
    - 존재 시
      - `true` 반환
    - 미존재 시
      - `false` 반환
  - 포함 여부만 확인
    - 위치 정보 X
  - 2번째 인수 <sub>(`pos`)</sub>
    - 검색 시작 위치
```javascript
alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") );    // false
alert( "Widget".includes("id") );    // true
alert( "Widget".includes("id", 3) ); // false, 3번째 위치 이후 "id" 없음
```
- `str.startsWith` · `str.endsWith`
- `str` <sub>(문자열)</sub> 특정 문자열로 시작 · 종료 여부 확인
```javascript
alert( "Widget".startsWith("Wid") ); // true
alert( "Widget".endsWith("get") );   // true
```

### 부분 문자열 추출하기
- 부분 문자열 추출 관련 메서드
  - `slice`
  - `substring`
  - `substr`

#### `str.slice(start [, end])`
- 문자열 위치 `start` ~ `end` <sub>(`end` 미포함)</sub> 반환
```javascript
let str = "stringify";
                          // stringify
                          // 012345678
alert( str.slice(0, 5) ); // strin
alert( str.slice(0, 1) ); // s
```
- 2번째 인수 <sub>(end)</sub> 생략 시
  - 범위 : `start` ~ 문자열 끝
```javascript
let str = "stringify";
                     // stringify
                     // 012345678
alert( str.slice(2) ); // ringify
```
- `start` · `end` 음수 가능
  - 문자열 끝에서 카운팅 시작
```javascript
let str = "stringify";
alert( str.slice(-5, -1) ); // ngif
                        // stringify
                        //     ↑ ~ ↑
                        // 0  -5  -1
```

#### `str.substring(start [, end])`
- 문자열 위치 `start` ~ `end` <sub>(`end` 미포함)</sub> 반환
- `slice` 와의 차이점
  - `start` > `end` 가능
  - 음수 인수 X
    - `0` 처리
```javascript
let str = "stringify";
                              //       012345678
alert( str.substring(2, 6) ); // ring, stringify
                              //         s   e
alert( str.substring(6, 2) ); // ring, stringify
                              //         e   s

                              //       012345678
alert( str.slice(2, 6) );     // ring, stringify
                              //         s   e
alert( str.slice(6, 2) );     // ""  , stringify
                              //             s
```

#### `str.substr(start [, length])`
- `start` 부터 `length` 개 글자 반환
  - 1번째 인수 음수
    - 뒤에서 카운트
```javascript
let str = "stringify";
alert( str.substr(2, 4) );  // ring, stringify
                            //       0 2
                            //         s---

let str = "stringify";
alert( str.substr(-4, 2) ); // gi  , stringify
                            //       0   -4
                            //            s-
```


|메서드|추출 문자열|음수 <sub>(인수)</sub>|
|---|---|---|
|`slice(start [, end])`|`start` ~ `end` <sub>(`end` 미포함)</sub>|허용|
|`substring(start [, end])`|`start` ~ `end` <sub>(`end` 미포함)|`0` 취급|
|`substr(start [, length])`|`start` 부터 `length` 개|허용|

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **메서드 선택**

- 모두 사용 OK
- `substr` 단점
  - 자바스크립트 명세서 (ECMA-262) X
  - 부록 B 정의
    - 구식 스크립트 위해 남겨둔 브라우저 전용 기능들
  - 거의 모든 곳 메서드 동작
  - 브라우저 이외 호스트 환경
    - 제대로 동작 X 가능성 존재

### 문자열 비교하기
- 알파벳 순서 기준
- 글자끼리 비교
- 모든 문자열 UTF-16 사용해 인코딩
- UTF-16
  - 모든 글자 → 숫자 형식 코드 매칭

#### `str.codePointAt(pos)`
- `pos` 위치 글자 코드 반환
```javascript
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
```

#### `String.fromCodePoint(code)`
- 숫자 형식 `code` 대응 글자 생성
- `\u` 뒤 특정 코드 붙이는 방식 가능
  - 글자 대응 16진수 코드
```javascript
alert( String.fromCodePoint(90) ); // Z

// 90 16진수 변환 → 5a
alert( '\u005a' ); // Z
```
- 주의 사항
  - 소문자 > 대문자
  - 발음 구별 기호 붙은 문자
    - 알파벳 순서 기준 X
```javascript
// 소문자 > 대문자
alert( 'a' > 'Z' ); // true

// 발음 구별 기호
alert( 'Österreich' > 'Zealand' ); // true

// 주의 사항 이유
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}

alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```
- 비교 시 숫자 코드 <sub>(글자 대응)</sub> 기준
  - 코드 크기 == 대응 글자 크기

#### 문자열 제대로 비교하기
- 언어마다 문자 체계 다름
  - 문자열 비교 알고리즘 생성 어려움
- 브라우저가 페이지 사용 언어 인식 필요
  - 대부분의 모던 브라우저
    - ECMA-402 <sub>(국제화 관련 표준)</sub> 지원
- ECMA-402 <sub>(국제화 관련 표준)</sub>
  - 문자열 비교 규칙 · 규칙 준수 메서드 정의
    - 언어 다를 때 적용
  - ex&#41; `str.localeCompare(str2)`
    - `str` &nbsp;< &nbsp;`str2` : 음수
    - `str` &nbsp;> &nbsp;`str2` : 양수
    - `str` == `str2` : `0`
```javascript
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

### 문자열 심화

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **심화 학습**

#### 서로게이트 쌍
- 자주 사용되는 글자들
  - 2byte 코드 보유
- 유럽권 언어 글자 · 숫자 · 상형 문자 대다수
  - 2byte 표현 체계 사용
- 2byte
  - 65,536 (2<sup>16</sup>) 개 조합
  - 현존 기호 모두 표현 불충분
- 제약 극복 위해 '서로게이트 쌍' 등장
- 사용 빈도 낮은 기호
  - 2byte 글자 쌍 사용해 인코딩
- 기호 길이 <sub>(서로게이트 쌍 사용해 인코딩)</sub>
  - 2
```javascript
alert( '𝒳'.length );  // 2, 수학에서 쓰이는 대문자 X
alert( '😂'.length ); // 2, 웃으면서 눈물 흘리는 얼굴 이모티콘
alert( '𩷶'.length );  // 2, 사용 빈도 낮은 중국어 (상형문자)
```
- 자바스크립트 초기
  - 서로게이트 쌍 미존재
  - 서로게이트 쌍 표현 기호 제대로 처리 X
- `String.fromCodePoint` · `str.codePointAt`
  - 명세서 추가된 지 얼마 안 된 메서드
  - 서로게이트 쌍 제대로 처리하는 몇 안 되는 메서드
- 위 두 메서드 등장 전
  - `String.fromCharCode` · `str.charCodeAt` 사용
    - 위 두 메서드와 동일 동작
    - 서로게이트 쌍 처리 X
- 서로게이트 쌍 2글자 취급
  - 기호 가져오기 까다로움
  - 서로게이트 쌍 구성 글자들
    - 붙어있을 때만 의미 有
```javascript
alert( '𝒳'[0] ); // 이상한 기호 출력
alert( '𝒳'[1] ); // 서로게이트 쌍 일부 출력
```
- 기술적으로 서로게이트 쌍 대응 코드 사용해 감지 가능
  - `0xd800` ~ `0xdbff` <sub>(글자 코드)</sub>
    - 쌍 구성 1번째 글자
  - `0xdc00` ~ `0xdfff` <sub>(글자 코드)</sub>
    - 쌍 구성 2번째 글자
  - `0xd800` ~ `0xdbff` · `0xdc00` ~ `0xdfff`
    - 표준에서 서로게이트 쌍 위해 일부러 비워둔 코드
```javascript
// charCodeAt
// - 서로게이트 쌍 처리 X
// - 서로게이트 쌍 구성 부분 코드 반환
alert( '𝒳'.charCodeAt(0).toString(16) ); // d835 (0xd800 ~ 0xdbff)
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3 (0xdc00 ~ 0xdfff)
```

#### 발음 구별 기호와 유니코드 정규화
- 합성 글자 구성
  - 베이스 글자 위 · 아래 + 발음 구별 기호
    - ex&#41; a → àáâäãåā
  - 대부분 독자적인 코드 보유 <sub>(UTF-16 테이블)</sub>
- 모든 합성 글자 코드 부여 X
  - 조합 가능 글자 수 너무 많음
- UTF-16 몇 개 유니코드 문자 남겨둠
  - 임의 조합 지원
- 베이스 글자 + 1 ~ n개 유니코드 문자
```javascript
// `S` + `\u0307`         → `Ṡ`
alert( 'S\u0307' );       // Ṡ

// `Ṡ` + `\u0323`         → `Ṩ`
alert( 'S\u0307\u0323' ); // Ṩ
```
- 엄청난 유연성 제공
- 단점 : 같은 글자 · 다른 유니코드 조합
```javascript
let s1 = 'S\u0307\u0323'; // Ṩ, S + 윗 점 + 아랫 점
let s2 = 'S\u0323\u0307'; // Ṩ, S + 아랫 점 + 윗 점

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // 눈에는 같은 글자
                   // 동등 비교 시 false
```
- 해결 : 유니코드 정규화 알고리즘 사용
  - 각 문자열 동일한 형태로 정규화
- `str.normalize()`
  - 유니코드 정규화 알고리즘 구현
```javascript
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

// 3개 글자 → 1개 글자 결합
// Ṩ '\u1e68' (유니코드)
alert( "S\u0307\u0323".normalize().length );      // 1
alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
```
- 현실 : UTF-16 작업자들의 주관적인 의견
    - `Ṩ` 코드 부여
      - '충분히 나타날 수 있는 사례' 간주
- 유니코드 표준 부록
  - [Unicode Normalization Forms](https://www.unicode.org/reports/tr15/ "Unicode Normalization Forms")

<br />

배열
====

- 순서 컬렉션 저장 자료구조

### 배열 선언
```javascript
let arr = new Array();
let arr = []; // 주로 사용
```
- `[]` <sub>(대괄호)</sub> 안 초기 요소 삽입
```javascript
let fruits = ["사과", "오렌지", "자두"];
```
- 각 배열 요소 숫자 <sub>(인덱스)</sub>
  - 0 ~
  - 배열 내 순서
- 배열 내 특정 요소 얻기
  - `[]` <sub>(대괄호)</sub> 안 인덱스
```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

// 배열 내 특정 요소 수정
fruits[2] = '배'; ["사과", "오렌지", "배"]

// 새 요소 추가
fruits[3] = '레몬'; // ["사과", "오렌지", "배", "레몬"]

// 배열 요소 갯수
alert( fruits.length ); // 4

// 요소 전체 출력
alert( fruits );    // 사과,오렌지,배,레몬
```
- 배열 요소 자료형 제약 X
```javascript
let arr = [
  '사과',
  { name: '이보라' },
  true,
  function() { alert('안녕하세요.'); }
];

// 인덱스 1 요소 (객체) name 프로퍼티
alert( arr[1].name ); // 이보라

// 인덱스 3 요소 (함수) 실행
arr[3](); // 안녕하세요.
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **trailing 쉼표**

- 배열 마지막 요소
  - 쉼표 사용 가능
- 모든 줄 생김새 유사
  - 요소 추가 · 삭제 용이
```javascript
let fruits = [
  "사과",
  "오렌지",
  "자두",
];
```

### `pop` · `push` vs `shift` · `unshift`

##### 큐 <sub>(queue)</sub>
- 배열 사용해 만드는 대표적인 자료구조
- 선입선출 <sub>(First-In-First-Out, FIFO)</sub>
- 순서 있는 컬렉션 저장
- 큐 주요 연산
  - `push`
    - 맨 끝에 요소 추가
  - `shift`
    - 제일 앞 요소 꺼내 제거
    - 남은 요소들 앞으로 밈

##### 스택 <sub>(stack)</sub>
- 배열 사용해 만드는 대표적인 자료구조
- 후입선출 <sub>(Last-In-First-Out, LIFO)</sub>
- 스택 주요 연산
  - `push`
    - 스택 끝에 요소 삽입
  - `pop`
    - 스택 끝 요소 추출

##### 배열
- 큐 · 스택 둘다 생성 가능
- 데큐 <sub>(deque, Double Ended Queue)</sub>
  - 처음 · 끝 요소 더하기 · 빼기 연산 제공 자료구조

#### 배열 끝 작업 메서드
- `pop`
  - 배열 끝 요소 제거
  -  제거한 요소 반환
- `push`
  - 배열 끝에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// pop
alert( fruits.pop() ); // 배
alert( fruits );       // 사과,오렌지

// push
// fruits.push( … )
// fruits[fruits.length] = … (동일)
fruits.push("배");
alert( fruits );       // 사과,오렌지,배
```

#### 배열 앞 작업 메서드
- `shift`
  - 배열 앞 요소 제거
  - 제거한 요소 반환
- `unshift`
  - 배열 앞에 요소 추가
```javascript
let fruits = ["사과", "오렌지", "배"];

// shift
alert( fruits.shift() ); // 사과
alert( fruits );         // 오렌지,배

// unshift
fruits.unshift('사과');
alert( fruits );         // 사과,오렌지,배
```
- `push` · `unshift`
  - 요소 여러 개 한 번에 더하기 가능
```javascript
let fruits = ["사과"];

fruits.push("오렌지", "배");
fruits.unshift("파인애플", "레몬");

alert( fruits ); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

### 배열의 내부 동작 원리
- 특별한 종류의 객체
- 숫자형 키 사용
  - 객체 기본 기능 보유
  - 순서 있는 컬렉션 제어 메서드
  - `length` <sub>(프로퍼티)</sub>
- 배열 본질 == 객체
```javascript
let fruits = ["바나나"]

let arr = fruits;        // 참조 복사
alert( arr === fruits ); // true

arr.push("배");  // 참조 이용해 배열 수정
alert( fruits ); // 바나나,배
```

#### 배열 특수 내부 표현방식
- 배열 요소
  - 인접한 메모리 공간에 차례로 저장
    - 연산 속도 ↑
- 다양한 배열 관련 연산 최적화 기법
- 배열 사용처
  - 순서 있는 자료 컬렉션
  - 일반 객체처럼 작업
    - 최적화 기법들 제대로 동작 X
```javascript
let fruits = [];
fruits[99999] = 5; // 배열 길이보다 훨씬 큰 숫자 사용해 프로퍼티 생성
fruits.age = 25;   // 임의의 이름 사용해 프로퍼티 생성
```
- 배열에 프로퍼티 추가 가능
  - 일반 객체처럼 다룸 <sub>(자바스크립트 엔진)</sub>
    - 배열 최적화 기법 동작 X
- 배열 특유 이점 사라지는 사용 방법들
```javascript
// 숫자 아닌 값 프로퍼티 키로 사용
arr.test = 1;

// 앞 · 끝에만 요소 추가
arr[0] = 1;
arr[1000] = 2;

// 요소 역순 삽입
arr[1000] = 1;
arr[999] = 2;
```
- 배열 목적 맞게 사용
- 임의 키 사용 시 일반 객체 적합

### 성능

##### `shift` · `unshift` : 느림
1. 인덱스 0 요소 제거 · 추가
2. 모든 요소 좌 · 우 이동
    - 모든 인덱스 1씩 감소 · 증가
3. `length` <sub>(프로퍼티)</sub> 값 갱신
- 배열 요소 多
  - 요소 이동 시간 · 메모리 관련 연산 ↑

##### `push` · `pop` : 빠름
1. 마지막에 요소 추가 · 제거
2. `length` <sub>(프로퍼티)</sub> 값 갱신
- 요소 이동 X
- 기존 인덱스 그대로 유지

### 반복문

#### `for` 문
  - 배열 순회 가장 오래된 방법
  - 순회시 인덱스 사용
```javascript
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

#### `for…of`
  - 요소 값
```javascript
let fruits = ["사과", "오렌지", "자두"];

for (let fruit of fruits) {
  alert( fruit );
}
```

#### `for…in`
- 요소 인덱스
```javascript
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  alert( arr[key] ); // 사과, 오렌지, 배
}
```

#### `for…in` 문제점
- 모든 프로퍼티 대상 순회
  - 숫자 키 외 프로퍼티 순회 대상 포함
- 유사 배열 객체
  - 브라우저 · 기타 호스트 환경 사용 객체
  - `length` <sub>(프로퍼티)</sub> · 요소 인덱스 보유
  - 숫자형 키 외 프로퍼티 · 메서드 존재 가능
    - '필요 없는' 프로퍼티들 문제 일으킬 가능성 ↑
- 객체에 최적화
  - 배열 사용 시 객체 대비 10 ~ 100배 느림
  - 반복문 자체 속도 빠름
    - 병목 지점에서만 문제
- 배열 되도록 `for…in` 사용 X

### `length` 프로퍼티
- 배열 조작 시 `length` <sub>(프로퍼티)</sub> 자동 갱신
- `length` <sub>(프로퍼티)</sub> 값
  - 가장 큰 인덱스 + 1 <sub>(≠ 실제 요소 개수)</sub>
  ```javascript
  // 잘못된 배열 사용
  let fruits = [];
  fruits[123] = "사과";

  alert( fruits.length ); // 124
  ```
- `length` <sub>(프로퍼티)</sub> 쓰기 가능
  - 값 수동 증가
    - 아무 일 X
  - 값 수동 감소
    - 배열 잘림
    - 잘린 배열 요소 복구 X
    - 간단하게 배열 비우기
      - `arr.length = 0;`
```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2;  // 요소 2개만 남기고 자르기
alert( arr );    // [1, 2]

arr.length = 5;  // 본래 길이 수동 증가
alert( arr[3] ); // undefined, 삭제된 기존 요소들 복구 X
```

### `new Array()`
- 배열 생성
```javascript
let arr = new Array("사과", "배", "기타");
```
- 잘 사용되지 않는 편
- 까다로운 사용법
  - 숫자형 인수 하나 전달 시
    - 요소 없음
    - 길이 == 인수
  ```javascript
  let arr = new Array(2);

  alert( arr[0] );     // undefined, 요소 없음
  alert( arr.length ); // 길이 : 2
  ```

### 다차원 배열
- 배열 내 배열
- 행렬 저장
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5
```

### `toString`
- 배열 `toString`  <sub>(메서드)</sub> 구현
  - 전체 요소 쉼표 구분 문자열 반환
```javascript
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
- 배열 `Symbol.toPrimitive` · `valueOf` 보유 X
  - 문자열 형 변환 발생
```javascript
alert( [] + 1 );    // "1"
alert( [1] + 1 );   // "11"
alert( [1,2] + 1 ); // "1,21"

alert( "" + 1 );    // "1"
alert( "1" + 1 );   // "11"
alert( "1,2" + 1 ); // "1,21"
```

<br />

배열과 메서드
============

### 요소 추가 · 제거 메서드

#### `splice`
- `delete`
  - 배열 요소 1개 삭제 <sub>(배열 == 객체형)</sub>
  - 원하는 요소 삭제
  - 배열 요소 개수 변화 X
```javascript
let arr = ["I", "go", "home"];
delete arr[1];   // "go" 삭제
alert( arr[1] ); // undefined

// delete 요소 삭제 후 배열
// arr = ["I",  , "home"];
alert( arr.length ); // 3
```
- `splice`
  - 요소 추가 · 삭제 · 교체
```javascript
arr.splice(index[, deleteCount, elem1, …, elemN])
```
- `index`
  - 조작 가할 1번째 요소 인덱스 <sub>(index)</sub>
- `deleteCount`
  - 제거 요소 개수
- `elem1, …, elemN`
  - 배열 추가할 요소
```javascript
/* 요소 삭제 */
let arr1 = ["I", "study", "JavaScript"];
arr1.splice(1, 1); // 인덱스 1부터 요소 1개 제거
alert( arr1 );     // ["I", "JavaScript"]

/* 처음 (0) 3개 (3) 요소 삭제 후 다른 요소 대체 */
let arr2 = ["I", "study", "JavaScript", "right", "now"];
arr2.splice(0, 3, "Let's", "dance");
alert( arr2 ) // ["Let's", "dance", "right", "now"]

/* 삭제된 요소 구성 배열 반환 */
let arr3 = ["I", "study", "JavaScript", "right", "now"];
let removed = arr3.splice(0, 2); // 처음 2개 요소 삭제
alert( removed );                // "I", "study"

/*
 삭제 X · 새 요소 추가
 - deleteCount == 0
 인덱스 2부터 0개 요소 삭제 후 "complex", "language" 추가
 */
let arr = ["I", "study", "JavaScript"];
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **음수 인덱스 사용 가능**

- 배열 관련 메서드 음수 인덱스
  - 배열 끝 기준 요소 위치
```javascript
/*
 음수 인덱스
 - 배열 끝 기준
 인덱스 -1 (배열 끝 1번째 요소) 부터 0개 요소 삭제 후 3, 4 추가
 */
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5
```

#### `slice`
```javascript
arr.slice([start], [end])
```
- 해당 범위 요소 복사한 새 배열 반환
  - 범위 : `start` ~ `end` <sub>(`end` 제외)</sub>
- `start` · `end` 음수
  - 배열 끝 기준
- 인수 X
  - 복사본 생성
- `str.slice` <sub>(문자열 메서드)</sub> 동작 유사
```javascript
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s
alert( arr.slice(-2) );   // s,t
```

#### `concat`
- 기존 배열 요소 사용해 새 배열 생성
- 기존 배열 요소 추가
- 인수
  - 배열 · 값
  - 개수 제한 X
```javascript
arr.concat(arg1, arg2 …)
```
- `arr` 전체 요소 + `arg1` · `arg2` … 전체 요소
  - 요소 합친 새 배열 반환
- 인수 `argN` : 배열
  - 배열 내 모든 요소 복사
```javascript
let arr = [1, 2];
alert( arr.concat([3, 4]) );         // 1,2,3,4
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
alert( arr.concat([3, 4], 5, 6) );   // 1,2,3,4,5,6
```
- 제공받은 배열 요소 복사해 활용
- 객체 인자
  - 객체 <sub>(유사 배열 객체 포함)</sub> 분해 X
  - 통으로 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```
- 유사 배열 객체 인자
  - `Symbol.isConcatSpreadable` <sub>(특수 프로퍼티)</sub> 존재 시
    - 배열 취급
      - 객체 전체 복사 X
      - 객체 프로퍼티 값 복사
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

#### `forEach` 로 반복작업 하기
- 함수 인자
  - 배열 요소 각각에 실행
  - 반환값 무시
```javascript
arr.forEach(function(item, index, array) {
  // …
});
```
```javascript
// 각 요소마다 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

// 각 요소마다 인덱스 정보 더해서 alert 실행
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```

### 배열 탐색하기

#### `indexOf` · `lastIndexOf` · `includes`
- 동명 문자열 메서드와 문법 · 작업 동일
- `arr.indexOf(item, from)`
  - `from` <sub>(인덱스)</sub> 부터 `item` <sub>(요소)</sub> 검색
  - 해당 요소 발견 시
    - 해당 요소 인덱스 반환
  - 해당 요소 미발견 시
    - `-1` 반환
- `arr.lastIndexOf(item, from)`
  - `indexOf` 동일 기능
  - 끝부터 검색
- `arr.includes(item, from)`
  - `from` <sub>(인덱스)</sub> 부터 시작해 `item` 검색
  - 해당 요소 발견 시
    - `true` 반환
  - 해당 요소 미발견 시
    - `false` 반환
```javascript
let arr = [1, 0, false];

alert( arr.indexOf(0) );     //  1
alert( arr.indexOf(false) ); //  2
alert( arr.indexOf(null) );  // -1
alert( arr.includes(1) );    // true
```
- 요소 검색 시 `===` <sub>(완전 항등 연산자)</sub> 사용
  - ex&#41; `false` 검색 시
    - 정확히 `false` 만 검색
    - `0` 검색 X
- `includes`
  - 요소 위치 X
  - 배열 내 존재 여부만 확인
  - `NaN` 제대로 처리
    - `indexOf` · `lastIndexOf` 와의 차이
```javascript
const arr = [NaN];
alert( arr.indexOf(NaN) );  // -1  , '===' (완전 항등 비교) NaN 동작 X
alert( arr.includes(NaN) ); // true, NaN 여부 확인
```

#### `find` 와 `findIndex`
- 특정 조건 부합 요소 검색
```javascript
let result = arr.find(function(item, index, array) {
  /*
   조건 해당 요소 존재 시 (true 반환)
   - 반복 중단 · 해당 요소 반환
   조건 해당 요소 미존재 시
   - undefined 반환
   */
});
```
- `find`
  - 전체 요소 대상 함수 순차적으로 호출
  - `item`
    - 함수 호출 요소
  - `index`
    - 요소 인덱스
  - `array`
    - 배열 자기 자신
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // John
```
- 가장 많이 사용되는 패턴
  - `(item => item.id == 1)` <sub>(1번째 인자만 사용)</sub>
  - 다른 인자들 <sub>(`index` · `array`)</sub> 자주 사용 X
- `arr.findIndex`
  - `find` 동일
  - 요소 반환 X
  - 요소 인덱스 반환
  - 조건 해당 요소 미존재 시
    - `-1` 반환

#### `filter`
- 조건 부합 요소들 담은 배열 반환
```javascript
let results = arr.filter(function(item, index, array) {
  // 조건 충족 요소 results 에 순차적으로 추가
  // 조건 충족 요소 하나도 없으면 빈 배열 반환
});
```
```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명 반환
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
```
### 배열을 변형하는 메서드

#### `map`
- 전체 배열 요소 대상 함수 호출
- 변형된 요소들 담은 배열 반환
```javascript
let result = arr.map(function(item, index, array) {
  // 요소 대신 새 값 반환
});
```
```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

#### `sort(fn)`
- 배열 요소 정렬
- 배열 자체 변경
- 재정렬 된 배열 반환
  - 반환 값 잘 사용 X <sub>(이미 배열 자체 수정)</sub>
```javascript
let arr = [ 1, 2, 15 ];

// arr 내부 재정렬
// 인수 없으면 요소 문자열 취급하여 재정렬
// - 사전편집순 : "15" < "2"
arr.sort();
alert( arr );           // 1, 15, 2

// 새 정렬 기준 함수
// - 값 2개 비교
// - 반환 값 존재
function compareNumeric(a, b) {
  if (a > b) return 1;  // 1번째 값 > 2번째 값
  if (a == b) return 0; // 두 값 동일
  if (a < b) return -1; // 1번째 값 < 2번째 값
}
arr.sort(compareNumeric);
alert(arr);             // 1, 2, 15
```
- 정렬 과정 확인 트릭
  - 어떤 요소끼리 비교 발생했는지
```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **정렬 함수 : 어떤 숫자든 반환 가능**

- 정렬 함수 반환 값 제약 X
- 양수 반환
   - 1번째 인수 > 2번째 인수
- 음수 반환
   - 1번째 인수 < 2번째 인수
```javascript
// 간결한 표현
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15

// 화살표 함수 (더 간결)
arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **문자열 : `localeCompare` 사용**

- `Ö` 같은 문자 언어 대응
```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );
// Andorra,Vietnam,Österreich (제대로 정렬 X)

alert( countries.sort( (a, b) => a.localeCompare(b) ) );
// Andorra,Österreich,Vietnam (제대로 정렬)
```

#### `reverse`
- 요소 역순 정렬
- 재정렬된 배열 반환
```javascript
let arr = [1, 2, 3, 4, 5];

arr.reverse();
alert( arr ); // 5,4,3,2,1
```

#### `split`
- `str.split(delim)`
  - `delim` <sub>(구분자)</sub> 기준 문자열 분리
```javascript
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');
for (let name of arr) {
  alert( `${name}에게 보내는 메시지` ); // Bilbo에게 보내는 메시지
                                      // Gandalf에게 보내는 메시지
                                      // Nazgul에게 보내는 메시지
}
```
- 2번째 인수
  - 숫자형
  - 배열 길이 제한
  - 길이 초과 요소 무시
  - 실무 가끔 사용
```javascript
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **문자열 글자 단위 분리**

- 구분자 : `""` <sub>(빈 문자열)</sub>
  -  문자열 글자 단위 분리
```javascript
let str = "test";

alert( str.split('') ); // t,e,s,t
```

#### `arr.join(glue)`
- `glue` <sub>(인수)</sub> 기준 배열 요소 모두 합침
  - 하나의 문자열 생성
```javascript
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');
alert( str ); // Bilbo;Gandalf;Nazgul
```

#### `reduce` · `reduceRight`
- 각 요소 돌면서 반복 작업 수행
  - 값 하나 도출
```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
  // …
}, [initial]);
```
- 함수 인자
  - 전체 배열 요소 대상 순차적으로 적용
  - 적용 결과
    - 다음 함수 호출 시 사용
  - `accumulator`
    - 이전 함수 호출 결과
  - `item`
     - 현재 배열 요소
  - `index`
    - 요소 인덱스
  - `array`
    - 배열
- `initial`
  - 최초 호출 시 초깃값 <sub>(옵션)</sub>
- 이전 함수 호출 결과
  -  다음 함수 호출 시 1번째 인수 <sub>(이전 적용값)</sub> 사용 예
```javascript
let arr = [1, 2, 3, 4, 5];

// 전체 배열 요소 더하기
// 일반적으로 인수 2개 사용
let result = arr.reduce((sum, current) => sum + current, 0);
alert( result ); // 15

// 초깃값 X
let result = arr.reduce((sum, current) => sum + current);
alert( result ); // 15
```

![reduce](./images/4/reduce.svg)

||`sum`|`current`|`sum`|
|:---:|:---:|:---:|:---:|
|1번째 호출|`0`|`1`|`1`|
|2번째 호출|`1`|`2`|`3`|
|3번째 호출|`3`|`3`|`6`|
|4번째 호출|`6`|`4`|`10`|
|5번째 호출|`10`|`5`|`15`|

- 초깃값 X
  - 1번째 요소 초깃값 사용
  - 2번째 요소부터 함수 호출
  - 빈 배열
    - 호출 시 에러 발생
    - 항상 초깃값 명시 권장
  ```javascript
  let arr = [];

  // TypeError: Reduce of empty array with no initial value
  // - 초깃값 설정 시 초깃값 반환
  arr.reduce((sum, current) => sum + current);
  ```
- `arr.reduceRight`
  - `reduce` 동일 기능
  - 배열 오른쪽부터 연산 수행

### `Array.isArray` 로 배열 여부 알아내기
- 배열
  - 독립된 자료형 X
  - 객체형 취급
  - `typeof`
    - 일반 객체 · 배열 구분 X
```javascript
alert(typeof {}); // object
alert(typeof []); // object
```
- `Array.isArray(value)`
  - `value` == 배열
    - `true` 반환
  - `value` !== 배열
    - `false` 반환
```javascript
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

### 배열 메서드와 `thisArg`
- 함수 인수 받는 대부분의 배열 메서드 <sub>(`sort` 제외)</sub>
  - `thisArg` 매개변수 옵션
  - 가끔 사용되는 인수
```javascript
// 선택적으로 사용할 수 있는 마지막 인수
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```
- `thisArg`
  - `func` 의 `this`
```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// thisArg == canJoin 컨텍스트 (army 객체) 정보
let soldiers1 = users.filter(army.canJoin, army);
//                                        thisArg

// 동일 · thisArg 방식 좀 더 이해 쉬움 (더 자주 사용)
let soldiers2 = users.filter(user => army.canJoin(user))

alert(soldiers1.length); // 2
alert(soldiers1[0].age); // 20
alert(soldiers1[1].age); // 23
```
- `thisArgs` : `army` 미지정 시
  - `army.canJoin` 단독 함수 취급
  - 함수 본문 내 `this` → `undefined` 에러 발생

<br />

iterable 객체
=============

- 반복 가능한 객체
  - 배열의 일반화 객체
- 이터러블 개념 사용 시
  - 어떤 객체든 `for…of` <sub>(반복문)</sub> 적용 가능
- 대표적인 이터러블
  - 배열
  - 문자열
  - 다수 내장 객체
- 컬렉션 <sub>(목록 · 집합 등)</sub> 객체 <sub>(배열 X)</sub>
  - `for…of` 문법 사용 시 컬렉션 순회 유용

### `Symbol.iterator`
- 이터러블 만들기
  - 객체에 `Symbol.iterator` <sub>(메서드)</sub> 추가
    - `Symbol.iterator` : 특수 내장 심볼
1. 반복 시작 시
    - `for…of` : `Symbol.iterator` <sub>(메서드)</sub> 호출
      - 미존재 시 에러 발생
      - 반드시 이터레이터 <sub>(`next` 메서드 보유 객체)</sub> 반환
2. 반환된 이터레이터 객체 대상 `for…of` 동작
3. 다음 값 필요 시
    - `for…of` : 이터레이터 `next()` <sub>(메서드)</sub> 호출
4. `next()` 반환 값
    - `{ done: Boolean, value: any }`
    - `done`
      - `true` &nbsp;: 반복 종료
      - `false` : `value` 에 다음 값 저장
- 직접 이터러블 객체 생성해보기
  - `for…of` 적용 적합한 객체 생성 <sub>(배열 X)</sub>
  - 객체 `range`
    - 숫자 간격 표현
```javascript
// for…of 동작 목표
// for(let num of range) … num=1,2,3,4,5
let range = {
  from: 1,
  to: 5
};

// 1. for…of : 최초 Symbol.iterator 호출
range[Symbol.iterator] = function() {

  // Symbol.iterator 이터레이터 객체 반환
  // 2. for…of : 반환된 이터레이터 객체만 대상 동작
  // - 이때 다음 값 정해짐
  return {
    current: this.from,
    last: this.to,

    // 3. for…of 반복마다 next() 호출
    next() {

      // 4. next() 반환 값
      // - 객체 { done: …, value: … }
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 결과
for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- 이터러블 객체 핵심
  - '관심사의 분리' <sub>(Separation of concern, SoC)</sub>
- `range`
  - `next()` <sub>(메서드)</sub> 보유 X
  - `range[Symbol.iterator]()` 호출
    - 이터레이터 객체 반환
      - `next()` <sub>(메서드)</sub> 보유
      - 반복에 사용될 값 생성
  - 이터레이터 객체 · 반복 대상 객체 분리
- 자체 이터레이터
  - 이터레이터 객체 + 반복 대상 객체
  - 더 간단한 코드
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, 2, 3, 4, 5
}
```
- `range[Symbol.iterator]()`
  - `range` <sub>(객체)</sub> 자체 반환
    - `next()` <sub>(메서드)</sub> 보유
- `this.current`
  - 반복 진행 정도 값 저장
- 코드 더 짧아짐
  - 이런 방식 작성 종종 좋음
- 2개 `for…of` : 하나의 객체 동시 사용 X
  - 이터레이터 <sub>(객체 자신)</sub> 하나뿐
    - 두 반복문 반복 상태 공유
  - 동시 2개 `for…of` 사용
    - 비동기 처리에서도 흔한 케이스 X

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **무한개의 이터레이터**

- 무수히 많은 이터레이터 가능
- `range.to` : `Infinity` 할당 시
  - `range` 무한대
  - 무수히 많은 의사 난수 생성 이터러블 객체
    - 이 방법 종종 유용
- `next` 제약사항 X
  - 값 계속 반환 시 정상 동작
  - 무한개 이터러블 `for…of` 사용 시
    - `break` : 언제든지 반복 중단 가능

### 문자열은 이터러블입니다
- 배열 · 문자열
  - 가장 많이 쓰이는 내장 이터러블
```javascript
// for…of 문자열 각 글자 순회
for (let char of "test") {
  // 글자 하나당 한 번 실행 (4회 호출)
  alert( char ); // t, e, s, t 차례대로 출력
}

// 서로게이트 쌍 잘 동작
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, 😂 차례대로 출력
}
```

### 이터레이터를 명시적으로 호출하기
- 이터레이터 명시적 호출하는 경우 거의 無
- `for…of` 보다 반복 과정 더 잘 통제
- 반복 과정 여러 개로 쪼개기 가능
  - 반복 시작 → 잠시 멈춰 다른 작업 → 다시 반복 시작 등
```javascript
/* 직접 호출 순회 */
// 문자열 이터레이터 생성 후 값 '수동으로' 가져옴
let str = "Hello";

// for…of 사용 동일 작업
// for (let char of str) alert(char);
let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자 하나씩 출력
}
```

### 이터러블 vs 유사 배열
- 이터러블 <sub>(iterable)</sub>
  -  `Symbol.iterator` <sub>(메서드)</sub> 구현 객체
- 유사 배열
  - 인덱스 · `length` <sub>(프로퍼티)</sub>
  - 배열처럼 보이는 객체
- 호스트 <sub>(브라우저 등)</sub> 환경 자바스크립트 사용 시
  - 각 2가지 · 혼합 객체 종종 사용
  - 혼합 객체 <sub>(이터러블 + 유사 배열)</sub>
    - `for…of` 사용 가능
    - 숫자 인덱스 · `length` <sub>(프로퍼티)</sub>
    - ex&#41; 문자열
- 이터러블 객체 ≠ 유사 배열 객체
```javascript
/* 유사 배열 객체 (이터러블 객체 X) */
// 인덱스 · length 프로퍼티
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

// Symbol.iterator 미존재
// - 에러 발생
for (let item of arrayLike) {}
```
- 이터러블 · 유사 배열
  - 대개 배열 X
    - `push` · `pop` 등 메서드 지원 X
    - 이터러블 · 유사 배열 배열처럼 다루고 싶을 때 불편함 초래

### `Array.from`
- 이터러블 · 유사 배열 → 배열 생성
  - 배열 메서드 사용 가능
- 유사 배열
  - 이터러블 속성 이용
```javascript
/* 유사 배열 → 배열 */
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

/*
 객체 받아 이터러블 · 유사 배열 여부 조사
 인수 이터러블 · 유사 배열 경우
 - 새 배열 생성 후 객체 모든 요소 새롭게 만든 배열로 복사
 */
let arr = Array.from(arrayLike); // 배열 메서드 정상 동작
alert(arr.pop());
```
```javascript
/* 이터러블 (range 예시 객체) → 배열 */
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5, 배열 문자열 형 변환 정상 동작
```
```javascript
Array.from(obj[, mapFn, thisArg])
```
- 2번째 인수 <sub>(`mapFn` )</sub>
  - 선택적
  - 새 배열 `obj`에 요소 추가 전
    - 각 요소 대상 `mapFn` 적용
- 3번째 인수 <sub>(`thisArg`)</sub>
  - 각 요소 `this` 지정
```javascript
/* range 예시 객체 */
// 각 숫자 제곱
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```
```javascript
/* 문자열 → 배열 */
let str = '𝒳😂';

// str 분해 → 글자 담긴 배열
let chars1 = Array.from(str);

alert(chars1[0]);     // 𝒳
alert(chars1[1]);     // 😂
alert(chars1.length); // 2

// 문자열 자체 이터러블 속성 이용해 동작
// - str.split 과 차이
// - for…of 같이 서로게이트 쌍 정상 적용
let chars2 = [];

// Array.from 내부
// - 동일 반복문 동작
for (let char of str) {
  chars2.push(char);
}

alert(chars2[0]);     // 𝒳
alert(chars2[1]);     // 😂
alert(chars2.length); // 2
```
- 서로게이트 쌍 처리 `slice` 직접 구현
```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 내장 순수 메서드
// - 서로게이트 쌍 미지원
alert( str.slice(1, 3) ); // 쓰레깃값 출력 (영역 다른 특수 값)
```

<br />

맵과 셋
=======

### 맵
- 키
  - 객체 유사
  - 다양한 자료형 허용

##### 주요 메서드 · 프로퍼티
- `new Map()`
  - 맵 생성
- `map.set(key, value)`
  - `key` : `value` 쌍 저장
- `map.get(key)`
  - `key` 해당 값 반환
  - `key` 미존재 시
    - `undefined` 반환
- `map.has(key)`
  - `key` 존재 시
    - `true` 반환
  - `key` 미존재 시
    - `false` 반환
- `map.delete(key)`
  - `key` 해당 값 삭제
- `map.clear()`
  - 모든 요소 제거
- `map.size`
  - 요소 개수 반환
```javascript
let map = new Map();

map.set('1', 'str1');   // 문자형 키
map.set(1, 'num1');     // 숫자형 키
map.set(true, 'bool1'); // 불린형 키

// 객체 : 키 문자형 변환
// 맵   : 키 타입 변환 X (그대로 유지)
alert( map.get(1)   );  // 'num1'
alert( map.get('1') );  // 'str1'

alert( map.size );      // 3
```
- 객체와 달리 키 문자형 변환 X
  - 키 자료형 제약 X

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`map[key]` : 잘못된 방법**

- `map[key]` <sub>(대괄호)</sub> 사용 가능
  - `map` 일반 객체 취급
    - 여러 제약 발생
- 전용 메서드 사용 권장

#### 맵은 키로 객체를 허용합니다.
```javascript
/* 맵 */
let john1 = { name: "John" };
let visitsCountMap1 = new Map();
visitsCountMap1.set(john1, 123);

alert( visitsCountMap1.get(john1) ); // 123

/* 객체 */
let john2 = { name: "John" };
let visitsCountObj2 = {};     // 객체
visitsCountObj2[john2] = 123; // 객체 키로 값 (123) 저장

alert( visitsCountObj2["[object Object]"] ); // 123, 문자열 형 변환 발생
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **맵 : 키 비교 방식**

- 값 등가 여부 확인
  - SameValueZero 알고리즘
    - `===` <sub>(일치 연산자)</sub> 거의 유사
    - 차이
      - `NaN === NaN` 취급
      - `NaN` 키 사용 가능

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **체이닝**

- `map.set` 호출 시 맵 자신 반환
```javascript
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```

### 맵의 요소에 반복 작업하기
- 이터러블
  - 반복 가능한 객체
- `map.keys()`
  - 각 요소 키 모은 이터러블 객체 반환
- `map.values()`
  - 각 요소 값 모은 이터러블 객체 반환
- `map.entries()`
  - 각 요소 [키 : 값] 쌍 모은 이터러블 객체 반환
```javascript
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 키 순회
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 값 순회
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// [키 : 값] 쌍 순회
// recipeMap.entries() 동일
for (let entry of recipeMap) {
  alert(entry); // cucumber,500 …
}
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **맵 : 삽입 순서 기억**

- 값 삽입 순서대로 순회
  - 객체 : 프로퍼티 순서 기억 X

<br />

- `forEach` <sub>(내장 메서드)</sub> 지원
  - 배열 유사
```javascript
// 각 [키 : 값] 쌍 요소 대상 함수 실행
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 …
});
```

### `Object.entries` : 객체를 맵으로 바꾸기
- 맵 생성자 인수
  - [키 : 값] 쌍 요소 배열 · 이터러블 객체 전달 시
    - 맵 초기화
```javascript
// [키 : 값] 쌍 배열 인수
let map = new Map([
  ['1' , 'str1'],
  [1 , 'num1'],
  [true, 'bool1']
]);
alert( map.get('1') ); // str1

// 객체 내장 메서드 Object.entries(obj)
// - [키 : 값] 쌍 배열 반환
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));
/*
 Object.entries(obj)
 {
   name: "John",
   age: 30
 }
↓↓↓
 [
   ["name","John"],
   ["age", 30]
 ]
 */

alert( map.get('name') ); // John
```

### `Object.fromEntries` : 맵을 객체로 바꾸기
- 요소 [키 : 값] 쌍 배열 → 객체
```javascript
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);
/*
 ↓↓↓
 {
   banana: 1,
   orange: 2,
   meat: 4
 }
 */

alert(prices.orange); // 2
```
  - `map.entries()`
    - [키 : 값] 쌍 이터러블 객체 반환
```javascript
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

 // 맵 → 이터러블 객체
let obj = Object.fromEntries(map.entries());
//        Object.fromEntries(map); 동일
/*
 ↓↓↓
 {
   banana: 1,
   orange: 2,
   meat: 4
 }
 */

alert(obj.orange); // 2
```
- `Object.fromEntries` 인수
  - 반드시 배열 전달 X
  - `map.entries()`
    - 그냥 맵 전달해도 동일 동작
- `map` · 반복문
  - `map.entries()` 동일
    - 동일한 [키 : 값] 쌍 객체 반환

### 셋
- 중복 미허용 값 모아놓은 컬렉션
- 키 없이 값 저장

##### 주요 메서드
- `new Set(iterable)`
  - 셋 생성
  - 인수 : 배열 · 이터러블 객체
    - 셋 초기화
- `set.add(value)`
  - 값 추가 후 셋 자신 반환
- `set.delete(value)`
  - 값 제거
    - 셋 내 값 존재 · 제거 성공 시
      - `true` 반환
    - 셋 내 값 부재 · 제거 실패 시
      - `false` 반환
- `set.has(value)`
  - 셋 내 값 존재 시
    - `true` 반환
  - 셋 내 값 부재 시
    - `false` 반환
- `set.clear()`
  - 셋 비움
- `set.size`
  - 요소 개수 반환

<br />

- 셋 내 동일한 값 존재 시
  - `set.add(value)` <sub>(추가 메서드)</sub> 호출해도 반응 X
    - 셋 내 값 중복 없는 이유
```javascript
let set = new Set();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// 유일무이한 값만 저장
alert( set.size );  // 3

for (let user of set) {
  alert(user.name); // John, Pete, Mary
}
```
- 셋 대신 배열 사용해 중복 값 관리
  - 배열 내 요소 전체 뒤져 <sub>(`find`)</sub> 중복 값 찾음
    - 성능 ↓
    - 셋 : 유일무이한 값 확인에 최적화

### 셋의 값에 반복 작업하기
- `for…of` · `forEach`
```javascript
let set = new Set(["oranges", "apples", "bananas"]);

// for…of
for (let value of set) alert(value);

/*
 forEach
 - 인수 value · valueAgain
   - 맵 호환성 때문
     - 맵 forEach 콜백 : 3개 인수
     - 맵 ↔ 셋 교체 용이
 */
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

##### 반복 작업 메서드
  - `set.keys()`
    - 셋 내 모든 값 보유 이터러블 객체 반환
  - `set.values()`
    - `set.keys()` 동일 기능
    - 맵과의 호환성 위한 메서드
  - `set.entries()`
    - `[value, value]` 배열 포함 이터러블 객체 반환
    - 맵과의 호환성 위한 메서드

<br />

위크맵과 위크셋
===============================

- 자바스크립트 엔진
  - 도달 가능한 <sub>(추후 사용 가능성 있는)</sub> 값
    - 메모리에 유지
```javascript
/*
 john 객체 참조 통해 접근 가능
 참조 null 덮어쓰면 객체 더 이상 도달 불가능
 - 메모리에서 삭제
 */
let john = { name: "John" };
john = null;
```
- 자료구조 내 구성 요소
  - 도달 가능한 값 취급
    - 대개 자신 속한 자료구조 메모리에 남아있는 동안
      - 객체 프로퍼티
      - 배열 요소
      - 맵 · 셋 구성 요소
      - 기타 등등
```javascript
// 배열 메모리에 남아있는 동안 배열 요소 객체 메모리에 남아있음
// - 객체 참조 아무것도 없어도
let john = { name: "John" };
let array = [ john ];

john = null; // 객체 참조 null 덮어씀

// john 객체
// - 배열 요소 (array[0])
// - 가비지 컬렉터 대상 X
alert(JSON.stringify(array[0]));
```
- 맵 객체 키
  - 맵 메모리에 있는 한 객체 메모리에 남음
    - 가비지 컬렉터 대상 X
```javascript
let john = { name: "John" };
let map = new Map();
map.set(john, "…");

john = null; // 객체 참조 null 덮어씀

// john 객체 맵 내 키로 저장
// map.keys() 이용해 john 객체 얻기 가능
for(let obj of map.keys()){
  alert(JSON.stringify(obj));
}

alert(map.size);
```

### 위크맵
- 일반 맵과 전혀 다름
- 키 객체
  - 가비지 컬렉션 대상

#### 위크맵 vs 맵 차이 ①
- 키
  - 반드시 객체
  - 원시값 X
```javascript
let weakMap = new WeakMap();
let obj = {};

weakMap.set(obj, "ok");        // 정상 동작, 객체 키
weakMap.set("test", "Whoops"); // 문자열 ("test") 키 사용 X
                               // Error: Invalid value used as weak map key
```
- 위크맵 키 객체 참조 미존재 시
  - 해당 객체 메모리 · 위크맵 자동 삭제
```javascript
let john = { name: "John" };
let weakMap = new WeakMap();

weakMap.set(john, "…");

john = null; // 참조 null 덮어씀

// john 객체 메모리에서 제거
```
- `"john"` 객체 오로지 위크맵 키 사용
  - 참조 덮어쓰면 객체 위크맵  · 메모리에서 자동 삭제

#### 맵 vs 위크맵 차이 ②
- 반복 작업 · `keys()` · `values()` · `entries()` 메서드 미지원
- 키 · 값 전체 얻기 불가능
- 위크맵 지원 메서드
  - `weakMap.get(key)`
  - `weakMap.set(key, value)`
  - `weakMap.delete(key)`
  - `weakMap.has(key)`
- 적은 메서드 제공
  - 가비지 컬렉션 동작 방식
    - 객체 모든 참조 잃으면 자동 가비지 컬렉션 대상
    - 가비지 컬렉션 동작 시점 정확히 인지 X
      - 시점 자바스크립트 엔진 결정
      - 그 즉시 · 대기 중 함께 삭제될 수도
      - 한 번에 메모리 청소 · 부분 부분 메모리 청소
        - 현재 위크맵 요소 몇 개 있는지 정확히 파악 자체 불가능
        - 위크맵 요소 </sub>(키 · 값)</sub> 전체 대상 무언가를 동작 자체 불가능

### 유스 케이스: 추가 데이터
- 부차적인 데이터 저장할 곳 필요할 때
  - 서드파티 라이브러리 같은 외부 코드 '속한' 객체 작업
    - 이 객체 데이터 추가
    - 추가 데이터
      - 객체 살아있는 동안에만 유효
- 위크맵 원하는 데이터 저장
  - 키 : 객체 사용
    - 객체 가비지 컬렉션 대상 될 때 데이터 함께 제거
```javascript
// john 사망 시 비밀문서 자동 파기
weakMap.set(john, "비밀문서");
```
```javascript
/* 📁 visitsCount.js */
// 맵 사용자 방문 횟수 저장
let visitsCountMap = new Map();

// 사용자 방문 시 방문 횟수 ↑
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

/* 📁 main.js */
let john = { name: "John" };

countUser(john); // John 방문 횟수 증가

// John 방문 횟수 셀 필요 없어지면 john null로 덮어씀
john = null;
```
- `"john"` 객체 가비지 컬렉션 대상 되어야 하는데 `visitsCountMap` 키 사용되고 있어 메모리에서 삭제 X
- 특정 사용자 객체 메모리에서 사라지면 해당 객체 대한 정보 <sub>(방문 횟수)</sub> 손수 지워줘야 하는 상황
  - 이렇게 하지 않으면 `visitsCountMap` 차지 메모리 공간 한없이 ↑
  - 애플리케이션 구조 복잡할 경우 쓸모 없는 데이터 수동 비우기 꽤 골치 아픔
- 위크맵 사용해 문제 예방
```javascript
/* 📁 visitsCount.js */
// 위크맵 사용자 방문 횟수 저장함
let visitsCountMap = new WeakMap();

// 사용자 방문 시 방문 횟수 ↑
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```
- 위크맵 사용해 사용자 방문 횟수 저장 시 `visitsCountMap` 수동 청소 필요 X
- `"john"` 객체 도달 가능하지 않은 상태 되면 자동 메모리에서 삭제
- 위크맵 키 </sub>(`"john"`)</sub> 대응 값 <sub>(`"john"` 방문 횟수)</sub> 자동 가비지 컬렉션 대상

### 유스 케이스: 캐싱
- 캐싱 <sub>(caching)</sub> 필요할 때 유용
- 시간 오래 걸리는 작업 결과 저장해서 연산 시간 · 비용 절약 기법
- 동일 함수 여러 번 호출해야 할 때, 최초 호출 시 반환된 값 어딘가 저장 후 다음에 함수 호출 대신 저장된 값 사용
```javascript
/* 📁 cache.js */
let cache = new Map();

// 연산 수행 후 그 결과 맵에 저장
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

/* 📁 main.js */
// 함수 process() 호출
let obj = {/* … 객체 … */};

// 함수 호출
let result1 = process(obj);

// 동일 함수 2번째 호출
// 연산 수행 X, 맵 저장 결과 가져옴
let result2 = process(obj);

// 객체 쓸모없어지면 null 덮어씀
obj = null;

// 객체 여전히 cache 안 존재 (메모리 낭비)
// 수동 cache 청소 필요
alert(cache.size); // 1
```
- 위크맵 문제 예방
- 객체 메모리에서 삭제 시, 캐시 저장 결과 <sub>(함수 연산 결과)</sub> 역시 메모리에서 자동 삭제
```javascript
// 📁 cache.js
let cache = new WeakMap();

// 이하 동일

/*
 cache.size 사용 불가능
 obj 가비지 컬렉션 대상 되므로 캐싱 데이터 역시 메모리에서 삭제
 삭제 진행 후 cache 그 어떤 요소 미존재
 */
```

### 위크셋
- 셋 유사
- 차이
  - 객체만 저장 가능
  - 원시값 저장 X
- 셋 안 객체 도달 가능할 때만 메모리 유지
- 적은 메서드 지원
  - `add`
  - `has`
  - `delete`
- 미지원 메서드 · 프로퍼티
  - `size`
  - `keys()`
  - 반복 작업 관련 메서드
- 부차적인 데이터 저장 시 사용 <sub>(위크맵 유사)</sub>
- 복잡한 데이터 저장 X
  - 간단한 정보 보관 용도
    - '예' · '아니오' 등
```javascript
let visitedSet = new WeakSet();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john);
visitedSet.add(pete);
visitedSet.add(john);

alert(visitedSet.has(john)); // true
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet에서 john 객체 자동 삭제
```
- 위크맵 · 위크셋 가장 큰 단점
  - 반복 작업 불가능
  - 저장 자료 한 번에 얻기 불가능
  - 위크맵 · 위크셋 이용 주요 작업 방해 X
  - 객체 함께 '추가' 데이터 저장 용도

<br />

`Object.keys` · `values` · `entries`
============================

- 순회 관련 메서드
  - `keys()`
  - `values()`
  - `entries()`
- 순회 관련 메서드 사용 가능 자료구조
  - `Map`
  - `Set`
  - `Array`
- 포괄적인 용도
  - 메서드 적용 자료구조 일련 합의 준수
    - 커스텀 자료구조 대상 순회 시
      - 기존 메서드 사용 X
      - 직접 메서드 구현
- 일반 객체용 순회 관련 메서드 <sub>(자료구조 메서드 문법 상이)</sub>
  - `Object.keys(obj)`
    - 객체 키 배열 반환
  - `Object.values(obj)`
    - 객체 값 배열 반환
  - `Object.entries(obj)`
    - [키 · 값] 쌍 배열 반환

||맵|객체|
|---|---|---|
|호출 문법|`map.keys()`|`Object.keys(obj)` ≠ `obj.keys()`|
|반환 값|iterable 객체|'진짜' 배열|

#### 차이 ①
- 호출 주체
  - `Object.keys(obj)`　&nbsp;O
  - `obj.keys()` 　　　　X
- 유연성
  - 복잡한 자료구조 전체 → 객체 기반
  - 커스텀 메서드 구현 상태
    - 커스텀 메서드 · 내장 메서드 둘 다 사용 가능

#### 차이 ②
- 반환 값
  - 배열 <sub>(객체 한 종류)</sub> 　O
  - iterable 객체 　　　　X
- 하위 호환성
```javascript
let user = {
  name: "John",
  age: 30
};

// Object.keys(user)    → [ "name", "age" ]
// Object.values(user)  → [ "John", 30 ]
// Object.entries(user) → [ ["name","John"], ["age",30] ]
```
- `Object.values` 사용 시 프로퍼티 값 대상 원하는 작업 가능
```javascript
let user = {
  name: "Violet",
  age: 30
};

// 값 순회
for (let value of Object.values(user)) {
  alert(value); // Violet, 30 연속적으로 출력
}
```

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`Object.keys` · `values` · `entries` : 심볼형 프로퍼티 무시**

- 심볼형 키 프로퍼티 무시
  - `for…in` <sub>(반복문)</sub>
  - `Object.keys`
  - `Object.values`
  - `Object.entries`
- 대개 심볼형 키 연산 대상 미포함 권장
  - 필요한 경우
    - `Object.getOwnPropertySymbols`
      - 심볼형 키 배열 형태 반환 메서드
    - `Reflect.ownKeys(obj)`
      - 키 전체 배열 형태 반환

### 객체 변환하기
- 객체 대상 배열 전용 메서드 <sub>(`map` · `filter` 등)</sub> 사용 X
- `Object.entries` · `Object.fromEntries` 순차적으로 적용 시 객체 배열 전용 메서드 사용 가능
- 적용 방법
  1. `Object.entries(obj)`
      - 객체 키 · 값 쌍 요소 배열 얻기
  2. 배열에 `map` 등 배열 전용 메서드 사용
  3. `Object.fromEntries(array)`
    - 메서드 사용 후 반환 배열 다시 객체 변환
```javascript
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

// 객체 → 배열 → 배열 전용 메서드 → 객체
//                  (.map)   (.fromEntries)
let doublePrices = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```

<br />

구조 분해 할당
=============

- 구조 분해 할당
  - 객체 · 배열 변수로 '분해'
  - 함수 매개변수 多
  - 매개변수 기본값 필요 등

### 배열 분해하기
```javascript
// 이름과 성을 요소로 가진 배열
let arr = ["Bora", "Lee"]

// 구조 분해 할당
// firstName ← arr[0]
// surname   ← arr[1]
let [firstName, surname] = arr;

alert(firstName); // Bora
alert(surname);   // Lee

// 반환 값 배열 메서드 함께 활용
let [firstName, surname] = "Bora Lee".split(' ');
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **'분해 <sub>(destructuring)</sub>' ≠ '파괴 <sub>(destructive)</sub>'**

- '분해 <sub>(destructurize)</sub>' 의미
- 분해 대상 수정 · 파괴 X
- 배열 요소 직접 변수 할당보다 코드 양 ↓
```javascript
// 구조 분해 할당
let [firstName1, surname1] = arr;

// 직접 할당
let firstName2 = arr[0];
let surname2 = arr[1];
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **쉼표 사용하여 요소 무시**

- 쉼표 사용 시 불필요 배열 요소 버림
```javascript
// 2번째 요소는 필요하지 않음
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **할당 연산자 우측 : 모든 이터러블 가능**

- 모든 이터러블 <sub>(iterable, 반복 가능 객체)</sub> 적용 가능
```javascript
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **할당 연산자 좌측 : 뭐든지 가능**

- 할당 연산자 좌측
  - '할당할 수 있는' 것이라면 어떤 것이든 가능
  - 객체 프로퍼티 가능
```javascript
let user = {};
[user.name, user.surname] = "Bora Lee".split(' ');

alert(user.name); // Bora
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`.entries()` 반복**

- `Object.entries(obj)`
  - 구조 분해 조합
    - 객체 키 · 값 순회해 변수로 분해 할당
```javascript
// 객체
let user1 = {
  name: "John",
  age: 30
};

// 객체 키 · 값 순회
for (let [key, value] of Object.entries(user1)) {
  alert(`${key}:${value}`); // name: John, age: 30
}

// 맵
let user2 = new Map();
user2.set("name", "John");
user2.set("age", "30");

// 맵 키 · 값 순회
for (let [key, value] of user2) {
  alert(`${key}:${value}`); // name: John, age: 30
}
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **변수 교환 트릭**

- 두 변수 값 교환
```javascript
let guest = "Jane";
let admin = "Pete";

[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane
```

#### `...` 로 나머지 요소 가져오기
- '나머지' 요소 가져오기
- 나머지 배열 요소 저장 새 배열
```javascript
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1);   // Julius
alert(name2);   // Caesar

// `rest` : 배열입니다.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```
- `...` 변수 앞의 점 세 개
- 가장 마지막 위치

#### 기본값
- 할당 변수 개수 > 분해 배열 길이
  - 에러 발생 X
  - 할당 값 없으면 `undefined` 취급
```javascript
let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname);   // undefined
```
- `=`
  - 할당 값 없을 때 '기본값' 설정
```javascript
// 기본값
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius   , 배열 값
alert(surname); // Anonymous, 기본값
```
- 복잡한 표현식 · 함수 호출 기본값 가능
  - 할당 값 없을 때 표현식 평가 · 함수 호출
```javascript
// 값 미제공 때만 함수 호출
// prompt 한 번만 호출 (name의 prompt)
let [surname = prompt('성을 입력하세요.'), name = prompt('이름을 입력하세요.')] = ["김"];

alert(surname); // 김, 배열 값
alert(name);    // prompt 값
```

### 객체 분해하기
- 우측
  - 분해 대상 객체
- 좌측
  - 상응 객체 프로퍼티 '패턴'
```javascript
let {var1, var2} = {var1:…, var2:…}
```
```javascript
// 분해 대상 객체 프로퍼티 키 목록 패턴 사용
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
- 순서 미중요
```javascript
// let { … } 안 순서 바뀌어도 동일 동작
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
```
- 할당 연산자 좌측 좀 더 복잡한 패턴 가능
- 분해 대상 객체 프로퍼티 · 변수 연결 조정
  - `:` 콜론
    - `분해 대상 객체 프로퍼티: 목표 변수`
```javascript
// 객체 프로퍼티 · 다른 이름 변수 저장
// 콜론 (:)
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { 객체 프로퍼티: 목표 변수 }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title
alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```
- `=`
  - 프로퍼티 부재 대비 기본값 설정
```javascript
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
- 표현식 · 함수 호출 기본값 할당 가능
  - 값 미제공 시 표현식 평가 · 함수 호출
```javascript
let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // prompt 창 입력 값
```
- `:` 콜론 · `=` 할당 연산자 동시 사용 가능
```javascript
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```
- 프로퍼티 많은 복잡한 객체 원하는 정보만 뽑아오기
```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// title만 변수로 뽑아내기
let { title } = options;

alert(title); // Menu
```

#### 나머지 패턴 `...`
- 나머지 프로퍼티 어딘가에 할당
- 모던 브라우저 지원
- IE 등 몇몇 구식 브라우저 미지원
  - 바벨 <sub>(Babel)</sub> 이용
```javascript
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// rest = 나머지 프로퍼티들
let {title, ...rest} = options;

// rest → { height: 200, width: 100 } 할당
alert(rest.height); // 200
alert(rest.width);  // 100
```

<img class="icon" src="./images/commons/icons/circle-exclamation-solid.svg" /> **`let` 없이 사용**

- 기존 변수 분해 값 할당 가능
```javascript
// 잘못된 코드
let title, width, height;

// SyntaxError: Unexpected token '='
// 코드 블록으로 인식
{title, width, height} = {title: "Menu", width: 200, height: 100};
```
- 표현식 안에 있지 않으면서 주요 코드 흐름 상에 있는 `{ … }`
  - 코드 블록 인식
  - 코드 블록 본래 용도
    - 문 <sub>(statement)</sub> 묶기
  ```javascript
  {
    // 코드 블록
    let message = "Hello";
    // …
    alert( message );
  }
  ```
- 할당문 괄호 `( … )` 감싸 `{ … }` 코드 블록 아닌 표현식으로 해석
```javascript
let title, width, height;

({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
```

### 중첩 구조 분해
- 객체 · 배열 다른 객체 · 배열 포함 시, 좀 더 복잡한 패턴 사용
  - 중첩 배열 · 객체 정보 추출
```javascript
/*
options.size 프로퍼티
- 또 다른 객체
items 프로퍼티
- 배열
대입 연산자 좌측 패턴
- 정보 추출 대상 객체 options 같은 구조
*/
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// 코드 여러 줄 걸쳐 작성해 의도하는 바 명확히 드러냄
let {
  size: { // size 객체 프로퍼티
    width,
    height
  },
  items: [item1, item2], // items 배열 프로퍼티
  title = "Menu"         // 분해 객체 title 프로퍼티 미존재 → 기본값 사용
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
// extra 미할당

// size · items 전용 변수 X
// 전용 변수 대신 size · items 안 정보 변수 할당
```

### 똑똑한 함수 매개변수
- 종종 함수 매개변수 상당수 선택적으로 사용
```javascript
function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // …
}
```
- 넘겨주는 인수 순서 틀려 문제 발생 가능
- 대부분의 매개변수 기본값 설정
  - 굳이 인수 넘겨주지 않아도 되는 경우 문제 발생
```javascript
// 기본값 사용 시 undefined 여러 개 전달
// 가독성 ↓
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
```
- 매개변수 객체에 모아 함수 전달
- 함수 전달받은 객체 분해하여 변수 할당
```javascript
// 함수에 전달할 객체
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// 전달받은 객체 분해 후 변수 즉시 할당
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items  → 객체 options
  // width, height → 기본값
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
```
- 중첩 객체 · `:` 콜론 조합
  - 좀 더 복잡한 구조 분해
```javascript
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,                // width  → w
  height: h = 200,               // height → h
  items: [item1, item2]          // items 1번째 요소 → item1
}) {                             // items 2번째 요소 → item2
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```
- 똑똑한 함수 매개변수 문법
  - 구조 분해 할당 문법 동일
```javascript
// incomingProperty → varName
// 값 부재 시 defaultValue 기본값 사용
function({
  incomingProperty: varName = defaultValue
  …
})
```
- 함수 매개변수 구조 분해 시
  - 반드시 인수 전달 가정 유의
  - 모든 인수 기본값 할당 시 빈 객체 명시적으로 전달
```javascript
showMenu({}); // 모든 인수 기본값 할당
showMenu();   // 에러가 발생 가능
```
- 빈 객체 `{}` 인수 전체의 기본값 설정
- 어떤 경우든 분해할 것 존재
  - 인수 전부 미전달 시 에러 발생 X
```javascript
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
```

<br />

Date 객체와 날짜
===============

- 생성 · 수정 시간 저장
- 시간 측정
- 현재 날짜 출력 등

### 객체 생성하기

#### `new Date()`
  - 인수 없이 호출 시 현재 날짜 · 시간 저장된 `Date` 객체 반환
```javascript
let now = new Date();
alert( now ); // 현재 날짜 · 시간 출력
```

#### `new Date(milliseconds)`
- UTC 기준 <sub>(UTC+0)</sub> 1970.1.1 00:00:00 에서 milliseconds 밀리초 <sub>(1/1000 초)</sub> 후 시점 저장된 `Date` 객체 반환
```javascript
// 1970.1.1 00:00:00 (UTC+0) 표현 객체
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// 1970.1.1 24시간 후 → 1970.1.1 (UTC+0)
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
```
- 타임스탬프 <sub>(timestamp)</sub>
  - 1970년 첫날 기준 흘러간 밀리초 나타내는 정수
  - 날짜 숫자 형태로 간편하게 표현
  - `new Date(timestamp)` · 타임스탬프 사용해 특정 날짜 저장된 `Date` 객체 손쉽게 생성
  - `date.getTime()` 메서드 사용해 `Date` 객체 타임스탬프 추출
- 1970.1.1 이전 날짜 해당 타임스탬프 값
  - 음수
```javascript
// 1969.12.31
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
```

#### `new Date(datestring)`
- 인수 문자열 하나
  - 해당 문자열 자동으로 구문 분석
  - 구문 분석 적용 알고리즘
    - `Date.parse` 사용 알고리즘 동일
```javascript
let date = new Date("2017-01-26");
alert(date);
/*
 인수 시간 미지정하지 → GMT 자정 가정
 코드 실행 시간대 (timezone) 따라 출력 문자열 바뀜
 Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
 or
 Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
 등 출력
 */
```

#### `new Date(year, month, date, hours, minutes, seconds, ms)`
- 주어진 인수 조합해 생성 가능 날짜 저장된 객체 반환 <sub>(지역 시간대 기준)</sub>
- 필수 : 1 · 2번째 인수
  - `year`
    - 4자리 숫자
      - 2013 &nbsp;O
      - 98 　&nbsp;X
  - `month`
    - 0 <sub>(1월)</sub> ~ 11 <sub>(12월)</sub> 사이 숫자
  - `date`
    - 일
    - 값 부재 시 1일 처리
  - `hours` · `minutes` · `seconds` · `ms`
    - 값 없는 경우 `0` 처리
```javascript
new Date(2011, 0, 1, 0, 0, 0, 0); // 2011.1.1, 00:00:00
new Date(2011, 0, 1); // 모든 인수 기본값 : 0

// 최소 정밀도 : 1밀리초 (1 / 1000초)
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 2011.1.1., 02:03:04.567
```

### 날짜 구성요소 얻기
- `getFullYear()`
  - 연도 <sub>(4자릿수)</sub> 반환
- `getMonth()`
  - 월 반환 <sub>(`0` ~ `11`)</sub>
- `getDate()`
  - 일 반환 <sub>(`1` ~ `31`)</sub>
- `getHours()` · `getMinutes()` · `getSeconds()` · `getMilliseconds()`
  - 시 · 분 · 초 · 밀리초 반환

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **`getYear()` 사용 X · `getFullYear()` 사용**

- 여러 자바스크립트 엔진 더는 사용되지 않는 <sub>(`deprecated`)</sub> 비표준 메서드 `getYear()` 구현
- 두 자릿수 연도 반환 경우 有
  - 절대 사용 X
  - `getFullYear()` 사용

#### `getDay()`
- `0` <sub>(일요일)</sub> ~ `6` <sub>(토요일)</sub> 중 하나 반환
- 몇몇 나라에서 요일의 첫날이 일요일이 아니긴 하지만, `getDay` 에선 항상 `0` 이 일요일을 나타냅니다. 이를 변경할 방법은 없습니다.

#### 위 메서드 모두 현지 시간 기준 날짜 구성요소 반환
- 표준시 <sub>(UTC+0)</sub> 기준 날짜 구성 요소 반환 메서드
  - `getUTCFullYear()`
  - `getUTCMonth()`
  - `getUTCDay()`
```javascript
// 현재 일시
let date = new Date();

// 현지 시간 기준 시
alert( date.getHours() );

// 표준시간대 (UTC+0, 일광 절약 시간제 미적용 런던 시간) 기준 시
alert( date.getUTCHours() );
```

#### `getTime()`
- 주어진 일시 ~ 1970.1.1 00:00:00 사이 간격 <sub>(밀리초 단위)</sub> 타임스탬프 반환

#### `getTimezoneOffset()`
- 현지 시간 ~ 표준 시간 차이 <sub>(분)</sub> 반환

### 날짜 구성요소 설정하기
- 날짜 구성요소 설정 메서드
  - `setFullYear(year, [month], [date])`
  - `setMonth(month, [date])`
  - `setDate(date)`
  - `setHours(hour, [min], [sec], [ms])`
  - `setMinutes(min, [sec], [ms])`
  - `setSeconds(sec, [ms])`
  - `setMilliseconds(ms)`
  - `setTime(milliseconds)` <sub>(1970.1.1 00:00:00 UTC ~ 밀리초 이후 나타내는 날짜 설정)</sub>
- `setTime()` 제외 모든 메서드 표준시 날짜 구성 요소 설정 메서드 有
  - ex&#41; `setUTCHours()`
```javascript
let today = new Date();

today.setHours(0);
alert(today); // 날짜 변경 X, 시 변경 (0)

today.setHours(0, 0, 0, 0);
alert(today); // 날짜 변경 X, 시, 분, 초 모두 변경 (00:00:00초)
```

### 자동 고침
- 범위 밖 값 설정 시 자동 고침 기능 활성화, 값 자동 수정
```javascript
let date = new Date(2013, 0, 32); // 2013.1.32 불가능
alert(date);                      // 2013.2.1  출력
```
- 입력받은 날짜 구성 요소 범위 벗어나면 초과분 자동으로 다른 날짜 구성요소 배분
- 윤년 자동 계산
```javascript
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 2016.3.1
```
- 일정 시간 지난 후 날짜 구하는데도 종종 사용
```javascript
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // 70초 후 날짜 출력
```
- 0 · 음수 날짜 구성요소 설정 가능
```javascript
let date = new Date(2016, 0, 2); // 2016.1.2

date.setDate(1); // 변경 (1일)
alert( date );   // 2016.1.1

date.setDate(0); // 일 최솟값 : 1, 0 입력 시 전 달 마지막 날 설정 효과
alert( date );   // 2015.12.31
```

### `Date` 객체를 숫자로 변경해 시간차 측정하기
- `Date` 객체 숫자형 변경 시 타임스탬프 <sub>(`date.getTime()` 호출 시 반환 값)</sub>
```javascript
let date = new Date();
alert(+date); // 타임스탬프 (date.getTime() 호출 동일)
```
- 날짜 마이너스 연산자 적용해 밀리초 기준 시차 구하기
```javascript
let start = new Date(); // 측정 시작

// 원하는 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date();   // 측정 종료

alert( `반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.` );
```

### `Date.now()`
- 현재 타임스탬프 반환 메서드
- `new Date().getTime()` 의미론적으로 동일
- 중간 Date 객체 미생성
  - `new Date().getTime()` 보다 빠름
    -  가비지 컬렉터 일 ↓
- 성능 중요 시 `Date.now()` 자주 활용
```javascript
let start = Date.now(); // 1970.1.1 ~ 현재까지의 밀리초

// 원하는 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now();   // done

// Date 객체 X, 숫자끼리 차감
alert( `반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.` );
```

### 벤치마크 테스트
- 비교 대상 성능 비교 · 시험 · 평가
- CPU 소모 큰 함수 신뢰할만한 벤치마크 <sub>(평가 기준)</sub> 구하려면 상당한 주의 필요
```javascript
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// 반환 값 : 밀리초
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

// 벤치마크 테스트
function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'diffSubtract 십만번 호출 소모 시간: ' + bench(diffSubtract) + 'ms' );
alert( 'diffGetTime  십만번 호출 소모 시간: ' + bench(diffGetTime) + 'ms' );
```
- 형 변환 X
  - 엔진 최적화 소모 자원 ↓
  - `getTime()` 훨씬 빠름
- 멀티 프로세스 지원 운영체제
  - 병렬 처리 <sub>(CPU 자원 투입)</sub> → 부정확
- 좀 더 신뢰할만한 벤치마크 테스트
  - benchmark 번갈아 가면서 여러 번 실행
```javascript
// … 동일 …

let time1 = 0;
let time2 = 0;

// 벤치마크 테스트
// 함수 bench 각 함수 (diffSubtract, diffGetTime) 별로 10번씩 실행
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'diffSubtract에 소모된 시간: ' + time1 );
alert( 'diffGetTime에 소모된 시간: ' + time2 );
```
- 모던 자바스크립트 엔진 아주 많이 실행된 코드인 'hot code' 대상 최적화 수행
  - 메인 반복문 실행 전 예열용 bench 실행
```javascript
// 메인 반복문 실행 전, "예열용" 코드
bench(diffSubtract);
bench(diffGetTime);

// 벤치마크 테스트 시작
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

<img class="icon" src="./images/commons/icons/triangle-exclamation-solid.svg" /> **세밀한 벤치마킹 진행 시 주의**

- 모던 자바스크립트 엔진 최적화 多
  - '만들어진 테스트' · '실제 사례' 결과 상이 가능
  - 특히 연산자, 내장 함수 등 아주 작은 것일수록 더 상이할 수 있음
  - 진지하게 성능 이해
    - 자바스크립트 엔진 동작 방식 공부
    - [Javscript v8 Engine](http://mrale.ph "Javscript v8 Engine Essay")

### `Date.parse` · 문자열
- 문자열에서 날짜 읽음
- 요구 문자열 형식
  - `YYYY-MM-DDTHH:mm:ss.sssZ`
    - `YYYY-MM-DD`
      - 날짜 (연-월-일)
    - `T`
      - 구분 기호
    - `HH:mm:ss.sss`
      - 시:분:초.밀리초
    - `Z` (옵션)
      - `+-hh:mm` 형식 시간대
      - `Z` 한 글자 : `UTC+0`
  - 더 짧은 문자열 형식
    - `YYYY-MM-DD`
    - `YYYY-MM`
    - `YYYY`
    - 기타 등등
- 문자열 대응 날짜 타임스탬프 반환
- 문자열 형식 조건 안 맞으면 `NaN` 반환
```javascript
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (타임스탬프)

// 타임스탬프만으로 새 Date 객체 생성 가능
let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
```

<br />

JSON과 메서드
============

- JSON <sub>(JavaScript Object Notation)</sub>
  - 값 · 객체 표현 범용 포맷 <sub>(RFC 4627 표준)</sub>
  - 데이터 교환 목적 사용 多
    - 클라이언트 측 언어 자바스크립트
- JSON 관련 메서드
  - `JSON.stringify`
    - 객체 → JSON
  - `JSON.parse`
    - JSON → 객체

### `JSON.stringify`
```javascript
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // string

alert(json);
/* JSON 인코딩된 객체:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
```
- JSON - □□□ - 객체
  - encoded <sub>(인코딩된)</sub>
  - serialized <sub>(직렬화 처리된)</sub>
  - stringified <sub>(문자열 변환된)</sub>
  - marshalled <sub>(결집된)</sub>
- JSON 인코딩 객체 vs 일반 객체
  - 문자열
    - 큰따옴표
    - 작은따옴표 X
    - 백틱 X
    - 'John' → "John"
  - 객체 프로퍼티명
    - 큰따옴표
    - age: 30 → "age": 30
- 적용 가능 자료형
  - 객체 `{ … }`
  - 배열 `[ … ]`
  - 원시형
    - 문자형
    - 숫자형
    - 불린형 값
      - `true`
      - `false`
    - `null`
```javascript
// 숫자 → JSON : 숫자
alert( JSON.stringify(1) ); // 1

// 문자열 → JSON : 문자열 (큰따옴표 추가)
alert( JSON.stringify('test') ); // "test"

alert( JSON.stringify(true) );      // true
alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
```
- 데이터 교환 목적
  - 언어 종속 X 포맷
  - 자바스크립트 특유 객체 프로퍼티 `JSON.stringify` 처리 X
- `JSON.stringify` 호출 시 무시 프로퍼티
  - 함수 프로퍼티 <sub>(메서드)</sub>
  - 심볼형 프로퍼티 <sub>(심볼 키 프로퍼티)</sub>
  - `undefined` 프로퍼티
```javascript
let user = {
  sayHi() {            // 무시
    alert("Hello");
  },
  [Symbol("id")]: 123, // 무시
  something: undefined // 무시
};

alert( JSON.stringify(user) ); // {}, 빈 객체
```
- 중첩 객체 자동 문자열 변환
```javascript
let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* 객체 전체가 문자열로 변환되었습니다.
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
```
- 순환 참조
  - 객체 문자열 변환 X
```javascript
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;      // meetup → room
room.occupiedBy = meetup; // room   → meetup

JSON.stringify(meetup);   // Error: Converting circular structure to JSON
```

### `replacer` 로 원하는 프로퍼티만 직렬화하기
- `JSON.stringify` 문법
```javascript
let json = JSON.stringify(value[, replacer, space])
```
- `value`
  - 인코딩 하려는 값
- `replacer`
  - JSON 인코딩 목표 프로퍼티 배열 · 매핑 함수 `function(key, value)`
- `space`
  - 공백 문자 수 <sub>(서식 변경)</sub>
- 보통 `JSON.stringify` 인수 하나만 넘겨서 사용
  - 순환 참조 같이 전환 프로세스 정교하게 조정
    -  2번째 인수
- JSON 변환 대상 프로퍼티 배열 2번째 인수
  - 이 프로퍼티들만 인코딩
```javascript
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room             // meetup → room 참조
};

room.occupiedBy = meetup; // room → meetup 참조

// 문자열 participants 비어버림
// - 배열 'name' 프로퍼티 X (규칙 너무 까다로움)
alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}

// 배열 너무 길어짐
alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/

// Replacer 함수 사용
// replacer 함수 프로퍼티 (키, 값) 쌍 전체 대상 호출
// 기존 프로퍼티 값 대신 사용할 값 반환
// 특정 프로퍼티 직렬화 누락
//   - 반환 값 : undefined
alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));
/*
replacer 함수 처리 키 · 값 쌍 목록
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
```
- `replacer` 함수 중첩 객체 ∼ 배열 요소 포함한 모든 키 · 값 쌍 처리
- 재귀적으로 키 · 값 쌍 처리
  - 함수 내 `this`
    - 현재 처리 중인 프로퍼티 위치한 객체 참조
- 함수 최초 호출 때 `{"": meetup}` 형태 "래퍼 객체" 생성
  - 문자열 `":[object Object]"`
  - `replacer` 함수 가장 처음 처리하는 <sub>(key, value)</sub> 쌍
    - 키 : 빈 문자열
    - 값 : 변환 대상 객체 <sub>(`meetup`)</sub> 전체

### `space` 로 가독성 높이기
- 3번째 인수 `space`
  - 중간 삽입 공백 문자 수
    - 가독성 ↑ 목표
```javascript
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

// 공백 문자 2개
alert(JSON.stringify(user, null, 2));
/*
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

    // 공백 문자 4개
alert(JSON.stringify(user, null, 4));
/*
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
```

### 커스텀 `toJSON`
- 객체 `toJSON` 메서드 구현 시
  - 객체 → JSON
  - `JSON.stringify` 감지, `toJSON` 자동 호출
- 직접 호출 · 중첩객체 사용
```javascript
let room = {
  number: 23,

  // 커스텀 toJSON
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

// 직접 호출
alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",

    // Date 객체 내장 메서드 toJSON 호출
    "date":"2017-01-01T00:00:00.000Z",

    // 중첩객체
    // 커스텀 toJSON
    "room": 23

    // 커스텀 toJSON 미존재 시
    "room": {"number":23}
  }
*/
```

### `JSON.parse`
- JSON 인코딩 객체 → 객체
```javascript
let value = JSON.parse(str, [reviver]);
```
- `str`
  - JSON 형식 문자열
- `reviver`
  - 모든 <sub>(key · value)</sub> 쌍 대상 호출 `function(key,value)` 함수
    - 값 변경
```javascript
// 문자열 변환 배열
let numbers = "[0, 1, 2, 3]";
numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1


// 중첩 객체
let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
```
- 디버깅 등의 목적 직접 JSON 생성 시 저지르는 실수 일부
```javascript
let json = `{
  name: "John",                     // 1: 프로퍼티명 큰따옴표 X
  "surname": 'Smith',               // 2: 프로퍼티 값 큰따옴표 O, 작은따옴표 X
  'isAdmin': false                  // 3: 프로퍼티 키 큰따옴표 O, 작은따옴표 X
  "birthday": new Date(2000, 2, 3), // 4: "new" 사용 X
                                    // 순수한 값 (bare value) 만 사용
  "friends": [0,1,2,3]              // 문제 없음
}`;
```
- JSON 주석 지원 X
- JSON5 포맷
  - 키 큰따옴표 X 가능
  - 주석 지원
  - 자바스크립트 명세서 정의 X <sub>(독자적인 라이브러리)</sub>

### `reviver` 사용하기
```javascript
// 서버로부터 문자열 변환 meetup 객체 전송 받음
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

// 역직렬화(deserialize) → 자바스크립트 객체
let meetup1 = JSON.parse(str);

// meetup1.date
// - 문자열 (Date 객체 X)
alert( meetup1.date.getDate() ); // 에러

// 2번째 인수 reviver 함수 사용
let meetup2 = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // 정상 작동

// 중첩 객체
let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // 정상 작동
```
