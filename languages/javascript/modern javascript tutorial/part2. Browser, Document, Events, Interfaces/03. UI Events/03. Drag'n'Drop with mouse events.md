드래그 앤 드롭 · 마우스 이벤트
============================

##### [모던 HTML 표준 내용](https://html.spec.whatwg.org/multipage/dnd.html#dnd)
- 특수 이벤트
  - `dragstart`
  - `dragend`
  - 기타 등등
- 기타 등등

#### `drag[start·end]` <sub>(이벤트)</sub>

##### 특별한 드래그 앤 드롭 기능 제공
- 파일 드래그 <sub>(파일 관리 앱)</sub>
- 파일 드롭 <sub>(브라우저 화면)</sub>
  - 파일 내용 처리 가능

##### 한계 多
- 특정 영역 드래그 막기 X
- 수평 · 수직 드래그 X
- 부족한 모바일 환경 지원
- 기타 등등

##### 한계 극복
- 마우스 이벤트 활용

### 기본 알고리즘

##### 1. `mousedown` <sub>(이벤트)</sub>
- 움직임 필요 요소 준비
  - 기존 요소 복사본 생성
  - 해당 요소 클래스 추가
  - 기타 등등

##### 2. `mousemove` <sub>(이벤트)</sub>
- `left ∙ top` 변경
  - `position: absolute`

##### 3. `mouseup` <sub>(이벤트)</sub>
- 완료 관련 작업 수행

##### 공 <sub>(요소)</sub> 드래그
```javascript
ball.onmousedown = function(event) {

  // (1)
  // absolute (속성) · zIndex (프로퍼티) 수정
  // - 공 (요소) 이동 준비
  //   - 최상단 설정
  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;

  // 공 (요소) 문서 상 위치 변경
  // - 현재 위치 부모 → body
  //   - body 기준 위치 지정
  document.body.append(ball);

  // 공 (요소) 위치 설정
  // - 요소 중앙 → 포인터 위치
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
  }

  // 공 (요소) 이동 (클릭 시점)
  // - 포인터 위치
  moveAt(event.pageX, event.pageY);

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  // (2)
  // 공 (요소) 이동 (mousemove)
  // - 드래그 중
  document.addEventListener('mousemove', onMouseMove);

  // (3)
  // 공 (요소) 드롭 (onmouseup)
  // - 불필요 핸들러 제거
  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};
```

![drag-and-drop-algorithm](../../images/02/03/03/drag-and-drop-algorithm.png)

##### 드래그 시 복사된 공 <sub>(요소)</sub> 찍어 이동하는 현상 발생
- 브라우저 자체 제공 기능 자동 실행
  - 이미지 · 요소 대상
  - 코드 충돌
    - 비활성화 필요
```javascript
ball.ondragstart = function() {
  return false;
};
```

![drag-and-drop-algorithm](../../images/02/03/03/drag-and-drop-algorithm.png)

##### `mousemove` <sub>(이벤트)</sub> 추적
- `ball` <sub>(요소)</sub> X
- `document`

##### `mousemove` <sub>(이벤트)</sub>
- 모든 픽셀 대상 자주 트리거 X
- 빠른 이동 시 포인터 점프 현상 발생
  - `document` 중간
  - 윈도우 어딘가
  - 기타 등등
    - `document` 내 처리

### 올바른 위치 지정

##### 공 <sub>(요소)</sub> 중앙
- 항상 포인터 위치 이동
```javascript
ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
```

##### 부작용
- 공 가장자리에 `mousedown` <sub>(이벤트)</sub> 발생 시
  - 점프 현상 발생
    - 공 중앙 → 포인터 위치
- 요소 초기 이동 유지 <sub>(포인터 기준)</sub>
  - 점프 현상 방지
- ex\) 공 가장자리 드래그 시작 시
  - 드래그 중 포인터 위치 <sub>(공 가장자리)</sub> 유지

![ball_shift](../../images/02/03/03/ball_shift.svg)

#### 개선된 알고리즘

##### 1. 클릭 <sub>(`mousedown` 이벤트 발생)</sub> 시
- 거리 <sub>(공 좌상단 모서리 ~ 포인터)</sub> 계산
  - `shift[X∙Y]` <sub>(변수)</sub> 저장
  - 드래그 중 거리 유지
```javascript
/* onmousedown 핸들러 */
// 포인터 좌표 - 공 좌상단 모서리 좌표
let shiftX = event.clientX - ball.getBoundingClientRect().left;
let shiftY = event.clientY - ball.getBoundingClientRect().top;
```

##### 2. 공 <sub>(요소)</sub> 드래그 시
- 공 <sub>(요소)</sub> 이동
  - 거리 <sub>(공 좌상단 모서리 ~ 포인터)</sub> 유지
```javascript
/* onmousemove 핸들러 */
// 공 (요소) 이동 중 거리 유지
// - 공 좌상단 모서리 ~ 포인터
ball.style.left = event.pageX - shiftX + 'px';
ball.style.top = event.pageY - shiftY + 'px';
```

##### 개선된 코드
```javascript
ball.onmousedown = function(event) {

  // 거리 계산
  // - 공 좌상단 모서리 ~ 포인터
  let shiftX = event.clientX - ball.getBoundingClientRect().left;
  let shiftY = event.clientY - ball.getBoundingClientRect().top;

  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;

  document.body.append(ball);

  moveAt(event.pageX, event.pageY);

  // 클릭 · 드래그 시 거리 유지
  // - 공 좌상단 모서리 ~ 포인터
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - shiftX + 'px';
    ball.style.top = pageY - shiftY + 'px';
  }

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  document.addEventListener('mousemove', onMouseMove);

  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};

// 브라우저 자체 드래그 기능 비활성화
ball.ondragstart = function() {
  return false;
};
```

![drag-and-drop-algorithm](../../images/02/03/03/drag-and-drop-algorithm.png)

### 잠재적 드롭 대상 <sub>(드롭 가능)</sub>

##### 실생활 중 일반적인 드롭
- 한 요소
  - 다른 요소에 드롭
  - 어디서나 드롭 X
- '드래그 가능한' 요소
  - '드롭 가능한' 요소에 드롭

##### 필수사항
- 요소 드롭될 위치
  - 드래그 앤 드롭 작업 끝 부분
- 드롭 가능 여부 강조 표시
  - 드롭 위치에 끌고 와 포인터 위치 시

##### 잠재적 드롭 요소
- `mouse[over∙up]` 핸들러 설정 시
  - 동작 X
- 드래그 중 드래그 가능 요소
  - 항상 다른 요소 위 위치
- 마우스 이벤트 내
  - 맨 위 요소
    - 이벤트 발생
  - 그 아래 요소
    - 이벤트 미발생

##### `<div>` <sub>(요소)</sub> 2개
- 빨강 요소
  - 파랑 요소 전체 덮음
- 파랑 요소
  - 이벤트 잡을 방법 X
```html
<style>
  div {
    width: 50px;
    height: 50px;
    position: absolute;
    top: 0;
  }
</style>
<div style="background:blue" onmouseover="alert('never works')"></div>
<div style="background:red" onmouseover="alert('over red!')"></div>
```

![potential-drop-target-1](../../images/02/03/03/potential-drop-target-1.png)

##### 공 <sub>(요소)</sub> 드래그 시
- 공 <sub>(요소)</sub>
  - 항상 다른 요소 위 위치
    - 이벤트 발생
- 하위 요소 설정 핸들러
  - 동작 X

##### `elementFromPoint` <sub>(메서드)</sub>
- 최다 중첩 요소 반환
  - 윈도우 기준 좌표 <sub>(인수)</sub> 위치
- `null` 반환
  - 윈도우 밖 좌표

##### 마우스 이벤트 핸들러
- 포인터 아래 드롭 가능성 감지
```javascript
/* 마우스 이벤트 핸들러 */

/* 드래그 중인 요소 숨김
  생략 시
  - ball (공 요소)
    - 포인터 아래 맨 위 요소
  elemBelow (변수) 저장 좌표
  - ball (공 요소) 좌표
*/
ball.hidden = true;

// elemBelow (변수)
// - 드롭 가능 요소 (공 요소 아래)
let elemBelow = document.elementFromPoint(event.clientX, event.clientY);

ball.hidden = false;
```

##### `onMouseMove` <sub>(함수)</sub> 확장 코드
- '드롭 가능한' 요소 찾음
```javascript
// 즉시 날아가는 (강조 제거) 잠재적 드롭 가능 요소
let currentDroppable = null;

function onMouseMove(event) {
  moveAt(event.pageX, event.pageY);

  ball.hidden = true;
  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
  ball.hidden = false;

  /* 마우스 이벤트
   공 : 윈도우 밖으로 드래그 시
   - 트리거 X
   client[X∙Y]
   - 윈도우 밖 위치 시
     - elementFromPoint (메서드)
       - null 반환
   */
  if (!elemBelow) return;

  // 잠재적 드롭 가능 요소
  // - '.droppable' (클래스) 지정
  //   - 다른 로직 가능
  let droppableBelow = elemBelow.closest('.droppable');

  if (currentDroppable != droppableBelow) {

    /* 두 값 모두 null 가능
     currentDroppable == null
     - 이벤트 전 놓을 수 있는 요소 위 위치 X
       - ex) 빈 공간
     droppableBelow == null
     - 이벤트 중 놓을 수 있는 요소 위 위치 X
     */

    if (currentDroppable) {

      // '날아가는 것' 처리 로직
      // - 강조 제거
      leaveDroppable(currentDroppable);
    }

    currentDroppable = droppableBelow;

    if (currentDroppable) {

      // '들어오는 것' 처리 로직
      // - 강조
      enterDroppable(currentDroppable);
    }
  }
}
```

![potential-drop-target-2](../../images/02/03/03/potential-drop-target-2.png)

```html
<!-- index.html -->
<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <p>Drag the ball.</p>

  <img src="https://en.js.cx/clipart/soccer-gate.svg" id="gate" class="droppable">

  <img src="https://en.js.cx/clipart/ball.svg" id="ball">

  <script>
    let currentDroppable = null;

    ball.onmousedown = function(event) {

      let shiftX = event.clientX - ball.getBoundingClientRect().left;
      let shiftY = event.clientY - ball.getBoundingClientRect().top;

      ball.style.position = 'absolute';
      ball.style.zIndex = 1000;
      document.body.append(ball);

      moveAt(event.pageX, event.pageY);

      function moveAt(pageX, pageY) {
        ball.style.left = pageX - shiftX + 'px';
        ball.style.top = pageY - shiftY + 'px';
      }

      function onMouseMove(event) {
        moveAt(event.pageX, event.pageY);

        ball.hidden = true;
        let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
        ball.hidden = false;

        if (!elemBelow) return;

        let droppableBelow = elemBelow.closest('.droppable');
        if (currentDroppable != droppableBelow) {
          if (currentDroppable) {
            leaveDroppable(currentDroppable);
          }
          currentDroppable = droppableBelow;
          if (currentDroppable) {
            enterDroppable(currentDroppable);
          }
        }
      }

      document.addEventListener('mousemove', onMouseMove);

      ball.onmouseup = function() {
        document.removeEventListener('mousemove', onMouseMove);
        ball.onmouseup = null;
      };

    };

    function enterDroppable(elem) {
      elem.style.background = 'pink';
    }

    function leaveDroppable(elem) {
      elem.style.background = '';
    }

    ball.ondragstart = function() {
      return false;
    };
  </script>

</body>
</html>
```
```css
/* style.css */
#gate { cursor: pointer; margin-bottom: 100px; width: 83px; height: 46px; }
#ball { cursor: pointer; width: 40px; height: 40px; }
```

<br />

## 요약

#### 기본 알고리즘

##### 1. 이벤트 흐름
1. `ball.mousedown`
2. `document.mousemove`
3. `ball.mouseup`
- `ondragstart` <sub>(이벤트)</sub> 비활성화

##### 2. 드래그 시작 시
- 포인터 초기 이동 <sub>(요소 기준)</sub>
  - `shift[X∙Y]` <sub>(변수)</sub> 저장
  - 드래그 중 유지

##### 3. `document.elementFromPoint` <sub>(메서드)</sub>
- 포인터 아래 드롭 가능 요소 감지

##### 기본 알고리즘 확장
- 드롭 종료 시 동작 구현
  - `mouseup` <sub>(이벤트)</sub> 내
    - 데이터 변경
    - 요소 이동
    - 기타 등등
- 날아가는 요소 강조
- 특정 영역 · 방향 드래그 제한
- `mouse[down·up]` 이벤트 위임
  - 넓은 영역 이벤트 핸들러
  - `event.target` 확인
  - 드래그 앤 드롭 관리
    - 수백 개 요소 대상
- 기타 등등

##### 아키텍처 구축 프레임워크
- 챕터 내용 유사 작업 수행
  - `DragZone`
  - `Droppable`
  - `Draggable`
  - 기타 클래스 등

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### Slider
Create a slider:

![assignment-slider](../../images/02/03/03/assignment-slider.png)

Drag the blue thumb with the mouse and move it.

Important details:

When the mouse button is pressed, during the dragging the mouse may go over or below the slider. The slider will still work (convenient for the user).
If the mouse moves very fast to the left or to the right, the thumb should stop exactly at the edge.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

As we can see from HTML/CSS, the slider is a `<div>` with a colored background, that contains a runner – another `<div>` with `position:relative`.

To position the runner we use `position:relative`, to provide the coordinates relative to its parent, here it's more convenient here than `position:absolute`.

Then we implement horizontal-only Drag'n'Drop with limitation by width.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/lBpFSUdqUXAgYJEO?p=preview)

<hr />

### Drag superheroes around the field
This task can help you to check understanding of several aspects of Drag'n'Drop and DOM.

Make all elements with class `draggable` – draggable. Like a ball in the chapter.

Requirements:
- Use event delegation to track drag start: a single event handler on `document` for `mousedown`.
- If elements are dragged to top/bottom window edges – the page scrolls up/down to allow further dragging.
- There is no horizontal scroll (this makes the task a bit simpler, adding it is easy).
- Draggable elements or their parts should never leave the window, even after swift mouse moves.

The demo is too big to fit it here, so here's the link.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

To drag the element we can use `position:fixed`, it makes coordinates easier to manage. At the end we should switch it back to `position:absolute` to lay the element into the document.

When coordinates are at window top/bottom, we use `window.scrollTo` to scroll it.

More details in the code, in comments.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/6cvMkqQmcmxvYnyL?p=preview)
