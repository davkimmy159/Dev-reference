포인터 이벤트
============

##### 다양한 포인터 디바이스 입력 처리
- 마우스
- 팬 · 스타일러스
- 터치스크린
- 기타 등등

### 간략한 역사 훑기

#### 과거
- 오직 마우스 이벤트만 존재

#### 현대

##### 터치 디바이스
- 보편화
  - 스마트폰
  - 태블릿
  - 기타 등등
- 마우스 이벤트 생성
  - ex\) 스크린 터치 시
    - `mousedown` <sub>(이벤트)</sub> 생성
  - 기존 스크립트 호환 목적
- 더 다양한 동작 가능
  - 여러군데 동시 터치하기
  - 기타 등등

##### 터치 이벤트 도입
- `touch[start·end]`
- `touchmove`
- 기타 등등
  - 전용 프로퍼티 有

##### 여전히 부족
- 기타 다양한 포인터 디바이스 有
  - 팬
  - 스타일러스
  - 기타 등등
- 반복적인 코드량 증가
  - 이벤트 리스너 작성
    - 터치 이벤트
    - 마우스 이벤트
    - 기타 등등

##### 해결책
- 새 표준 포인터 이벤트 도입
  - 모든 포인터 디바이스 이벤트 담당

##### [Pointer Events Level 2](https://www.w3.org/TR/pointerevents2/) 스펙
- 대다수 주요 브라우저 지원

##### [Pointer Events Level 3](https://w3c.github.io/pointerevents/) 스펙
- 표준화 작업 중
- 높은 호환성 <sub>(Level 2)</sub>

##### 모던 브라우저 대상 개발 시
- 포인터 이벤트 사용
  - 마우스 · 터치 디바이스 입력 처리
- 마우스 · 터치 이벤트 사용 X

### 포인터 이벤트 타입

##### 포인터 이벤트 타입명
- 마우스 이벤트 타입명 유사

|포인터 이벤트|마우스 이벤트|
|---|---|
|`pointerdown`|`mousedown`|
|`pointerup`|`mouseup`|
|`pointermove`|`mousemove`|
|`pointerover`|`mouseover`|
|`pointerout`|`mouseout`|
|`pointerenter`|`mouseenter`|
|`pointerleave`|`mouseleave`|
|`pointercancel`|-|
|`gotpointercapture`|-|
|`lostpointercapture`|-|

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **마우스 이벤트 → 포인터 이벤트**

##### 마우스 이벤트 챕터 코드
- 마우스 이벤트 → 포인터 이벤트 대체
  - 실행 · 결과 확인
- 터치 디바이스 지원 향상
  - `touch-action: none` 필요 가능
    - CSS 코드

<br />

### 포인터 이벤트 프로퍼티

##### 마우스 이벤트 프로퍼티 동일
- `client[X·Y]`
- `target`
- 기타 등등

#### 추가 프로퍼티

##### `pointerId`
- 유일 식별자
  - 이벤트 발생 포인터
- 브라우저 생성
  - 다수 포인터 처리 가능
    - 터치스크린
    - 스타일러스
    - 멀티 터치
    - 기타 등등

##### `pointerType` <sub>(문자열)</sub>
- 포인터 디바이스 타입
  - `"mouse"`
  - `"pen"`
  - `"touch"`
  - 기타 등등
- 타입별 다른 동작 실행

##### `isPrimary` <sub>(`boolean`)</sub>
- `true`
  - 주요 포인터
- 멀티 터치 시
  - 첫 손가락 터치

#### 일부 포인터 디바이스
- 접촉 영역 · 압력 측정
  - ex\) 터치스크린 상 손가락 터치

##### `width` · `height`
- 포인터 터치 <sub>(디바이스)</sub> 영역 너비 · 높이
- 미지원 시 <sub>(마우스 등)</sub>
  - 항상 `1`

##### `pressure`
- 포인터 끝쪽 압력
  - `0` ~ `1`
- 미지원 시
  - `0.5` <sub>(터치)</sub>
  - `0` <sub>(터치 X)</sub>

##### `tangentialPressure`
- 정규화된 탄젠트 압력

##### `tilt[X·Y]` · `twist`
- 펜 전용
  - ㅇ
  - pen-specific properties that describe how the pen is positioned relative the surface.

These properties aren't supported by most devices, so they are rarely used. You can find the details about them in the [specification](https://w3c.github.io/pointerevents/#pointerevent-interface) if needed.

### Multi-touch
One of the things that mouse events totally don't support is multi-touch: a user can touch in several places at once on their phone or tablet, or perform special gestures.

Pointer Events allow handling multi-touch with the help of the `pointerId` and `isPrimary` properties.

Here's what happens when a user touches a touchscreen in one place, then puts another finger somewhere else on it:
1. At the first finger touch:
    - `pointerdown` with `isPrimary=true` and some `pointerId`.
2. For the second finger and more fingers (assuming the first one is still touching):
    - `pointerdown` with `isPrimary=false` and a different `pointerId` for every finger.

Please note: the `pointerId` is assigned not to the whole device, but for each touching finger. If we use 5 fingers to simultaneously touch the screen, we have 5 `pointerdown` events, each with their respective coordinates and a different `pointerId`.

The events associated with the first finger always have `isPrimary=true`.

We can track multiple touching fingers using their `pointerId`. When the user moves and then removes a finger, we get `pointermove` and `pointerup` events with the same `pointerId` as we had in `pointerdown`.

Here's the demo that logs `pointerdown` and `pointerup` events:

![multi-touch](../../images/02/03/04/multi-touch.png)

Please note: you must be using a touchscreen device, such as a phone or a tablet, to actually see the difference in `pointerId`/`isPrimary`. For single-touch devices, such as a mouse, there'll be always same `pointerId` with `isPrimary=true`, for all pointer events.

### Event: `pointercancel`
The `pointercancel` event fires when there's an ongoing pointer interaction, and then something happens that causes it to be aborted, so that no more pointer events are generated.

Such causes are:
- The pointer device hardware was physically disabled.
- The device orientation changed (tablet rotated).
- The browser decided to handle the interaction on its own, considering it a mouse gesture or zoom-and-pan action or something else.

We'll demonstrate `pointercancel` on a practical example to see how it affects us.

Let's say we're impelementing drag'n'drop for a ball, just as in the beginning of the article 드래그 앤 드롭과 마우스 이벤트.

Here is the flow of user actions and the corresponding events:
1. The user presses on an image, to start dragging
    - `pointerdown` event fires
2. Then they start moving the pointer (thus dragging the image)
    - `pointermove` fires, maybe several times
3. And then the surprise happens! The browser has native drag'n'drop support for images, that kicks in and takes over the drag'n'drop process, thus generating `pointercancel` event.
    - The browser now handles drag'n'drop of the image on its own. The user may even drag the ball image out of the browser, into their Mail program or a File Manager.
    - No more `pointermove` events for us.

So the issue is that the browser "hijacks" the interaction: `pointercancel` fires in the beginning of the "drag-and-drop" process, and no more `pointermove` events are generated.

Here's the drag'n'drop demo with loggin of pointer events (only `up`/`down`, `move` and `cancel`) in the `textarea`:

![event-pointercancel](../../images/02/03/04/event-pointercancel.png)

We'd like to implement the drag'n'drop on our own, so let's tell the browser not to take it over.

**Prevent the default browser action to avoid `pointercancel`.**

We need to do two things:
1. Prevent native drag'n'drop from happening:
    - We can do this by setting `ball.ondragstart = () => false`, just as described in the article 드래그 앤 드롭과 마우스 이벤트.
    - That works well for mouse events.
2. For touch devices, there are other touch-related browser actions (besides drag'n'drop). To avoid problems with them too:
    - Prevent them by setting `#ball { touch-action: none }` in CSS.
    - Then our code will start working on touch devices.

After we do that, the events will work as intended, the browser won't hijack the process and doesn't emit `pointercancel`.

This demo adds these lines:

![event-pointercancel](../../images/02/03/04/event-pointercancel.png)

As you can see, there's no `pointercancel` any more.

Now we can add the code to actually move the ball, and our drag'n'drop will work for mouse devices and touch devices.

### Pointer capturing
Pointer capturing is a special feature of pointer events.

The idea is very simple, but may seem quite odd at first, as nothing like that exists for any other event type.

The main method is:
- `elem.setPointerCapture(pointerId)` – binds events with the given `pointerId` to `elem`. After the call all pointer events with the same `pointerId` will have `elem` as the target (as if happened on `elem`), no matter where in document they really happened.

In other words, `elem.setPointerCapture(pointerId)` retargets all subsequent events with the given `pointerId` to `elem`.

The binding is removed:
- automatically when `pointerup` or `pointercancel` events occur,
- automatically when `elem` is removed from the document,
- when `elem.releasePointerCapture(pointerId)` is called.

**Pointer capturing can be used to simplify drag'n'drop kind of interactions.**

As an example, let's recall how one can implement a custom slider, described in the 드래그 앤 드롭과 마우스 이벤트.

We make a slider element with the strip and the "runner" (`thumb`) inside it.

Then it works like this:
1. The user presses on the slider `thumb` – `pointerdown` triggers.
2. Then they move the pointer – `pointermove` triggers, and we move the `thumb` along.
    - …As the pointer moves, it may leave the slider `thumb`: go above or below it. The `thumb` should move strictly horizontally, remaining aligned with the pointer.

So, to track all pointer movements, including when it goes above/below the `thumb`, we had to assign `pointermove` event handler on the whole `document`.

That solution looks a bit "dirty". One of the problems is that pointer movements around the document may cause side effects, trigger other event handlers, totally not related to the slider.

Pointer capturing provides a means to bind `pointermove` to `thumb` and avoid any such problems:
- We can call `thumb.setPointerCapture(event.pointerId)` in `pointerdown` handler,
- Then future pointer events until `pointerup`/`cancel` will be retargeted to `thumb`.
- When `pointerup` happens (dragging complete), the binding is removed automatically, we don't need to care about it.

So, even if the user moves the pointer around the whole document, events handlers will be called on `thumb`. Besides, coordinate properties of the event objects, such as `clientX`/`clientY` will still be correct – the capturing only affects `target`/`currentTarget`.

Here's the essential code:
```javascript
thumb.onpointerdown = function(event) {
  // retarget all pointer events (until pointerup) to thumb
  thumb.setPointerCapture(event.pointerId);
};

thumb.onpointermove = function(event) {
  // moving the slider: listen on the thumb, as all pointer events are retargeted to it
  let newLeft = event.clientX - slider.getBoundingClientRect().left;
  thumb.style.left = newLeft + 'px';
};

// note: no need to call thumb.releasePointerCapture,
// it happens on pointerup automatically
```

The full demo:

![pointer-capturing](../../images/02/03/04/pointer-capturing.png)

At the end, pointer capturing gives us two benefits:

1. The code becomes cleaner as we don't need to add/remove handlers on the whole `document` any more. The binding is released automatically.
2. If there are any `pointermove` handlers in the document, they won't be accidentally triggered by the pointer while the user is dragging the slider.

#### Pointer capturing events
There are two associated pointer events:
- `gotpointercapture` fires when an element uses `setPointerCapture` to enable capturing.
- `lostpointercapture` fires when the capture is released: either explicitly with `releasePointerCapture` call, or automatically on `pointerup`/`pointercancel`.

<br />

## 요약
Pointer events allow handling mouse, touch and pen events simultaneously, with a single piece of code.

Pointer events extend mouse events. We can replace `mouse` with `pointer` in event names and expect our code to continue working for mouse, with better support for other device types.

For drag'n'drops and complex touch interactions that the browser may decide to hijack and handle on its own – remember to cancel the default action on events and set `touch-events: none` in CSS for elements that we engage.

Additional abilities of pointer events are:
- Multi-touch support using `pointerId` and `isPrimary`.
- Device-specific properties, such as `pressure`, `width`/`height`, and others.
- Pointer capturing: we can retarget all pointer events to a specific element until `pointerup`/`pointercancel`.

As of now, pointer events are supported in all major browsers, so we can safely switch to them, especially if IE10- and Safari 12- are not needed. And even with those browsers, there are polyfills that enable the support of pointer events.
