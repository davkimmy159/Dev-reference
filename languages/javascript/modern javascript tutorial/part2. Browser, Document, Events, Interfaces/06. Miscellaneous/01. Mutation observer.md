Mutation observer
=================

##### `MutationObserver` <sub>(내장 객체)</sub>
- DOM 요소 감시
- 변화 감지 시
  - 콜백 호출

### 문법

##### `observer` 생성
- 콜백 <sub>(인수)</sub> 전달
```javascript
let observer = new MutationObserver(callback);
```
#### DOM 노드 설정
```javascript
observer.observe(node, config);
```

##### `config` <sub>(`boolean` 옵션 객체 · 감시 대상 설정)</sub>
- `childList`
  - 자식 노드
- `subtree`
  - 자손 노드
- `attributes`
  - 속성
- `attributeFilter`
  - 특정 속성 <sub>(속성명 배열)</sub>
- `characterData`
  - `data` <sub>(프로퍼티)</sub>
    - 텍스트 내용
- `attributeOldValue`
  - 이전 속성값 콜백 전달 여부
  - `attributes` <sub>(옵션)</sub> (설정) 필요
- `characterDataOldValue`
  - 이전 `data` <sub>(프로퍼티)</sub> 값 콜백 전달 여부
  - `characterData`<sub>(옵션)</sub> (설정) 필요

##### 요소 내 변화 발생 시 콜백 실행
- 1번째 인수
  - [`MutationRecord`](https://dom.spec.whatwg.org/#mutationrecord) <sub>(객체)</sub> 리스트
    - 변화 내용
- 2번째 인수
  - `MutationObserver` <sub>(자기 자신 객체)</sub>

#### [`MutationRecord`](https://dom.spec.whatwg.org/#mutationrecord) <sub>(객체)</sub>

##### `type` <sub>(변화 감지 타입)</sub>
- `'attributes'`
  - 속성 변화
- `'characterData'`
  - `data` <sub>(프로퍼티)</sub> 변화
  - 텍스트 노드
- `'childList'`
  - 자식 노드 추가 · 삭제

##### `target` <sub>(변화 발생 위치)</sub>
- 요소
  - `'attributes'`
  - `'childList'`
- 텍스트 노드
  - `'characterData'`

##### `[added·removed]Nodes`
- 추가 · 삭제된 노드

##### `[previous·next]Sibling`
- 추가 · 삭제된 노드 이전 · 다음 형제 노드

##### `attributeName[space]`
- 변화 속성 이름 · 네임스페이스 <sub>(XML)</sub>

##### `oldValue` <sub>(이전 값)</sub>
- 속성 <sub>(`attributeOldValue` 설정 시)</sub>
- 텍스트 <sub>(`characterDataOldValue` 설정 시)</sub>

##### `<div contentEditable>` <sub>(요소)</sub>
- 요소 포커스 설정 · 내용 수정 가능
```html
<div contentEditable id="elem">Click and <b>edit</b>, please</div>

<script>
let observer = new MutationObserver(mutationRecords => {
//console.log(the changes)
  console.log(mutationRecords);
});

// 전부 (속성 제외) 감시
observer.observe(elem, {
  childList: true, // 자식 노드
  subtree: true,   // 자손 노드

  // 이전 텍스트 값 콜백 전달
  characterDataOldValue: true
});
</script>
```

##### 요소 내 텍스트 입력
- 변화 1개 콘솔 출력
```javascript
mutationRecords = [{
  type: "characterData",
  oldValue: "edit",
  target: <text node>,
  /* … 나머지 빈 프로퍼티 … */
}];
```

##### 요소 내 복잡한 변경 적용
- 요소 내 텍스트 <sub>(`<b>edit</b>`)</sub> 제거 시
  - 다수 변화 콘솔 출력
```javascript
mutationRecords = [{
  type: "childList",
  target: <div#elem>,
  removedNodes: [<b>],
  nextSibling: <text node>,
  previousSibling: <text node>,
  /* … 나머지 빈 프로퍼티 … */
}, {
  type: "characterData"
  target: <text node>,
  /*
   변화 상세 정보
   - 브라우저별 처리 따라 상이
     - ex) 두 근접 노드 ("edit" · "please")
       - 합치기 · 유지
   */
}];
```

### 통합 시 사용

##### 서브파티 스크립트
- 필요 · 불필요 기능 구현
  - ex\) 광고 요소 표시
- 일반적인 서드파티 스크립트
  - 불필요 기능 제거 방법 X
```html
<div class="ads">Unwanted ads</div>
```

##### `MutationObserver`
- 불필요 요소 등장 시
  - 감지 · 제거

### 아키텍쳐 내 사용

#### 프로그래밍 웹사이트
- 글 · 기타 구성 요소
  - 소스코드 스니핏 포함

##### HTML 마크업 내 스니핏
```html
…
<pre class="language-javascript">
<code>
  // here's the code
  let hello = "world";
</code>
</pre>
…
```

##### [Prism.js](https://prismjs.com/) <sub>(문법 강조 라이브러리)</sub> 적용 <sub>(가독성 ↑)</sub>
- `Prism.highlightElem(pre)`
  - `pre` <sub>(요소)</sub> 검사
  - 특수 태그 · 스타일 추가
    - 문법 강조 <sub>(색 사용)</sub>

##### 문법 강조 메서드 실행 시점
- `DOMContentLoaded` <sub>(이벤트)</sub>
- 페이지 끝 부분 <sub>(최하단)</sub>
- DOM 준비 완료 시
  1. `pre[class*="language"]` <sub>(요소)</sub> 검색
  2. `Prism.highlightElem` <sub>(메서드)</sub> 호출
```javascript
// 페이지 내 코드 스니핏 (요소) 강조
document
  .querySelectorAll('pre[class*="language"]')
  .forEach(Prism.highlightElem);
```

Everything's simple so far, right? We find code snippets in HTML and highlight them.

Now let's go on. Let's say we're going to dynamically fetch materials from a server. We'll study methods for that later in the tutorial. For now it only matters that we fetch an HTML article from a webserver and display it on demand:
```javascript
let article = /* fetch new content from server */
articleElem.innerHTML = article;
```

The new `article` HTML may contain code snippets. We need to call `Prism.highlightElem` on them, otherwise they won't get highlighted.

**Where and when to call `Prism.highlightElem` for a dynamically loaded article?**

We could append that call to the code that loads an article, like this:
```javascript
let article = /* fetch new content from server */
articleElem.innerHTML = article;

let snippets = articleElem.querySelectorAll('pre[class*="language-"]');
snippets.forEach(Prism.highlightElem);
```

…But, imagine if we have many places in the code where we load our content – articles, quizzes, forum posts, etc. Do we need to put the highlighting call everywhere, to highlight the code in content after loading? That's not very convenient.

And what if the content is loaded by a third-party module? For example, we have a forum written by someone else, that loads content dynamically, and we'd like to add syntax highlighting to it. No one likes patching third-party scripts.

Luckily, there's another option.

We can use `MutationObserver` to automatically detect when code snippets are inserted into the page and highlight them.

So we'll handle the highlightin

#### 동적 강조 데모
Here's the working example.

If you run this code, it starts observing the element below and highlighting any code snippets that appear there:
```javascript
let observer = new MutationObserver(mutations => {

  for(let mutation of mutations) {
    // examine new nodes, is there anything to highlight?

    for(let node of mutation.addedNodes) {
      // we track only elements, skip other nodes (e.g. text nodes)
      if (!(node instanceof HTMLElement)) continue;

      // check the inserted element for being a code snippet
      if (node.matches('pre[class*="language-"]')) {
        Prism.highlightElement(node);
      }

      // or maybe there's a code snippet somewhere in its subtree?
      for(let elem of node.querySelectorAll('pre[class*="language-"]')) {
        Prism.highlightElement(elem);
      }
    }
  }

});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, {childList: true, subtree: true});
```

Here, below, there's an HTML-element and JavaScript that dynamically fills it using `innerHTML`.

Please run the previous code (above, observes that element), and then the code below. You'll see how `MutationObserver` detects and highlights the snippet.

A demo-element with `id="highlight-demo"`, run the code above to observe it.

The following code populates its `innerHTML`, that causes the `MutationObserver` to react and highlight its contents:
```javascript
let demoElem = document.getElementById('highlight-demo');

// dynamically insert content with code snippets
demoElem.innerHTML = `A code snippet is below:
  <pre class="language-javascript"><code> let hello = "world!"; </code></pre>
  <div>Another one:</div>
  <div>
    <pre class="language-css"><code>.class { margin: 5px; } </code></pre>
  </div>
`;
```

Now we have `MutationObserver` that can track all highlighting in observed elements or the whole `document`. We can add/remove code snippets in HTML without thinking about it.

### Additional methods
There's a method to stop observing the node:
- `observer.disconnect()` – stops the observation.

When we stop the observing, it might be possible that some changes were not yet processed by the observer. In such cases, we use
- `observer.takeRecords()` – gets a list of unprocessed mutation records – those that happened, but the callback has not handled them.

These methods can be used together, like this:
```javascript
// get a list of unprocessed mutations
// should be called before disconnecting,
// if you care about possibly unhandled recent mutations
let mutationRecords = observer.takeRecords();

// stop tracking changes
observer.disconnect();
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **Records returned by `observer.takeRecords()` are removed from the processing queue**

The callback won't be called for records, returned by `observer.takeRecords()`.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **Garbage collection interaction**

Observers use weak references to nodes internally. That is, if a node is removed from the DOM, and becomes unreachable, then it can be garbage collected.

The mere fact that a DOM node is observed doesn't prevent the garbage collection.

<br />

## 요약
`MutationObserver` can react to changes in DOM – attributes, text content and adding/removing elements.

We can use it to track changes introduced by other parts of our code, as well as to integrate with third-party scripts.

`MutationObserver` can track any changes. The config "what to observe" options are used for optimizations, not to spend resources on unneeded callback invocations.
