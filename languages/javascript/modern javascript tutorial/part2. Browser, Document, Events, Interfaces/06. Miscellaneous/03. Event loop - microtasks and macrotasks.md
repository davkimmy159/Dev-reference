이벤트 루프 · \[매크로·마이크로\]태스크
================================

##### JS 실행 흐름 <sub>(브라우저 · Node.js)</sub>
- 이벤트 루프 기반

### 이벤트 루프

##### JS 내 루프
1. 태스크 진입 대기 <sub>(idle 상태)</sub>
2. 태스크 진입 시 처리
3. 처리 태스크 부재 → ① 번

##### JS 엔진 알고리즘 일반화
1. 처리 태스크 존재 시
    - 선진입 태스크부터 순차적 처리
2. 처리 태스크 부재 시
    - idle 상태
    - 새 태스크 추가 → ① 번
- 대다수 시간
  - idle 상태
- 스크립트 · 핸들러 · 이벤트 동작 · 발생 시
  - 활성화

##### JS 엔진 활성화 태스크
- 외부 스크립트 <sub>(`<script src="…">`)</sub> 로드 시
  - 해당 스크립트 실행
- 사용자 마우스 이동 시
  - `mousemove`
    - 이벤트 발생
    - 핸들러 실행
- `setTimeout` <sub>(함수)</sub> 설정 시간 도달 시
  - 콜백 함수 실행
- 기타 등등

##### 태스크
- 하나의 집합 구성

##### JS 엔진
- 태스크 집합 차례대로 처리
- 새 태스크 추가 대기
  - CPU 자원 소비 X
  - idle 상태

##### 매크로태스크 큐 <sub>(V8 언어)</sub>
- 엔진 바쁠 때 새 태스크 추가 시
  - 큐 내 해당 태스크 추가

![eventLoop](../../images/02/06/03/eventLoop.svg)

##### 엔진 : `script` 바쁘게 처리 중
1. 사용자 마우스 이동 <sub>(`mousemove` 이벤트 활성화)</sub>
2. `setTimeout` <sub>(함수)</sub> 설정 시간 도달
- 태스크 3개
  - 큐 내 순차적 추가

##### 큐 내 태스크 순차적 처리 <sub>(추가 순서)</sub>
1. `script`
2. `mousemove` <sub>(이벤트)</sub> · 핸들러
3. `setTimeout` 핸들러

#### 엔진 : 태스크 처리 중 렌더링 X

##### 1. 태스크 처리 소모 시간 小
- 처리 완료 시 DOM 변경 화면 반영

##### 2. 태스크 처리 소모 시간 大
- 새 태스크 처리 X
  - 태스크 처리 중 발생 이벤트 등
- ex\) '응답 없는 페이지' 얼럿 창
  - 아주 복잡한 계산 필요
  - 무한 루프 <sub>(프로그래밍 에러)</sub>
    - 페이지 전체 · 태스크 취소 유도

### 유스 케이스 1 <sub>(CPU 소모 大 태스크 쪼개기)</sub>

#### 코드 강조 기능

##### 필요 작업
- 강조 필요 부분 사전 분석
- 색 변경 요소 생성 · 추가
- 기타 등등

##### 강조 태스크 수행 → 엔진 바빠짐
- 타 태스크 중단 <sub>(지연 · 멈춤 현상)</sub>
  - 사용자 이벤트 처리
  - DOM 관련 작업
  - 기타 등등

##### 태스크 → 다수 조각 쪼개기
- 앞부분 100줄 먼저 강조
- 그 다음 100줄
  - 지연시간 0 `setTimeout` 스케줄링

#### 1 ~ 1000000000 숫자 카운트

##### 리팩토링 전 코드
- 실행 시 엔진 중단 <sub>(몇 초간)</sub>
- 지연 발생 직접 확인
  - 실행 후 페이지 내 아무 버튼 클릭
    - ex\) 마우스 우측 버튼
- 숫자 카운팅 종료 후 ~ 얼럿창 출력 전
  - 모든 사용자 이벤트 처리 X
- 저사양 머신
  - 'the script takes too long' <sub>(경고)</sub>
```javascript
let i = 0;

let start = Date.now();

function count() {

  // 무거운 작업 (CPU 소모 大)
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
}

count();
```

##### 태스크 쪼개기
- 중첩 `setTimeout` <sub>(함수)</sub> 호출
- 숫자 카운트 중 제 기능 수행
```javascript
let i = 0;

let start = Date.now();

function count() {

  // 태스크 일부 처리
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
  } else {

    // 태스크 미완료 시
    // - 태스크 (새 호출) 재스케줄링
    setTimeout(count);
  }

}

count();
```
1. 1번째 카운팅
    - `i = 1       … 1000000`
2. 2번째 카운팅
    - `i = 1000001 … 2000000`
3. …
4. n번째 카운팅 <sub>(종료)</sub>
    - `i = 990000001 … 1000000000`

##### 1번째 카운팅 중 새 태스크
- 큐 내 추가
- 처리 시점
  - 1번째 카운팅 완료 후
  - 2번쨰 카운티 시작 전

##### 부분 카운팅 실행 도중 '환기' <sub>(이벤트 루프 실행)</sub>
- 무거운 태스크 처리
- 사용자 이벤트 반응

##### 개선된 태스크 쪼개기 <sub>(시간차 ↓)</sub>
- 스케줄링 코드 위치 이동
  - `count()` <sub>(함수)</sub> 앞
- `count()` <sub>(함수)</sub> 호출 후 카운트 미완료 시
  - 부분 카운팅 시작 전 재스케줄링

```javascript
let i = 0;

let start = Date.now();

function count() {

  if (i < 1e9 - 1e6) {
    setTimeout(count);
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
  }

}

count();
```

##### 시간차 단축 이유
- 다수 중첩 `setTimeout` 호출 시
  - 브라우저 최소 대기 시간 제약 <sub>(4밀리초)</sub>
    - 코드상 대기 시간
      - 0
    - 실제 대기시간
      - `4ms` 이상
- 카운팅 전 스케줄링
  - 카운팅 중 대기시간 소모

### 유스 케이스 2 <sub>(프로그레스 바)</sub>

##### 브라우저 렌더링 동작 방식
- 현재 작업 중인 태스크 종료 후
  - DOM 변경분 렌더링 <sub>(작업 시간 무관)</sub>
- '중간' 상태 <sub>(미완성)</sub> 화면
  - 사용자 노출 방지

##### 반복문 카운트 변수 <sub>(`i`)</sub> 화면 렌더링
- 함수 실행 도중 변화 X
  - 마지막 상태 <sub>(`1000000`)</sub> 만 출력
```html
<div id="progress"></div>

<script>

  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>
```

##### 인디케이터 <sub>(작업 진척 상태 표시)</sub>
- 태스크 쪼개기 <sub>(`setTimeout` 함수)</sub>
  - 하위 태스크 사이 상태 변화 표시
```html
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 무거운 작업 쪼개기
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }

  }

  count();
</script>
```

### 유스 케이스 3 <sub>(이벤트 처리 종료 후 작업)</sub>

##### 특정 액션 지연
- 이벤트 버블링 종료 후
  - 모든 DOM 트리 레벨 내 이벤트 처리 전
```javascript
menu.onclick = function() {
  // …

  // 커스텀 이벤트 생성
  // - 클릭한 메뉴 내 항목 정보 보유
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // 비동기 디스패칭 (커스텀 이벤트)
  setTimeout(() => menu.dispatchEvent(customEvent));
};
```

### 매크로태스크 · 마이크로태스크

##### 마이크로태스크
- 프라미스 핸들러 <sub>(주 사용)</sub>
  - `.then`
  - `catch`
  - `finally`
- `await` <sub>(프라미스 처리 문법)</sub>
- `queueMicrotask(func)` <sub>(표준 API)</sub>
  - `func` <sub>(함수)</sub> → 마이크로태스크 큐

##### 매크로 · 마이크로태스크 처리 순서 관계 <sub>(JS 엔진)</sub>
1. 매크로태스크 1개 처리 시
3. 마이크로태스크 큐 내 태스크 전부 처리
2. 타 매크로태스크 · 렌더링 작업 1개 처리
4. 마이크로태스크 큐 내 태스크 전부 처리
5. 반복
```javascript
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

얼럿 창엔 아래 순서대로 문자열이 출력됩니다.
1. `code` – 일반적인 동기 호출이므로 가장 먼저 매크로태스크 큐에 들어간 후 실행됩니다.
2. `promise` – `.then`은 마이크로태스크 큐에 들어가 처리되기 때문에, 현재 코드(`alert("code")`)가 실행되고 난 후에 실행됩니다.
3. `timeout` – `setTimeout`에서 설정한 시간이 끝난 후 콜백 함수를 실행하는 것은 매크로태스크이기 때문에 가장 마지막에 출력됩니다.

매크로태스크와 마이크로태스크 처리 로직을 첨가하면 위에서 살펴본 그림을 좀 더 고도화 할 수 있습니다. 그림을 위에서부터 아래로 봅시다. 매크로태스크(`script`, `mousemove`, `setTimeout` 등) 하나가 처리되고 난 후 마이크로태스크 전부(microtasks)가 처리되고 그 이후 렌더링이 진행되는 것을 확인할 수 있습니다.

![eventLoop-full](../../images/02/06/03/eventLoop-full.svg)

이처럼 마이크로태스크는 다른 이벤트 핸들러나 렌더링 작업, 혹은 다른 매크로태스크가 실행되기 전에 처리됩니다.

이런 처리순서가 아주 중요한 이유는 (마우스 좌표 변경이나 네트워크 통신에 의한 데이터 변경 같이 애플리케이션 환경에 변화를 주는 작업에 영향을 받지 않고) 모든 마이크로태스크를 동일한 환경에서 처리할 수 있기 때문입니다.

그런데 개발을 하다 보면 직접 만든 함수를 현재 코드 실행이 끝난 후, 새로운 이벤트 핸들러가 처리되기 전이면서 렌더링이 실행되기 전에 비동기적으로 실행해야 하는 경우가 생기곤 합니다. 이럴 때 `queueMicrotask`를 사용해 커스텀 함수를 스케줄링하면 됩니다.

앞서 살펴본 '프로그레스 바' 예시에서 `setTimeout` 대신 `queueMicrotask`를 사용해 함수 `count`를 재스케줄링해 보았습니다. 예시를 실행하면 동기 코드처럼 카운팅이 다 끝났을 때 숫자가 렌더링 되는 것을 확인할 수 있습니다.
```html
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 무거운 작업을 쪼갠 후 이를 수행
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
</script>
```

<br />

## 요약
이벤트 루프 알고리즘을 요약하면 다음과 같습니다(자세한 사항은 [명세서](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)에서 확인할 수 있습니다).
1. _매크로태스크 큐_ 에서 가장 오래된 태스크를 꺼내 실행합니다(예: 스크립트를 실행).
2. 모든 _마이크로태스크_ 를 실행합니다.
    - 이 작업은 마이크로태스크 큐가 빌 때까지 이어지고
      - 태스크는 오래된 순서대로 처리됩니다.
3. 렌더링할 것이 있으면 처리합니다.
4. 매크로태스크 큐가 비어있으면 새로운 매크로태스크가 나타날 때까지 기다립니다.
5. 1번으로 돌아갑니다.

새로운 _매크로태스크_ 를 스케줄링하는 방법은 다음과 같습니다.
- 지연시간이 `0`인 `setTimeout(f)` 사용하기

이 방법을 사용하면 계산이 복잡한 큰 태스크 하나를 여러 개로 쪼갤 수 있습니다. 태스크를 여러 개로 쪼개면 태스크 중간중간 사용자 이벤트에 반응할 수 있고, 작업 진척 상태를 화면에 표시해줄 수도 있습니다.

지연시간이 `0`인 `setTimeout`은 이벤트가 완전히 처리되고 난 후(버블링이 끝난 후)에 특정 작업을 수행하도록 스케줄링할 때도 사용됩니다.

새로운 _마이크로태스크_ 를 스케줄링하는 방법은 다음과 같습니다.
- `queueMicrotask(f)` 사용하기
- 이 외에도 프라미스 핸들러는 마이크로태스크 큐에 들어가 처리됩니다.

마이크로태스크 전체가 처리되는 동안에는 UI 변화나 네트워크 이벤트 핸들링이 일어나지 않습니다. 렌더링이나 네트워크 요청 등의 작업들은 마이크로태스크 전부가 처리되고 난 직후 처리됩니다.

이런 처리 순서 덕분에 `queueMicrotask`를 사용해 함수를 비동기적으로 처리할 때 애플리케이션 상태의 일관성이 보장됩니다.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **웹 워커**

이벤트 루프를 막을 우려가 있는 무거운 연산은 [웹 워커(Web Worker)](https://html.spec.whatwg.org/multipage/workers.html)를 사용해 처리할 수 있습니다.

웹 워커를 사용하면 별도의 백그라운드 스레드에서 코드를 병렬적으로 실행할 수 있습니다.

메인 스레드와 메시지를 교환할 수 있긴 하지만 웹 워커엔 메인 스레드와 연관 없는 고유한 변수들과 자체 이벤트 루프가 있습니다.

웹 워커는 DOM에 접근할 수 없기 때문에 여러 CPU 코어를 동시에 사용해야 하는 연산에 주로 사용합니다.

<br />

[참조글](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif)

![macrotask](../../images/02/06/03/macrotask.gif)
