속성과 프로퍼티
==============

##### 브라우저
- HTML 읽고 <sub>(파싱)</sub> DOM 객체 생성

##### 요소 노드
- 대다수 표준 HTML 속성
  - == DOM 객체 프로퍼티
- ex&#41; `<body id="page">` <sub>(태그)</sub>
  - `body.id="page"`
- \[속성:프로퍼티\] 일대일 매핑 예외 존재

### DOM 프로퍼티

##### 커스텀 프로퍼티
- `document.body`
  - 새 프로퍼티 생성
```javascript
// 커스텀 프로퍼티
document.body.myData = {
  name: 'Caesar',
  title: 'Imperator'
};

alert(document.body.myData.title); // Imperator

document.body.sayTagName = function() {
  alert(this.tagName);
};

// 커스텀 메서드
// - this 값
//   - document.body
document.body.sayTagName(); // BODY
```

##### 내장 프로토타입 수정
- 모든 요소 노드
  - 메서드 사용
```javascript
Element.prototype.sayHi = function() {
  alert(`Hello, I'm ${this.tagName}`);
};

document.documentElement.sayHi(); // Hello, I'm HTML
document.body.sayHi();            // Hello, I'm BODY
```

##### DOM 프로퍼티 · 메서드
- 일반 JS 객체처럼 행동
  - 모든 값 할당 가능
  - 대 · 소문자 구분

### HTML 속성

##### DOM 객체 생성 시
- HTML 표준 속성 인식
  - DOM 프로퍼티 생성
- HTML 비표준 속성 인식 X
  - DOM 프로퍼티 생성 X
```html
<body id="test" something="non-standard">
  <script>
    alert(document.body.id); // test
    
    // 비표준 속성
    // - 프로퍼티 전환 X
    alert(document.body.something); // undefined
  </script>
</body>
```

##### 요소별 특정 표준 속성 <sub>(명세서 참조)</sub>
- ex&#41; `type`
  - `<input>` <sub>(`HTMLInputElement`)</sub> 표준
  - `<body>` <sub>(`HTMLBodyElement`)</sub> 표준 X
```html
<body id="body" type="text">
  <input id="input" type="text">
  <script>
    alert(input.type); // text
    alert(body.type);  // undefined
  </script>
</body>
```

##### 비표준 속성 접근 메서드 <sub>(HTML 명시 속성 대상 동작)</sub>
- `hasAttribute(name)`
  - 속성 존재 여부 확인
- `getAttribute(name)`
  - 속성값 가져오기
- `setAttribute(name, value)`
  - 속성값 변경
- `removeAttribute(name)`
  - 속성값 제거

##### `attributes` <sub>(프로퍼티)</sub>
- 모든 속성값 가져오기
- `Attr` <sub>(내장 클래스)</sub> 구현 객체 컬렉션
  - `name` <sub>(프로퍼티)</sub>
  - `value` <sub>(프로퍼티)</sub>
```html
<body something="non-standard">
  <script>
    // 비표준 속성 접근
    alert(document.body.getAttribute('something'));
  </script>
</body>
```

##### HTML 속성 특징
- 대 · 소문자 구분 X
  - ex&#41; `id` == `ID`
- 값
  - 항상 문자열
```html
<body>
  <div id="elem" about="Elephant"></div>

  <script>
    // (1)
    // 속성 읽기
    // - about="Elephant"
    alert( elem.getAttribute('About') );

    // (2)
    // 속성 추가
    // - Test="123"
    elem.setAttribute('Test', 123);

    // (3)
    // 추가된 속성 확인
    alert( elem.outerHTML );

    // (4)
    // 속성 전체 나열
    for (let attr of elem.attributes) {
      alert( `${attr.name} = ${attr.value}` );
    }
  </script>
</body>
```

1. `getAttribute('About')`
    - HTML 안
      - 전부 소문자 <sub>('about')</sub>
    - 속성
      - 대 · 소문자 구분 X
2. 모든 값 : 속성 대입 가능
    - 최종적으로 문자열 변환
      - 123 <sub>(숫자)</sub> → "123" <sub>(문자열)</sub>
3. `outerHTML` <sub>(프로퍼티)</sub>
    - 모든 속성 확인 가능
4. `attributes` <sub>(프로퍼티)</sub> 반환 컬렉션
    - 열거 가능 <sub>(이터러블 객체)</sub>
      - `name` <sub>(프로퍼티)</sub>
      - `value` <sub>(프로퍼티)</sub>

### 프로퍼티 · 속성 동기화
- 표준 속성 수정 시
  - 대응 프로퍼티 자동 갱신
- 대응 프로퍼티 수정 시
  - 속성 자동 갱신 <sub>(예외 有)</sub>
- 표준 속성 ⇆ 대응 프로퍼티
```html
<input>

<script>
  let input = document.querySelector('input');

  // 속성 추가 → 프로퍼티 갱신
  input.setAttribute('id', 'id');
  alert(input.id); // id

  // 프로퍼티 변경 → 속성 갱신
  input.id = 'newId';
  alert(input.getAttribute('id')); // newId
</script>
```

##### 예외
- 단방향 <sub>(속성 → 프로퍼티)</sub>
  - ex&#41; `input.value`
- 유용한 상황
  - `value` 값 수정 후
    - '원래' 값 복구 <sub>(속성 저장 값)</sub>
```html
<input>

<script>
  let input = document.querySelector('input');

  // 속성 추가 → 프로퍼티 갱신
  input.setAttribute('value', 'text');
  alert(input.value); // text

  // 프로퍼티 변경 → 속성 갱신 X
  input.value = 'newValue';
  alert(input.getAttribute('value')); // text
</script>
```

### DOM 프로퍼티 값의 타입
DOM 프로퍼티는 항상 문자열이 아닙니다. 체크 박스에 사용되는 input.checked 프로퍼티의 경우 불린 값을 가집니다.
```html
<input id="input" type="checkbox" checked> checkbox

<script>
  alert(input.getAttribute('checked')); // 속성 값: 빈 문자열
  alert(input.checked); // 프로퍼티 값: true
</script>
```

몇 가지 다른 예를 살펴봅시다. style 속성의 경우 문자열이지만, style 프로퍼티는 객체입니다.
```html
<div id="div" style="color:red;font-size:120%">Hello</div>

<script>
  // string
  alert(div.getAttribute('style')); // color:red;font-size:120%

  // object
  alert(div.style); // [object CSSStyleDeclaration]
  alert(div.style.color); // red
</script>
```

대부분의 프로퍼티의 값은 문자열입니다.

아주 드물긴 하지만, DOM 프로퍼티 값이 문자열이더라도 속성값과 다른 경우도 있습니다. href 속성이 상대 URL이나 #hash이더라도 href DOM 프로퍼티엔 항상 URL 전체 가 저장되는 경우가 대표적인 예입니다.

예시:
```html
<a id="a" href="#hello">link</a>
<script>
  // 속성
  alert(a.getAttribute('href')); // #hello

  // 프로퍼티
  alert(a.href ); // 실행되는 사이트 주소에 따라 http://site.com/page#hello 형태로 값이 저장됨
</script>
```

HTML에 내에 명시된 href 속성의 값을 정확하게 얻고 싶다면 getAttribute을 사용하면 됩니다.

### 비표준 속성, dataset
HTML을 작성할 때 우리는 대부분 표준 속성을 사용합니다. 하지만 표준이 아닌 속성도 존재합니다. 이런 비표준이 유용한 지 아닌지, 그리고 어떤 경우에 비표준 속성을 사용해야 하는지 알아봅시다.

비표준 속성은 사용자가 직접 지정한 데이터를 HTML에서 자바스크립트로 넘기고 싶은 경우나 자바스크립트를 사용해 조작할 HTML 요소를 표시하기 위해 사용할 수 있습니다.

예시:
```html
<!-- 이름(name) 정보를 보여주는 div라고 표시 -->
<div show-info="name"></div>
<!-- 나이(age) 정보를 보여주는 div라고 표시 -->
<div show-info="age"></div>

<script>
  // 표시한 요소를 찾고, 그 자리에 원하는 정보를 보여주는 코드
  let user = {
    name: "Pete",
    age: 25
  };

  for(let div of document.querySelectorAll('[show-info]')) {
    // 원하는 정보를 필드 값에 입력해 줌
    let field = div.getAttribute('show-info');
    div.innerHTML = user[field]; // Pete가 'name'에, 25가 'age'에 삽입됨
  }
</script>
```

비표준 속성은 요소에 스타일을 적용할 때 사용되기도 합니다.

아래 예시에선 주문 상태(order state)를 나타내는 커스텀 속성 order-state를 사용해 주문 상태에 따라 스타일을 변경합니다.
```html
<style>
  /* 스타일이 커스텀 속성 'order-state'에 따라 변합니다. */
  .order[order-state="new"] {
    color: green;
  }

  .order[order-state="pending"] {
    color: blue;
  }

  .order[order-state="canceled"] {
    color: red;
  }
</style>

<div class="order" order-state="new">
  A new order.
</div>

<div class="order" order-state="pending">
  A pending order.
</div>

<div class="order" order-state="canceled">
  A canceled order.
</div>
```

이렇게 커스텀 속성을 사용하는 게 .order-state-new, .order-state-pending, order-state-canceled같은 클래스를 사용하는 것보다 왜 선호될까요?

이유는 속성은 클래스보다 다루기 편리하다는 점 때문입니다. 속성의 상태는 아래와 같이 쉽게 변경할 수 있습니다.
```javascript
// 새 클래스를 추가하거나 지우는 것보다 더 쉽게 상태(state)를 바꿀 수 있습니다
div.setAttribute('order-state', 'canceled');
```

물론 커스텀 속성에도 문제가 발생할 수 있습니다. 비표준 속성을 사용해 코드를 작성했는데 나중에 그 속성이 표준으로 등록되게 되면 문제가 발생합니다. HTML은 살아있는 언어이기 때문에 개발자들의 요구를 반영하기 위해 지속해서 발전합니다. 따라서 이런 경우 예기치 못한 부작용이 발생할 수 있습니다.

이런 충돌 상황을 방지하기 위한 속성인 data-* 가 있습니다.

’data-'로 시작하는 속성 전체는 개발자가 용도에 맞게 사용하도록 별도로 예약됩니다. dataset 프로퍼티를 사용하면 이 속성에 접근할 수 있습니다.

요소 elem에 이름이 "data-about"인 속성이 있다면 elem.dataset.about을 사용해 그 값을 얻을 수 있죠.

예시:
```html
<body data-about="Elephants">
<script>
  alert(document.body.dataset.about); // Elephants
</script>
```

data-order-state 같이 여러 단어로 구성된 속성은 카멜 표기법(camel-cased)을 사용해 dataset.orderState으로 변환됩니다.

이런 특징을 사용해 주문 상태에 관한 예시를 다시 작성하면 다음과 같습니다.
```html
<style>
  .order[data-order-state="new"] {
    color: green;
  }

  .order[data-order-state="pending"] {
    color: blue;
  }

  .order[data-order-state="canceled"] {
    color: red;
  }
</style>

<div id="order" class="order" data-order-state="new">
  A new order.
</div>

<script>
  // 읽기
  alert(order.dataset.orderState); // new

  // 수정하기
  order.dataset.orderState = "pending"; // (*)
</script>
```

data-* 속성은 커스텀 데이터를 안전하고 유효하게 전달해줍니다.

data-* 속성을 사용하면 읽기 뿐만 아니라 수정도 가능하다는 점에 유의해주세요. 속성이 수정되면 CSS가 해당 뷰를 자동으로 업데이트해 줍니다. 위 예시에서 (*)로 표시한 줄에서 색이 파란색으로 바뀝니다.

<br />

## 요약
- 속성 – HTML 안에 쓰임
- 프로퍼티 – DOM 객체 안에 쓰임

비교표:


|프로퍼티|속성|
|---|---|
|타입|모든 타입 가능, 각 표준 프로퍼티의 타입은 명세서에 설명되어 있음|문자열|
|이름|대·소문자 구분|대·소문자 구분하지 않음|

속성과 함께 쓰이는 메서드:
- elem.hasAttribute(name) – 속성 존재 여부 확인
- elem.getAttribute(name) – 속성값을 가져옴
- elem.setAttribute(name, value) – 속성값을 변경함
- elem.removeAttribute(name) – 속성값을 지움
- elem.attributes – 속성의 컬렉션을 반환함

거의 모든 상황에서 속성보다는 프로퍼티를 사용하는 게 더 낫습니다. 다만 아래 사례같이 정확한 HTML 속성 값이 필요한 경우에는 프로퍼티가 적절치 않으므로 속성을 사용해야 합니다.

- 비표준 속성이 필요한 경우. 다만 속성이 data-로 시작하는 경우엔 dataset을 사용해야 합니다.
- HTML에 적힌 값 '그대로’를 읽고 싶은 경우. href 프로퍼티에 항상 전체 URL이 저장되는 것 같이 DOM 프로퍼티의 값과 속성 값이 다른데, '원본’값을 얻고 싶은 경우엔 속성을 사용해야 합니다.

<br />

### <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

<hr />

### 속성 가져오기

문서에서 data-widget-name이라는 속성을 가진 요소를 찾고, 해당 요소의 값을 읽는 코드를 작성해 보세요.
```html
<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    /* your code */
  </script>
</body>
</html>
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

```html
<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    // getting it
    let elem = document.querySelector('[data-widget-name]');

    // reading the value
    alert(elem.dataset.widgetName);
    // or
    alert(elem.getAttribute('data-widget-name'));
  </script>
</body>
</html>
```

<hr />

### 외부 링크를 주황색으로 만들기
style 프로퍼티를 변경해 모든 외부 링크를 주황색으로 만들어 보세요.

외부 링크가 되기 위한 조건은 아래와 같습니다.

- href에 ://가 포함되어 있어야 합니다.
- 하지만 http://internal.com으로 시작하지 않아야 합니다.

예시:
```html
<a name="list">the list</a>
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

<script>
  // setting style for a single link
  let link = document.querySelector('a');
  link.style.color = 'orange';
</script>
```

결과:

![outside-link-orange-color](../../images/02/01/06/outside-link-orange-color.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

먼저 외부 참조를 모두 찾아야 합니다.

두 가지 방법을 사용해 외부 참조를 찾을 수 있습니다.

첫 번째 방법은 document.querySelectorAll('a')를 사용해 모든 링크를 찾은 후 필요한 것만 걸러내는 것입니다.
```javascript
let links = document.querySelectorAll('a');

for (let link of links) {
  let href = link.getAttribute('href');
  if (!href) continue; // 속성이 존재하지 않음

  if (!href.includes('://')) continue; // 프로토콜이 존재하지 않음

  if (href.startsWith('http://internal.com')) continue; // 내부 링크

  link.style.color = 'orange';
}
```

참고: HTML의 값이 필요하기 때문에 link.href가 아니라 link.getAttribute('href')를 사용합니다.

더 간단한 방법은 CSS 선택자에 조건을 명시해 주는 것입니다.
```javascript
// href에 :// 가 포함된 모든 링크를 찾습니다.
// 그 중 http://internal.com으로 시작하지 않는 링크를 찾습니다.
let selector = 'a[href*="://"]:not([href^="http://internal.com"])';
let links = document.querySelectorAll(selector);

links.forEach(link => link.style.color = 'orange');
```
