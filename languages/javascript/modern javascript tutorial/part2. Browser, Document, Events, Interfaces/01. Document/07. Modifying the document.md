문서 수정하기
============

##### DOM 조작
- '생동감 있는' 웹페이지 핵심

### 예제 : 메시지 보여주기
- `alert` 창보다 보기 좋은 메시지 창
  - HTML 사용해 생성
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert">
  <strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.
</div>
```

![example-message-check](../../images/02/01/07/example-message-check.png)

- JS 사용해 메시지 창 생성 학습
- 스타일
  - HTML · 외부 CSS 파일 저장 가정

### 요소 생성하기

#### DOM 노드 생성 메서드 <sub>(2가지)</sub>

##### `document.createElement(tag)`
- 새 요소 노드 생성
- `tag`
  - 태그명
```javascript
let div = document.createElement('div');
```

##### `document.createTextNode(text)`
- 새 텍스트 노드 생성
- `text`
  - 문자열
```javascript
let textNode = document.createTextNode('안녕하세요.');
```

##### 개발 시 주요 생성 노드
- 메시지 들어간 요소 노드

#### 메시지 생성하기

##### 메시지 들어갈 `<div>` <sub>(요소)</sub> 생성 <sub>(3단계)</sub>
```javascript
// (1)
// <div> (요소) 생성
// - div (변수) 할당
let div = document.createElement('div');

// (2)
// 만든 요소 클래스 값
// - 'alert' 설정
div.className = "alert";

// (3)
// 내용 채워넣기
div.innerHTML = "<strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.";
```

##### 요소 생성 후
- 아직 변수 <sub>(`div`)</sub> 상태
  - 페이지 표시 X

### 삽입 메서드

##### 생성한 요소 <sub>(`div`)</sub>
- `document` 내 어딘가 삽입 필요 <sub>(페이지 표시)</sub>
  - ex&#41; `<body>` <sub>(`document.body`)</sub>

##### `append` <sub>(노드 삽입 메서드)</sub>
- `document.body.append(div)`
- 다른 요소에도 호출 가능
  - ex&#41; `div.append(…)`
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.";

  // 요소 삽입
  document.body.append(div);
</script>
```

##### 노드 삽입 메서드
- `node.append(노드 · 문자열)`
  - `node` 끝에 삽입
- `node.prepend(노드 · 문자열)`
  - `node` 맨 앞에 삽입
- `node.before(노드 · 문자열)`
  - `node` 이전에 삽입
- `node.after(노드 · 문자열)`
  - `node` 다음에 삽입
- `node.replaceWith(노드 · 문자열)`
  - `node` 대체

##### 문자열 전달 시
- 텍스트 노드 생성
```html
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  // <ol> (요소) 앞
  // - 'before' (문자열) 삽입
  ol.before('before');

  // <ol> (요소) 뒤
  // - 'after' (문자열) 삽입
  ol.after('after');

  // <ol> (요소) 첫 항목
  // - liFirst (요소) 삽입
  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst);

  // <ol> (요소) 마지막 항목
  // - liLast (요소) 삽입
  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast);
</script>

↓↓↓

```html
before
<ol id="ol">
  <li>prepend</li>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>append</li>
</ol>
after
```

![example-inserting-method](../../images/02/01/07/example-inserting-method.png)

![before-prepend-append-after](../../images/02/01/07/before-prepend-append-after.svg)

##### 여러 노드 · 문자열 삽입
```html
<div id="div"></div>

<script>
  div.before('<p>안녕하세요</p>', document.createElement('hr'));
</script>

↓↓↓

&lt;p&gt;안녕하세요&lt;/p&gt;
<hr>
<div id="div"></div>
```

##### 문자열 인수 <sub>(텍스트 노드)</sub>
- 특수문자 <sub>(`<` · `>` 등)</sub>
  - 이스케이프 처리

##### 문자열 : 안전한 방법으로 삽입
- `textContent` <sub>(프로퍼티)</sub> 사용 동일

### `insertAdjacentHTML` · `Text` · `Element`
- 다재다능한 메서드 

#### `elem.insertAdjacentHTML(where, html)`
- 'HTML 그 자체' <sub>(문자열 형태)</sub> 삽입
  - 태그 정상 동작
  - `innerHTML` 사용 동일

##### `where` <sub>(`elem` 기준 상대 위치)</sub>
- `'beforebegin'`
  - `elem` 바로 앞
- `'afterbegin`'
  - `elem` 1번째 자식 요소 바로 앞
- `'beforeend'`
  - `elem` 마지막 자식 요소 바로 다음
- `'afterend'`
  - `elem` 바로 다음

##### `html`
- HTML 문자열
- 이스케이프 처리 X
  - '그대로' 삽입
```html
<div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>안녕하세요.</p>');
  div.insertAdjacentHTML('afterend', '<p>안녕히 가세요.</p>');
</script>

↓↓↓

<p>안녕하세요.</p>
<div id="div"></div>
<p>안녕히 가세요.</p>
```

![insert-adjacent](../../images/02/01/07/insert-adjacent.svg)

#### 두 가지 형제 메서드
- 메서드 구색 갖추기 목적
- 드물게 사용

##### `elem.insertAdjacentText(where, text)`
- 문법 동일
- `text`
  - '문자 그대로' 삽입

##### `elem.insertAdjacentElement(where, elem)`
- 문법 동일
- `elem` <sub>(요소)</sub> 삽입

새롭게 배운 메서드 `insertAdjacentHTML`를 사용해 메시지 창 예시를 다시 작성하면 다음과 같습니다.

```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
    <strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.
  </div>`);
</script>
```

### 노드 삭제하기
- `node.remove()` <sub>(메서드)</sub>

##### 1초 후 메시지 사라짐
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.";

  document.body.append(div);
  setTimeout(() => div.remove(), 1000);
</script>
```

##### 참고 : 노드 삽입 메서드
- 요소 노드 이동 시
  - 기존 노드
    - 수동 삭제 필요 X
    - 자동 삭제
```html
<div id="first">First</div>
<div id="second">Second</div>
<script>
  // remove (메서드) 호출 필요 X
  // id가 second인 노드를 가져오고, 해당 노드의 뒤에 id가 first인 노드를 삽입
  second.after(first);
</script>
```

### `cloneNode`<sub>(노드 복제)</sub>

##### `elem.cloneNode(true)`
- `elem` '깊은' 복제본 생성
  - 속성 · 자손 요소 전부 복사

##### `elem.cloneNode(false)`
- `elem` 만 복제
  - 자손 노드 복사 X
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert" id="div">
  <strong>안녕하세요!</strong> 중요 메시지를 확인하셨습니다.
</div>

<script>
  // 메시지 창 복제
  let div2 = div.cloneNode(true);

  // 복제한 메시지 창 내용 수정
  div2.querySelector('strong').innerHTML = '안녕히 가세요!';

  // 복제한 메시지 창
  // - 기존 메시지 창 다음 표시
  div.after(div2);
</script>
```

### `DocumentFragment`

##### 래퍼 역할
- 그룹 <sub>(여러 노드 구성)</sub> 감싸 다른 곳 전달
- 문서 상 다른 노드 추가 가능
- 삽입 시
  - 본체 사라짐
  - 내부 추가 노드만 남음

##### `getListContent` <sub>(함수)</sub>
- fragment 생성
  - `<li>` <sub>(노드)</sub> 구성
```html
<ul id="ul"></ul>

<script>
function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)
</script>

↓↓↓

<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

##### 직접 사용 흔치 않음
- 더 쉬운 방법 존재 <sub>(배열 등)</sub>
```html
<ul id="ul"></ul>

<script>
function getListContent() {
  let result = [];

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }

  return result;
}

ul.append(...getListContent());
</script>
```

### 구식 삽입 · 삭제 메서드

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **오래된 문법**

- 오래된 스크립트 이해에 필요

<br />

- 하위 호환성 위해 존재

##### `p.appendChild(node)`
- `p` 마지막 자식으로 추가
```html
<ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  let newLi = document.createElement('li');
  newLi.innerHTML = 'Hello, world!';

  list.appendChild(newLi);
</script>
```

##### `p.insertBefore(node, nextSibling)`
- `p` 안 `nextSibling` 앞에 추가
```html
<ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>
<script>
  let newLi = document.createElement('li');
  newLi.innerHTML = 'Hello, world!';

  list.insertBefore(newLi, list.children[1]);
</script>

↓↓↓

<ol id="list">
  <li>0</li>
  <li>Hello, world!'</li>
  <li>1</li>
  <li>2</li>
</ol>
```
- 첫 번째 항목으로 추가 시
  - `firstChild` <sub>(프로퍼티)</sub>
```javascript
list.insertBefore(newLi, list.firstChild);
```

##### `p.replaceChild(node, oldChild)`
- `p` 자식 노드 중 `oldChild` → `node` 교체

##### `p.removeChild(node)`
- `p` 자식 노드 증 `node` 삭제

```html
<ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  let li = list.firstElementChild;
  list.removeChild(li);
</script>

↓↓↓

<ol id="list">
  <li>1</li>
  <li>2</li>
</ol>
```

##### 삽입 · 삭제한 노드 반환
- 반환 값
  - 사용할 일 거의 없음

### `document.write` 첨언
- 아주 오래된 메서드
- 웹페이지에 뭔가 더함
```html
<p>페이지 어딘가...</p>
<script>
  document.write('<b>자바스크립트를 사용해 Hello 입력</b>');
</script>
<p>끝</p>
```

##### 페이지 '그 자리에 즉시' 추가
- HTML 형식 문자열 동적 작업 가능

##### 페이지 불러오는 도중에만 작동
- 페이지 로드 완료 후 호출 시
  - 기존 문서 내용 사라짐
```html
<p>일 초 후, 이 페이지의 내용은 전부 교체됩니다.</p>
<script>
  // 1초 후 document.write 호출
  // - 페이지 로드 끝난 후 호출 시
  //   - 기존 내용 사라짐
  setTimeout(() => document.write('<b>...사라졌습니다.</b>'), 1000);
</script>
```

##### DOM 조작 X <sub>(속도 아주 빠름)</sub>
- HTML '읽는 <sub>(파싱하는)</sub>' 도중 만나면
  - 마치 원래 페이지에 있었던 것처럼 HTML <sub>(텍스트 형식)</sub> 해석

##### 유용한 상황 <sub>(흔치 않은 상황)</sub>
1. 매우 많은 글자를 HTML에 동적 추가 +
2. 아직 페이지 불러오는 중 +
3. 속도 중요

##### 메서드 발견 시
- 오래된 스크립트일 확률 ↑

<br />

## 요약

#### 노드 생성 메서드:

##### `document.createElement(tag)`
- 새 요소 생성
  - `tag` <sub>(태그명)</sub>

##### `document.createTextNode(value)`
- 텍스트 노드 생성
  - 드물게 사용

##### `elem.cloneNode(deep)`
- 요소 복제
- `deep == true`
  - 모든 자손 요소 복제

##### 노드 삽입 · 삭제 메서드:
- `node.append(노드 · 문자열)`
  - `node` 끝에 삽입
- `node.prepend(노드 · 문자열)`
  - `node` 맨 앞에 삽입
- `node.before(노드 · 문자열)`
  - `node` 이전에 삽입
- `node.after(노드 · 문자열)`
  - `node` 다음에 삽입
- `node.replaceWith(노드 · 문자열)`
  - `node` 대체
- `node.remove()`
  - `node` 제거
- 문자열 삽입 · 삭제 시
  - 문자열 '그대로' 전달

##### '구식' 노드 삽입 · 삭제 메서드 <sub>(`node` 반환)</sub>
- `p.appendChild(node)`
- `p.insertBefore(node, nextSibling)`
- `p.removeChild(node)`
- `p.replaceChild(newElem, node)`

##### `elem.insertAdjacentHTML(where, html)`
- `where` <sub>(위치)</sub> 에 `html` <sub>(HTML)</sub> 삽입
- `"beforebegin"`
  - `elem` 바로 앞
- `"afterbegin"`
  - `elem` 1번째 자식 요소 바로 앞
- `"beforeend"`
  - `elem` 마지막 자식 요소 바로 다음
- `"afterend"`
  - `elem` 바로 다음

##### `elem.insertAdjacent[Text · Element]`
- 문자열 · 요소 삽입
- 드물게 사용

##### `document.write(html)`
- 페이지 로딩 끝나기 전 HTML 삽입
- 문서 로딩 끝난 후 호출 시
  - 문서 내용 지워짐
- 오래된 스크립트에서 볼 수 있음

<br />

### <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

<hr />

### createTextNode vs `innerHTML` vs `textContent`
빈 DOM 요소 `elem`과 `text`라는 문자열이 있습니다.

셋 중에서 같은 동작을 수행하는 명령어는 무엇일까요?

1. `elem.append(document.createTextNode(text))`
2. `elem.innerHTML = text`
3. `elem.textContent = text`

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

정답: 1 과 3.

두 명령어는 `text`를 ‘텍스트로’ `elem` 안에 추가합니다.

예시:
```html
<div id="elem1"></div>
<div id="elem2"></div>
<div id="elem3"></div>
<script>
  let text = '<b>text</b>';

  elem1.append(document.createTextNode(text));
  elem2.innerHTML = text;
  elem3.textContent = text;
</script>
```

<hr />

### 요소 삭제하기
요소의 모든 하위 요소들을 삭제하는 `clear(elem)` 이라는 함수를 만들어 보세요.
```html
<ol id="elem">
  <li>Hello</li>
  <li>World</li>
</ol>

<script>
  function clear(elem) { /* 여기에 코드를 작성하세요. */ }

  clear(elem); // elem 내부 리스트를 삭제합니다.
</script>
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

먼저 잘못된 방법부터 살펴보겠습니다.
```javascript
function clear(elem) {
  for (let i=0; i < elem.childNodes.length; i++) {
      elem.childNodes[i].remove();
  }
}
```

`remove()`는 `elem.childNodes`을 변화시키기 때문에 반복문을 실행할 때마다 `0` 번째 인덱스부터 시작해야만 합니다. 그러나 `i` 는 계속해서 증가하므로, 결국 일부 원소들을 지나치게 됩니다.

`for…of` 반복문에도 역시 같은 문제가 있습니다.

올바른 방법은 다음과 같습니다.
```javascript
function clear(elem) {
  while (elem.firstChild) {
    elem.firstChild.remove();
  }
}
```
같은 동작을 수행하는 더 쉬운 방법도 있습니다.
```javascript
function clear(elem) {
  elem.innerHTML = '';
}
```

<hr />

### 왜 'aaa' 가 남아 있을까요
아래 예시에서는 `table.remove()` 가 호출되었으니 문서에서 표를 삭제해야만 합니다.

그러나 이 코드를 실행해보면, 텍스트 `'aaa'` 가 여전히 나타나는 것을 확인할 수 있습니다.

왜 이런 일이 일어나는 걸까요?
```html
<table id="table">
  aaa
  <tr>
    <td>Test</td>
  </tr>
</table>

<script>
  alert(table); // table 은 삭제할 표의 id 입니다.

  table.remove();
  // 왜 문서 안에 aaa가 남아 있을까요?
</script>
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

이 이상한 동작의 이유는 바로 주어진 HTML이 잘못되었기 때문입니다.

브라우저는 이를 자동으로 고쳐야 합니다. 그러나 명세에 따르면 `<table>` 안에는 표와 관련된 특정 태그만이 존재할 수 있기 때문에 텍스트가 있어서는 안 됩니다. 따라서 브라우저는 `'aaa'`를 `<table>` 앞에 추가합니다.

이제 표를 삭제해도 텍스트가 남아있는 이유가 분명해졌습니다.

이 문제는 브라우저 도구를 사용해 DOM을 탐색해보면 쉽게 답을 찾을 수 있습니다. 브라우저 도구에서는 `<table>` 앞에 `'aaa'` 가 있는 것으로 표시됩니다.

HTML 표준에는 잘못된 HTML을 수정하는 방법이 구체적으로 정해져 있으므로, 이러한 브라우저의 동작은 올바른 동작입니다.

<hr />

### 리스트 생성하기
사용자로부터 값을 입력받아 리스트를 생성하는 인터페이스를 만들어 보세요.

리스트의 모든 요소는 아래 방법으로 생성합니다.

1. `prompt`를 사용해 사용자로부터 리스트의 내용을 입력받습니다.
2. 1번에서 입력받은 내용을 갖는 `<li>` 를 생성한 후 `<ul>` 에 추가합니다.
3. 사용자가 입력을 취소할 때까지 계속합니다 (ESC 키나 프롬프트 창의 취소 버튼을 누를 때까지).
모든 요소는 동적으로 생성되어야 합니다.

사용자가 HTML 태그를 입력하더라도 텍스트로 처리되어야 합니다.

[새 창에서 데모 보기](https://ko.js.cx/task/create-list/solution/)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

`<li>` 에 내용을 추가하기 위한 `textContent` 사용법을 참고하세요.
[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/bmDA88Onms5B8lDv?p=preview)

<hr />

### 객체로부터 트리(tree) 생성하기
중요도: 5
중첩된 객체의 데이터로 `ul`·`li` 리스트를 생성하는 `createTree` 함수를 만들어 보세요.

예시:
```javascript
let data = {
  "Fish": {
    "trout": {},
    "salmon": {}
  },

  "Tree": {
    "Huge": {
      "sequoia": {},
      "oak": {}
    },
    "Flowering": {
      "apple tree": {},
      "magnolia": {}
    }
  }
};
```

코드 형식:
```javascript
let container = document.getElementById('container');
createTree(container, data); // container 요소 내에 트리를 생성합니다.
```

결과물이 될 트리는 이런 모습이어야 합니다.

![](../../images/02/01/07/assignment-making-tree-from-object.png)

두 방법 중 원하는 방법으로 과제를 해결해 보세요.

1. 전체 트리를 생성한 후 `container.innerHTML` 로 컨테이너에 추가합니다.
2. 노드를 각각 생성한 후 DOM 메서드를 사용해 컨테이너에 추가합니다.
두 방법을 모두 사용해보면 더 좋습니다.

내용이 없는 `<ul></ul>`처럼 ‘불필요한’ 요소가 트리에 존재해서는 안된다는 점을 참고하세요.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

객체를 순회하는 가장 쉬운 방법은 재귀를 사용하는 것입니다.

1. [innerHTML을 사용한 풀이.](https://plnkr.co/edit/uzYDJhClECPCrjqo?p=preview)
2. [DOM을 사용한 풀이.](https://plnkr.co/edit/zO8vT3dGOJCsgxuz?p=preview)

<hr />

### 트리의 자손 수 나타내기
중첩된 `ul`·`li` 로 이루어진 트리가 있습니다.

각 `<li>` 가 가진 자손 요소들의 수를 표시하는 코드를 작성해 보세요. (자식이 없는 노드는 생략하세요.)

결과는 아래와 같습니다.

![assignment-displaying-tree-grandchilds](../../images/02/01/07/assignment-displaying-tree-grandchilds.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

각 `<li>` 에 텍스트를 추가하기 위해 텍스트 노드의 `data` 를 변경할 수 있습니다.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/avz8NRsacBbhZIiR?p=preview)

<hr />

### 달력 만들기
`createCalender(elem, year, month)` 라는 함수를 작성해 보세요.

이 함수는 주어진 연도/월의 달력을 생성하고 `elem` 안에 추가해야 합니다.

달력은 각 주를 `<tr>`, 날짜는 `<td>`로 나타내는 표여야 하며 표의 최상단은 월요일로 시작해서 일요일로 끝나는 요일이 적힌 `<th>` 여야 합니다.

예를 들면 `createCalender(cal, 2012, 9)` 는 `cal` 요소 안에 아래 달력을 생성합니다.

![assignment-making-calendar](../../images/02/01/07/assignment-making-calendar.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

여기서는 표를 `"<table>...</table>"` 처럼 문자열의 형태로 생성한 후 `innerHTML` 을 사용해 문서에 삽입하는 방식을 소개하겠습니다.

방법:

1. 먼저 `<th>`를 사용해 표의 헤더(header)를 만든 후 요일을 적어줍니다.
2. `d = new Date(year, month-1)` 형식으로 날짜 객체를 생성합니다. 이러면 month 로 대입한 월의 첫 번째 날을 구할 수 있습니다. (자바스크립트에서는 월을 `0`부터 시작한다는 점에 유의하세요.)
3. 첫번째 열부터 `d.getDay()` 로 구한 각 달의 첫번째 날까지의 빈칸은 `<td></td>` 로 채워주세요.
4. `d.setDate(d.getDate()+1)`을 사용해 d객체의 날짜를 증가시키세요. `d.getMonth()` 로 구한 달이 다음 달로 변하기 전까지 `<td>`를 사용해 새로운 칸을 추가하면 됩니다. 만약 새로운 칸이 일요일이라면 `“</tr><tr>”` 를 사용해 다음 주로 넘어가세요.
5. 달력이 완성되었지만 마지막 행에 빈 공간이 남아있다면 빈 `<td>` 를 사용해 달력을 사각형으로 만들 수 있습니다.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/mY8MUTL7KtJo5TuN?p=preview)

<hr />

### `setInterval`을 사용한 알록달록한 시계
아래처럼 알록달록한 시계를 만들어 보세요.

![assignment-making-colorful-clock-using-setinterval](../../images/02/01/07/assignment-making-colorful-clock-using-setinterval.png)

자바스크립트는 요소 내부 시간을 업데이트할 때만 사용됩니다. 스타일을 꾸미려면 HTML·CSS를 사용하세요.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

먼저 HTML·CSS를 만들어 줍니다.

시간을 구성하는 시, 분, 초는 각각 `<span>` 을 사용해 꾸밀 수 있습니다.
```html
<div id="clock">
  <span class="hour">hh</span>:<span class="min">mm</span>:<span class="sec">ss</span>
</div>
```

색을 입히기 위해서는 CSS가 필요합니다.

`setInterval`에 의해 매 초 호출되는 `update` 함수는 시각을 갱신합니다.
```javascript
function update() {
  let clock = document.getElementById('clock');
  let date = new Date(); // (*)
  let hours = date.getHours();
  if (hours < 10) hours = '0' + hours;
  clock.children[0].innerHTML = hours;

  let minutes = date.getMinutes();
  if (minutes < 10) minutes = '0' + minutes;
  clock.children[1].innerHTML = minutes;

  let seconds = date.getSeconds();
  if (seconds < 10) seconds = '0' + seconds;
  clock.children[2].innerHTML = seconds;
}
```

`(*)`로 표시한 줄에서는 현재 날짜를 확인합니다. `setInterval`을 사용해 호출하면 지연이 생길 수 있기 때문에 신뢰성이 떨어집니다.

시계를 관리하는 함수 코드:
```javascript
let timerId;

function clockStart() { // run the clock
  timerId = setInterval(update, 1000);
  update(); // (*)
}

function clockStop() {
  clearInterval(timerId);
  timerId = null;
}
```

`update()`는 `clockStart()` 에서뿐만 아니라 `(*)`로 표시한 줄에서도 호출됩니다. 양쪽 모두에서 `update()`를 호출하지 않으면 `setInterval`이 실행되기 전까지 사용자는 아무런 내용이 없는 시계를 봐야 하기 때문입니다.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/l1pafBuHjny7dkzL?p=preview)

<hr />

### 리스트에 HTML 삽입하기
두 `<li>` 사이에 `<li>2</li><li>3</li>`을 추가하는 코드를 작성해 보세요.
```html
<ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul>
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

문서 어딘가에 HTML을 추가해야 할 때는 `insertAdjacentHTML`이 최고의 선택입니다.

정답:
```javascript
one.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');
```

<hr />

### 표 정렬하기
주어진 표가 하나 있습니다.
```html
<table>
<thead>
  <tr>
    <th>Name</th><th>Surname</th><th>Age</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>John</td><td>Smith</td><td>10</td>
  </tr>
  <tr>
    <td>Pete</td><td>Brown</td><td>15</td>
  </tr>
  <tr>
    <td>Ann</td><td>Lee</td><td>5</td>
  </tr>
  <tr>
    <td>...</td><td>...</td><td>...</td>
  </tr>
</tbody>
</table>
```

표에는 이보다 더 많은 행들이 있을 수 있습니다.

`'name'` 열을 기준으로 표를 정렬하는 코드를 작성해 보세요.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

꼼수처럼 보일지도 모르겠지만 해답은 간단한데요, 상세한 설명은 아래에 있습니다.
```javascript
let sortedRows = Array.from(table.tBodies[0].rows) // 1
  .sort((rowA, rowB) => rowA.cells[0].innerHTML.localeCompare(rowB.cells[0].innerHTML));

table.tBodies[0].append(...sortedRows); // (3)
```

풀이 과정:

1. `<tbody>`로부터 모든 `<tr>`을 불러옵니다.
2. 그 후 `name` 필드에 해당하는 첫 번째 `<td>`의 내용을 기준으로 정렬합니다.
3. 이제 `.append(...sortedRows)`를 사용해 정렬된 노드를 삽입합니다.

행에 해당하는 요소들을 지울 필요 없이 ‘재삽입’ 하면 기존 위치를 저절로 벗어나게 됩니다.

예시에서는 `<tbody>` 가 표에 명시적으로 존재하는데요, HTML 표가 명시적으로 `<tbody>`를 갖지 않더라도 DOM 구조상에는 언제나 존재한다는 점을 참고하세요.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/fTJ5OR6dti9679X9?p=preview)
