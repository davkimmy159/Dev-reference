DOM 탐색하기
===========

##### `document` <sub>(객체)</sub>
- DOM
  - 수행 연산 시작점
  - 접근 위한 '진입점'

##### DOM 노드 탐색 관계도

![dom-links](../../images/02/01/03/dom-links.svg)

### `documentElement` · `body` <sub>(트리 상단)</sub>

#### `document` 프로퍼티
- DOM 트리 상단 노드 접근

##### `documentElement` <sub>(프로퍼티)</sub>
- `<html>` <sub>(태그 · 요소)</sub>
- DOM 트리 꼭대기 노드 <sub>(`document` 제외)</sub>

##### `body` <sub>(프로퍼티)</sub>
- `<body>` <sub>(태그 · 요소)</sub>
- 개발 시 자주 사용

##### `head` <sub>(프로퍼티)</sub>
- `<head>` <sub>(태그 · 요소)</sub>

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`document.body` :  `null` 가능 <sub>(주의)</sub>**

##### 스크립트 읽는 도중 부재 요소
- 스크립트에서 접근 X

##### `<head>` <sub>(태그)</sub> 내 스크립트
- `document.body` 접근 X
  - 브라우저 : 아직 안 읽음

##### 1번째 `alert` 창
- `null` 출력
```html
<html>

<head>
  <script>

    // null
    // - 아직 <body> (노드) 생성 X
    alert( "HEAD: " + document.body );
  </script>
</head>

<body>

  <script>

    // HTMLBodyElement
    // - <body> (노드) 생성되어 존재
    alert( "BODY: " + document.body );
  </script>

</body>
</html>
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **DOM : `null` == '존재하지 않음'**

##### DOM
- `null` == '존재하지 않음' · '해당 노드 없음'

### 자식 노드 탐색하기

##### 자식 노드
- 부모 노드 바로 아래 <sub>(중첩 관계)</sub>
- `<html>` <sub>(요소)</sub> 자식 노드
  - `<head>` <sub>(요소)</sub>
  - `<body>` <sub>(요소)</sub>

##### 후손 노드
- 중첩 관계에 있는 모든 요소
  - 자식 노드
  - 자식 노드의 모든 자식 노드
  - 기타 등등

##### `<body>` <sub>(요소)</sub> 자식 노드
- `<div>` <sub>(요소)</sub>
- `<ul>` <sub>(요소)</sub>
- 빈 텍스트 노드 여러 개
```html
<html>
<body>
  <div>시작</div>

  <ul>
    <li>
      <b>항목</b>
    </li>
  </ul>
</body>
</html>
```

##### `<body>` <sub>(요소)</sub> 후손 노드
- 자식 노드
- 더 깊은 곳에 있는 중첩 요소
  - `<ul>` <sub>(요소)</sub> 자식 노드
    - `<li>` <sub>(요소)</sub>
    - `<b>` <sub>(요소)</sub>
    - 기타 등등

#### `childNodes` <sub>(프로퍼티 · 컬렉션)</sub>
- 모든 자식 노드 <sub>(텍스트 노드 포함)</sub>

##### `document.body` 자식 노드 출력
```html
<html>
<body>
  <div>시작</div>

  <ul>
    <li>항목</li>
  </ul>

  <div>끝</div>

  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {

      // Text, DIV, Text, UL, ... , SCRIPT
      alert( document.body.childNodes[i] );
    }
  </script>
  
  …추가 내용…

</body>
</html>
```

##### 마지막 출력 : `<script>`
- `<script>` <sub>(태그)</sub> 아래 <sub>(…추가 내용…)</sub>
  - 읽지 못한 상태 <sub>(스크립트 실행 시점)</sub>

#### `firstChild` · `lastChild`  <sub>(프로퍼티)</sub>
- 1번째 · 마지막 자식 노드
- 단축키 역할

##### 자식 노드 존재 시
- 비교문 : 항상 참
```javascript
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

#### `hasChildNodes` <sub>(메서드)</sub>
- 자식 노드 존재 여부 확인

### DOM 컬렉션

##### `childNodes` <sub>(프로퍼티 · 컬렉션)</sub>
- 배열 X
- 컬렉션
  - 이터러블 <sub>(반복 가능 객체)</sub>
  - 유사 배열 객체

#### 컬렉션 특징

##### 1. `for…of` <sub>(반복문)</sub>
- 이터러블 <sub>(반복 가능 객체)</sub>
  - `[Symbol.iterator]` <sub>(프로퍼티)</sub> 구현
```javascript
for (let node of document.body.childNodes) {
  alert(node); // 컬렉션 내 모든 노드
}
```

##### 2. 배열 메서드 X
```javascript

// undefined (filter 메서드 X)
alert(document.body.childNodes.filter);
```
- `Array.from` <sub>(정적 메서드)</sub> 사용
```javascript
// function
alert( Array.from(document.body.childNodes).filter );
```

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **DOM 컬렉션 : 읽기만 가능**

##### 자식 노드 교체 <sub>(`childNodes[i] = …`)</sub>
- 불가능

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **DOM 컬렉션 : 살아있음**

- DOM 현재 상태 반영 <sub>(몇몇 예외사항 제외)</sub>

##### `elem.childNodes` <sub>(컬렉션)</sub> 참조 도중
- 새 노드 추가 · 삭제 <sub>(변경사항 발생)</sub> 시
  - 컬렉션 자동 반영

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **컬렉션 : `for…in` 반복문 X**

#### 모든 열거 가능 프로퍼티 순회
- 거의 사용되지 않는 '추가' 프로퍼티 포함
```html
<body>
<script>
  
  // 불필요 프로퍼티
  // - 0, 1, length, item, values 등
  for (let prop in document.body.childNodes) alert(prop);
</script>
</body>
```

### 형제 · 부모 노드

#### 형제 노드
- 같은 부모 가진 노드

##### `nextSibling` · `previousSibling`<sub>(프로퍼티)</sub>
- 다음 · 이전 형제 노드

##### ex&#41; `<head>` · `<body>` <sub>(요소)</sub>
```html
<html>
  <head> … </head><body> … </body>
</html>
```

##### `<body>` <sub>(요소)</sub>
- `<head>` <sub>(요소)</sub> '다음' · '우측' 형제 노드
- `head.nextSibling`

##### `<head>` <sub>(요소)</sub>
- `<body>` <sub>(요소)</sub> '이전' · '좌측' 형제 노드
- `body.previousSibling`


#### 부모 노드

##### `parentNode` <sub>(프로퍼티)</sub>
```javascript
// <body> (요소) 부모 노드
// - <html> (요소)
// true
alert( document.body.parentNode === document.documentElement );

// <head> (요소) 다음 형제 노드
// - <body> (요소)
// HTMLBodyElement
alert( document.head.nextSibling );

// <body> (요소) 이전 형제 노드
// - <head> (요소)
// // HTMLHeadElement
alert( document.body.previousSibling );
```

### 요소 간 이동

##### 실무
- 텍스트 · 주석 노드
  - 잘 다루지 않음
- 요소 노드
  - 주요 작업 대상

![dom-links-elements](../../images/02/01/03/dom-links-elements.svg)

##### `children` <sub>(프로퍼티)</sub>
- 자식 노드 중 요소 노드

##### `firstElementChild` · `lastElementChild` <sub>(프로퍼티)</sub>
- 1번째 마지막 자식 요소 노드

##### `previousElementSibling` · `nextElementSibling` <sub>(프로퍼티)</sub>
-,형제 요소 노드

##### `parentElement` <sub>(프로퍼티)</sub>
- 부모 요소 노드

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **부모가 요소가 아니라면 parentElement는 어떻게 되나요?
**

parentElement 프로퍼티는 부모 '요소 노드’를 반환하는 반면 parentNode 프로퍼티는 '종류에 상관없이 부모 노드’를 반환합니다. 대개 두 프로퍼티는 같은 노드를 반환합니다.

그런데 document.documentElement아래와 같은 상황에서는 다른 노드를 반환합니다.
```javascript
alert( document.documentElement.parentNode ); // document
alert( document.documentElement.parentElement ); // null
```
반환 값이 다른 이유는 `<html>`에 해당하는 document.documentElement의 부모는 document인데, document 노드는 요소 노드가 아니기 때문입니다. 따라서 위 예시에서 parentNode는 의도한 대로 document 노드를 반환하지만, parentElement는 null을 반환합니다.

이런 사소한 차이는 임의의 요소 노드 elem에서 시작해 `<html>`까지 거슬러 올라가고 싶은데, document까지는 가고 싶지 않을 때 유용하게 활용할 수 있습니다.
```javascript
while(elem = elem.parentElement) { // <html>까지 거슬러 올라갑니다.
  alert( elem );
}
```

<br />

앞서 보았던 예시에서 childNodes를 children으로 대체해봅시다. 요소 노드만 출력되는 것을 확인할 수 있습니다.
```html
<html>
<body>
  <div>시작</div>

  <ul>
    <li>항목</li>
  </ul>

  <div>끝</div>

  <script>
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
  </script>
  …
</body>
</html>
```

### 테이블 탐색하기
지금까지 DOM 탐색 기본 프로퍼티를 알아보았습니다.

그런데 일부 DOM 요소 노드는 편의를 위해 기본 프로퍼티 외에 추가적인 프로퍼티를 지원합니다.

테이블이 가장 대표적입니다. 좀 더 자세히 알아봅시다.

`<table>` 요소는 기본 프로퍼티 이외에 다음과 같은 프로퍼티를 지원합니다.
- table.rows는 `<tr>`요소를 담은 컬렉션을 참조합니다.
- table.caption/tHead/tFoot은 각각 `<caption>`, `<thead>`, `<tfoot>` 요소를 참조합니다.
- table.tBodies는 `<tbody>` 요소를 담은 컬렉션을 참조합니다. 표준에 따르면, 테이블 내에 여러 개의 `<tbody>`가 존재하는 게 가능한데, 최소한 하나는 무조건 있어야 합니다. HTML 문서에는 `<tbody>`가 없더라도 브라우저는 `<tbody>` 노드를 DOM에 자동으로 추가합니다.

`<thead>`, `<tfoot>`, `<tbody>` 요소는 rows 프로퍼티를 지원합니다.
- tbody.rows는 tbody 내 `<tr>` 요소 컬렉션을 참조합니다.

`<tr>` 요소는 다음 프로퍼티를 지원합니다.
- tr.cells는 주어진 `<tr>` 안의 모든 `<td>`, `<th>`을 담은 컬렉션을 반환합니다.
- tr.sectionRowIndex는 주어진 `<tr>`이 `<thead>`/`<tbody>`/`<tfoot>`안쪽에서 몇 번째 줄에 위치하는지를 나타내는 인덱스를 반환합니다.
- tr.rowIndex는 `<table>`내에서 해당 `<tr>`이 몇 번째 줄인 지를 나타내는 숫자를 반환합니다.

`<td>`와 `<th>` 요소는 다음 프로퍼티를 지원합니다.

td.cellIndex는 `<td>`나 `<th>`가 속한 `<tr>`에서 해당 셀이 몇 번째인지를 나타내는 숫자를 반환합니다.

용례:
```html
<table id="table">
  <tr>
    <td>일</td><td>이</td>
  </tr>
  <tr>
    <td>삼</td><td>사</td>
  </tr>
</table>

<script>
  // '이'가 적힌 td를 가져옴(첫 번째 줄, 두 번째 칸)
  let td = table.rows[0].cells[1];
  td.style.backgroundColor = "red"; // 강조
</script>
```
표에 관련한 공식 명세서는 [tabular data](https://html.spec.whatwg.org/multipage/tables.html)에서 찾아볼 수 있습니다.

테이블과 마찬가지로, HTML 폼(form)에만 쓸 수 있는 탐색 프로퍼티도 있습니다. 폼을 배우면서 이 프로퍼티에 대해서도 살펴보도록 하겠습니다.

<br />

## 요약
탐색 프로퍼티를 사용하면 이웃 노드로 바로 이동할 수 있습니다.

탐색 프로퍼티는 크게 두 개의 집합으로 나뉩니다.

- 모든 노드에 적용 가능한 parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling
- 요소 노드에만 적용 가능한 parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling

테이블과 같은 몇몇 DOM 요소는 추가 프로퍼티와 콘텐츠에 접속할 수 있게 해주는 컬렉션을 제공합니다.

<br />

### <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

<hr />

### 자식 DOM
아래 페이지를 살펴봅시다.
```html
<html>
<body>
  <div>사용자:</div>
  <ul>
    <li>John</li>
    <li>Pete</li>
  </ul>
</body>
</html>
```

아래 DOM 노드에 접근할 방법을 최소 한 가지 이상씩 생각해보세요.
- `<div>` DOM 노드
- `<ul>` DOM 노드
- 두 번째 `<li>` (Pete)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

방법은 다양합니다.

`<div>` DOM 노드:
```javascript
document.body.firstElementChild
// 또는
document.body.children[0]
// 또는 (첫 번째 노드는 공백이므로 두 번째 노드를 가져옴)
document.body.childNodes[1]
```

`<ul>` DOM 노드:
```javascript
document.body.lastElementChild
// 또는
document.body.children[1]
```

두 번째 `<li>` (Pete):
```javascript
// <ul>을 가져오고, <ul>의 마지막 자식 요소를 가져옴
document.body.lastElementChild.lastElementChild
```

<hr />

### 형제 노드에 관한 질문
임의의 DOM 요소 노드 elem이 있다고 가정해봅시다.
- elem.lastChild.nextSibling은 항상 null일까요?
- elem.children[0].previousSibling은 항상 null일까요?

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

1. 네 맞습니다. elem.lastChild는 항상 마지막 노드이기 때문에 nextSibling이 없습니다.
2. 아닙니다. elem.children[0]은 요소 노드 중 첫 번째 자식 노드를 나타내기 때문입니다. 이 앞에 요소 노드가 아닌 다른 노드가 올 수도 있습니다. previousSibling은 텍스트 노드가 될 수도 있습니다.

주의 사항: 두 경우 모두 자식 노드가 없는 경우 에러가 발생합니다.

자식 노드가 없으면 elem.lastChild은 null이 되기 때문에 elem.lastChild.nextSibling에 접근할 수 없습니다. 그리고 컬렉션 elem.children은 빈 배열 []같이 빈 상태가 됩니다.

<hr />

### 모든 대각선 셀 선택하기
테이블의 모든 대각선 셀을 빨간색으로 칠하는 코드를 작성해보세요.

`<table>`에서 모든 대각선 `<td>`를 가져와 아래 코드를 이용해 칠해야 합니다.
```javascript
// td는 테이블 셀에 대한 참조가 되어야 합니다.
td.style.backgroundColor = 'red';
```

결과는 아래와 같습니다.

![select-all-diagonal-lines](../../images/02/01/03/select-all-diagonal-lines.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

rows와 cells 프로퍼티를 이용해 테이블의 대각선 셀에 접근합니다.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/z4zT9zp7dGDd1Ze9?p=preview&preview)
