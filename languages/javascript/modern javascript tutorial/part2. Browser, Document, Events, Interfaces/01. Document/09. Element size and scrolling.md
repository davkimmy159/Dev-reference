요소 사이즈와 스크롤
==================

##### 요소 기하 정보 관련 프로퍼티
- ex&#41;
  - 너비
  - 높이
  - 기타 등등
- 요소 이동 · 특정 좌표 위치 시 사용

### 샘플 요소
```html
<div id="example">
  …텍스트… 
</div>
<style>
  #example {
    width: 300px;
    height: 200px;
    border: 25px solid #E8C48F;
    padding: 20px;
    overflow: auto; // 스크롤바

    // margin
    // - 요소 자체 포함 X
    // - 관련 특수 JS 프로퍼티 X
//  margin: …;
  }
</style>
```

##### [요소 생김새](https://plnkr.co/edit/sSVXtcaSEX2qGs6h?p=preview)

![metric-css](../../images/02/01/09/metric-css.svg)

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **스크롤바 잊지 말기**

##### 스크롤바 위치 <sub>(몇몇 브라우저)</sub>
- 콘텐츠 영역 너비 일부 빌림
  - _'content width'_ 표시

##### 샙플 예시
- 스크롤바 부재 시
  - 콘텐츠 영역 너비 : `300px`
- 스크롤바 존재 시
  - 스크롤바 너비 : `16px`
    - 브라우저 · 디바이스마다 상이
  - 콘텐츠 영역 너비 : `284px`
- 요소 다룰 때
  - 스크롤바 차지 공간 주의하기

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **텍스트 넘침 주의 <sub>(`padding-bottom`)</sub>**

##### 요소 내 텍스트 길어 넘칠 시
- `padding-bottom` 영역에 표시
  - 정상적인 동작

<br />

### 기하 프로퍼티

![metric-all](../../images/02/01/09/metric-all.svg)

기하 프로퍼티의 값은 숫자인데 그 단위는 '픽셀’입니다. 기하 프로퍼티는 픽셀 단위로 측정된다고 보시면 됩니다.

이제 요소 제일 밖부터 시작해 차근차근 기하 프로퍼티를 살펴보도록 합시다.

### `offsetParent`와 `offsetLeft`, `offsetTop`
잘 쓰이는 프로퍼티는 아니지만 가장 바깥에 있는 기하 프로퍼티이므로 `offsetParent`와 `offsetLeft`, `offsetTop`부터 알아보겠습니다(offset은 요소가 화면에서 차지하는 영역 전체 크기를 나타내는데, 요소의 너비와 높이에 패딩, 스크롤바, 테두리를 합친 크기이며 마진은 포함되지 않습니다 – 옮긴이).

`offsetParent` 프로퍼티는 해당 요소를 렌더링할 때, 좌표 계산에 사용되는 가장 가까운 조상 요소(the closest positioned ancestor element)의 참조를 반환합니다.

CSS `position` 프로퍼티가 설정되어있는 조상 요소가 없는 경우엔 가장 가까운 조상 `<td>`나 `<th>`, 혹은 `<table>`, 아니면 `<body>`가 반환되기 때문에 `offsetParent`에 의해 반환되는 가장 가까운 조상 요소는 아래 셋 중 하나에 속하게 됩니다.
1. CSS `position` 프로퍼티가 `absolute`나 `relative`, `fixed`, `sticky`인 가장 가까운 조상 요소
2. `<td>`나 `<th>`, 혹은 `<table>`
3. `<body>`

`offsetLeft`와 `offsetTop` 프로퍼티는 `offsetParent`를 기준으로 각각 요소가 오른쪽으로, 아래쪽으로 얼마나 떨어져 있는지를 나타냅니다.

예시를 살펴봅시다. 안쪽에 있는 `<div>`의 `offsetParent`는 `<main>`이고 `offsetLeft`와 `offsetTop`은 각각 `180`입니다.

```html
<main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (주의: 문자열 '180px'이 아닌 숫자 180이 반환됩니다.)
  alert(example.offsetTop); // 180
</script>
```

![metric-offset-parent](../../images/02/01/09/metric-offset-parent.svg)

다음 같은 경우엔 `offsetParent`가 `null`이 될 수 있습니다.

1. 화면에 보이지 않는 요소(CSS `display` 프로퍼티가 `none`이거나 문서 내에 있지 않은 요소)
2. `<body>`와 `<html>`
3. `position` 프로퍼티가 `fixed`인 요소

### `offsetWidth`와 `offsetHeight`
이제 본격적으로 요소 자체에 집중해 봅시다.

`offsetWidth`와 `offsetHeight`는 가장 간단한 프로퍼티입니다. 두 프로퍼티는 각각 요소 '가장 바깥 부분(outer)'이 차지하는 너비와 높이 정보를 제공합니다. 테두리를 포함한 요소 '전체’의 사이즈 정보를 제공한다고 보시면 됩니다.

![metric-offset-width-height](../../images/02/01/09/metric-offset-width-height.svg)

샘플 요소를 대상으로 `offsetWidth`와 `offsetHeight`를 계산하면 다음과 같습니다.

- `offsetWidth` = `390` – CSS width 프로퍼티(`300px`)를 사용해 얻을 수 있는 바깥 너비에 패딩(`2 * 20px`)과 테두리(`2 * 25px`) 너비를 더한 값
- `offsetHeight` = `290` – 바깥 높이

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **화면에 표시되지 않는 요소의 기하 프로퍼티 값은 `0` 또는 `null`입니다.**

기하 프로퍼티는 보이는 요소(displayed element)를 대상으로만 계산됩니다.

따라서 요소(혹은 이 요소의 조상 요소 중 어떤 것이든)의 CSS `display` 프로퍼티가 `none`이거나 문서 내에 해당 요소가 없으면 모든 기하 프로퍼티 값이 `0`이 됩니다(`offsetParent` 프로퍼티의 값은 `null`).

요소를 만들긴 했지만 아직 문서에 삽입하기 전이라던가, 새롭게 만든 요소의 `display` 프로퍼티가 `none`이면 기하 프로퍼티 값은 `0`, `offsetParent` 프로퍼티의 값은 `null`이 되는 것이죠.

이런 특징을 이용하면 요소의 숨김 상태 여부를 아래 같은 방법으로 확인할 수 있습니다.
```javascript
function isHidden(elem) {
  return !elem.offsetWidth && !elem.offsetHeight;
}
```
참고로 `isHidden`은 요소가 화면에 있긴 하지만 사이즈가 0일 때(비어있는 `<div>` 등)도 `true`를 반환하기 때문에 주의해서 사용해야 합니다.

<br />

### `clientTop`과 `clientLeft`
테두리(border)는 요소 내에 있습니다.

`clientTop`과 `clientLeft`를 사용하면 테두리 두께를 측정할 수 있습니다.

샘플 예시에서 테두리 두께를 계산하면 다음과 같습니다.

`clientLeft` = `25` – 왼쪽 테두리 너비
`clientTop` = `25` – 위쪽 테두리 높이

![metric-client-left-top](../../images/02/01/09/metric-client-left-top.svg)

그런데 사실 `clientTop`과 `clientLeft` 프로퍼티는 테두리 높이, 너비와 정확히 일치하지 않습니다. 정확히는 테두리 바깥을 기준으로 한 테두리 안 상대 좌표를 나타냅니다.

조금 헷갈릴 수 있으니 자세히 설명해보겠습니다.

`clientTop`과 `clientLeft`의 차이는 아랍어나 히브리어처럼 오른쪽에서 왼쪽으로 글이 전개되는 언어일 때 드러납니다. 아랍어가 세팅된 브라우저에선 스크롤바가 오른쪽이 아닌 왼쪽에 나타나게 되는데, 그럼 `clientLeft`에 스크롤바의 너비가 포함됩니다.

`clientLeft`가 `25`가 아닌 스크롤바 너비를 포함한 `41`(`25 + 16`)이 되는 거죠.

히브리어를 예시로 직접 살펴봅시다.

![](../../images/02/01/09/metric-client-left-top-rtl.svg)

### `clientWidth`와 `clientHeight`
`clientWidth`와 `clientHeight` 프로퍼티는 테두리 안 영역의 사이즈 정보를 제공합니다.

테두리 안에는 콘텐츠 너비와 패딩이 포함되는데, 스크롤바 너비는 포함되지 않습니다.

![](../../images/02/01/09/metric-client-width-height.svg)

그림에서 `clientHeight`로 표시된 부분을 먼저 살펴봅시다.

가로 스크롤바가 없기 때문에 `clientHeight`는 테두리 안 영역 전체를 더한 값이 됩니다. 높이 `200px`에 위, 아래 패딩(`2 * 20px`)을 더한 값인 `240px`이 되죠.

이제 `clientWidth`를 계산해 봅시다. `clientWidth`를 계산할 때 주의할 점은 세로 스크롤바가 차지하는 너비 `16px` 때문에 콘텐츠 너비는 `300px`이 아닌 `284px`이 된다는 점입니다. 따라서 `clientWidth`는 콘텐츠 너비 `284px`에 왼쪽, 오른쪽 패딩(`2 * 20px`)을 더한 값인 `324px`가 됩니다.

**패딩이 없었다면 `clientWidth`와 `clientHeight`는 테두리와 스크롤바 안쪽에 있는 콘텐츠 영역의 너비, 높이와 정확히 일치했을 겁니다.**

![](../../images/02/01/09/metric-client-width-nopadding.svg)

따라서 패딩이 없는 경우엔 `clientWidth`와 `clientHeight`를 사용해 콘텐츠 영역 크기를 구할 수 있습니다.

### `scrollWidth`와 `scrollHeight`
`scrollWidth`와 `scrollHeight` 프로퍼티는 `clientWidth`와 `clientHeight` 유사한데, 스크롤바에 의해 감춰진 영역도 포함한다는 점에서 차이가 있습니다.

![](../../images/02/01/09/metric-scroll-width-height.svg)

그림을 살펴봅시다.
- `scrollWidth` = `324` – 수평 스크롤바가 없기 때문에 안쪽 영역 전체를 나타내는 `clientWidth`와 동일합니다.
- `scrollWidth` = `324` – 스크롤 때문에 가려진 영역을 포함한 콘텐츠 영역 높이 전체
- `scrollHeight` = `723` – 세로 스크롤바에 가려진 부분을 포함하는 콘텐츠 영역 안쪽 전체의 높이
- `scrollWidth` = `324` – 콘텐츠 영역 안쪽 전체의 너비. 그림은 가로 스크롤바가 없기 때문에 `clientWidth`와 동일합니다.

`scrollWidth`와 `scrollHeight`는 요소 크기를 콘텐츠가 차지하는 만큼 늘리고자 할 때 사용할 수 있습니다.

예시:
```javascript
// 콘텐츠가 차지하는 높이만큼 요소 높이를 늘림
element.style.height = `${element.scrollHeight}px`;
```

버튼을 눌러 직접 요소 크기를 확장해 봅시다.

![scrollWidth-scrollHeight-1](../../images/02/01/09/scrollWidth-scrollHeight-1.png)

↓↓↓

![scrollWidth-scrollHeight-2](../../images/02/01/09/scrollWidth-scrollHeight-2.png)

### `scrollLeft`와 `scrollTop`
`scrollLeft`와 `scrollTop`은 가로 스크롤이 오른쪽, 세로 스크롤이 아래로 움직임에 따라 가려진 영역의 너비와 높이를 나타냅니다.

세로 스크롤바를 아래로 조금 내린 경우를 가정한 그림을 예시로 들어봅시다. `scrollHeight`에서 `scrollTop`이 얼마만큼의 영역을 차지하는지를 살펴볼 수 있습니다.

![metric-scroll-top](../../images/02/01/09/metric-scroll-top.svg)

이렇게 scrollTop은 ‘세로 스크롤바에 의해 가려져 보이지 않는’ 위쪽 콘텐츠의 높이가 됩니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`scrollLeft`와 `scrollTop`은 수정 가능합니다.**

기하 프로퍼티 대부분은 읽기전용이지만 `scrollLeft`와 `scrollTop`은 변경이 가능합니다. 스크립트로 프로퍼티를 수정하면 자동으로 요소 내 스크롤이 움직입니다.

요소를 클릭하면 스크롤바가 `10px` 아래로 내려가도록 `elem.scrollTop += 10`을 스크립트에 추가해 놓았습니다.

![](../../images/02/01/09/scrollLeft-scrollTop-modifiable.png)

이런 특징을 이용하면 `scrollTop`을 `0`이나 `1e9`같은 아주 큰 숫자로 설정해 스크롤바를 최상단이나 최하단으로 옮길 수 있습니다.

<br />

### CSS를 사용해 너비와 높이를 얻지 마세요
지금까지 요소 너비와 높이, 요소 포지셔닝 관련 거리를 구하는 데 사용되는 기하 프로퍼티를 살펴보았습니다.

그런데 우리는 스타일과 클래스 챕터에서 `getComputedStyle`를 사용해 CSS가 적용된 요소의 높이와 너비를 구할 수 있다는 것을 알아본 바 있습니다.

그렇다면 왜 `getComputedStyle`를 사용해 요소 너비와 높이를 얻지 말라고 하는 걸까요?

```javascript
let elem = document.body;

alert( getComputedStyle(elem).width ); // CSS가 적용된 elem의 너비
```

`getComputedStyle`가 아닌 기하 프로퍼티를 사용해 너비와 높이 정보를 얻어야 하는 데는 다음과 같은 이유가 있습니다.

1. CSS `width`와 `height`는 다른 CSS 프로퍼티의 영향을 받습니다. 요소의 너비와 높이 계산 방법을 '지정’하는 `box-sizing`이 이런 프로퍼티의 대표적인 예이죠. `box-sizing`을 변경하면 `getComputedStyle`로 구한 값이 부정확 할 수 있습니다.
2. CSS `width`와 `height`는 `auto`일 수 있습니다. 인라인 요소(inline element)가 이런 경우에 속합니다.
```html
<span id="elem">안녕하세요!</span>

<script>
  alert( getComputedStyle(elem).width ); // auto
</script>
```
CSS 관점에서 보면 `width:auto`는 전혀 이상할 게 없어 보입니다. 그런데 자바스크립트 입장에선 정확한 `px`값이 있어야 계산을 할 수 있기 때문에 `auto`라는 값은 쓸모가 없습니다.

다른 한 가지 이유는 스크롤바때문입니다. 스크롤바가 없으면 정상 동작하는데, 스크롤바가 생기면 의도한 대로 동작하지 않는 코드가 있습니다. 이런 일은 스크롤바가 콘텐츠 영역을 차지하는 몇몇 브라우저에서 발생합니다. 이들 브라우저에선 콘텐츠가 실제 차지하는 영역이 CSS로 설정한 너비보다 좁은데, `clientWidth`와 `clientHeight`는 이를 고려해 클라이언트 요소가 차지하는 공간을 계산합니다.

그런데 `getComputedStyle(elem).width`를 사용하면 상황이 달라집니다. Chrome 같은 브라우저는 스크롤바 너비를 제외한 진짜 내부 너비를 반환하는데 Firefox 같은 브라우저는 스크롤바를 무시하고 CSS로 설정한 너비를 반환합니다. 이런 브라우저 간 차이 때문에 `getComputedStyle`이 아닌 기하 프로퍼티를 사용해야 합니다.

스크롤바가 차지하는 영역을 따로 두는 브라우저(Windows에서 돌아가는 대부분의 브라우저)에서 아래 예시를 실행하면 300px이 아닌 다른 값이 출력되는 것을 확인할 수 있습니다.

![width-height-get-from-css-1](../../images/02/01/09/width-height-get-from-css-1.png)

![width-height-get-from-css-2](../../images/02/01/09/width-height-get-from-css-2.png)

텍스트가 들어있는 위 요소의 CSS엔 `width:300px`가 설정되어 있는 상태입니다.

Windows가 설치된 데스크톱 PC의 Firefox, Chrome, Edge 브라우저는 모두 스크롤바 영역을 따로 떼어놓습니다. 그런데 Windows 이외의 OS가 설치된 PC의 Firefox에서 예시를 실행하면 `300px`이 출력되는 것을 확인할 수 있습니다. 다른 브라우저들은 ‘진짜’ 너비를 출력하는 반면 Firefox는 CSS로 설정한 너비를 출력하기 때문입니다.

`getComputedStyle`과 기하 프로퍼티의 차이는 자바스크립트를 사용해 `getComputedStyle(...).width`로 값을 얻고자 할 때만 발생합니다. 눈으로 봤을 땐 전혀 문제가 없으니 이 점에 유의하시기 바랍니다.

<br />

## 요약
요소는 다음과 같은 기하 프로퍼티를 지원합니다.

- `offsetParent` – 위치 계산에 사용되는 가장 가까운 조상 요소나 `td`, `th`, `table`, `body`
- `offsetLeft`와 `offsetTop` – `offsetParent` 기준으로 요소가 각각 오른쪽, 아래쪽으로 얼마나 떨어져 있는지를 나타내는 값
- `offsetWidth`와 `offsetHeight` – 테두리를 포함 요소 '전체’가 차지하는 너비와 높이
- `clientLeft`와 `clientTop` – 요소 제일 밖을 감싸는 영역과 요소 안(콘텐츠 + 패딩)을 감싸는 영역 사이의 거리를 나타냄. 대부분의 경우 왼쪽, 위쪽 테두리 두께와 일치하지만, 오른쪽에서 왼쪽으로 글을 쓰는 언어가 세팅된 OS에선 `clientLeft`에 스크롤바 두께가 포함됨
- `clientWidth`와 `clientHeight` – 콘텐츠와 패딩을 포함한 영역의 너비와 높이로, 스크롤바는 포함되지 않음
- `scrollWidth`와 `scrollHeight` – `clientWidth`, `clientHeight` 같이 콘텐츠와 패딩을 포함한 영역의 너비와 높이를 나타내는데, 스크롤바에 의해 숨겨진 콘텐츠 영역까지 포함됨
- `scrollLeft`와 `scrollTop` – 스크롤바가 오른쪽, 아래로 움직임에 따라 가려지게 되는 요소 콘텐츠의 너비와 높이

스크롤바를 움직일 수 있게 해주는 `scrollLeft`와 `scrollTop`을 제외한 모든 프로퍼티는 읽기 전용입니다.

<br />

### <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

<hr />

### What's the scroll from the bottom?
중요도: 5
The `elem.scrollTop` property is the size of the scrolled out part from the top. How to get the size of the bottom scroll (let’s call it `scrollBottom`)?

Write the code that works for an arbitrary `elem`.

P.S. Please check your code: if there’s no scroll or the element is fully scrolled down, then it should return `0`.
content

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

The solution is:
```javascript
let scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;
```

In other words: (full height) minus (scrolled out top part) minus (visible part) – that’s exactly the scrolled out bottom part.

<hr />

### What is the scrollbar width?
Write the code that returns the width of a standard scrollbar.

For Windows it usually varies between `12px` and `20px`. If the browser doesn’t reserve any space for it (the scrollbar is half-translucent over the text, also happens), then it may be `0px`.

P.S. The code should work for any HTML document, do not depend on its content.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

To get the scrollbar width, we can create an element with the scroll, but without borders and paddings.

Then the difference between its full width `offsetWidth` and the inner content area width `clientWidth` will be exactly the scrollbar:
```javascript
// create a div with the scroll
let div = document.createElement('div');

div.style.overflowY = 'scroll';
div.style.width = '50px';
div.style.height = '50px';

// must put it in the document, otherwise sizes will be 0
document.body.append(div);
let scrollWidth = div.offsetWidth - div.clientWidth;

div.remove();

alert(scrollWidth);
```

<hr />

### Place the ball in the field center
Here’s how the source document looks:

![assignment-place-the-ball-in-the-field-center-1](../../images/02/01/09/assignment-place-the-ball-in-the-field-center-1.png)

What are coordinates of the field center?

Calculate them and use to place the ball into the center of the green field:

![assignment-place-the-ball-in-the-field-center-2](../../images/02/01/09/assignment-place-the-ball-in-the-field-center-2.png)

- The element should be moved by JavaScript, not CSS.
- The code should work with any ball size (`10`, `20`, `30` pixels) and any field size, not be bound to the given values.

P.S. Sure, centering could be done with CSS, but here we want exactly JavaScript. Further we’ll meet other topics and more complex situations when JavaScript must be used. Here we do a “warm-up”.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

The ball has `position:absolute`. It means that its `left`/`top` coordinates are measured from the nearest positioned element, that is `#field` (because it has `position:relative`).

The coordinates start from the inner left-upper corner of the field:

![field](../../images/02/01/09/field.svg)

The inner field width/height is `clientWidth`/`clientHeight`. So the field center has coordinates (`clientWidth/2`, `clientHeight/2`).

…But if we set `ball.style.left/top` to such values, then not the ball as a whole, but the left-upper edge of the ball would be in the center:
```javascript
ball.style.left = Math.round(field.clientWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2) + 'px';

```
Here’s how it looks:

![assignment-place-the-ball-in-the-field-center-1](../../images/02/01/09/assignment-place-the-ball-in-the-field-center-1.png)

To align the ball center with the center of the field, we should move the ball to the half of its width to the left and to the half of its height to the top:
```javascript
ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
```

Now the ball is finally centered.

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **Attention: the pitfall!**

The code won’t work reliably while `<img>` has no width/height:
Attention: the pitfall!

```html
<img src="ball.png" id="ball">
```

<br />

When the browser does not know the width/height of an image (from tag attributes or CSS), then it assumes them to equal `0` until the image finishes loading.

So the value of `ball.offsetWidth` will be `0` until the image loads. That leads to wrong coordinates in the code above.

After the first load, the browser usually caches the image, and on reloads it will have the size immediately. But on the first load the value of `ball.offsetWidth` is `0`.

We should fix that by adding `width`/`height` to `<img>`:
```html
<img src="ball.png" width="40" height="40" id="ball">
```
…Or provide the size in CSS:
```css
#ball {
  width: 40px;
  height: 40px;
}
```

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/c90eAUpyikvBYKKj?p=preview)

<hr />

### CSS `width`와 `clientWidth`의 차이
`getComputedStyle(elem).width`와 `elem.clientWidth`의 차이점은 무엇일까요?

최소 세 가지 차이점을 설명해주세요. 더 많을수록 좋습니다.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

둘의 차이점은 다음과 같습니다.

1. `clientWidth`는 숫자형을 반환하는 반면, `getComputedStyle(elem).width`는 끝에 `px`가 붙은 문자열을 반환합니다.
2. `getComputedStyle`은 인라인 요소의 너비를 구할 때 `"auto"`와 같은 숫자가 아닌 값을 반환할 수도 있습니다.
3. `clientWidth`는 콘텐츠와 패딩을 포함한 영역의 너비를 가르키지만, (표준 `box-sizing`과 연관된) CSS `width`는 패딩을 제외한 콘텐츠 영역의 너비를 가리킵니다.
4. 페이지에 스크롤바가 있고 브라우저가 스크롤바 영역을 따로 처리하는 경우에, 어떤 브라우저는 CSS width를 계산할 때 스크롤바 너비를 제외하는 반면(스크롤바 영역은 콘텐츠를 담을 수 없기 때문) 어떤 브라우저는 스크롤바 영역을 포함합니다. `clientWidth` 프로퍼티는 브라우저 종류에 상관 없이 항상 동일하게 스크롤바 영역이 있는 경우엔 스크롤바 너비를 제외합니다.
