`getElement[*]` · `querySelector[*]` : 요소 검색하기
==========================================

- 검색 시
  - 상대 위치 X

### `getElementById` <sub>(메서드)</sub> · `id` <sub>(속성)</sub>

##### `getElementById` <sub>(메서드)</sub>
- `id` <sub>(속성)</sub> 존재 시 접근
  - 위치 상관 X
```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // 요소 얻기
  let elem = document.getElementById('elem');

  // 요소 배경색 변경
  elem.style.background = 'red';
</script>
```

##### `id` 속성값 그대로 딴 전역 변수 <sub>(자동 선언)</sub>
```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // elem (변수)
  // - 요소 참조
  //   - id (속성) 값 : "elem"
  elem.style.background = 'red';

  /*
   elem-content (변수)
   - 요소 참조
     - id (속성) 값 : "elem-content"
   - 하이폰 (-)
     - 변수명 X
     - [ … ] (대괄호)
   */
  window["elem-content"].style.background = 'red';
</script>
```
- 동일명 변수 선언 시
  - 무용지물
```html
<div id="elem"></div>

<script>
  // elem (변수)
  // - <div id="elem"> (요소) 참조 X
  let elem = 5;

  alert(elem); // 5
</script>
```

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`id` <sub>(속성)</sub> 값 따서 생성된 전역 변수 : 요소 접근 시 사용 X
**

##### `id` <sub>(속성)</sub> 대응 전역 변수
- 표준
  - 명세서 내용 구현
  - 하위 호환성

##### 스크립트 · DOM 네임스페이스 공유 <sub>(브라우저)</sub>
- 개발 편의 도모
- 이름 충돌 가능
- 코드만 보고 변수 출처 이해 X

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`id` <sub>(속성)</sub> 값 중복 X**

##### `id` <sub>(속성)</sub> 값
- 유일무이 필수

##### 동일 `id` <sub>(속성)</sub> 값 존재 시
-`id` <sub>(속성)</sub> 이용 요소 검색 메서드 동작
  - 예측 불가능
  - 임의 요소 반환

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **`anyNode.getElementById` X`**

##### `getElementById` <sub>(메서드)</sub>
- `document` <sub>(객체)</sub> 대상 동작
- 다른 노드 호출 X

### `querySelectorAll` <sub>(메서드)</sub>
- CSS 선택자 대응 자식 요소 전체 반환

##### 마지막 `<li>` <sub>(요소)</sub> 모두 반환
```html
<ul>
  <li>1-1</li>
  <li>1-2</li>
</ul>
<ul>
  <li>2-1</li>
  <li>2-2</li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "1-2", "2-2"
  }
</script>
```

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`querySelectorAll` : 가상 클래스 사용 가능**

##### CSS 선택자 가상 클래스
- `:hover`
- `:active`
- 기타 등등

##### ex&#41; `document.queryselectorAll(':hover')`
- 마우스 포인터가 위에 있는 요소 컬렉션 반환
  - hover 상태
- 요소 순서
  - 최상단 <sub>(`<html>` 요소)</sub> → 최하단

### `querySelector` <sub>(메서드)</sub>
- CSS 선택자 대응 1번째 자식 요소 반환
- `querySelectorAll(css)[0]` 결과 동일

##### `querySelectorAll(css)[0]`
- 선택자 대응 모든 요소 검색 후 1번째 요소 반환
  - 속도 느림

##### `querySelector(css)`
- 해당 요소 찾으면 검색 중단
  - 속도 빠름
- 코드 길이 ↓

### `matches` <sub>(메서드)</sub>
- 선택자 일치 여부 판단

##### 요소 배열 순회 시
- 원하는 요소 필터링 유용
```html
<a href="http://example.com/file.zip"> … </a>
<a href="http://ya.ru"> … </a>

<script>
  // 컬렉션
  // - 메서드 사용 가능
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("주어진 CSS 선택자와 일치하는 요소: " + elem.href );
    }
  }
</script>
```

### `closest` <sub>(메서드)</sub>
- 선택자 일치하는 가장 가까운 조상 요소 반환
  - 자기 자신 포함
- DOM 트리 한 단계씩 거슬러 올라가면서 찾음
- 요소 찾을 시
  - 검색 중단 · 해당 요소 반환

##### 조상 요소
- 특정 요소 상위 위치 요소들
  - 부모 요소
  - 부모 요소의 부모 요소
  - 기타 등등

```html
<h1>목차</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">1장</li>
    <li class="chapter">2장</li>
  </ul>
</div>

<script>
  // <li class="chapter">1장</li> (요소)
  let chapter = document.querySelector('.chapter');

  // <ul class="book"> (요소)
  alert(chapter.closest('.book'));

  // <div class="contents"> (요소)
  alert(chapter.closest('.contents'));

  // null
  // - h1 : li (요소) 조상 요소 X
  alert(chapter.closest('h1'));
</script>
```

### `getElementsBy[*]` <sub>(메서드)</sub>
- 태그 · 클래스 등 이용
- 요즘 잘 안 쓰임
- `querySelector[*]` <sub>(메서드)</sub>
  - 더 편리
  - 문법 짧음

##### `getElementsByTagName(tag)`
- `tag` <sub>(태그)</sub> 해당 요소 검색
- 해당 요소 컬렉션 반환
- `tag` <sub>(매개변수)</sub> 값 : `"*"`
  - 모든 태그 검색

##### `getElementsByClassName(className)`
- `class` <sub>(속성)</sub> 값 해당 요소 검색
- 해당 요소 컬렉션 반환

##### `getElementsByName(name)`
- 아주 드물게 사용
- 문서 전체 대상 검색 수행
- `name` <sub>(속성)</sub> 값 해당 요소 검색
- 해당 요소 컬렉션 반환

##### 문서 내 모든 div (요소) 얻기
```javascript
let divs = document.getElementsByTagName('div');
```

##### 표 안 모든 input (태그 · 요소) 찾기
```html
<table id="table">
  <tr>
    <td>나이:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked> 18세 미만
      </label>
      <label>
        <input type="radio" name="age" value="mature"> 18세 이상, 60세 미만
      </label>
      <label>
        <input type="radio" name="age" value="senior"> 60세 이상
      </label>
    </td>
  </tr>
</table>

<script>
  let inputs = table.getElementsByTagName('input');

  for (let input of inputs) {
    alert( input.value + ': ' + input.checked );
  }
</script>
```

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **'s'를 절대 빠트리지 마세요!**

초보 개발자들은 가끔 's'를 빼먹는 실수를 하곤 합니다. getElementsByTagName를 써야 하는데 getElementByTagName을 입력하곤 하죠.

getElementById는 요소 하나만을 반환하기 때문에 s가 없습니다. getElementsByTagName 등의 메서드는 대응하는 요소를 담은 컬렉션을 반환하기 때문에 메서드 중간에 "s"가 들어갑니다.

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **요소 하나가 아닌, 컬렉션을 반환합니다!**

초보자들이 자주 저지르는 실수가 하나 더 있습니다.
```javascript
// 동작하지 않는 코드
document.getElementsByTagName('input').value = 5;
```

input 요소 전체를 담은 컬렉션에 5를 할당하는 위 코드는 동작하지 않습니다. 아마도 본래 의도는 컬렉션 내 요소에 값을 할당하는 것이었을 겁니다.

컬렉션을 순회하거나 인덱스를 사용해 요소를 얻고 그 요소에 값을 할당하면 기존 의도대로 동작합니다. 아래와 같이 말이죠.
```javascript
// (문서에 input 요소가 있다면) 아래 코드는 잘 동작합니다.
document.getElementsByTagName('input')[0].value = 5;
```

<br />

아래는 클래스 속성의 값이 article인 요소를 검색해주는 예시입니다.
```html
<form name="my-form">
  <div class="article">글</div>
  <div class="long article">내용이 긴 글</div>
</form>

<script>
  // name 속성을 이용해 검색
  let form = document.getElementsByName('my-form')[0];

  // form 내에서 클래스 이름을 이용해 검색
  let articles = form.getElementsByClassName('article');
  alert(articles.length); // 2. 클래스 속성값이 'article'인 요소는 2개입니다.
</script>
```

### 살아있는 컬렉션
'getElementsBy'로 시작하는 모든 메서드는 살아있는 컬렉션을 반환합니다. 문서에 변경이 있을 때마다 컬렉션이 '자동 갱신’되어 최신 상태를 유지합니다.

예시 내엔 스크립트 두 개가 있습니다.

1. 첫 번째 스크립트는 `<div>`에 상응하는 요소를 담은 컬렉션에 대한 참조를 만듭니다. 스크립트가 실행되는 시점에 이 컬렉션의 길이는 1입니다.
2. 두 번째 스크립트는 문서에 `<div>`가 하나 더 추가된 이후에 실행됩니다. 따라서 컬렉션의 길이는 2가 됩니다.
```html
<div>첫 번째 div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>두 번째 div</div>

<script>
  alert(divs.length); // 2
</script>
```

반면, querySelectorAll은 정적인 컬렉션을 반환합니다. 컬렉션이 한 번 확정되면 더는 늘어나지 않습니다.

querySelectorAll을 사용하면 두 스크립트가 동일하게 1을 출력합니다.
```html
<div>첫 번째 div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>두 번째 div</div>

<script>
  alert(divs.length); // 1
</script>
```

예시를 통해 두 방식의 차이를 살펴보았습니다. 문서에 새로운 div가 추가되어도 querySelectorAll이 반환한 컬렉션은 이를 반영하지 못합니다.

<br />

## 요약
DOM에서 원하는 노드를 검색하게 해주는 주요 메서드 6가지는 다음과 같습니다.

|메서드|검색 기준|호출 대상이 요소가 될 수 있는지에 대한 여부|컬렉션 갱신여부|
|---|---|---|---|
|querySelector|CSS 선택자|✔|-|
|querySelectorAll|CSS 선택자|✔|-|
|getElementById|id|-|-|
|getElementsByName|name|-|✔|
|getElementsByTagName|태그나 '*'|✔|✔|
|getElementsByClassName|class|✔|✔|

아마 실무에선 querySelector나 querySelectorAll을 가장 많이 사용하실 겁니다. getElementBy로 시작하는 메서드는 대개 오래된 스크립트에서 만날 수 있는데, 일부 이 메서드가 꼭 필요한 상황에서 쓰이는 경우도 있습니다.

이 외에 알아두면 좋을 만한 메서드는 아래와 같습니다.

- elem.matches(css)는 elem이 해당 CSS 선택자와 일치하는지 여부를 검사합니다.
- elem.closest(css)는 해당 CSS 선택자와 일치하는 가장 가까운 조상 요소를 탐색합니다. 이때, elem 자기 자신도 검색 대상에 포함됩니다.

위에선 언급하지 않았지만, 노드의 부모-자식 관계를 확인할 수 있도록 도와주는 유용한 메서드 하나를 더 소개해 드리고 마무리하겠습니다.

- elemA.contains(elemB)는 elemB가 elemA에 속하거나(elemB가 elemA의 후손인 경우) elemA==elemB일 때, 참을 반환합니다.

<br />

### <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

<hr />

### 요소 검색하기
테이블과 폼이 있는 문서가 있다고 가정합시다.

아래 조건에 맞는 요소는 어떻게 찾을 수 있을까요?

1. id="age-table"인 테이블
2. 테이블 내의 label 요소 모두(총 3개)
3. 테이블 내의 첫 번째 td(Age가 적힌 곳)
4. name="search"인 form
5. 폼의 첫 번째 input
6. 폼의 마지막 input

별도의 창에서 table.html을 열어 브라우저 내 도구를 사용해 문제를 풀어보세요.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

다양한 방법으로 문제를 풀 수 있습니다.

그 중 일부를 여기서 소개해드리겠습니다.

```javascript
// 1. `id="age-table"`인 테이블
let table = document.getElementById('age-table')

// 2. 테이블 내의 `label` 요소 모두
table.getElementsByTagName('label')
// 또는
document.querySelectorAll('#age-table label')

// 3. 테이블 내의 첫 번째 `td`(Age가 적힌 곳)
table.rows[0].cells[0]
// 또는
table.getElementsByTagName('td')[0]
// 또는
table.querySelector('td')

// 4. `name="search"`인 `form`
// name이 "search"인 요소는 문서에 단 하나뿐이라고 가정합시다.
let form = document.getElementsByName('search')[0]
// from을 정확히 지정해 줄 수도 있습니다.
document.querySelector('form[name="search"]')

// 5. 폼의 첫 번째 `input`
form.getElementsByTagName('input')[0]
// 또는
form.querySelector('input')

// 6. 폼의 마지막 `input`
let inputs = form.querySelectorAll('input') // 모든 input 요소를 찾교
inputs[inputs.length-1] // 마지막 요소를 얻어냅니다.
```
