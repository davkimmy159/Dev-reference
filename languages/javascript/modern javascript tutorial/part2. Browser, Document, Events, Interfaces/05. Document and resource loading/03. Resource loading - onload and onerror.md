`on[loadÂ·error]` <sub>(ë¦¬ì†ŒìŠ¤ ë¡œë”©)</sub>
=================================

##### ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¶”ì  ê°€ëŠ¥
- ìŠ¤í¬ë¦½íŠ¸
- `iframe`
- ì´ë¯¸ì§€
- ê¸°íƒ€ ë“±ë“±

##### ê´€ë ¨ ì´ë²¤íŠ¸
- `onload`
  - ë¦¬ì†ŒìŠ¤ ë¡œë“œ ì„±ê³µ
- `onerror`
  - ë¦¬ì†ŒìŠ¤ ë¡œë“œ ì‹¤íŒ¨

### ìŠ¤í¬ë¦½íŠ¸ ë¡œë”©

##### ì„œë“œíŒŒí‹° ìŠ¤í¬ë¦½íŠ¸ ë¡œë”© í›„ í•¨ìˆ˜ í˜¸ì¶œ
- ìŠ¤í¬ë¦½íŠ¸
  - ë™ì  ë¡œë“œ
- í•¨ìˆ˜
  - ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì™„ë£Œ í›„ í˜¸ì¶œ
```javascript
let script = document.createElement('script');
script.src = "my.js";

document.head.append(script);
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **ì£¼ì˜**

##### JS ëª¨ë“ˆ
- ì„œë“œíŒŒí‹° ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¯¸ì§€ì› ê°€ëŠ¥ì„± æœ‰

<br />

#### `script.onload`

##### `load` <sub>(ì´ë²¤íŠ¸)</sub>
- ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ Â· ì‹¤í–‰ í›„ ë°œìƒ
```javascript
let script = document.createElement('script');
script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
document.head.append(script);

// í•¸ë“¤ëŸ¬ ì„¤ì •
// - ë¡œë”© ìŠ¤í¬ë¦½íŠ¸ ë‚´ ë³€ìˆ˜ Â· í•¨ìˆ˜ ì‚¬ìš©
script.onload = function() {

  // lodash (ë¼ì´ë¸ŒëŸ¬ë¦¬) ìŠ¤í¬ë¦½íŠ¸
  // '_' (ë³€ìˆ˜) ìƒì„±
  alert( _.VERSION ); // ë¼ì´ë¸ŒëŸ¬ë¦¬ ë²„ì „
};
```

#### `script.onerror`

##### `error` <sub>(ì´ë²¤íŠ¸)</sub>
- ìŠ¤í¬ë¦½íŠ¸ ë¡œë”© ì‹¤íŒ¨ ì‹œ ë°œìƒ
  - `404` ì—ëŸ¬ <sub>(ìŠ¤í¬ë¦½íŠ¸ ë¶€ì¬)</sub>
  - ì„œë²„ ë¬¸ì œ ë°œìƒ <sub>(ì‚¬ìš© ë¶ˆê°€ëŠ¥)</sub>

##### `404` ì—ëŸ¬ <sub>(ìŠ¤í¬ë¦½íŠ¸ ë¶€ì¬)</sub>
- ë¯¸ì¡´ì¬ ìŠ¤í¬ë¦½íŠ¸ ìš”ì²­
```javascript
let script = document.createElement('script');

// ë¯¸ì¡´ì¬ ìŠ¤í¬ë¦½íŠ¸
script.src = "https://example.com/404.js";
document.head.append(script);

script.onerror = function() {

  // Error loading https://example.com/404.js
  alert("Error loading " + this.src);
};
```

##### ì°¸ê³ 
- HTTP ì—ëŸ¬ ìƒì„¸ ì •ë³´ X
  - `400`
  - `500`
  - ê¸°íƒ€ ë“±ë“±
- ë¡œë”© ì‹¤íŒ¨ë§Œ í™•ì¸

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **ì¤‘ìš”**

##### `on[loadÂ·error]` <sub>(ì´ë²¤íŠ¸)</sub>
- ë¡œë”© ì™¸ ì¶”ì  X
  - ì²˜ë¦¬
  - ì‹¤í–‰
  - ê¸°íƒ€ ë“±ë“±
- ë¡œë”© ì™¸ ì¶”ì  í•„ìš” ì‹œ
  - `window.onerror` <sub>(ì „ì—­ í•¸ë“¤ëŸ¬)</sub> ì‚¬ìš©

<br />

### ê¸°íƒ€ ë¦¬ì†ŒìŠ¤

##### `load` Â· `error` <sub>(ì´ë²¤íŠ¸)</sub>
- ì™¸ë¶€ ì†ŒìŠ¤ <sub>(`src` ì†ì„±)</sub> ìš”ì†Œ ëŒ€ìƒ ë°œìƒ
```javascript
let img = document.createElement('img');

// src (ì†ì„±)
// - ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ ì„¤ì •
img.src = "https://js.cx/clipart/train.gif";

img.onload = function() {
  alert(`Image loaded, size ${img.width}x${img.height}`);
};

img.onerror = function() {
  alert("Error occurred while loading image");
};
```

#### íŠ¹ì§• <sub>(ì—­ì‚¬ì  ì´ìœ )</sub>

##### ëŒ€ë‹¤ìˆ˜ ë¦¬ì†ŒìŠ¤ <sub>(ìš”ì†Œ)</sub>
- ë¬¸ì„œ ë‚´ ì¶”ê°€ ì‹œ ë¡œë“œ ì‹œì‘

##### `<img>` <sub>(ìš”ì†Œ)</sub>
- `src` <sub>(ì†ì„±)</sub> ì„¤ì • ì‹œ ë¡œë“œ ì‹œì‘

##### `<iframe>` <sub>(ìš”ì†Œ)</sub> `load Â· error` <sub>(ì´ë²¤íŠ¸)</sub>
- ë¡œë“œ ì™„ë£Œ ì‹œ ë°œìƒ

### Crossorigin ì •ì±…

##### ê·œì¹™
- í•œ ì‚¬ì´íŠ¸ ë‚´ ìŠ¤í¬ë¦½íŠ¸
  - íƒ€ ì‚¬ì´íŠ¸ ì½˜í…ì¸  ì ‘ê·¼ X
- í•œ origin <sub>(ë„ë©”ì¸ Â· í¬íŠ¸ Â· í”„ë¡œí† ì½œ)</sub>
  - íƒ€ origin ì½˜í…ì¸  ì ‘ê·¼ X
- ex\) `https://facebook.com` <sub>(ë‚´ ìŠ¤í¬ë¦½íŠ¸)</sub>
  - `https://gmail.com` ë‚´ ë©”ì¼ ì½ê¸° X
- ì„œë¸Œë„ë©”ì¸ Â· íƒ€ í¬íŠ¸
  - ê°ê° íƒ€ origin
    - ì„œë¡œì˜ ì½˜í…ì¸  ì ‘ê·¼ X
- í•œ origin
  - íƒ€ ë„ë©”ì¸ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ X

If we're using a script from another domain, and there's an error in it, we can't get error details.

For example, let's take a script `error.js` that consists of a single (bad) function call:
```javascript
// ğŸ“ error.js
noSuchFunction();
```

Now load it from the same site where it's located:
```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script src="/article/onload-onerror/crossorigin/error.js"></script>
```

We can see a good error report, like this:
```
Uncaught ReferenceError: noSuchFunction is not defined
https://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1
```

Now let's load the same script from another domain:
```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
```

The report is different, like this:
```
Script error.
, 0:0
```

Details may vary depending on the browser, but the idea is the same: any information about the internals of a script, including error stack traces, is hidden. Exactly because it's from another domain.

Why do we need error details?

There are many services (and we can build our own) that listen for global errors using `window.onerror`, save errors and provide an interface to access and analyze them. That's great, as we can see real errors, triggered by our users. But if a script comes from another origin, then there's not much information about errors in it, as we've just seen.

Similar cross-origin policy (CORS) is enforced for other types of resources as well.

**To allow cross-origin access, the `<script>` tag needs to have the `crossorigin` attribute, plus the remote server must provide special headers.**

There are three levels of cross-origin access:
1. No `crossorigin` attribute â€“ access prohibited.
2. `crossorigin="anonymous"` â€“ access allowed if the server responds with the header `Access-Control-Allow-Origin` with `*` or our origin. Browser does not send authorization information and cookies to remote server.
3. `crossorigin="use-credentials"` â€“ access allowed if the server sends back the header `Access-Control-Allow-Origin` with our origin and `Access-Control-Allow-Credentials: true`. Browser sends authorization information and cookies to remote server.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **ì£¼ì˜**

You can read more about cross-origin access in the chapter CORS. It describes the `fetch` method for network requests, but the policy is exactly the same.

Such thing as "cookies" is out of our current scope, but you can read about them in the chapter ì¿ í‚¤ì™€ document.cookie.

<br />

In our case, we didn't have any crossorigin attribute. So the cross-origin access was prohibited. Let's add it.

We can choose between `"anonymous"` (no cookies sent, one server-side header needed) and `"use-credentials"` (sends cookies too, two server-side headers needed).

If we don't care about cookies, then `"anonymous"` is the way to go:
```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script crossorigin="anonymous" src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
```

Now, assuming that the server provides an `Access-Control-Allow-Origin` header, everything's fine. We have the full error report.

<br />

## ìš”ì•½
Images `<img>`, external styles, scripts and other resources provide `load` and `error` events to track their loading:
- `load` triggers on a successful load,
- `error` triggers on a failed load.

The only exception is `<iframe>`: for historical reasons it always triggers `load`, for any load completion, even if the page is not found.

The `readystatechange` event also works for resources, but is rarely used, because `load`/`error` events are simpler.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> ê³¼ì œ

### Load images with a callback
Normally, images are loaded when they are created. So when we add `<img>` to the page, the user does not see the picture immediately. The browser needs to load it first.

To show an image immediately, we can create it "in advance", like this:
```javascript
let img = document.createElement('img');
img.src = 'my.jpg';
```

The browser starts loading the image and remembers it in the cache. Later, when the same image appears in the document (no matter how), it shows up immediately.

**Create a function `preloadImages(sources, callback)` that loads all images from the array `sources` and, when ready, runs `callback`.**

For instance, this will show an `alert` after the images are loaded:
```javascript
function loaded() {
  alert("Images loaded")
}

preloadImages(["1.jpg", "2.jpg", "3.jpg"], loaded);
```

In case of an error, the function should still assume the picture "loaded".

In other words, the `callback` is executed when all images are either loaded or errored out.

The function is useful, for instance, when we plan to show a gallery with many scrollable images, and want to be sure that all images are loaded.

In the source document you can find links to test images, and also the code to check whether they are loaded or not. It should output `300`.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The algorithm:
1. Make `img` for every source.
2. Add `onload`/`onerror` for every image.
3. Increase the counter when either `onload` or `onerror` triggers.
4. When the counter value equals to the sources count â€“ we're done: `callback()`.

[ìƒŒë“œë°•ìŠ¤ë¥¼ ì—´ì–´ ì •ë‹µì„ í™•ì¸í•´ë³´ì„¸ìš”.](https://plnkr.co/edit/M0qVEmqZnmYnFVIT?p=preview)
