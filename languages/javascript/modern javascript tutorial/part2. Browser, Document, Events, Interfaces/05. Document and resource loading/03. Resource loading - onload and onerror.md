`on[load·error]` <sub>(리소스 로딩)</sub>
=================================

##### 외부 리소스 로딩 추적 가능
- 스크립트
- `iframe`
- 이미지
- 기타 등등

##### 관련 이벤트
- `onload`
  - 리소스 로드 성공
- `onerror`
  - 리소스 로드 실패

### 스크립트 로딩

##### 서드파티 스크립트 로딩 후 함수 호출
- 스크립트
  - 동적 로드
- 함수
  - 스크립트 로드 완료 후 호출
```javascript
let script = document.createElement('script');
script.src = "my.js";

document.head.append(script);
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### JS 모듈
- 서드파티 라이브러리 미지원 가능성 有

<br />

#### `script.onload`

##### `load` <sub>(이벤트)</sub>
- 스크립트 로드 · 실행 후 발생
```javascript
let script = document.createElement('script');
script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
document.head.append(script);

// 핸들러 설정
// - 로딩 스크립트 내 변수 · 함수 사용
script.onload = function() {

  // lodash (라이브러리) 스크립트
  // '_' (변수) 생성
  alert( _.VERSION ); // 라이브러리 버전
};
```

#### `script.onerror`

##### `error` <sub>(이벤트)</sub>
- 스크립트 로딩 실패 시 발생
  - `404` 에러 <sub>(스크립트 부재)</sub>
  - 서버 문제 발생 <sub>(사용 불가능)</sub>

##### `404` 에러 <sub>(스크립트 부재)</sub>
- 미존재 스크립트 요청
```javascript
let script = document.createElement('script');

// 미존재 스크립트
script.src = "https://example.com/404.js";
document.head.append(script);

script.onerror = function() {

  // Error loading https://example.com/404.js
  alert("Error loading " + this.src);
};
```

##### 참고
- HTTP 에러 상세 정보 X
  - `400`
  - `500`
  - 기타 등등
- 로딩 실패만 확인

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **중요**

##### `on[load·error]` <sub>(이벤트)</sub>
- 로딩 외 추적 X
  - 처리
  - 실행
  - 기타 등등
- 로딩 외 추적 필요 시
  - `window.onerror` <sub>(전역 핸들러)</sub> 사용

<br />

### 기타 리소스

##### `load` · `error` <sub>(이벤트)</sub>
- 외부 소스 <sub>(`src` 속성)</sub> 요소 대상 발생
```javascript
let img = document.createElement('img');

// src (속성)
// - 외부 리소스 설정
img.src = "https://js.cx/clipart/train.gif";

img.onload = function() {
  alert(`Image loaded, size ${img.width}x${img.height}`);
};

img.onerror = function() {
  alert("Error occurred while loading image");
};
```

#### 특징 <sub>(역사적 이유)</sub>

##### 대다수 리소스 <sub>(요소)</sub>
- 문서 내 추가 시 로드 시작

##### `<img>` <sub>(요소)</sub>
- `src` <sub>(속성)</sub> 설정 시 로드 시작

##### `<iframe>` <sub>(요소)</sub> `load · error` <sub>(이벤트)</sub>
- 로드 완료 시 발생

### Cross-origin 정책

##### 규칙
- 한 사이트 내 스크립트
  - 타 사이트 콘텐츠 접근 X
- 한 오리진 <sub>(도메인 · 포트 · 프로토콜)</sub>
  - 타 오리진 콘텐츠 접근 X
- ex\) `https://facebook.com` <sub>(내 스크립트)</sub>
  - `https://gmail.com` 내 메일 읽기 X
- 서브도메인 · 타 포트
  - 각각 타 오리진
    - 서로의 콘텐츠 접근 X
- 한 오리진
  - 타 도메인 리소스 접근 X
- 타 도메인 스크립트 <sub>(에러 발생)</sub> 사용 시
  - 에러 상세 정보 접근 X

##### `error.js` <sub>(스크립트)</sub>
- 잘못된 함수 호출 구현
```javascript
/* 📁 error.js */
noSuchFunction();
```
- 동일 사이트 내 함수 <sub>(`error.js`)</sub> 호출
```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script src="/article/onload-onerror/crossorigin/error.js"></script>
```
- 에러 상세 정보
```
Uncaught ReferenceError: noSuchFunction is not defined
https://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1
```
- 타 도메인 내 함수 <sub>(`error.js`)</sub> 호출
```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
```
- 에러 상세 정보 X <sub>(브라우저별 상이)</sub>
```
Script error.
, 0:0
```

##### 수많은 서비스
- 전역 에러 처리 <sub>(`window.onerror`)</sub>
- 에러 저장
- 인터페이스 제공
  - 에러 접근 · 분석
- 실제 사용자 유발 에러
  - 분석 · 처리 · 대응
- 타 오리진 스크립트
  - 에러 내 상제 정보 X
    - 에러 분석 · 처리 X

##### 기타 리소스
- 동일 규칙 적용

##### cross-origin 접근 허용
- `<script>` <sub>(태그)</sub>
  - `crossorigin` <sub>(속성)</sub> 설정
- 원격 서버
  - 특수 헤더 제공

#### 과정

##### 1. `crossorigin` <sub>(속성)</sub> 부재
- 접근 거절

##### 2. `crossorigin="anonymous"`
- 원격 서버 헤더 응답 시
  - 접근 허용
```javascript
Access-Control-Allow-Origin: [*·오리진]
```
- 브라우저 → 원격 서버
  - 허가 정보 · 쿠키 미전송

##### 3. `crossorigin="use-credentials"`
- 원격 서버 헤더 <sub>(2개)</sub> 응답 시
  - 접근 허용
```javascript
Access-Control-Allow-Origin: 오리진
Access-Control-Allow-Credentials: true
```
- 브라우저 → 원격 서버
  - 허가 정보 · 쿠키 전송

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **주의**

##### CORS 챕터 참고
- `fetch` <sub>(메서드)</sub> 설명
  - 네트워크 요청 <sub>(동일 정책)</sub>

##### 쿠키
- 쿠키 챕터 참고

<br />

##### `crossorigin` <sub>(속성)</sub> 설정
- `"anonymous"`
  - 쿠키 미전송
  - 응답 헤더 1개 필요
- `"use-credentials"`
  - 쿠키 전송
  - 응답 헤더 2개 필요

##### `crossorigin="anonymous"` <sub>(속성)</sub> 설정
- 원격 서버 필요 헤더 함께 응답 시
  - 에러 상세 정보 접근 가능

```html
<script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script crossorigin="anonymous" src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
```

<br />

## 요약
Images `<img>`, external styles, scripts and other resources provide `load` and `error` events to track their loading:
- `load` triggers on a successful load,
- `error` triggers on a failed load.

The only exception is `<iframe>`: for historical reasons it always triggers `load`, for any load completion, even if the page is not found.

The `readystatechange` event also works for resources, but is rarely used, because `load`/`error` events are simpler.

<br />

## <img src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### Load images with a callback
Normally, images are loaded when they are created. So when we add `<img>` to the page, the user does not see the picture immediately. The browser needs to load it first.

To show an image immediately, we can create it "in advance", like this:
```javascript
let img = document.createElement('img');
img.src = 'my.jpg';
```

The browser starts loading the image and remembers it in the cache. Later, when the same image appears in the document (no matter how), it shows up immediately.

**Create a function `preloadImages(sources, callback)` that loads all images from the array `sources` and, when ready, runs `callback`.**

For instance, this will show an `alert` after the images are loaded:
```javascript
function loaded() {
  alert("Images loaded")
}

preloadImages(["1.jpg", "2.jpg", "3.jpg"], loaded);
```

In case of an error, the function should still assume the picture "loaded".

In other words, the `callback` is executed when all images are either loaded or errored out.

The function is useful, for instance, when we plan to show a gallery with many scrollable images, and want to be sure that all images are loaded.

In the source document you can find links to test images, and also the code to check whether they are loaded or not. It should output `300`.

<br />

<img src="../../images/commons/icons/circle-answer.svg" />

The algorithm:
1. Make `img` for every source.
2. Add `onload`/`onerror` for every image.
3. Increase the counter when either `onload` or `onerror` triggers.
4. When the counter value equals to the sources count – we're done: `callback()`.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/M0qVEmqZnmYnFVIT?p=preview)
