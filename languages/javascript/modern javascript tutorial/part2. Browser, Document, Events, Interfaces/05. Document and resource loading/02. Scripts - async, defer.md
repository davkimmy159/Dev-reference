`defer` · `async` 스크립트
====================

##### 모던 웹브라우저 상 대다수 스크립트
- HTML 보다 '무거움'
- 큰 용량
  - 다운로드 · 처리 시간 ↑

##### HTML 파싱 중 `<script [src="…"]>` <sub>(태그)</sub> 도달 시
- 스크립트 먼저 실행 · 로드
  - DOM 생성 일시 중단

#### 중요 이슈 발생 <sub>(부작용)</sub>

##### 1. 스크립트 아래 DOM 요소 접근 X <sub>(스크립트 내)</sub>
- 다양한 동작 수행 X
  - DOM 요소 핸들러 설정
  - 기타 등등

##### 2. 용량 큰 스크립트 <sub>(페이지 위쪽)</sub>
- 스크립트 의해 페이지 '막힘'
- 스크립트 로드 · 실행 전
  - 아래쪽 페이지 볼 수 없음
```html
<p> … 스크립트 앞 콘텐츠 … </p>

<script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- 스크립트 다운로드 및 실행 완료 전까지 아래 내용 안 보임 -->
<p> … 스크립트 뒤 콘텐츠 … </p>
```

##### 페이지 최하단 스크립트 위치 <sub>(우회 방법)</sub>
- 스크립트 위 요소 접근 가능
- 페이지 콘텐츠 출력 막기 X
```html
<body>
  … 스크립트 위 콘텐츠들 …

  // 스크립트 위치
  // - 문서 내 최하단
  <script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>
</body>
```

##### 아주 큰 HTML 문서
- HTML 문서 전체 로드 후 스크립트 로드 시
  - 페이지 로드 속도 ↓

### `defer` <sub>(속성)</sub>

##### 지연 <sub>(`defer`)</sub> 스크립트
- 백그라운드 다운로드 수행
  - HTML 파싱 중단 X
  - 페이지 생성 막기 X
- 스크립트 실행 지연
  - 페이지 구성 완료 전까지
```html
<p> … 스크립트 앞 콘텐츠 … </p>

<!-- defer (속성) 추가 -->
<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- 바로 볼 수 있네요! -->
<p> … 스크립트 뒤 콘텐츠 … </p>
```

##### 실행 시점
- DOM 준비 후
- `DOMContentLoaded` <sub>(이벤트)</sub> 발생 전
```html
<p> … 스크립트 앞 콘텐츠 … </p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("`defer` 스크립트가 실행된 후, DOM이 준비되었습니다!")); // (2)
</script>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<p> … 스크립트 뒤 콘텐츠 … </p>
```
1. 페이지 콘텐츠
    - 바로 출력
2. `DOMContentLoaded` <sub>(이벤트)</sub>
    - 지연 스크립트 실행 대기
- DOM 트리 완성 · 지연 스크립트 실행 후
  - 얼럿창 출력

##### 지연 스크립트 간 순서
- HTML 추가 순서
  - 상대순
  - 요소순

#####  긴 스크립트 앞 · 짧은 스크립트 뒤
- 짧은 스크립트
  - 긴 스크립트 실행 대기
```html
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **작은 스크립트 : 먼저 다운로드 · 나중 실행**

##### 브라우저 성능 고려
- 페이지 내 스크립트들 체크 후
  - 병렬적 다운로드 실행
- 다운로드 완료 순서
  1. 작은 파일 <sub>(`small.js`)</sub>
  2. 큰 파일 <sub>(`long.js`)</sub>
- 실행 순서 <sub>(문서 추가 순서 · 명세서 정의)</sub>
  1. 큰 파일 <sub>(`long.js`)</sub>
  2. 작은 파일 <sub>(`small.js`)</sub>

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`defer` <sub>(속성)</sub> : 외부 스크립트만 유효**

##### `src` <sub>(속성)</sub> 부재 `<script>`
- `defer` <sub>(속성)</sub> 무시

<br />

### `async` <sub>(속성)</sub>

##### 비동기 <sub>(`async`)</sub> 스크립트
- 페이지와 완전히 독립적으로 동작

- `async` 스크립트는 `defer` 스크립트와 마찬가지로 백그라운드에서 다운로드됩니다. 따라서 HTML 페이지는 `async` 스크립트 다운이 완료되길 기다리지 않고 페이지 내 콘텐츠를 처리, 출력합니다(하지만 `async` 스크립트 실행중에는 HTML 파싱이 멈춥니다 – 옮긴이).
- `DOMContentLoaded` 이벤트와 `async` 스크립트는 서로를 기다리지 않습니다.
  - 페이지 구성이 끝난 후에 `async` 스크립트 다운로딩이 끝난 경우, `DOMContentLoaded`는 `async` 스크립트 실행 전에 발생할 수 있습니다,
  - `async` 스크립트가 짧아서 페이지 구성이 끝나기 전에 다운로드 되거나 스크립트가 캐싱처리 된 경우, `DOMContentLoaded`는 `async` 스크립트 실행 후에 발생할 수도 있습니다.
- 다른 스크립트들은 `async` 스크립트를 기다리지 않습니다. `async` 스크립트 역시 다른 스크립트들을 기다리지 않습니다.

이런 특징 때문에 페이지에 `async` 스크립트가 여러 개 있는 경우, 그 실행 순서가 제각각이 됩니다. 실행은 다운로드가 끝난 스크립트 순으로 진행됩니다.
```html
<p>...스크립트 앞 콘텐츠...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("DOM이 준비 되었습니다!"));
</script>

<script async src="https://javascript.info/article/script-async-defer/long.js"></script>
<script async src="https://javascript.info/article/script-async-defer/small.js"></script>

<p>...스크립트 뒤 콘텐츠...</p>
```

1. 비동기 스크립트 다운로드는 페이지 로딩을 막지 않기 때문에 페이지 콘텐츠가 바로 출력됩니다.
2. `DOMContentLoaded` 이벤트는 상황에 따라 비동기 스크립트 전이나 후에 실행됩니다. 정확한 순서를 예측할 수 없습니다.
3. 비동기 스크립트는 서로를 기다리지 않습니다. 위치상으론 `small.js`가 아래이긴 하지만 `long.js`보다 먼저 다운로드되었기 때문에 먼저 실행됩니다. 이렇게 먼저 로드가 된 스크립트가 먼저 실행되는 것을 'load-first order'라고 부릅니다.

비동기 스크립트는 방문자 수 카운터나 광고 관련 스크립트처럼 각각 독립적인 역할을 하는 서드 파티 스크립트를 현재 개발 중인 스크립트에 통합하려 할 때 아주 유용합니다. `async` 스크립트는 개발 중인 스크립트에 의존하지 않고, 그 반대도 마찬가지이기 때문입니다.
```html
<!-- Google Analytics는 일반적으로 다음과 같이 삽입합니다. -->
<script async src="https://google-analytics.com/analytics.js"></script>
```

### 동적 스크립트
자바스크립트를 사용하면 문서에 스크립트를 동적으로 추가할 수 있습니다. 이렇게 추가한 스크립트를 동적 스크립트(dynamic script)라고 부릅니다.
```javascript
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script); // (*)
```

위 예시에서 외부 스크립트는 관련 요소가 문서에 추가되자 마자(`(*)`로 표시한 줄) 다운로드가 시작됩니다.

그런데 동적 스크립트는 기본적으로 `'async'` 스크립트처럼 행동합니다.

따라서 다음과 같은 특징을 갖습니다.
- 동적 스크립트는 그 어떤 것도 기다리지 않습니다. 그리고 그 어떤 것도 동적 스크립트를 기다리지 않습니다.
- 먼저 다운로드된 스크립트가 먼저 실행됩니다('load-first' order).

아래 예시에선 두 스크립트를 동적으로 문서에 추가합니다. 그런데 `script.async=false`가 없었다면 이 스크립트들은 'load-first order'로 실행됩니다. 그럼 크기가 작은 `small.js`가 먼저 실행되겠죠. 하지만 `script.async=false`가 있기 때문에 실행은 '문서에 추가된 순서'대로 됩니다.
```javascript
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.body.append(script);
}

// async=false이기 때문에 long.js가 먼저 실행됩니다.
loadScript("/article/script-async-defer/long.js");
loadScript("/article/script-async-defer/small.js");
```
<br />

## 요약
요약
`async`와 `defer` 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점이 있습니다. 따라서 `async`와 `defer`를 적절히 사용하면 사용자가 오래 기다리지 않고 페이지 콘텐츠를 볼 수 있게 할 수 있습니다.

두 스크립트의 차이점은 다음과 같습니다.

||순서|`DOMContentLoaded`|
|---|---|---|
|`async`|load-first order. 문서 내 순서와 상관없이 먼저 다운로드된 스크립트가 먼저 실행됩니다.|비동기 스크립트는 HTML 문서가 완전히 다운로드되지 않은 상태라도 로드 및 실행될 수 있습니다. 스크립트 크기가 작거나 캐싱 처리 되어있을 때 혹은 HTML 문서 길이가 아주 길 때 이런 일이 발생합니다.|
|`defer`|문서에 추가된 순|지연 스크립트는 문서 다운로드와 파싱이 완료된 후에, `DOMContentLoaded` 이벤트 발생 전에 실행됩니다.|

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **스크립트 다운로드가 끝나지 않았어도 페이지는 동작해야 합니다.**

`defer`를 사용하게 되면 스크립트가 실행되기 전 에 페이지가 화면에 출력된다는 점에 항상 유의해야 합니다.

사용자는 그래픽 관련 컴포넌트들이 준비되지 않은 상태에서 화면을 보게 될 수 있죠.

따라서 지연 스크립트가 영향을 주는 영역엔 반드시 '로딩 인디케이터'가 있어야 합니다. 관련 버튼도 사용 불가(disabled) 처리를 해줘야 하죠. 이렇게 해야 사용자에게 현재 어떤 것은 사용할 수 있는지, 어떤 것은 사용할 수 없는지를 알려줄 수 있습니다.

<br />

실무에선 `defer`를 DOM 전체가 필요한 스크립트나 실행 순서가 중요한 경우에 적용합니다. `async`는 방문자 수 카운터나 광고 관련 스크립트같이 독립적인 스크립트에 혹은 실행 순서가 중요하지 않은 경우에 적용합니다.

![image-1](../../images/02/05/02/image-1.png)
![image-2](../../images/02/05/02/image-2.png)
