커스텀 이벤트 디스패치
====================

##### 커스텀 이벤트
- 새 이벤트 직접 생성 가능
- 그래픽 컴포넌트 생성 시 사용
- ex\) 메뉴 <sub>(루트 요소)</sub>
  - `open` <sub>(이벤트)</sub>
    - 메뉴 열기 시 발생
  - `select` <sub>(이벤트)</sub> 
    - 항목 선택 시 발생

##### 내장 이벤트
- 직접 생성 기능
- 테스팅 자동화 용이
- ex\)
  - `click`
  - `mousedown`
  - 기타 등등

### `Event` 생성자 

##### 내장 이벤트 클래스
- 계층 구조 형성
  - DOM 요소 클래스 유사
- 최상위
  - [`Event`](https://dom.spec.whatwg.org/#event) <sub>(클래스)</sub>

#### `Event` <sub>(생성자 함수)</sub>
```javascript
let event = new Event(type[, options]);
```

##### `type`
- 이벤트 타입 <sub>(문자열)</sub>
  - 내장 이벤트 <sub>(`"click"` 등)</sub>
  - 커스텀 이벤트 <sub>(`"my-event"` 등)</sub>

##### `options` <sub>(객체)</sub>
- `bubbles` <sub>(`boolean` · 선택)</sub>
  - 이벤트 버블링 여부
  - 기본값 : `false`
- `cancelable` <sub>(`boolean` · 선택)</sub>
  - 기본 동작 막기 여부
  - 기본값 : `false`

### `dispatchEvent`

##### 이벤트 실행
- 이벤트 <sub>(객체)</sub> 생성 후
  - `elem.dispatchEvent(event)` 호출
  - 미호출 시
    - 핸들러 반응 X

##### `click` <sub>(이벤트)</sub> 생성 · 실행
- 이벤트 핸들러 동작
- 실제 버튼 클릭 X
```html
<button id="elem" onclick="alert('클릭!');">자동으로 클릭 되는 버튼</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
```

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`event.isTrusted`**

##### 사용자 액션 여부
- `true`
  - 사용자 액션 통해 생성
- `false`
  - 스크립트 통해 생성

<br />

### 커스텀 이벤트 버블링

##### 커스텀 이벤트 생성
- 이벤트명
  - `'hello'`
- 버블링 활성화
  - `bubbles: true`
- 이벤트 처리
  - `document`
```html
<h1 id="elem">Hello from the script!</h1>

<script>
  /*
   버블링 발생
   - document : 이벤트 처리
   on<event> (문법)
   - 내장 이벤트 전용
   - 커스텀 이벤트
     - 비정상 동작
       - ex) document.onhello
     - addEventListener (메서드) 사용
   */
  document.addEventListener("hello", function(event) {

    // Hello from H1
    alert("Hello from " + event.target.tagName);
  });

  /*
   hello (이벤트) 생성
   - elem (요소) : 이벤트 디스패치
   `bubbles: true` 명시 X
   - 이벤트 버블링 X
  let event = new Event("hello", { bubbles: true });
  elem.dispatchEvent(event);

  // document 할당 핸들러 동작
  // - 메시지 얼럿창 출력
</script>
```

##### 내장 · 커스텀 이벤트
- 버블링 메커니즘 동일
  - 캡쳐링 · 버블링 단계 포함

### 다양한 이벤트

#### [UI 이벤트](https://www.w3.org/TR/uievents/) 섹션 <sub>(명세서)</sub>

##### 다양한 UI 이벤트 클래스 명시
- `UIEvent`
- `FocusEvent`
- `MouseEvent`
- `WheelEvent`
- `KeyboardEvent`
- 기타 등등

##### 관련 내장 클래스 사용
- ex\) `new MouseEvent("click")`
- `new Event` X
  - 전용 표준 프로퍼티 X
  
##### `new MouseEvent("click")`
- 전용 표준 프로퍼티 설정
  - `clientX`
  - `clientY`
```javascript
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
```

##### `new Event("click")`
- 전용 표준 프로퍼티 X
```javascript
let event = new Event("click", {
  bubbles: true,    // O
  cancelable: true, // O
  clientX: 100,     // X
  clientY: 100      // X
});

// 알 수없든 프로퍼티 무시
alert(event.clientX); // undefined

// 우회
// - 프로퍼티 값 직접 명시 가능
event.clientX = 100;
```

##### 브라우저 생성 UI 이벤트
- 정확한 이벤트 타입 필수

##### UI 이벤트별 표준 프로퍼티 목록
- 명세서 확인
  - ex\) [`MouseEvent`](https://www.w3.org/TR/uievents/#mouseevent)

### 커스텀 이벤트

##### [`CustomEvent`](https://dom.spec.whatwg.org/#customevent)
- `Event` 거의 유사
- 2번째 인수 <sub>(객체)</sub>
  - `detail` <sub>(프로퍼티)</sub>
    - 커스텀 이벤트 정보 명시 · 전달
```html
<h1 id="elem">이보라님, 환영합니다!</h1>

<script>
  // 추가 정보는 이벤트와 함께 핸들러에 전달됩니다.
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "보라" }
  }));
</script>
```

##### `detail` <sub>(프로퍼티)</sub>
- 모든 타입 데이터 가능
- 타 이벤트 프로퍼티 충돌 방지
  - `new Event` 객체 내 `detail`
    - 충도 가능성 有
- `new CustomEvent` <sub>(생성자 함수)</sub>
  - 코드 자체
    - '커스텀 이벤트' 설명

### `event.preventDefault()`
브라우저 이벤트 대다수는 '기본 동작'과 함께 실행됩니다. 링크 클릭 시 특정 URL로 이동하기, 전송 버튼 클릭 시 서버에 폼 전송하기 같은 동작은 이런 기본 동작의 대표적인 예입니다.

우리가 직접 만든 커스텀 이벤트에는 당연히 기본 동작이 없습니다. 하지만 커스텀 이벤트를 만들고 디스패칭 해 주는 코드에 원하는 동작을 넣으면, 커스텀 이벤트에도 기본 동작을 설정해줄 수 있습니다.

이벤트 기본 동작은 `event.preventDefault()`를 호출해 취소할 수 있습니다. `event.preventDefault()`를 호출하면 이벤트 핸들러는 기본 동작이 취소되어야 한다는 신호를 보내기 때문입니다.

이벤트 기본동작이 취소되면 `elem.dispatchEvent(event)` 호출 시 `false`가 반환됩니다. 해당 이벤트를 디스패치 하는 코드에선 이를 통해 기본동작이 취소되어야 한다는 것을 인지합니다.

토끼 숨기기 예시를 통해 지금까지 배운 내용을 직접 실습해봅시다. 참고로 이 예시는 메뉴 숨기기 등으로 응용 가능합니다.

예시엔 `id`가 `rabbit`인 요소, `"hide"` 이벤트를 실행시키는 함수 `hide()`가 있습니다. `hide()`는 다른 코드들이 이벤트 실행 여부를 알 수 있게 해줍니다.

`rabbit.addEventListener('hide',...)`를 사용하면 어떤 핸들러에서도 `"hide"`를 리스닝 할 수 있습니다. 그리고 필요하다면 `event.preventDefault()`를 사용해 `"hide"` 이벤트의 기본 동작을 취소할 수 있습니다. 이렇게 기본동작이 취소되면 토끼가 화면에서 사라지지 않습니다.
```html
<pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<button onclick="hide()">hide()를 호출해 토끼 숨기기</button>

<script>
  // hide() will be called automatically in 2 seconds
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // cancelable를 true로 설정하지 않으면 preventDefault가 동작하지 않습니다.
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('기본 동작이 핸들러에 의해 취소되었습니다.');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("preventDefault를 호출하시겠습니까?")) {
      event.preventDefault();
    }
  });
</script>
```

![event-preventDefault](../../images/02/02/05/event-preventDefault.png)

예시에서 주의 깊게 봐야 할 점은 `cancelable: true`입니다. `event.preventDefault()`가 제대로 동작하게 하려면 이벤트 `hide`의 `cancelable`을 반드시 `true`로 지정해줘야 합니다. 그렇지 않으면 `event.preventDefault()`가 무시됩니다.

### 이벤트 안 이벤트
이벤트는 대게 큐에서 처리됩니다. 따라서 브라우저가 `onclick` 이벤트를 처리하고 있는데 마우스를 움직여서 새로운 이벤트를 발생시키면 이 이벤트에 상응하는 `mousemove` 핸들러는 `onclick` 이벤트 처리가 끝난 후에 호출됩니다.

그런데 이벤트 안 `dispatchEvent` 처럼 이벤트 안에 다른 이벤트가 있는 경우엔 위와 같은 규칙이 적용되지 않습니다. 이벤트 안에 있는 이벤트는 즉시 처리됩니다. 새로운 이벤트 핸들러가 호출되고 난 후에 현재 이벤트 핸들링이 재개됩니다.

예시를 살펴봅시다. `menu-open` 이벤트는 `onclick` 이벤트가 처리되는 도중에 트리거됩니다.

`menu-open` 이벤트 처리는 `onclick` 핸들러가 끝날 때까지 기다리지 않고 바로 처리됩니다.
```html
<button id="menu">메뉴(클릭해주세요)</button>

<script>
  menu.onclick = function() {
    alert(1);

    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  // 1과 2 사이에 트리거됩니다
  document.addEventListener('menu-open', () => alert('중첩 이벤트'));
</script>
```

![event-in-event](../../images/02/02/05/event-in-event.png)

얼럿창에 '1', '중첩 이벤트', '2'가 차례대로 출력되는 것을 확인할 수 있습니다.

이 예시에서 주목해야 할 것은 중첩 이벤트 `menu-open`이 `document`에 할당된 핸들러에서 처리된다는 점입니다. 중첩 이벤트의 전파와 핸들링이 외부 코드(`onclick`)의 처리가 다시 시작되기 전에 끝났습니다.

이런 일은 중첩 이벤트가 `dispatchEvent`일 때뿐만 아니라 이벤트 핸들러 안에서 다른 이벤트를 트리거 하는 메서드를 호출할 때 발생합니다. 즉, 이벤트 안 이벤트는 동기적으로 처리되는 것이죠.

그런데 때에 따라 중첩 이벤트가 동기적으로 처리되는걸 원치 않는 경우도 있기 마련입니다. 위 예시에서 `menu-open`이벤트나 다른 이벤트의 처리 여부와 상관없이 `onclick` 이벤트를 먼저 처리하려면 어떻게 해야 할까요?

`onclick` 끝에 `dispatchEvent` 등의 이벤트 트리거 호출을 넣는 게 하나의 방법이 될 수 있습니다. 이에 더하여 중첩 이벤트를 지연시간이 `0`인 `setTimeout`으로 감싸는 것도 방법입니다.
```html
<button id="menu">Menu (click me)</button>

<script>
  menu.onclick = function() {
    alert(1);

    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('중첩 이벤트'));
</script>
```

이제 원하는 대로 `dispatchEvent`가 `mouse.onclick`을 포함한 현재 코드 실행이 종료된 이후에 실행됩니다. 이벤트 핸들러들이 완전히 독립적으로 되었네요.

출력 순서는 '1', '2', '중첩 이벤트'입니다.

<br />

## 요약
코드를 사용해 이벤트를 직접 생성하려면 먼저 이벤트 <sub>(객체)</sub>를 만들어야 합니다.

범용적으로 쓰이는 `Event(name, options)` 클래스의 생성자는 임의의 이벤트 이름과 두 개의 프로퍼티가 있는 `options`라는 객체를 받습니다.
- `bubbles: true` 이면 이벤트는 버블링됩니다.
- `cancelable: true` 이면 `event.preventDefault()`가 동작합니다.

이 외에 `MouseEvent`, `KeyboardEvent` 같은 네이티브 이벤트 클래스의 생성자들은 이벤트 특유의 프로퍼티를 받습니다. 마우스 이벤트의 `clientX`가 대표적인 예입니다.

이벤트를 직접 만드는 경우라면 `CustomEvent` 생성자를 써야 합니다. `CustomEvent` 생성자엔 `detail`이라는 추가 프로퍼티를 명시할 수 있는데, 여기에 이벤트 관련 정보를 저장해야 합니다. 이렇게 하면 모든 핸들러에서 `event.detail`을 통해 커스텀 이벤트의 정보를 알 수 있습니다.

커스텀 이벤트의 이름을 `click`나 `keydown` 같이 브라우저 내장 이벤트처럼 지을 수 있긴 한데, 이런 경우엔 아주 조심해야 합니다.

되도록이면 내장 이벤트와 같은 이름을 가진 브라우저 이벤트를 만들지 말도록 합시다. 대부분의 경우 설계 관점에서 아주 좋지 않은 영항을 끼치기 때문입니다.

그렇지만 이런 경우에는 브라우저 이벤트를 만드는게 불가피 하니, 사용해도 괜찮습니다.
- 서드파티 라이브러리가 제대로 동작하게 하려면 꼭 필요한 경우. 네이티브 이벤트를 만드는 것 이 외에는 서드파티 라이브러리와 상호작용할 수 있는 수단이 없는 경우엔 괜찮습니다.
- 테스팅을 자동화 하려는 경우. '버튼 클릭'등의 이벤트를 사용자 동작 없이 코드만으로 유발시키고 제대로 동작하는지 그 결과를 확인하고자 할 때는 괜찮습니다.

네이티브 이벤트 이름과 겹치지 않게 커스텀 이벤트를 만드는 것은 설계 측면에서 자주 쓰이는 전략입니다. 커스텀 이벤트를 응용하면 메뉴나 사이드바, 캐러셀 등의 안에서 발생하는 일을 알려줄 수 있습니다.
