버블링 · 캡처링
==============

##### `<div>` <sub>(요소)</sub> 할당 이벤트 핸들러
- 중첩 태그 클릭에도 동작
  - `<em>` <sub>(요소)</sub>
  - `<code>` <sub>(요소)</sub>
  - 기타 등등
```html
<div onclick="alert('div에 할당한 핸들러!')">
  <em><code>EM</code>을 클릭했는데도 <code>DIV</code>에 할당한 핸들러가 동작합니다.</em>
</div>
```

![clicked-em-but-div](../../images/02/02/02/clicked-em-but-div.png)

이상하지 않나요? `<em>`을 클릭했는데 왜 `<div>`에 할당한 핸들러가 동작하는 걸까요?

### 버블링

##### 원리
1. 한 요소 이벤트 발생
2. 해당 요소 할당 핸들러 동작
3. 부모 요소 핸들러 동작
4. 최상단 조상 요소 만날 때까지 과정 반복
    - 각 요소 할당된 핸들러 동작

##### 중첩 구조
- 요소 3개
  - `FORM > DIV > P`
  - 각각 이벤트 핸들러 할당
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

![bubbling](../../images/02/02/02/bubbling.png)

##### 가장 안쪽 `<p>` <sub>(요소)</sub> 클릭 시
1. `<p>` <sub>(요소)</sub> 할당 핸들러 <sub>(`onclick`)</sub> 동작
2. 바깥 `<div>` <sub>(요소)</sub> 할당 핸들러 동작
3. 그 바깥 `<form>` <sub>(요소)</sub> 할당 핸들러 동작
4. 각 요소 할당된 핸들러 <sub>(`onclick`)</sub> 동작
    - `document` <sub>(객체)</sub> 만날 때까지

![event-order-bubbling](../../images/02/02/02/event-order-bubbling.svg)

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **거의 모든 이벤트 : 버블링 발생**

##### 일부 이벤트 <sub>(`focus` 등)</sub>
- 버블링 미발생

<br />

### `event.target`

##### 부모 요소 핸들러
- 이벤트 발생 위치 관련 상세 정보 접근 가능

##### target <sub>(요소)</sub>
- 이벤트 발생한 가장 안쪽 요소
- `event.target` 사용해 접근

##### `event.target` · `this` <sub>(`event.currentTarget`)</sub>
- `event.target`
  - '타깃' 요소
    - 실제 이벤트 발생 지점
  - 버블링 진행 시
    - 참조 요소 변경 X
- `this`
  - '현재' 요소
  - 현재 실행 중인 핸들러 할당 요소 참조

#### 예시
- 할당 핸들러 하나 <sub>(`form.onclick`)</sub>
  - 폼 내 모든 요소 발생 클릭 이벤트 처리
- `<form>` <sub>(요소)</sub> 까지 이벤트 버블링 진행
  - 핸들러 실행

##### `form.onclick` <sub>(핸들러)</sub>
- `event.target`
  - 폼 안쪽 실제 클릭한 요소
- `this` <sub>(`event.currentTarget`)</sub>
  - `<form>` <sub>(요소)</sub>
- `event.target` == `this` <sub>(`event.currentTarget`)</sub>
  - `<form>` <sub>(요소)</sub> 정확히 클릭

##### 결과
![event-target](../../images/02/02/02/event-target.png)

```html
<!-- index.html -->
<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="example.css">
</head>

<body>
  클릭하면 <code>event.target</code>과 <code>this</code>정보를 볼 수 있습니다.

  <form id="form">FORM
    <div>DIV
      <p>P</p>
    </div>
  </form>

  <script src="script.js"></script>
</body>
</html>
```
```javascript
/* script.js */
form.onclick = function(event) {
  event.target.style.backgroundColor = 'yellow';

  // 크롬 (브라우저)
  // - 노란색 칠하는데 약간의 시간 필요
  setTimeout(() => {
    alert("target = " + event.target.tagName + ", this=" + this.tagName);
    event.target.style.backgroundColor = ''
  }, 0);
};
```
```css
/* example.css */
form { background-color: green; position: relative; width: 150px; height: 150px; text-align: center; cursor: pointer; }
div { background-color: blue; position: absolute; top: 25px; left: 25px; width: 100px; height: 100px; }
p { background-color: red; position: absolute; top: 25px; left: 25px; width: 50px; height: 50px; line-height: 50px; margin: 0; }
body { line-height: 25px; font-size: 16px; }
```

### 버블링 중단하기

##### 이벤트 버블링
- 타깃 이벤트 → `document` <sub>(객체)</sub>
  - 각 노드 모두 발생

##### 몇몇 이벤트
- 타깃 이벤트 → `window` <sub>(객체)</sub>
  - 모든 핸들러 호출

##### `event.stopPropagation()` <sub>(메서드)</sub>
- 핸들러 : 이벤트 완전히 처리 후
  - 버블링 중단

##### `<button>` <sub>(요소)</sub> 클릭 시
- `body.onclick` 동작 X
```html
<body onclick="alert(`버블링은 여기까지 도달하지 못합니다.`)">
  <button onclick="event.stopPropagation()">클릭해 주세요.</button>
</body>
```

![cancelling-bubbling](../../images/02/02/02/cancelling-bubbling.png)

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **`event.stopImmediatePropagation()` <sub>(메서드)</sub>**

##### 한 요소 특정 이벤트 : 다수 핸들러 처리 상황
- 핸들러 중 하나 버블링 중단
  - 나머지 핸들러 여전히 동작

##### `event.stopPropagation()` <sub>(메서드)</sub>
- 버블링 중단
- 다른 핸들러들 동작 중단 X

##### `event.stopImmediatePropagation()` <sub>(메서드)</sub>
- 버블링 중단
- 다른 핸들러들 동작 중단

<br />

<img src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **버블링 막지 말기 <sub>(필요한 경우 제외)</sub>**

##### 아키텍처 신중히 고려
- 진짜 막아야 하는 상황에서만 버블링 막기

##### `event.stopPropagation()` <sub>(메서드)</sub>
- 추후 문제될 상황 유발 가능

#### 문제될만한 시나리오

##### 1. 중첩 메뉴
- 각 서브 메뉴 해당 요소
  - 클릭 이벤트 처리
- 상위 메뉴 클릭 이벤트 핸들러
  - `stopPropagation` 적용 <sub>(동작 X)</sub>

##### 2. 행동 패턴 분석 <sub>(사람들 페이지 내 클릭 위치 등)</sub>
- window 내 발생 클릭 이벤트 전부 감지
  - 실제 일부 분석 시스템 분석 방식
```javascript
document.addEventListener('click'…)`
```

##### 3. 버블링 막힌 영역 <sub>(`stopPropagation`)</sub>
- 분석 시스템 코드 동작 X
  - 분석 제대로 실행 X
  - '죽은 영역'

##### 이벤트 버블링 막아야 하는 경우
- 거의 없음
- 버블링 막아야 해결되는 문제
  - 커스텀 이벤트 등 사용해 문제 해결

##### 다른 이벤트 버블링 통ㅈㆍ기
- 핸들러 `event` <sub>(객체)</sub>
  - 데이터 저장 후 다른 핸들러 접근 허용
  - 아래쪽 일 : 부모 요소 핸들러 전달

<br />

### 캡처링

##### 표준 [DOM 이벤트](https://www.w3.org/TR/DOM-Level-3-Events/) 정의 이벤트 흐름 <sub>(3가지 단계)</sub>
- 캡처링 단계
  - 이벤트 : 하위 요소 전파
- 타깃 단계
  - 이벤트 : 실제 타깃 요소 전달
- 버블링 단계
  - 이벤트 : 상위 요소 전파

##### 테이블 안 `<td>` <sub>(요소)</sub> 클릭
1. 캡쳐링 단계
    - 이벤트 전파 <sub>(최상위 조상 → 아래쪽)</sub>
2. 타깃 단계
    - 이벤트 도착 · 실행 <sub>(타깃 요소)</sub>
3. 버블링 단계
    - 이벤트 전파 <sub>(다시 위쪽)</sub>

![eventflow](../../images/02/02/02/eventflow.svg)

##### 캡처링 단계
- **이용 경우 흔치 않음**

##### 3가지 이벤트 할당 방식

- 캡처링 미인식
- 타깃 · 버블링 단계만 동작
`on<event>` <sub>(프로퍼티)</sub> · HTML 속성, `addEventListener(event, handler)`를 이용해 할당된 핸들러는 캡처링에 대해 전혀 알 수 없습니다. 이 핸들러들은 두 번째 혹은 세 번째 단계의 이벤트 흐름(타깃 단계와 버블링 단계)에서만 동작합니다.

캡처링 단계에서 이벤트를 잡아내려면 `addEventListener`의 `capture` 옵션을 `true`로 설정해야 합니다.
```javascript
elem.addEventListener(..., {capture: true})
// 아니면, 아래 같이 {capture: true} 대신, true를 써줘도 됩니다.
elem.addEventListener(..., true)
```
`capture` 옵션은 두 가지 값을 가질 수 있습니다.
- `false`이면(default 값) 핸들러는 버블링 단계에서 동작합니다.
- `true`이면 핸들러는 캡처링 단계에서 동작합니다.

공식적으론 총 3개의 이벤트 흐름이 있지만, 이벤트가 실제 타깃 요소에 전달되는 단계인 '타깃 단계'(두 번째 단계)는 별도로 처리되지 않습니다. 캡처링과 버블링 단계의 핸들러는 타깃 단계에서 트리거됩니다.

아래 예시를 통해 캡처링과 버블링에 대해 살펴보도록 합시다.
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`캡쳐링: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`버블링: ${elem.tagName}`));
  }
</script>
```

![capturing](../../images/02/02/02/capturing.png)

이 예시는 문서 내 요소 '전체'에 핸들러를 할당해서 어떤 핸들러가 동작하는지를 보여줍니다.

`<p>`를 클릭하면 다음과 같은 순서로 이벤트가 전달됩니다.
1. `HTML` → `BODY` → `FORM` → `DIV` (캡처링 단계, 첫 번째 리스너)
2. `P` (타깃 단계, 캡쳐링과 버블링 둘 다에 리스너를 설정했기 때문에 두 번 호출됩니다.)
3. `DIV` → `FORM` → `BODY` → `HTML` (버블링 단계, 두 번째 리스너)

`event.eventPhase` 프로퍼티를 이용하면 현재 발생 중인 이벤트 흐름의 단계를 알 수 있습니다. 반환되는 정숫값에 따라 이벤트 흐름의 현재 실행 단계를 구분할 수 있죠. 하지만 핸들러를 통해 흐름 단계를 알 수 있기 때문에 이 프로퍼티는 자주 사용되지 않습니다.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **핸들러를 제거할 때 `removeEventListener`가 같은 단계에 있어야 합니다.**

`addEventListener(..., true)`로 핸들러를 할당해 줬다면, 핸들러를 지울 때, `removeEventListener(..., true)`를 사용해 지워야 합니다. 같은 단계에 있어야 핸들러가 지워집니다.

<br />

<img src="../../images/commons/icons/circle-exclamation-solid.svg" /> **같은 요소와 같은 단계에 설정한 리스너는 설정한 순서대로 동작합니다.**

특정 요소에 `addEventListener`를 사용해 한 단계에 이벤트 핸들러를 여러개 설정했다면 이 핸들러들은 설정한 순서대로 동작합니다.
```javascript
elem.addEventListener("click", e => alert(1)); // 첫 번째로 트리거됩니다.
elem.addEventListener("click", e => alert(2));
```

<br />

## 요약
이벤트가 발생하면 이벤트가 발생한 가장 안쪽 요소가 '타깃 요소(`event.target`)'가 됩니다.

- 이벤트는 `document`에서 시작해 DOM 트리를 따라 `event.target`까지 내려갑니다. 이벤트는 트리를 따라 내려가면서 `addEventListener(..., true)`로 할당한 핸들러를 동작시킵니다. `addEventListener(..., true)`의 `true`는 `{capture: true}`의 축약형입니다.
- 이후 타깃 요소에 설정된 핸들러가 호출됩니다.
- 이후엔 이벤트가 `event.target`부터 시작해서 다시 최상위 노드까지 전달되면서 각 요소에 `on<event>`로 할당한 핸들러와 `addEventListener`로 할당한 핸들러를 동작시킵니다. `addEventListener`로 할당한 핸들러 중, 세 번째 인수가 없거나 `false`, `{capture: false}`인 핸들러만 호출됩니다.

각 핸들러는 아래와 같은 `event` 객체의 프로퍼티에 접근할 수 있습니다.
- `event.target` – 이벤트가 발생한 가장 안쪽의 요소
- `event.currentTarget` (=`this`) – 이벤트를 핸들링 하는 현재 요소 (핸들러가 실제 할당된 요소)
- `event.eventPhase` – 현재 이벤트 흐름 단계(캡처링=1, 타깃=2, 버블링=3)

핸들러에서 `event.stopPropagation()`을 사용해 이벤트 버블링을 멈출 수 있습니다. 다만, 이 방법은 추천하지 않습니다. 지금은 상위 요소에서 이벤트가 어떻게 쓰일지 확실치 않더라도, 추후에 버블링이 필요한 경우가 생기기 때문입니다.

캡처링 단계는 거의 쓰이지 않고, 주로 버블링 단계의 이벤트만 다뤄집니다. 이렇게 된 데는 논리적 배경이 있습니다.

현실에서 사고가 발생하면 지역 경찰이 먼저 사고를 조사합니다. 그 지역에 대해 가장 잘 아는 기관은 지역 경찰이기 때문입니다. 추가 조사가 필요하다면 그 이후에 상위 기관이 사건을 넘겨받습니다.

이벤트 핸들러도 이와 같은 논리로 만들어졌습니다. 특정 요소에 할당된 핸들러는 그 요소에 대한 자세한 사항과 무슨 일을 해야 할지 가장 잘 알고 있습니다. `<td>`에 할당된 핸들러는 `<td>`에 대한 모든 것을 알고 있기 때문에 `<td>`를 다루는데 가장 적합합니다. 따라서 `<td>`를 다룰 기회를 이 요소에 할당된 핸들러에게 가장 먼저 주는 것입니다.

버블링과 캡처링은 '이벤트 위임(event delegation)'의 토대가 됩니다. 이벤트 위임은 강력한 이벤트 핸들링 패턴입니다. 다음 챕터에서 이를 다루도록 하겠습니다.
