브라우저 이벤트 소개
================

##### 이벤트 <sub>(event)</sub>
- 무언가 일어났다는 신호
- 모든 DOM 노드 생성
- DOM 한정 개념 X

#### 주요 DOM 이벤트

##### 마우스 이벤트
- `click`
  - 요소 위 마우스 좌측 버튼 클릭 · 탭
- `contextmenu`
  - 요소 위 마우스 우측 버튼 클릭
- `mouse[over·out]`
  - 요소 위 · 밖 마우스 커서 이동
- `mouse[down·up]`
  - 요소 위 마우스 좌측 버튼 누르기 · 때기
- `mousemove`
  - 마우스 이동

##### 폼 요소 이벤트
- `submit`
  - 사용자 `<form>` 제출
- `focus`
  - 사용자 폼 요소 <sub>(`<input>` 등)</sub> 포커스

##### 키보드 이벤트
- `key[down·up]`
  - 사용자 키보드 버튼 누르기 · 때기

##### 문서 이벤트
- `DOMContentLoaded`
  - HTML 전부 로드 · 처리 후
    - DOM 생성 완료

##### CSS 이벤트
- `transitionend`
  - CSS 애니메이션 종료

##### 이 외 다양한 이벤트 존재
- 기타 등등

### 이벤트 핸들러 <sub>(habdler)</sub>
- 이벤트 발생 시 실행 함
- 사용자 행동 대응 반응 JS 코드
- 여러 할당 방법 존재

#### HTML 속성 <sub>(할당)</sub>
- HTML 내 `on<event>` <sub>(속성)</sub>

##### ex&#41; `<input>` <sub>(태그)</sub>
- `onclick` <sub>(속성)</sub>
  - `click` <sub>(핸들러)</sub> 할당
```html
<!--
버튼 클릭 시
- `onclick` (핸들러) 코드 실행
-->
<input value="클릭해 주세요." onclick="alert('클릭!')" type="button">
```

##### 속성값 내 따옴표 주의
- 속성값 전체 : `""` <sub>(큰 따옴표)</sub>
  - `''` <sub>(작은 따옴표)</sub> 사용
  - `""` <sub>(큰 따옴표)</sub> 사용 시 작동 X
```javascript 
onclick="alert("클릭!")"
```

##### 긴 코드
- HTML 속성값 X
- 함수 생성 후 호출

##### 버튼 클릭 시 `countRabbits()` <sub>(함수)</sub> 호출
```html
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert(`토끼 ${i}마리`);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="토끼를 세봅시다!">
```

![count-rabbits](../../images/02/02/01/count-rabbits.png)

##### 대 · 소문자 구분 X
- `ONCLICK` == `onClick` == `onCLICK`
- 대개 소문자 작성
  - `onclick`

#### DOM 프로퍼티
- `on<event>` <sub>(DOM 프로퍼티)</sub>

##### `elem.onclick`
```html
<input id="elem" type="button" value="클릭해 주세요.">
<script>
  elem.onclick = function() {
    alert('감사합니다.');
  };
</script>
```

![onclick](../../images/02/02/01/onclick.png)

##### 두 방법 동일 작동
1. HTML 속성 할당
2. 속성값 이용해 새 함수 생성
3. 생성된 새 함수 → DOM 프로퍼티

##### 1. HTML만 사용
```html
<!-- button.onclick 초기화 -->
<input type="button" onclick="alert('클릭!')" value="클릭해 주세요.">
```

![onclick](../../images/02/02/01/onclick.png)

2. HTML · JS 함께 사용
```html
<input type="button" id="button" value="클릭해 주세요.">
<script>
  button.onclick = function() {
    alert('클릭!');
  };
</script>
```

![onclick](../../images/02/02/01/onclick.png)

##### `onclick` <sub>(프로퍼티)</sub>
- 단 하나 존재
  -  복수 이벤트 핸들러 할당 X
- 핸들러 하나 더 추가 시
  - 기존 핸들러 덮어씌워짐
```html
<input type="button" id="elem" onclick="alert('이전')" value="클릭해 주세요.">
<script>
  // 기존 작성된 핸들러 덮어씀
  elem.onclick = function() {
    alert('이후');
  };
</script>
```

##### 핸들러 제거
- `null` 할당
  - ex&#41; `elem.onclick = null`

### `this` <sub>(요소 접근)</sub>

##### 핸들러 내부 `this` 값
- 핸들러 할당 요소


##### `this.innerHTML`
- `this` == `<button>` <sub>(요소)</sub>
- 버튼 클릭 시
  - 버튼 안 콘텐츠 얼럿창 출력
```html
<button onclick="alert(this.innerHTML)">클릭해 주세요.</button>
```

![this.png](../../images/02/02/01/this.png)

### 흔한 실수

##### 함수 → 직접 핸들러 할당
```javascript
function sayThanks() {
  alert('감사합니다!');
}

// 올바른 방법
// - 함수 할당
elem.onclick = sayThanks;

// 틀린 방법
// - 함수 호출 · 반환값 할당
//   - 반환값 부재 : undefined 할당
elem.onclick = sayThanks();
```

##### HTML 속성값
- 괄호 필요
```html
<input type="button" id="button" onclick="sayThanks()">
```

##### 브라우저
1. 속성값 읽음
2. 핸들러 함수 생성
    - 속성값 → 함수 본문
3. `onclick` <sub>(프로퍼티)</sub>
    - 새 함수 할당

##### `setAttribute` 사용 X
속성 : 항상 문자열
- 함수 → 문자열
```javascript
// <body> (요소) 클릭 시 에러 발생
document.body.setAttribute('onclick', function() { alert(1) });
```

##### DOM 프로퍼티 : 대·소문자 구분
- 핸들러 할당 시
  - `elem.onclick` <sub>(O)</sub>
  - `elem.ONCLICK` <sub>(X)</sub>

### `addEventListener`

##### 기존 방법 <sub>(HTML 속성 · DOM 프로퍼티)</sub> 핸들러 할당 문제점
- 이벤트 하나
  - 복수 핸들러 할당 X

##### 복수 이벤트
- 복수 이벤트 핸들러 필요
- ex&#41; 버튼 클릭 시
  - 버튼 강조
  - 메시지 표시

##### 기존 방법 <sub>(HTML 속성 · DOM 프로퍼티)</sub>
- 프로퍼티 덮어씌짐
```javascript
input.onclick = function() { alert(1); }

// …

// 이전 핸들러 덮어씀
input.onclick = function() { alert(2); }
```

##### `[add·remove]EventListener` <sub>(메서드)</sub>
- 복수 핸들러 할당

##### 문법
```javascript
element.addEventListener(event, handler, [options]);
element.removeEventListener(event, handler, [options]);
```
- `event`
  - 이벤트명 <sub>(ex : "click")</sub>
- `handler`
  - 핸들러 함수
- `options`
  - 특정 프로퍼티 보유 객체
```javascript
{
  // true
  // - 이벤트 발생 시 리스너 자동 삭제
  // - 1회용 리스너
  once: boolean,

  // 이벤트 처리 단계 설정
  // 호환성 유지
  // - boolean (非객체 인수) 전달 시
  //   - { capture: boolean } 동일
  capture: boolean,

  // 리스너 지정 함수
  // - `preventDefault()` 미호출
  passive: biolean
}
```

<br />

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **동일 함수만 삭제 가능**

##### 핸들러 삭제 시
- 할당 시 사용한 함수 그대로 전달

##### 모양 동일 · 다른 함수
```javascript
elem.addEventListener( "click" , () => alert('감사합니다!'));
// …

// 핸들러 삭제 X
elem.removeEventListener( "click", () => alert('감사합니다!'));

↓↓↓

function handler() {
  alert( '감사합니다!' );
}

input.addEventListener("click", handler);
// …
input.removeEventListener("click", handler);
```

##### 핸들러 : 변수 미저장 시
- 핸들러 삭제 X
- `addEventListener` <sub>(메서드)</sub> 할당 함수
  - 불러오기 X

<br />

##### `addEventListener` <sub>(메서드)</sub> 복수 호출
- 복수 핸들러 붙이기
```html
<input id="elem" type="button" value="클릭해 주세요."/>

<script>
  function handler1() {
    alert('감사합니다!');
  };

  function handler2() {
    alert('다시 한번 감사합니다!');
  }

  elem.onclick = () => alert("안녕하세요.");

  // "감사합니다!"
  elem.addEventListener("click", handler1);

  // "다시 한번 감사합니다!"
  elem.addEventListener("click", handler2);
</script>
```

<br />

<img class="icon" src="../../images/commons/icons/triangle-exclamation-solid.svg" /> **특정 이벤트 : `addEventListener` <sub>(메서드)</sub> 로만 동작**

##### DOM 프로퍼티 할당 불가 이벤트
- `addEventListener` <sub>(메서드)</sub> 사용

##### `DOMContentLoaded` <sub>(이벤트)</sub>
- 문서 읽고 DOM 트리 생성 완료 시 발생
```javascript
// 얼럿창 동작 X
document.onDOMContentLoaded = function() {
  alert("DOM이 완성되었습니다.");
};

// 얼럿창 정상 동작
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM이 완성되었습니다.");
});
```

##### `addEventListener` <sub>(메서드)</sub>
- 범용적인 리스너 할당 담당
- 예외적인 이벤트 담당

<br />

### 이벤트 객체

##### 이벤트 처리 : 상세한 정보 필요
- ‘click’ <sub>(이벤트)</sub>
  - 마우스 포인터 위치 등
- ‘keydown’ <sub>(이벤트)</sub>
  - 눌린 키 종류 등
- 기타 등등

##### 이벤트 발생 시
- 이벤트 객체 생성 <sub>(브라우저)</sub>
  - 이벤트 관련 상세 정보 보유
  - 핸들러에 전달 <sub>(인수 형태)</sub>

##### 포인터 좌표 정보 얻기 <sub>(이벤트 객체)</sub>
```html
<input type="button" value="클릭해 주세요." id="elem">

<script>
  elem.onclick = function(event) {

    // 이벤트 타입 · 요소 · 발생 좌표
    alert(event.type + " 이벤트가 " + event.currentTarget + "에서 발생했습니다.");
    alert("이벤트가 발생한 곳의 좌표는 " + event.clientX + ":" + event.clientY +"입니다.");
  };
</script>
```

#### 이벤트 <sub>(객체)</sub> 지원 프로퍼티 일부

##### `type`
- 이벤트 타입
  - ex&#41; `"click"`

##### `currentTarget`
- 이벤트 처리 요소
- `this` 값 동일 <sub>(일부 경우 제외)</sub>
  - 화살표 함수 핸들러
  - 다른 곳에 바인딩

##### `client[X·Y]`
- 커서 상대 좌표 <sub>(포인터 관련 이벤트)</sub>
  - 브라우저 화면 기준
  - 모니터 기준 X

##### 이외 다양한 프로퍼티 존재
- 타입 타라 제공 프로퍼티 상이

<br />

<img class="icon" src="../../images/commons/icons/circle-exclamation-solid.svg" /> **이벤트 <sub>(객체)</sub> : HTML 핸들러 안에서 접근 가능**

```html
<input type="button" onclick="alert(event.type)" value="이벤트 타입">
```

![event-object-in-html-handler](../../images/02/02/01/event-object-in-html-handler.png)

##### 속성 읽고 핸들러 생성 <sub>(브라우저)</sub>
- 생성된 핸들러 함수
  - 1번째 인수
    - `event`
  - 본문
    - 속성값
```javascript
function(event) {
  alert(event.type);
}
```
<br />

### 객체 형태 핸들러 · `handleEvent`

##### `addEventListener` <sub>(메서드)</sub>
- 함수 외 객체
  - 이벤트 핸들러로 할당 가능
- 이벤트 발생 시
  - `handleEvent` <sub>(객체 구현 메서드)</sub> 호출
```html
<button id="elem">클릭해 주세요.</button>

<script>
  let obj = {
    handleEvent(event) {
      alert(event.type + " 이벤트가 " + event.currentTarget + "에서 발생했습니다.");
    }
  };

  elem.addEventListener('click', obj);
</script>
```

보시다시피 `addEventListener`가 인수로 객체 형태의 핸들러를 받으면 이벤트 발생 시 `obj.handleEvent(event)`가 호출됩니다.

클래스를 사용할 수도 있습니다.
```html
<button id="elem">클릭해 주세요.</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "마우스 버튼을 눌렀습니다.";
          break;
        case 'mouseup':
          elem.innerHTML += " 그리고 버튼을 뗐습니다.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
```

위 예시에선 하나의 객체에서 두 개의 이벤트를 처리하고 있습니다. 이때 주의할 점은 `addEventListener`를 사용할 때는 요소에 타입을 정확히 명시해 주어야 한다는 점입니다. 위 예시에서 `menu` 객체는 오직 `mousedown` 와 `mouseup`이벤트에만 응답하고, 다른 타입의 이벤트에는 응답하지 않습니다.

`handleEvent` 메서드가 모든 이벤트를 처리할 필요는 없습니다. 이벤트 관련 메서드를 `handleEvent` 에서 호출해서 사용할 수도 있습니다. 아래와 같이 말이죠,
```html
<button id="elem">클릭해 주세요.</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "마우스 버튼을 눌렀습니다.";
    }

    onMouseup() {
      elem.innerHTML += " 그리고 버튼을 뗐습니다.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
```

이벤트 핸들러가 명확히 분리되었기 때문에 코드 변경이 원활해졌습니다.

<br />

## 요약
이벤트 핸들러는 3가지 방법으로 할당할 수 있습니다.

1. HTML 속성: `onclick="..."`.
2. DOM 프로퍼티: `elem.onclick = function`.
3. 메서드: `elem.addEventListener(event, handler[, phase])`로 핸들러를 추가하고, `removeEventListener` 로 핸들러를 제거함

HTML 속성을 이용한 이벤트 핸들러 할당은 자주 쓰이지 않습니다. HTML 태그 중간에 자바스크립트가 들어가 있으면 어색하기 때문입니다. 긴 코드를 끼워 넣는 게 불가능한 점도 이유 중 하나입니다.

DOM 프로퍼티를 사용한 방법은 괜찮습니다. 하지만 복수의 핸들러 할당이 불가능하다는 단점이 있습니다. 여러 상황에서 이런 제약이 큰 단점이 되진 않지만요.

메서드를 사용하는 방법은 가장 유연하지만, 코드는 가장 깁니다. `transitionend`와 `DOMContentLoaded`(추후 다룰 예정)같은 일부 이벤트는 이 방법으로만 처리할 수 있습니다. `addEventListener`는 객체 형태의 이벤트를 지원합니다. 이 경우엔 이벤트 발생 시 객체 안에 구현된 메서드인 `handleEvent`가 호출됩니다.

어떤 방법으로 이벤트 핸들러를 할당하던, 첫 번째 인자는 이벤트 객체입니다. 이벤트 객체는 어떤 일이 일어났는지에 대한 상세한 정보를 담고 있습니다.

다음 주제에서 이벤트에 대해 전반적인 내용과 다양한 이벤트 타입에 대해서 다루겠습니다.

<br />

## <img class="icon" src="../../images/commons/icons/circle-check-solid.svg" /> 과제

### 버튼 클릭 시 특정 요소 숨기기
`button`을 클릭하면 `<div id="text">`가 사라지도록 `button`에 자바스크립트를 추가해봅시다.

데모:

![assignment-hide-on-click](../../images/02/02/01/assignment-hide-on-click.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/b7LXYQMsfY5Tvut8?p=preview)

<hr />

### 클릭된 요소 숨기기
클릭 시 자신을 숨기는 버튼을 만들어봅시다.

예시:

![assignment-hide-clicked](../../images/02/02/01/assignment-hide-clicked.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

핸들러 내부에 `this`를 사용해 '요소 자체’를 참조할 수 있습니다.
```html
<input type="button" onclick="this.hidden=true" value="Click to hide">
```

<hr />

### 어떤 핸들러가 실행될까요
변수 안에 버튼이 있지만 버튼 처리를 담당하는 핸들러는 없다고 가정해봅시다.

이런 코드가 있는 경우에, 버튼 클릭시 실행되는 핸들러는 무엇일까요? 어떤 얼럿 창이 보일까요?
```javascript
button.addEventListener("click", () => alert("1"));

button.removeEventListener("click", () => alert("1"));

button.onclick = () => alert(2);
```

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

정답: `1`과 `2`가 얼럿 창에 표시됩니다.

`removeEventListener`가 있지만 첫 번째 핸들러는 `removeEventListener`에 의해 지워지지 않았기 때문에 트리거됩니다. 핸들러를 삭제하려면 핸들러 할당 시 사용한 함수를 그대로 전달해주어야 합니다. `removeEventListener`에 첫 번째 핸들러의 함수와 똑같이 생긴 함수를 전달했지만, 엄연히 다른 함수이기 때문에 `removeEventListener`를 사용해도 첫 번째 이벤트 핸들러는 지워지지 않습니다.

이미 등록한 핸들러 함수를 삭제하려면 다음과 같이 함수에 대한 참조를 저장해야 합니다.
```javascript
function handler() {
  alert(1);
}

button.addEventListener("click", handler);
button.removeEventListener("click", handler);
```

핸들러 `button.onclick`은 독립적으로 동작합니다. 따라서 `addEventListener`와 함께 동작하였습니다.

<hr />

### Move the ball across the field
Move the ball across the field to a click. Like this:

![assignment-move-the-ball-accross-the-field](../../images/02/02/01/assignment-move-the-ball-accross-the-field.png)

Requirements:

- The ball center should come exactly under the pointer on click (if possible without crossing the field edge).
- CSS-animation is welcome.
- The ball must not cross field boundaries.
- When the page is scrolled, nothing should break.

Notes:
- The code should also work with different ball and field sizes, not be bound to any fixed values.
- Use properties `event.clientX`/`event.clientY` for click coordinates.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

First we need to choose a method of positioning the ball.

We can’t use `position:fixed` for it, because scrolling the page would move the ball from the field.

So we should use `position:absolute` and, to make the positioning really solid, make `field` itself positioned.

Then the ball will be positioned relatively to the field:
```css
#field {
  width: 200px;
  height: 150px;
  position: relative;
}

#ball {
  position: absolute;
  left: 0; /* relative to the closest positioned ancestor (field) */
  top: 0;
  transition: 1s all; /* CSS animation for left/top makes the ball fly */
}
```

Next we need to assign the correct `ball.style.left/top`. They contain field-relative coordinates now.

Here’s the picture:

![move-ball-coords](../../images/02/02/01/move-ball-coords.svg)

We have `event.clientX/clientY` – window-relative coordinates of the click.

To get field-relative `left` coordinate of the click, we can substract the field left edge and the border width:
```javascript
let left = event.clientX - fieldCoords.left - field.clientLeft;
```

Normally, `ball.style.left` means the “left edge of the element” (the ball). So if we assign that `left`, then the ball edge, not center, would be under the mouse cursor.

We need to move the ball half-width left and half-height up to make it center.

So the final `left` would be:
```javascript
let left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;
```

The vertical coordinate is calculated using the same logic.

Please note that the ball width/height must be known at the time we access `ball.offsetWidth`. Should be specified in HTML or CSS.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/RaxSzVksClBe41iu?p=preview)

<hr />

### Create a sliding menu
Create a menu that opens/collapses on click:

![assignment-create-a-sliding-menu-1](../../images/02/02/01/assignment-create-a-sliding-menu-1.png)

P.S. HTML/CSS of the source document is to be modified.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

#### HTML/CSS
First let’s create HTML/CSS.

A menu is a standalone graphical component on the page, so it’s better to put it into a single DOM element.

A list of menu items can be laid out as a list `ul`/`li`.

Here’s the example structure:
```html
<div class="menu">
  <span class="title">Sweeties (click me)!</span>
  <ul>
    <li>Cake</li>
    <li>Donut</li>
    <li>Honey</li>
  </ul>
</div>
```

We use `<span>` for the title, because `<div>` has an implicit `display:block` on it, and it will occupy 100% of the horizontal width.

Like this:
```html
<div style="border: solid red 1px" onclick="alert(1)">Sweeties (click me)!</div>
```

![assignment-create-a-sliding-menu-2](../../images/02/02/01/assignment-create-a-sliding-menu-2.png)

So if we set `onclick` on it, then it will catch clicks to the right of the text.

As `<span>` has an implicit `display: inline`, it occupies exactly enough place to fit all the text:
```html
<span style="border: solid red 1px" onclick="alert(1)">Sweeties (click me)!</span>
```

![assignment-create-a-sliding-menu-3](../../images/02/02/01/assignment-create-a-sliding-menu-3.png)

#### Toggling the menu
Toggling the menu should change the arrow and show/hide the menu list.

All these changes are perfectly handled by CSS. In JavaScript we should label the current state of the menu by adding/removing the class `.open`.

Without it, the menu will be closed:
```css
.menu ul {
  margin: 0;
  list-style: none;
  padding-left: 20px;
  display: none;
}

.menu .title::before {
  content: '▶ ';
  font-size: 80%;
  color: green;
}
```

…And with `.open` the arrow changes and the list shows up:
```css
.menu.open .title::before {
  content: '▼ ';
}

.menu.open ul {
  display: block;
}
```

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/ndvUGyfb4lM0B6bc?p=preview)

<hr />

### Add a closing button
There’s a list of messages.

Use JavaScript to add a closing button to the right-upper corner of each message.

The result should look like this:

![assignment-add-a-closing-button](../../images/02/02/01/assignment-add-a-closing-button.png)

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

To add the button we can use either `position:absolute` (and make the pane `position:relative`) or `float:right`. The `float:right` has the benefit that the button never overlaps the text, but `position:absolute` gives more freedom. So the choice is yours.

Then for each pane the code can be like:
```javascript
pane.insertAdjacentHTML("afterbegin", '<button class="remove-button">[x]</button>');
```

Then the `<button>` becomes `pane.firstChild`, so we can add a handler to it like this:
```javascript
pane.firstChild.onclick = () => pane.remove();
```

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/77eBtLwpqwqBOe6m?p=preview)

<hr />

### Carousel
Create a “carousel” – a ribbon of images that can be scrolled by clicking on arrows.

![assignment-carousel](../../images/02/02/01/assignment-carousel.png)

Later we can add more features to it: infinite scrolling, dynamic loading etc.

P.S. For this task HTML/CSS structure is actually 90% of the solution.

<br />

<img class="icon" src="../../images/commons/icons/circle-answer.svg" />

The images ribbon can be represented as `ul`/`li` list of images `<img>`.

Normally, such a ribbon is wide, but we put a fixed-size `<div>` around to “cut” it, so that only a part of the ribbon is visible:

![carousel1](../../images/02/02/01/carousel1.svg)

To make the list show horizontally we need to apply correct CSS properties for `<li>`, like `display: inline-block`.

For `<img>` we should also adjust `display`, because by default it’s `inline`. There’s extra space reserved under `inline` elements for “letter tails”, so we can use `display:block` to remove it.

To do the scrolling, we can shift `<ul>`. There are many ways to do it, for instance by changing `margin-left` or (better performance) use `transform: translateX()`:

![carousel2](../../images/02/02/01/carousel2.svg)

The outer `<div>` has a fixed width, so “extra” images are cut.

The whole carousel is a self-contained “graphical component” on the page, so we’d better wrap it into a single `<div class="carousel">` and style things inside it.

[샌드박스를 열어 정답을 확인해보세요.](https://plnkr.co/edit/77eBtLwpqwqBOe6m?p=preview)
